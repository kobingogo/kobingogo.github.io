{"meta":{"title":"扬舲's blog","subtitle":"山重水复疑无路 柳暗花明又一村","description":"前端技术博客","author":"yangling","url":"http://yoursite.com","root":"/"},"pages":[{"title":"react-test","date":"2020-05-01T08:59:10.000Z","updated":"2020-05-05T09:01:45.717Z","comments":true,"path":"react-test/index.html","permalink":"http://yoursite.com/react-test/index.html","excerpt":"","text":"XSS 即（Cross Site Scripting）：跨站脚本攻击 原理 恶意攻击者在 web 页面中会插入一些恶意的 script 代码。当用户浏览该页面的时候，那么嵌入到 web 页面中 script 代码会执行，因此会达到恶意攻击用户的目的。 分类 存储型（持久性 XSS 攻击）、反射型(非持久性 XSS 攻击）及 DOM-based 型 反射性反射型 XSS 只是简单地把用户输入的数据 “反射” 给浏览器，这种攻击方式往往需要攻击者诱使用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。例子： 恶意链接的地址指向了 localhost:8001/?q=111&amp;p=222。然后，我再启一个简单的 Node 服务处理恶意链接的请求： 1234567891011const http = require(\"http\");function handleReequest(req, res) &#123; res.setHeader(\"Access-Control-Allow-Origin\", \"*\"); res.writeHead(200, &#123; \"Content-Type\": \"text/html; charset=UTF-8\" &#125;); res.write('&lt;script&gt;alert(\"反射型 XSS 攻击\")&lt;/script&gt;'); res.end();&#125;const server = new http.Server();server.listen(8001, \"127.0.0.1\");server.on(\"request\", handleReequest); 当用户点击恶意链接时，页面跳转到攻击者预先准备的页面，会发现在攻击者的页面执行了 js 脚本 这样就产生了反射型 XSS 攻击。攻击者可以注入任意的恶意脚本进行攻击，可能注入恶作剧脚本，或者注入能获取用户隐私数据(如 cookie)的脚本，这取决于攻击者的目的。 存储型存储型 XSS 会把用户输入的数据 “存储” 在服务器端，当浏览器请求数据时，脚本从服务器上传回并执行。这种 XSS 攻击具有很强的稳定性。 比较常见的一个场景是攻击者在社区或论坛上写下一篇包含恶意 JavaScript 代码的文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意的 JavaScript 代码。 基于 DOM基于 DOM 的 XSS 攻击是指通过恶意脚本修改页面的 DOM 结构，是纯粹发生在客户端的攻击。 123456789101112131415161718192021222324252627&lt;h2&gt;XSS:&lt;/h2&gt;&lt;input type=\"text\" id=\"input\" /&gt;&lt;button id=\"btn\"&gt;Submit&lt;/button&gt;&lt;div id=\"div\"&gt;&lt;/div&gt;&lt;script&gt; const input = document.getElementById(\"input\"); const btn = document.getElementById(\"btn\"); const div = document.getElementById(\"div\"); let val; input.addEventListener( \"change\", (e) =&gt; &#123; val = e.target.value; &#125;, false ); btn.addEventListener( \"click\", () =&gt; &#123; div.innerHTML = `&lt;a href=$&#123;val&#125;&gt;testLink&lt;/a&gt;`; &#125;, false );&lt;/script&gt; 点击 Submit 按钮后，会在当前页面插入一个链接，其地址为用户的输入内容。如果用户在输入时构造了如下内容 &#39;&#39; onclick=alert(/xss/) 用户提交之后，页面代码就变成了： &lt;a href onlick=&quot;alert(/xss/)&quot;&gt;testLink&lt;/a&gt; 此时，用户点击生成的链接，就会执行对应的脚本： SQL 注入SQL 注入是通过客户端的输入把 SQL 命令注入到一个应用的数据库中，从而执行恶意的 SQL 语句,一个例子： 我们有一个登录框，需要输入用户名和密码对吧，然后我们的密码输入 ‘or ‘123’ = ‘123 这样的。 我们在查询用户名和密码是否正确的时候，本来执行的 sql 语句是：select _ from user where username = ‘’ and password = ‘’. 这样的 sql 语句，现在我们输入密码是如上这样的，然后我们会通过参数进行拼接，拼接后的 sql 语句就是：select _ from user where username = ‘’ and password = ‘ ‘ or ‘123’ = ‘123 ‘; 这样的了，那么会有一个 or 语句，只要这两个有一个是正确的话，就条件成立，因此 123 = 123 是成立的。因此验证就会被跳过。这只是一个简单的列子，比如还有密码比如是这样的：’; drop table user;, 这样的话，那么 sql 命令就变成了：select * from user where username = ‘’ and password = ‘’; drop table user;’ , 那么这个时候我们会把 user 表直接删除了。 sql 被攻击的原因是：sql 语句伪造参数，然后对参数进行拼接后形成 xss 攻击的 sql 语句。最后会导致数据库被攻击了。 防范的方法： 我们可以使用预编译语句(PreparedStatement，这样的话即使我们使用 sql 语句伪造成参数，到了服务端的时候，这个伪造 sql 语句的参数也只是简单的字符，并不能起到攻击的作用。 数据库中密码不应明文存储的，可以对密码使用 md5 进行加密，为了加大破解成本，所以可以采用加盐的方式。 XSS 攻击的防范 cookie 安全策略 http-only: 只允许 http 或 https 请求读取 cookie、JS 代码是无法读取 cookie 的(document.cookie 会显示 http-only 的 cookie 项被自动过滤掉)。发送请求时自动发送 cookie. secure-only: 只允许 https 请求读取，发送请求时自动发送 cookie。 host-only: 只允许主机域名与 domain 设置完成一致的网站才能访问该 cookie。 输入检查 对于用户的任何输入要进行检查、过滤和转义。 输出检查 利用 sanitize-html 对输出内容进行有规则的过滤之后再输出到页面中。 开启 CSP 网页安全政策防止 XSS 攻击 CSP 是网页安全政策(Content Security Policy)的缩写。主要用来防止 XSS 攻击。是一种由开发者定义的安全性政策申明，通过 CSP 所约束的责任指定可信的内容来源，通过 Content-Security-Policy 网页的开发者可以控制整个页面中 外部资源 的加载和执行。 &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot; default-src http: https: *.xxx.com &#39;self&#39; &#39;unsafe-inline&#39; ; style-src &#39;self&#39; &#39;unsafe-inline&#39; *.yyy.com; script-src &#39;self&#39; &#39;unsafe-inline&#39; &#39;unsafe-eval&#39; ; &quot;&gt; CSRF(跨站请求伪造)完成一次 CSRF 攻击，需要完成如下事情： 登录受信任的网站 A，并且在本地生成 cookie。 在不登出网站 A 的情况下，继续访问危险网站 B。 CSRF 基本原理是：假设 A 网站是一个银行网站，而我是该网站的用户，当我以受信任的身份登录了该网站的时候，这时候 A 网站是通过 cookie 保留了我们的登录状态，这个时候我去登录了恶意网站 B 的时候，B 网站就会拿到我登录 A 网站的 cookie 信息到，因此 B 网站就把拿到的 cookie 信息去重新请求 A 网站的接口，但是在该接口后面的参数做一些修改，因此就这样达到攻击的目的。 CSRF 防范措施 服务端验证 HTTP Referer 字段 加验证码 使用 Token"},{"title":"文章分类","date":"2020-05-05T12:50:09.000Z","updated":"2020-05-05T13:11:22.088Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-05-05T12:52:32.000Z","updated":"2020-05-05T13:12:10.066Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2020-05-04T09:12:01.043Z","updated":"2020-05-04T09:12:01.043Z","comments":true,"path":"2020/05/04/hello-world/","link":"","permalink":"http://yoursite.com/2020/05/04/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"hexo——轻量、简易、高逼格的博客","slug":"test","date":"2018-08-31T09:54:54.000Z","updated":"2020-05-05T13:05:41.772Z","comments":true,"path":"2018/08/31/test/","link":"","permalink":"http://yoursite.com/2018/08/31/test/","excerpt":"当使用 iframe 作为文件下载的载体时，如何知道文件已经下载完毕。现有的 iframe 的 onLoad 方法具有兼容性问题，在 chrome、IE 下无法监听 onLoad 事件监听文件下载完毕，因为 onLoad 事件本身也是对 iframe 中的 html 结构的加载进度监听。","text":"当使用 iframe 作为文件下载的载体时，如何知道文件已经下载完毕。现有的 iframe 的 onLoad 方法具有兼容性问题，在 chrome、IE 下无法监听 onLoad 事件监听文件下载完毕，因为 onLoad 事件本身也是对 iframe 中的 html 结构的加载进度监听。 通过 iframe 下载文件判断下载完成的方法问题当使用 iframe 作为文件下载的载体时，如何知道文件已经下载完毕。现有的 iframe 的 onLoad 方法具有兼容性问题，在 chrome、IE 下无法监听 onLoad 事件监听文件下载完毕，因为 onLoad 事件本身也是对 iframe 中的 html 结构的加载进度监听。 123456789var url = \"http://www.example.com/file.zip\";var iframe = document.createElement(\"iframe\");iframe.src = url;iframe.style.display = \"none\";iframe.onload = function () &#123; console.debug(\"start downloading...\"); document.body.removeAttribute(iframe);&#125;;document.body.appendChild(iframe); 当 chrome、IE 下时，如果 HTTP 文件头中包含 Content-disposition: attachment；即下载文件的链接的话，不会触发这个事件 onLoad 事件。 Content-disposition 是 MIME 协议的扩展，MIME 协议指示 MIME 用户代理如何显示附加的文件。Content-disposition其实可以控制用户请求所得的内容存为一个文件的时候提供一个默认的文件名，文件直接在浏览器上显示或者在访问时弹出文件下载对话框。 Content-Disposition为属性名disposition-type是以什么方式下载，如attachment为以附件方式下载disposition-parm为默认保存时的文件名服务端向客户端游览器发送文件时，如果是浏览器支持的文件类型，一般会默认使用浏览器打开，比如txt、jpg等，会直接在浏览器中显示 注意事项： 1.当代码里面使用Content-Disposition来确保浏览器弹出下载对话框的时候。 response.addHeader(&#39;Content-Disposition&#39;, &#39;attachment&#39;);一定要确保没有做过关于禁止浏览器缓存的操作。 代码如下: response.setHeader(&#39;Pragma&#39;, &#39;No-cache&#39;); response.setHeader(&#39;Cache-Control&#39;, &#39;No-cache&#39;); response.setDateHeader(&#39;Expires&#39;, 0); 不然会发现下载功能在opera和firefox里面好好的没问题，在IE下面就是不行 解决思路一：利用 cookie后端将文件下载进度放在 cookie 中，通过轮询 cookie 的方式，对文件下载进度进行获取，判断文件是否已经下载完毕。 缺陷： 1、需要后端配合 2、如果客户端禁用了 cookie，则该方案完全失效；在无痕浏览模式下，读取 cookie，甚至代码报错。解决思路二：添加 header 配置 123456// 不让浏览器自动检测文件类型// 说明资料：http://drops.wooyun.org/tips/1166response.addHeader(\"X-Content-Type-Options\", \"nosniff\");// 提示浏览器不让其在frame或iframe中加载资源的文件内容// https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Optionsresponse.addHeader(\"X-Frame-Options\", \"deny\"); 但是在 chorome v58 版本将 header 的 X-Frame-Options 设为 deny 会报错。并且下载的时候网络连接会出现失败。 解决思路三：轮询监听 readyState定时器轮询监听 readyState 的状态，如果是 complete 或者 interactive 说明文件加载完成。 12345678910111213var timer = setInterval(function () &#123; iframe = document.getElementById(\"iframedownload\"); var iframeDoc = iframe.contentDocument || iframe.contentWindow.document; // Check if loading is complete if ( iframeDoc.readyState == \"complete\" || iframeDoc.readyState == \"interactive\" ) &#123; loadingOff(); clearInterval(timer); return; &#125;&#125;, 4000); 总结第三种方法比较好，因为不需要后端进行配合，且不依赖与 cookie 等变量带来的问题，能更好实现我们的需求。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"IT技术","slug":"IT技术","permalink":"http://yoursite.com/tags/IT%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"hexo——轻量、简易、高逼格的博客","slug":"hexo","date":"2018-08-31T09:54:54.000Z","updated":"2020-05-05T12:55:12.971Z","comments":true,"path":"2018/08/31/hexo/","link":"","permalink":"http://yoursite.com/2018/08/31/hexo/","excerpt":"这种方法可以根据文章的内容，自己在合适的位置添加标签，使用灵活，也是 Hexo 推荐的方法 ，这种方式也可以让 Hexo 中的插件更好的识别。","text":"这种方法可以根据文章的内容，自己在合适的位置添加标签，使用灵活，也是 Hexo 推荐的方法 ，这种方式也可以让 Hexo 中的插件更好的识别。 通过 iframe 下载文件判断下载完成的方法问题当使用 iframe 作为文件下载的载体时，如何知道文件已经下载完毕。现有的 iframe 的 onLoad 方法具有兼容性问题，在 chrome、IE 下无法监听 onLoad 事件监听文件下载完毕，因为 onLoad 事件本身也是对 iframe 中的 html 结构的加载进度监听。 123456789var url = \"http://www.example.com/file.zip\";var iframe = document.createElement(\"iframe\");iframe.src = url;iframe.style.display = \"none\";iframe.onload = function () &#123; console.debug(\"start downloading...\"); document.body.removeAttribute(iframe);&#125;;document.body.appendChild(iframe); 当 chrome、IE 下时，如果 HTTP 文件头中包含 Content-disposition: attachment；即下载文件的链接的话，不会触发这个事件 onLoad 事件。 Content-disposition 是 MIME 协议的扩展，MIME 协议指示 MIME 用户代理如何显示附加的文件。Content-disposition其实可以控制用户请求所得的内容存为一个文件的时候提供一个默认的文件名，文件直接在浏览器上显示或者在访问时弹出文件下载对话框。 Content-Disposition为属性名disposition-type是以什么方式下载，如attachment为以附件方式下载disposition-parm为默认保存时的文件名服务端向客户端游览器发送文件时，如果是浏览器支持的文件类型，一般会默认使用浏览器打开，比如txt、jpg等，会直接在浏览器中显示 注意事项： 1.当代码里面使用Content-Disposition来确保浏览器弹出下载对话框的时候。 response.addHeader(&#39;Content-Disposition&#39;, &#39;attachment&#39;);一定要确保没有做过关于禁止浏览器缓存的操作。 代码如下: response.setHeader(&#39;Pragma&#39;, &#39;No-cache&#39;); response.setHeader(&#39;Cache-Control&#39;, &#39;No-cache&#39;); response.setDateHeader(&#39;Expires&#39;, 0); 不然会发现下载功能在opera和firefox里面好好的没问题，在IE下面就是不行 解决思路一：利用 cookie后端将文件下载进度放在 cookie 中，通过轮询 cookie 的方式，对文件下载进度进行获取，判断文件是否已经下载完毕。 缺陷： 1、需要后端配合 2、如果客户端禁用了 cookie，则该方案完全失效；在无痕浏览模式下，读取 cookie，甚至代码报错。解决思路二：添加 header 配置 123456// 不让浏览器自动检测文件类型// 说明资料：http://drops.wooyun.org/tips/1166response.addHeader(\"X-Content-Type-Options\", \"nosniff\");// 提示浏览器不让其在frame或iframe中加载资源的文件内容// https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Optionsresponse.addHeader(\"X-Frame-Options\", \"deny\"); 但是在 chorome v58 版本将 header 的 X-Frame-Options 设为 deny 会报错。并且下载的时候网络连接会出现失败。 解决思路三：轮询监听 readyState定时器轮询监听 readyState 的状态，如果是 complete 或者 interactive 说明文件加载完成。 12345678910111213var timer = setInterval(function () &#123; iframe = document.getElementById(\"iframedownload\"); var iframeDoc = iframe.contentDocument || iframe.contentWindow.document; // Check if loading is complete if ( iframeDoc.readyState == \"complete\" || iframeDoc.readyState == \"interactive\" ) &#123; loadingOff(); clearInterval(timer); return; &#125;&#125;, 4000); 总结第三种方法比较好，因为不需要后端进行配合，且不依赖与 cookie 等变量带来的问题，能更好实现我们的需求。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"IT技术","slug":"IT技术","permalink":"http://yoursite.com/tags/IT%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"}]}],"categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"IT技术","slug":"IT技术","permalink":"http://yoursite.com/tags/IT%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"}]}