{"meta":{"title":"扬舲の博客","subtitle":"","description":"前端技术博客","author":"yangling","url":"https://kobingogo.github.io","root":"/"},"pages":[{"title":"文章分类","date":"2020-05-05T20:50:09.000Z","updated":"2022-02-18T02:31:03.811Z","comments":false,"path":"categories/index.html","permalink":"https://kobingogo.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-05-05T20:52:32.000Z","updated":"2022-02-18T02:31:03.811Z","comments":true,"path":"tags/index.html","permalink":"https://kobingogo.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"让代码更规范优雅 - husky的使用","slug":"tools-husky","date":"2022-02-17T17:52:37.000Z","updated":"2022-02-18T02:31:03.811Z","comments":true,"path":"tools-husky/","link":"","permalink":"https://kobingogo.github.io/tools-husky/","excerpt":"","text":"日常工作中，几乎每个项目都是由多个人进行维护，每个人的代码书写习惯和风格又不尽相同，在这种情况下，规范和约束就显得尤为重要！ githooks类似于前端框架中的生命周期钩子，git在某些特定事件发生前或后也会有某些执行特定功能的钩子，githooks就是在git执行特定事件（如commit、push、receive等）时触发运行的脚本。 githooks 保存在 .git 文件夹中 具体钩子如下表所示： git hook 执行时机 说明 applypatch-msg git am 执行前 默认情况下，如果commit-msg启用的话，applpatch-msg钩子在启用时会运行commit-msg钩子 pre-applypatc git am 执行前 默认的pre-applypatch钩子在启用时运行pre-commit钩子（如果后者已启用） post-applypatch git am 执行后 这个钩子主要用于通知，不能影响git-am的结果 pre-commit git commit 执行前 可以使用 git commit --no verify 命令绕过该钩子 pre-merge-commit git merge 执行前 可以使用 git merge --no verify 命令绕过该钩子 prepare-commit-msg git commit执行之后，编辑器打开之前 commit-msg git commit 执行前 可以使用 git commit --no verify 命令绕过该钩子 post-commit git commit 执行后 不影响git commit的结果 pre-rebase git rebase执行前 post-checkout git checkout 或 git switch执行后 如果不使用 --no-checkout 参数，则在 git clone 之后也会执行 post-merge git merge 执行后 在执行git pull 时也会被调用 pre-push git push 执行前 pre-receive git receive pack 执行前 update proc-receive post-receive git receive pack 执行前 不影响 git receive pack 的执行结果 post-update 当git receive pack对 git push 作出反应并更新仓库中的引用时 reference-transaction push-to-checkout 当git receive pack对 git push 作出反应并更新仓库中的引用时，以及当推送试图更新当前被签出的分支且 receive.denyCurrentBranch配置被updateInstead时 pre-auto-gc git gc --auto 执行前 post-rewrite 执行 git commit --amend 或 git rebase 时 sendemail-validate git send-email 执行前 fsmonitor-watchman 配置core.fsmonitor被设置为.git/hooks/fsmonitor-watchman 或.git/hooks/fsmonitor-watchmanv2时 p4-changelist git-p4 submit 执行并编辑完changelist message 之后 可以使用 git-p4 submit --no-verify绕过该钩子 p4-prepare-changelist git-p4 submit 执行后，编辑器启动前 可以使用 git-p4 submit --no-verify绕过该钩子 p4-post-changelist git-p4 submit 执行后 p4-pre-submit git-p4 submit 执行前 可以使用 git-p4 submit --no-verify绕过该钩子 post-index-change 索引被写入 read-cache.c do_write_locked_index后 husky(v7.0.1)husky 是一个让配置 git 钩子变得更简单的工具。支持所有的git钩子。 使用husky 首先执行安装命令 npm install husky --save-dev 要在安装后自动启用钩子，我们需要执行npm set-script prepare &quot;husky install&quot; 执行完上一步的命令之后可以在package.json 文件的scripts配置项中看到如下代码： &quot;scripts&quot;: { &quot;prepare&quot;: &quot;husky install&quot; } 复制代码 创建钩子，比如我们创建一个commit-msg钩子：yarn husky add .husky/commit-msg &#39;yarn commitlint --edit &quot;$1&quot;&#39; 将上一步创建的 commit-msg 钩子添加到git中：git add .husky/commit-msg 此外还有 husky-init命令， 执行之后可以在项目中快速的初始化一个husky。 lint-staged(v11.0.0)lint-staged 是一个在git暂存区上运行linters的工具。（Run linters against staged git files and don&#39;t let 💩 slip into your code base!） 它将根据package.json依赖项中的代码质量工具来安装和配置 husky 和 lint-staged ，因此请确保在此之前安装（npm install --save-dev）并配置所有代码质量工具，比如Prettier和ESlint。 安装：执行 yarn add lint-staged -D 命令 执行 npx lint-staged --help 命令可以看到相关的所有参数如下： 用法: lint-staged [options] Options: -V, --version 输出版本号 --allow-empty 当任务撤消所有分阶段的更改时允许空提交（默认值：false） -c, --config [path] 配置文件的路径 -d, --debug 打印其他调试信息（默认值：false） -p, --concurrent &lt;parallel tasks&gt; 要同时运行的任务数，或者为false则要连续运行任务（默认值：true） -q, --quiet 自己的控制台输出（默认值：false） -r, --relative 将相对文件路径传递给任务（默认值：false） -x, --shell 跳过任务解析以更好地支持shell（默认值：false） -h, --help 输出用法信息 复制代码 --allow-empty：使用此参数允许创建空的git提交。默认情况下，当LITER任务撤消所有阶段性的更改时，LITET阶段将抛出一个错误，并中止提交。 git commit提交规范通常使用 Google AnguarJS 规范的要求。 格式要求： &lt;type&gt;(&lt;scope&gt;): &lt;subject&gt; &lt;BLANK LINE&gt; &lt;body&gt; &lt;BLANK LINE&gt; &lt;footer&gt; 复制代码 &lt;type&gt;代表某次提交的类型，比如是修复一个 bug 或是增加一个 feature，具体类型如下： 类型 描述 feat 新增feature fix 修复bug docs 仅仅修改了文档，比如README, CHANGELOG, CONTRIBUTE等等; style 仅仅修改了空格、格式缩进、逗号等等，不改变代码逻辑; refactor 代码重构，没有加新功能或者修复bug perf 优化相关，比如提升性能、体验 test 测试用例，包括单元测试、集成测试等 chore 改变构建流程、或者增加依赖库、工具等 revert 回滚到上一个版本 scope：说明commit影响的范围。scope依据项目而定，例如在业务项目中可以依据菜单或者功能模块划分，如果是组件库开发，则可以依据组件划分。 subject:是commit的简短描述； body:提交代码的详细描述； footer:如果代码的提交是不兼容变更或关闭缺陷，则footer必需，否则可以省略。 实现 首先我们来安装需要用到的依赖，执行以下命令： 执行 yarn add husky -D 安装husky。 接着执行 npm set-script prepare &quot;husky install&quot; 之后，可以在package.json文件的scripts配置项中看到 &quot;prepare&quot;: &quot;husky install&quot; ps: npm set-script prepare &quot;husky install&quot; 在npm v7以上生效 继续执行 yarn prepare之后，可以在项目的根目录下看到多了如下图所示的目录： 如果执行yarn prepare之后报如下图所示错误，则需要执行git init然后再执行yarn prepare husky 准备好之后，我们接着来安装其他的用于规范，检查代码的依赖。 执行yarn add lint-staged -D 执行yarn add eslint prettier -D 在package.json文件下添加如下代码： &quot;lint-staged&quot;: { &quot;src/**/*.&#123;js,jsx,ts,tsx,json&#125;&quot;: [ &quot;prettier --write&quot;, &quot;eslint&quot;, &quot;git add&quot; ] } 复制代码 执行yarn add @commitlint/cli @commitlint/config-conventional -D安装commitlint相关依赖，用来帮助我们在多人开发时，遵守 git 提交约定。 执行echo &quot;module.exports = &#123;extends: [&#39;@commitlint/config-conventional&#39;]&#125;&quot; &gt; commitlint.config.js在根目录创建 commitlint.config.js 文件（当然也可以手动创建此文件），其内容如下所示： module.exports = { extends: [ &quot;@commitlint/config-conventional&quot; ], rules: &#123; &#39;type-enum&#39;: [ 2, &#39;always&#39;, [ &#39;bug&#39;, &#39;feat&#39;, &#39;fix&#39;, &#39;docs&#39;, &#39;style&#39;, &#39;refactor&#39;, &#39;test&#39;, &#39;chore&#39;, &#39;revert&#39;, &#39;merge&#39; ] ] &#125; }; 复制代码 如果还需要别的代码优化依赖包，可以接着进行安装 至此，准备好我们需要的依赖包之后，我们开始添加钩子 执行yarn husky add .husky/commit-msg &#39;yarn commitlint --edit &quot;$1&quot;&#39;之后，会看到在根目录的.husky文件夹下多了一个 commit-msg 文件，其内容如下： #!/bin/sh . &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot; yarn commitlint --edit &quot;$1&quot; 复制代码 紧接着，我们需要将上一步添加的钩子添加到git中去，执行git add .husky/commit-msg 执行yarn husky add .husky/pre-commit &#39;yarn lint-staged --allow-empty &quot;$1&quot;&#39;之后，会看到在根目录的.husky文件夹下多了一个 pre-commit 文件，其内容如下： #!/bin/sh . &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot; yarn lint-staged --allow-empty &quot;$1&quot; 复制代码 同样的，我们需要将上一步添加的钩子添加到git中去，执行git add .husky/pre-commit 接下来，就是检验我么配置的时候了：当我们按照 commit规范正确提交时，可以在控制台看到如下输出 当我们不按照配置的规范来提交commit时，就会发现如下报错，并阻止你提交代码 至此，我们的钩子配置已经完美收官！","categories":[{"name":"tool","slug":"tool","permalink":"https://kobingogo.github.io/categories/tool/"}],"tags":[{"name":"工程化","slug":"工程化","permalink":"https://kobingogo.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}]},{"title":"股票实战法笔记","slug":"financial-股票实战法","date":"2021-02-12T23:21:09.000Z","updated":"2022-02-18T02:31:03.811Z","comments":true,"path":"financial-股票实战法/","link":"","permalink":"https://kobingogo.github.io/financial-%E8%82%A1%E7%A5%A8%E5%AE%9E%E6%88%98%E6%B3%95/","excerpt":"","text":"一、常用指标1. MACD - 异同移动平均线 名称 概念 拓展 DIFF 短期(常用12天)指数移动平均线 与 长期(26天)指数移动平均线的差值 变动较为灵敏，又称为快线 DEA M日(常用9天)的平滑移动平均线 变化较慢，又称慢线 MACD红绿柱 DIFF值与DEA差值的2倍数 柱子高低直接反应多空强弱 零轴线 MACD多空分界线，DIFF和DEA在零轴之上为多头市场，在零轴以下是空头市场 / （1）金叉DIFF线自下而上穿越DEA，绿柱转为红柱 零轴上金叉 零轴下金叉 多头市场 往往只是空头市场短暂的反弹 往往意味着新一波大涨势的开始 力度不大 / 稳定性和可靠性较低 （2）死叉DIFF自上而下穿越DEA，红柱转变为绿柱，空头市场开始 零轴上死叉 零轴下死叉 往往只是多头市场中的回调（陷阱，也可能一直跌到零轴下方） 新一波下跌的开始 可靠性不高，调整幅度不会太大 可靠性极高，下跌幅度也较大 （3）MACD抄底术 要点（组合） ①经过一波下跌后反弹 ②股价再次下跌创新低 ③MACD的DIFF线低点股价不创新低 ④MACD金叉确定底背离即是买入信号 底背离：股价在不断创新高（新低）的过程中，指标并不跟随股价发生相应的变化，反而背道而驰 （4）MACD抓主升浪 要点（组合） ①经过一波上涨后调整 ②股价调整不破前低 ③MACD在略高于零轴线位置金叉 ④出中阳K线即买入信号 （5）MACD逃顶术 要点（组合） ①经过一波上涨后调整 ②股价第二波上涨创新高 ③MACD的DIFF线高点股价未创新高 ④MACD死叉确定顶背离即卖出信号 （6）补充不能看单指标进行操作，MACD指标具有滞后性，股价变化一段时间后，MACD才会出现变化 2. KDJ - 随机指标 名称 取值范围 速度 安全性 K 0-100 中 中 D 0-100 慢 高 J 可 &gt;100 &lt;0 超卖区 超买区 徘徊区 20以下 80以上 20-80 操作：买入 操作卖出 操作：边缘OB （1）金叉K线从D线下方向上穿越D线，同时J线从K、D线下方向上穿越K、D线，股价转强信号，超卖区形成金叉，股价成功反弹概率较高 （2）死叉K线同D线上方向下穿越D线，J线从K、D线上方向下穿越K、D线，股价转弱信号，在超买区形成死叉时，股价短期下跌的概率较高 （3）KDJ顶背离 顶背离 股价连续上涨并持续创新高 KDJ未同步创新高 预期股价上涨乏力 短期出局信号 （4）KDJ底背离 底背离 股价连续下跌并持续创新低 KDJ未同步创新低 短期下跌动能减弱 易止跌反弹 择机买入信号 （5）钝化行情大涨或暴跌中，指标数据出现粘连，失去指导作用，KDJ容易出现钝化 高位钝化 地位钝化 无法判定股价后续走势 可能要跌一段时间 参考其他指标进行操作 参考其他指标进行操作 个股强势 个股弱势（回归后金叉可抄底买入） （6）MACD+KDJ双金叉选股①KDJ由于是短期指标，其金叉与死叉不具备高准确性，可搭配MACD使用 ②KDJ出现金叉，MACD绿柱缩量迎来拐点，可判断KDJ为有效指导，保险起见可在KDJ金叉后1-2日买入 （7）MACD黄白线位于零轴线上方 （8）补充不要以来单一指标进行操作，KDJ响应快速，MACD响应慢速 3. BOLL - 布林线指标 作用 ①指示支撑和压力位置，股价上、下轨线显示股价安全运行的最高价位和最低价位 ②指示趋势，通道的中轨线之上为可操作趋势，中轨下之下为不建议操作区域，强势股总在中、上轨之间 ③布林线可以显示超卖、超买；股价冲出上轨线有回调，跌出下轨线有反抽 ④可以选择方向，上下轨收窄隐藏这突变，开口越大说明风险越大 （1）布林线开口向下马上离场，可低吸 （2）布林线开口紧缩行情可能突然变化，可参考其他指标操作 （3）布林线开口向上持股不动，股价上涨 （4）布林线与K线 K线 &amp; 布林线 走势 操作 K线从布林线中轨线以下向上突破布林线中轨 股价强势特征开始，概率上涨 买入为主 K线冲布林线中轨线以上向上突破布林线上轨时 强势特征已经确立，短期可能大涨 持股待涨或短期买入 K线向上突破布林线上轨，继续向上 强势特征依旧，短期还将上涨 持股待涨 K线在布林线轨道顶部开始有掉头向下迹象时 关注是否跌破中轨，短期行情可能结束，尤其是短期涨幅很大的股票 考虑卖出 （5）MACD+KDJ+MA5+BOLL判断走势MA5：五日均线 ①股价一直下跌，KJD金叉当天或第二天股价突然从下轨线附近站上5日均线，最佳买入时机 注：KDJ比较敏感（反应较快），会产生很多无效指标 ②股价从下方靠近中轨线，一举突破中轨线并在上方获得中轨线支撑并股价站上5日均线，当MACD形成金叉，即买入机会 ③股价一直运行在上升轨道，随后跌破中轨线和5日线，KDJ形成死叉，卖出获利跑路 注：当KDJ形成钝化时，需要MACD辅助查看指标 参数设置：BOLL参数设置为26日比设置20日更能准确反应股价的运行情况 （6）BBIBOLL - 多空布林线组成：多空线指标+普通布林线（BBI + BOLL） 两者单独使用的范围太小，而两者组成的系统，完美的结合了两者的优点，同事还具备对未来方向的判断。与普通布林线的区别在于，中轨线就是BBI 法则一：多空布林线中，行情缩口变张口，中轨线上方有阳线，行情涨；反之缩口变张口，中轨线下方有阴线，行情跌；这两种情况出现时，第二天均是有反应的，对大盘和个股都适用 法则二：行情上涨时，K线实体一旦突破甚至完全站在上轨线上方，行情大概率会回调；反之行情下跌是，K线实体一旦跌破甚至完全站在下轨线下方，行情极大概率反弹；举例：在第一阶段跌破下轨线的第二天买入，在冲破上轨线的第二天开盘卖出，可以吃光所有反弹利润 法则一 法则二 大趋势判断 逃顶抄底，低吸高抛 （7）补充不要把指标复杂化，都只是观察股价的一个图形，可以参考，但不能过度依赖，这些规律并不是绝对的 4. PSY - 心理线指标英文全称：Psychological，计算12日内上涨天数所占的比例数值来反映投资者的心理预期，仅计算收盘价 ①上涨时代表多数投资者看涨，下跌代表多数投资者看空 ②PSY在25-75之间波动，也就是过去12个交易日内，上涨天数在3-9天内是正常情况，正常交易即可 ③PSY达到或超过75时说明过去12天内上涨的天数在9天以上，短期获利盘较多，有超买迹象 ④PSY值达到或低于25时，说明过去12天内上涨天数小于3天，卖盘持续涌出，投资者看空卖出 ⑤如果短期持续下跌，特别是跌幅较大时，抛压会减轻，股价短期可能反弹向上 ⑥震荡时，股价处于区间盘整走势，价格跌幅可能在5-10%，但PSY指标却大幅下跌，往往预示着“盘久必跌”，考虑跑路 （1）超短线选股：PSY数值低于25的两种情况 （2）补充这两种情况90%概率盈利，但是超短线行情，赚到就跑 5. DMI - 趋向指标(捕捉超跌反弹)（1）拆分 PDI MDI ADX ADXR 多空指标派 多空指标派 趋向指标派 趋向指标派 0-100 0-100 0-100 0-100 越高市场越强 越高市场越弱 快速转向回拉力 慢速回拉力，ADX的移动平均值 越接近0时是新一轮行情的开始 行情开始前跌落至地位 上涨或下跌的单边市场时该指标均向上 跟随ADX慢速运行 在MDI上方属于多头强势 在PDI上方属于空头弱势 PDI与MDI缠绕时该指标无意义 确定ADX发出信号是否准确，有一定滞后性 作用 条件1 条件2 结果 ①判断行情趋势 ①PDI逐渐上升 ②MDI逐渐上升 ①ADX不断递增 ②ADX不断递增 ①上升趋势且十分强劲 ②下跌趋势，并将加速 ②判断行情是否盘整 四条线均在50以下运行 横向窄幅移动 盘整，趋势不明朗 ③判断行情是否转势 ADX值在高点由升转跌 行情即将翻转 ④捕捉反弹（与PSY辅助一起用） PDI&lt;5=超跌 PSY&lt;=25 = 过分悲观 即将反弹，等待第一个阳线买入 （3）补充指标间共振会大大提高准确率，选股可以结合版块来看 6. BIAS - 乖离率(捕捉超跌反弹)乖离率 = 收盘价与某条均线(任何一条均线都可，常用MA5)之间差距的百分比 示例：股价远高于5日均线时，即是5日均线乖离率很大，短线卖出时机 （1）买入卖出K线在均线上方乖离率为正，反之为负；当股价偏离市场平均成本太大时，投资者的心理因素就使偏离回归。正乖离率越大，获利越多，容易赚钱走人跑路，出现卖点；负乖离率越大，损失越大，容易出现抄底，买入时机。 （2）超跌反弹大盘股票价格指数超过2%，小盘股票价格指数超过4%，就大概率引发超跌反弹，但并非死板数字，不同行情下，指标不一样，结合其他指标综合来看 注：下跌通道中，出现了高负乖离率，也可能只是小反弹一两天，机会转瞬即逝，此时赚快钱即可 （3）补充通常当短线指标来看，在该指标在长线熊市中没有太大意义。，参数调整：3个5即可 7. 常用标识SAR：stop and reverse 标识 含义 股市 stop 结束、停止 止损、止盈 Reverse 逆向、返向 股票买入卖出操作 注：SAR红色入场、绿色空仓（周线） SAR红色入场 - 周线 SAR绿色空仓 - 周线 抓住了所有牛市 避开了所有熊市 曲线向下运行角度逐渐变小，股价突破SAR曲线，中长期下跌趋势可能结束，逢低买入 曲线向下运行时角度过大，跌势过猛短暂反弹后下跌概率较大 曲线向上运行角度偏大，短暂回调后继续上涨概率较大 曲线向上运行时间过长，短期股价涨幅过大，股价可能反转向下 8. ROE - 股票净资产收益率 ROE 公司盈利能力 股东回报率 股民买入 公司股价 &gt;20% 强 高 多 涨 （1）计算公式ROE = 净利润 * 总资产周转率 * 权益乘数 净利润 总资产周转率 权益乘数 提高ROE 企业的赚钱能力 企业的资产运用效率 负债程度高低 ①提高净利润率 ②提高总资产周转率 ③增加公司负债 （2）缺点①并不是ROE越高越好。如果过高，那三个数据肯定某个出现问题。高ROE可能来自企业过度负债。 ②未考虑经营现金流量和资产质量，对业绩可持续性判断不足，所以需要对应的加入其他财务指标 9. 股票估值（1）市盈率市盈率（PE） = 股价 / 每股收益 = 股价估值 + 确定值 示例： 一只鸡预计未来三年每天下一个蛋，不考虑利息和涨价的话：鸡的价值 = 365 * 6 * 蛋单价 某公司发行1亿股，每年为股东赚10亿，每股收益则是10元。 估值受到对未来预测的影响，未来越光明的公司，越容易获得高估值 知识点 ①指数的价格 = 盈利 * 估值 ②短期赚钱靠估值上升（主要受投资者情绪影响 ） ③长期赚钱靠盈利增加 + 估值上升（受经济发展影响） ④不同指数估值不同，不能用同一个PE区间衡量指数 （2）市盈率分类区分：用每股收益的界定区分 市盈率分类 定义 优点 缺点 代表 静态市盈率 年报上的每股收益，算出来的市盈率 好算 滞后 过去 滚动市盈率 季报上的每股收益，算出来的市盈率 更新及时 仍然落后 现在 动态市盈率 = 股价 / 预测未来一年的业绩 超前、未来 可能超预期，被割韭菜 未来 10. 筹码分布（1）筹码分布一个股价不同价位的持仓占比，且显示对应的获利亏损情况 （2）筹码形态①单峰密集 低位单峰密集，筹码高度集中在底部，股价处于横盘状态，为主力吸筹建仓的重要手法，也是单峰密集形成的主要原因，形成时间越长，意味着筹码换手和主力吸筹越充分，后续上攻行情力度越大 但低位筹码集中不一定会上攻，也可能因为利空而下跌，只是说一旦上攻将有可能迅猛上涨。 在股价突破低位单峰密集价位必须有成交量的配合，无量就要警惕假突破 股价回调跌破低位单峰时，注意建仓或空仓。上涨过程中，低位单峰密集区是属于下跌支撑位置 高位单峰密集形成时间较短，密集程度也相对较低。可能是高位震荡洗盘等待再次来升，也可能是主力资金出货，区别对待。如果股价跌破高位单峰密集区，即刻减仓或空仓 ②双峰密集 对于股价运行又较强的支撑力和阻力，股价运行至上方筹码峰处，容易遇到解套抛压盘，受阻回落。股价运行至下方筹码峰处，容易被吸收承接而反弹。上峰称为压力峰，下峰称为支撑峰 ③多峰密集 上涨过程中，每一个峰就是一个压力区，下跌过程中，每一个峰就是一个支撑区 形态 含义 获利不抛的筹码是主力的筹码 获利30%很难见到主力出货 解套不卖的筹码是主力的筹码 主力解套后继续拉升随后出货 横盘洗不掉的筹码是主力的筹码 洗盘散户出局 上峰不移，下跌不止 高位密集峰没有向下移动，高位套牢盘仍然存在，上涨阻力过大 下峰锁定，行情未止 低位密集峰没有松动，市场持筹稳定，抛压不大 11.TOWER宝塔线TOWER（TWR）：注重股价分析的中长期指标。原理：趋势线+支撑区+压力区 （1）K线与宝塔线区别 K线 宝塔线 有高、低、开、收四要素 只重视收盘价 实体和影线两部分 结合红、绿两色柱状体 / 比K线更容易追踪趋势 （2）宝塔线用法 用法 操作 翻红之后往往持续上升 可以买入 翻绿之后通常持续下降 最好卖出 盘整阶段，小幅度翻红翻绿 当做什么都没发生过 平头形态短线要反转 根据高低位买入卖出 和均线一起看：红色且5日均线往上，看多 可追高，尽量买在MA5处 和均线一起看：绿色且MA5往下，看空 坚决出局 （3）补充可能卖不到最高点或买不到最低点，但整体涨跌还是可以把握。如果再极端行情，平顶或平底大多只会出现两个，所以当出现两个宝塔线平头形态时，就要格外关注 二、均线1. 均线止损法（1）不能单纯的选择百分比止损，有时候也需要保证盈利比例进行止盈式的止损 （2）K线站上5日均线买入，跌破5日均线卖出 （3）MA5乖离率过高时，5日均线上方的K线买入没有任何意义，甚至可能出现亏损 （4）K线总是频繁接触MA5时，MA5也就失去了它的指导意义，此时可修改为9日线，看图更加清晰 2. 二线法（1）MA5下穿MA10时，清仓。反之上穿MA10时，短线买入。 （2）当股价存在大的波动时，5日线则会和10日线进行交叉，MA5和MA10用于短线操作，而60日均线则辅助确定长线趋势 3. 长短均线法（1）60日线助涨5、10日线金叉向上，如果60日线方向也向上，则助涨 （2）60日线助跌5、10日线死叉向下，如果60日线方向也向下，则助跌 （3）跌破60日线5日线、10日线回档时与60日线要有一定空隙，因为60日线起到一定支撑作用；两短线跌破60日线时是大幅下跌的预兆 （4）金叉位置要比前一个更高每个金叉比前一个金叉位置更高时，才能保持股价整体上涨的高度、角度、速度不变。当一旦上涨速度变慢或不创新高而创新低时，就要考虑会不会反跌了 （5）成交量线+MACD （6）补充此方法在大趋势的保障下可以短线操作，也可以每天只盯盘一次，佛系炒股 4. 三分法（1）概念MA7 + MA13 + MA20 （2）止损系统①三条均线每跌破一条线就卖出三分之一仓位，三条线全部跌破时清仓 ②对于暴涨的股票，必须在跌破7日线之后就清仓，否则会有较大风险 （3）买入系统①每站上一条均线，买入三分之一仓位，直到满仓，然后用三线止损卖出 ②三线交易法最忌讳横盘震荡，可用于高抛低吸，抓反弹 5. 60日生命线（1）60日线确定股票趋势 6. 357均线法（1）概念MA3 + MA5 + MA7 （2）跌破7日线3日线掉头或击破7日线时，落袋为安 （3）站上5日线，上穿三线K线站上5日线建仓，强势上穿3线时也可 （4）9日均线①三线可能经常出现反包现象，此时可增加9日线 ②下跌过程中，三线+9日线，9日线起支撑作用，站稳9日线可继续买入 三、成交量1. 量能（1）市场最真实的数据量能 （2）无量无行情 上涨需有量 （3）量能的三种形式①正常波动 此图资金短炒，一个涨停板后就已经出货，不能高位追涨 ②快速放量，筹码搜集 阴跌之后的企稳，成交量放大，短期走强有量能支撑，后续有机会放量突破 ③成交量萎缩，股价走低，下跌后，再次迎来爆量，上涨行情 （4）补充量能见顶，比如天量、阶段巨量等结合股价或K线图，大多是见顶信号。前市无量，有量则突破。而上涨过程中出现天量则是下跌前兆，需要关注。 2. 成交量口诀 成交量口诀 翻译 走势 ①新量新价有新高 近期一个新量配合股价创近期新高 后期继续看涨 ②缩量回调不必逃 成交量有明显缩减 股价有一定回调，但可以继续持有 ③放量滞涨要当心 成交量创新高，股价没新高 滞涨，可能大跌 ④无量上涨必须跑 量能缩减，股价却上涨，特别是高位 下跌风险 3. 顶量与底量（1）股价配合成交量看当股价顶点滑落一段时间后，会有一个见底回升的过程，配合成交量看是否有人在底部抄底 如果底量能大大的超过顶量则容易通过顶量造成的压力带，主力一般会在股价下跌过程中慢慢买入，并且是悄悄的一边打压股价一边买入，成交量不可能太大，当股价跌到主力满意时，主力资金才肯大力收集筹码，此时成交量会急骤放大。 若底部放量的量能高于前顶，则说明新行情继续开始，不必太担心股价冲不上去。 （2）补充顶量处有一定套牢盘，当股价从低位上涨至前头部顶量区间时，套牢盘会挣扎解套出局。如果底量没有超过顶量的话，对行情造成不利局面，股价上涨压力大。量在价先！ 4. 高量柱战法（1）高量柱容易辨认 （2）高量柱是主力所为散户不可能第一天就让量能那么高，第二天有突然那么低 （3）高量不破在高量柱对应k线最低点画一条线可以看到后面的走势都没有破这条线，说明有止跌迹象，但现在还不是介入时机 成交量放量出现高量柱，伴随高量柱，K线突破前期高点，此时介入 （4）如何判断高量柱股价突破后的走势①以买点的K线最低点划线，后面没有破，就可以放心持有 ②到了下根高量柱也就是高量接力柱，又在其K线最低点画线，后面不破，继续持有 ③依此类推 ④如果阴险跌破划线位置直接清仓，如果阳线低开，划线位置仍可持仓，也可半仓。阳线代表多方情绪，所以开始有后续承接力 5. 成交量看妖股（1）小版块一板、二板放量缩量都没关系，但是放量仍旧比缩量好，二板放量走的高度会更高，也更健康。小版块一般连续涨停四五天基本就到头了，有人提前获利跑路（陷阱：炒作） （2）大板块换手率高的龙头，经过放量分歧后可能还会继续缩量加速 （3）妖股必须放量抗住抛压继续上涨，后面有可能继续放量，也有可能再次缩量达到一致。继续放量意味着分歧。 妖股不怕分歧，就怕都看好，而达到筹码一致锁仓。当再次加速一致，就会加速死亡。 （4）相同的过程 6. 抓反弹反弹的力度取决于量能的大小，有价有量 涨幅高于 昨天跌幅50%，成交量高于昨天的20%可建仓，确定形势后可适当加仓 在大环境的影响下，如果大盘下跌没有企稳迹象，这个方法可能有风险 四、短线盘口1. 盘口1：量比（1）概念是反应成交量变化的重要指标，是股票开市后每分钟的平均成交量与过去5个交易日每分钟平均成交量之比 公式：（当天即时成交量 / 开盘至今的累计N分出钟） / （前五天总成交量 / 1200分钟） （2）看法①量比 &gt; 1，表明该股当日交易活跃，成交量较过去5日增多 ②量比 &lt; 1，表明该股成交量萎缩 （3）委比是所有委托阿米如的量与委托卖出的量之比 委比反应某只股票当日开盘后，是想买入的人多，还是想卖出的人多。当委比值为正且数值越大说明该股买入意愿强烈，股价大多会涨，反之大多会跌。 但委比并不那么靠谱，委托买入或卖出是随时可以撤单的，有人利用这个漏洞拉高或拉低委比制造假象 （4）利用量比选股方法一 方法 操作 ①圈定范围 早盘十点后，点击量比大小排序，前80里面点击涨幅排序，选出2%-5%的股票 ②批量剔除 按①操作后，再剔除流通市值大于100亿的股票 ③个股剔除 按②操作后，再剔除个图走势差的 1、剔除明显破位下跌趋势中的反弹股 2、重点剔除当天高开低走以及高开之后拉升，然后跌破开盘价的 ④优选形态 按③操作后，选出优质个股 1、股价长期横盘，并且成交量一直萎缩 2、当日股价已经一阳穿多线 3、该股题材是当日热点版块 方法二 方法 ①选出量比大于2，最好大于2.5的 ②然后在其中筛选出换手率小于5%的 ③然后能找出许久以来首次放量的个股最佳，当日收中阳，或长上影都以。若大阳上穿多条密集纠结的均线最佳 ④下方有较强支撑，次日择机在早盘或低价介入。选择均线、量线和MACD能够几乎同步金叉最好，其同步性前后最好不超过1天 2. 盘口2：换手率（1）概念换手率也称周转率，指在一定时间内市场中股票转手买卖的频率，反应股票流通强弱的指标之一。 公式：成交量 / 发行总股数 * 100% 示例：某只股票一天成交了500万股，而这只股票的流通股为1亿股，那么该股当日换手率为5%。 （2）为什么选换手率高的个股？ 原因 ①换手率越高，意味着股票交投越活跃，购买意愿越高，属于热门股，否则就是冷门股，一般大多每日换手率在1%-2.5%。3%为一个分界 ②换手率高一般意味着股票流通性好，近处市场比较容易，一般不会出现买不到或卖不掉的情况 ③与股价走势相结合，可以对未来股价做出一定预判 （3）补充换手率较高的股票，往往也是短线资金追逐的对象，投机性较强，股价起伏较大，风险相对较大。光看换手率还不行，结合其他指标综合查看 3. 盘口3：分时量（1）大盘分时量与未来涨缩量，跌放量，跌面大；涨放量，跌缩量，涨面大 涨缩量：大盘上涨的时候交易量及减少，大盘上看到的红柱越来越短。这种涨往往是虚涨。 跌放量：大盘下跌的时候交易量增加，在大盘分时图上，绿柱越来越长，卖出越来越多。这种下跌往往是实跌。 涨放量：大盘上涨的时候交易量增加，大盘上红柱越来越长，交易量带来的价格上涨是实涨。 跌缩量：大盘下降的时候交易量减少，绿柱越来越短，说明没有因为价格下跌而卖出，而是继续持有或观望态度。 （2）个股分时与未来上面的方法同样适合个股。 反弹有量，会有更高价格；反弹无量，后市会掉下来。 当某只股票价格反弹的时候，交易量也配合上涨，那么这只股票后期仍然还有上涨空间 （3）补充看单指标容易陷入卖了涨，买了跌的泥潭，配合其他因素一起来看 4. 盘口4：挂单栏 当某只股票分时盘口上突然出现连续或断断续续的大单挂单并开始成交，就表明有可能主力开始行动了。 单子大小跟该股流通盘大小有关，而且这个单不一定是一个人挂的，可能是几个人或几十个人。 单子的大小跟换手率也有关，一个换手极小的盘子稍大的股，大单往往也不算大 （1）压迫式挂单递增压迫式挂单是出现三档以上的递增式大卖单，后面的卖压越来越大，不趁早抛出，后面会越来越难卖。 递减式挂单相反，主力一旦吃掉第一档大单，往往市场就会立刻出现跟风盘，后面的挂单会在短时间内一扫而光 （2）拦截式挂单委买栏出现明显大买单，说明下方接盘巨大，可以放心买入 当上方的卖单被吃掉后，盘口又会出现类似的大买单，其重心会不断上移，反复多次，直至涨停。 （3）夹板式挂单分别在委买和委卖栏某一个价位挂出的大单 使买卖盘口上出现一种上有天花板，下有水泥板的格局。夹板一旦撤离，或是被大单打掉，就是主力向涨停板或跌停板发起最后进攻的信号 （4）蜂窝式挂单是密集挂出连续委买和委卖的大单，透露出市场参与者对筹码的关注程度很高。买卖气氛十分热烈。 如果是大盘股，多空双方分歧明显，想要攻击涨停，多头需付出极大努力 如果是中小盘，则主力不想自己干活，想借助市场力量去推挤股价 经验证明：委卖栏上的蜂窝式挂单，一旦开始被吃掉，涨停的概率远高于委买式蜂窝挂单被吃掉的涨停概率 前者是主力对倒盘，主力资金主动性攻击行为；后者主力资金诱导下的市场力量，上涨力度不如前者 （5）补充：四种大挂单形式，往往交错显示，并非一成不变。大单挂单的成交应该也是被大单吃掉。如果是小单去吃掉这些大单，则该股涨停的概率大大降低。因为不是主力行为。有些主力会利用盘口语言，忽悠韭菜进入，然后收割。 5. 盘口5：内外盘（1）概念内盘：里面的人想出去，成交明细里面的S（Sell） 外盘：外面的人想进来，成交明细里面的B（Buy） （2）看法外盘大说明股票主动买入多，外盘的大小影响股价的涨跌，但不能确定股价的方向。 （3）陷进主力资金要出货时，让外盘大大大于内盘，诱导散户接盘 （4）口诀 口诀 外盘偏大，股价看涨 内盘偏大，股价看跌 外大价跌，主力出逃 内大价涨，主力吸筹 6：集合竞价（1）概念开盘时的价格由集合竞价决定 9:00 - 9:15下单会在券商服务器排队。 9:15 - 9:20 开闸去交易所排队，期间可以撤单 9:20 - 9:25 无法撤单，且9:25分撮合成最终开盘价 （2）成交原则先价格优先，然后时间优先 ①成交量最大 ②高于基准价格的买入申报和低于基准价格的卖出申报全部成交 ③与基准价格相同的买卖双方中，有一方申报全部满足成交 结论：集合竞价时，要买就挂涨停价，要卖就挂跌停价 （3）陷阱9:20之前下单的都不靠谱，因为有些主力为了吸引眼球会出大单顶出高价，然后在最后十秒撤单 （4）图形集合竞价以大盘图表示成交量，分时为上下两种，上方为下单但未匹配的量，下方为下单匹配的量，也就是成交量 买方优势，显示为红色；卖方优势显示为绿色 （5）对股价的影响①高开：如果股价处于K线低位，高开是好事。如果股价处于K先高位，高开则大多是出货 ②低开：如果股价处于K线低位，小心新一波的下跌 ③挂单踊跃：如果股票买卖盘挂单都特别大，则往往意味着该股会出现异动 ④挂单稀疏：挂单稀疏的股，当天往往没戏 ⑤涨停价挂单：重大利好刺激或主力拉升，使得股票在集合竞价的时候就高开或奔向涨停，这个时候如果追，就要看速度 ⑥跌停价挂单：重大利空刺激或主力出货，使得股票在集合竞价的时候就低开或跌停 （6）补充价格优先，就是买入的时候价格越高越好，卖的时候价格越低越好。同样的，如果有人抢着买入，就看张，否则看跌。 五、即学即用的方法1. 区间法区间交易法：美国人西蒙斯 （1）示例一某股票在5-7元之间波动 也就是说这之间有2元的空间，把2元钱的空间分成若干等分，比如0.5元一个区间，如果5元建仓买入 涨到5.5的时候就卖掉一部分 涨到6的时候再卖掉一部分 当股价跌到5.5时再买入一部分，跌到5时再买入一部分 上面所说的一部分都是等量（股票数量）的 （2）示例二这只股票最低6.5元，最高11元，大概率在7-10元之间波动。 将其分为0.5元一个区间 假设在9.5元时买入，下跌到9元的时候就买入一部分，跌到8.5元继续买… 跌到7元时涨了。涨到7.5时就把7元时买入的部分卖掉 涨到8元时再把7.5元买入的卖出 然后股价又跌到7.5元，再把8元卖出的7.5元买回来 遵循这个原则，股价不断波动，就能不断赚钱 这只股票半年越高涨了3元，就算神算子，最低6.5元买入，不做波段，最高11元卖出，也就只赚了4.5元 如果严格按照区间交易法，可以赚到11元多（所有卖点-所有买点），买卖对冲使成本不断下降，利润不断累计 当区间变小时，区间价格对应减小即可。 （3）ATR - 波动率指标ATR波动越大，就代表股价波动越大 （4）总结该方法需选择波动大的股票来操作，适合的行情有： 绝对不适合的行情有： 横盘震荡幅度越大越挣钱，理论上区间越小越挣钱。但也需要根据资产以及股票历史性涨幅来自行规划 该方法需严格执行，纪律&gt;方法 2. 地摊法（1）概念通过资金管理来实现低风险稳收益的方案，思路来自连锁店经营模式 通过分散资金使其变动趋于平滑，尽量不让自己大起大落，从而控制风险，稳定盈利 （2）使用①资金分成等额几份，建议不低于5份 ②订一个退出标准，即止损，到达止损无条件离开 ③订止盈位置比如20% （3）总结实现了资金完全贴合走势的自动调节，缺点则是不适合震荡期。震荡期使用区间法操作。 3. 麻雀战术即 见好就收 （1）模式一买进股票后，第二天开盘期，就以买入价加上2.5%的净利润价格预先填单卖出 （2）模式二买进股票后的第二天开盘期，就以买入价加上2.5%的净利润的价格每多涨一个点就卖出10%，直到卖完 （3）模式三买进股票后，就让股票充分涨，一旦不能创新高，在每个高点分批卖出，直到回落至获净利润2.5%时彻底清仓 （4）补充操作时看准方向顺势而为，在选择买卖点时需要运用短线操作技巧 4. 龙回头战法选择行业里的大哥大（涨得快，跌得慢） （1）注意事项①短期获利丰厚，抛盘增多，主力开始打压价格 ②然后再次更高更快更强的拉升价格 ③主力资金运作爆发的潜力股都是从涨停开始的，没有涨停板，反弹力度就不够（不一定，接近涨停也可） ④量能积累是主力进场标志，下跌过程中要缩量。说明主力没退场 ⑤股价回落至重要支撑位，股价止跌企稳，量能极度萎缩。 （2）总结①第一波大幅拉升的股票，回调后出现龙回头情况，往往是一次绝佳的机会 ②接入龙回调形态的股价，往往会出现明显缩量或股价走势迟钝 ③龙回头股票在回调过程中如在关键支撑位或重要均线附近止跌，则可靠性加大 5. 打板（1）扫板离涨停价还有几档，或者十几档就开始挂涨停价扫货。说明资金对该股严重看好 （2）打板最后一档价格即将被吃完时买入，是比较有信心确定大资金想封板时，共同吃掉最后一档卖单 （3）排板当市场环境不好或者换手不充分而又看好该股票时，在看到大单封死的瞬间，确定不是秒炸的情况下，第一时间以涨停价排队 （4）回封板看好的股缩量上板但又抛压很重的时候，炸板后在日内均线价以上横盘震荡整理的时候，判断其有换手充分后回封的预期，就可以等再次回封的时候买入 （5）打板条件 条件 ①人气很高 ②换手充分 ③新高板 ④历史股性好 ⑤同板块里最强的 注意：尽量选择在主升或者反弹的行情中顺势操作，必须是主流题材，整个概念版块强度要高 （6）补充 6. T+0即 做T（低吸高抛） 被套牢的股票T+0有利润就出一部分，不然它后面没资金低吸，就可能会给投资者造成不可挽回的损失。做T需要强执行力 7. 抄底法新手死于追高，老手死于抄底，高手死于杠杆 看大盘的120日均线和60日均线组成的区间带，K线站在带上就是上涨行情，跌破区间带就要下跌了 8. 压力支撑投资：基本面、技术面 结合前面所说的指标查看 （1）画线 - 斜线 （2）注意①触碰波峰或波谷的次数越多，有效性越强，至少三个点以上 ②链接K线实柱比链接影线效果更强，最好更具量能的变化去测试 ③画线时的低点，是上涨过程中的回踩低点 ④趋势线上为最佳补仓点，没回调到趋势线时也可小仓位补仓，防止不到趋势线出现股价拉升，错过降低成本的机会 ⑤如果是大阴线，高量，高换手，这样大K线触及趋势线不破，更说明趋势线的支撑非常强 ⑥一旦跌破趋势线一般很难立即重新站上 ⑦要知道上涨趋势是否依然存在 别都已经跌势了，还在当回调等反弹 （3）画线 - 横线即 多空转换线 当股票没有明显大行情时，需要用到。该股票高位时的支撑点，低位时的压力点 多次下跌不破的位置叫支撑，多次上涨不破的位置叫压力，接触的点越多，线越稳 （4）注意①线要画在多次下跌不破的地方和上涨不破的地方 ②被触及且不破的次数越多，支撑、压力越强 ③触及后当天立即反弹，支撑也强，反之，压力也很强 ④股价跌破并在多空反转线下运行一段时间，后面再站上线，这样进场更安全 ⑤如果股价跌破，代表进入短线回调，短线注意风险 （5）总结通过画线来判断支撑位和压力位比较精准，基本能很好的把我买卖点，套牢的也可以准确补仓，降低成本。 9. 复盘法（1）好处 好处 减少无效操作 培养对盘面的发展趋势的敏感度 培养联动逻辑 （2）如何复盘 如何复盘 操作 ①给大盘整体走势打分 满分100，连续三天都在35分一下，直接空仓，看下盘面，是权重发威还是中小创雄起 ②罗列当天主流版块 把涨停个股按照涨停时间先后排序，观察上板时间、封板金额、换手率、量能、是否炸板，是否引起后排个股跟风，确定龙头老大、老二、老三 ③观察次日龙头是否持续 结合大盘环境看，大盘强势，就搞版块龙头老大，大盘弱势，就搞超跌的小弟 ④确定股票类型 手慢无的话可以做老二老三老四，加入自选池 ⑤自选池把没用的其他个股删掉 保持自选股列表清洁 ⑥看看认可的大V复盘 找自己的疏漏和别人值得借鉴的地方，注意不能盲目追随 六、选股1. 尾盘选股法尾盘的重要性，在于它处于一种承前启后的特殊位置，技能回顾前市，又能预测后市。 （1）判断大盘把大盘15分钟K线图调出来，如果在下午两点半过后，15分钟K线图是处于上升趋势的话，就有机会在尾盘买进股票 如果大盘全天都是下跌趋势的话，15分钟K线图就要关注如下形态，出现此类形态就可以找类似形态的个股进行买入操作。如果是大盘放量大跌就不要进场选股操作。 （2）选股条件①振幅在5%以内（多空没有剧烈争斗） ②流通股本在20亿以下（剔除大盘股） ③换手率3%以上 ④量比在1.5以上（较之前活跃） ⑤20天内有涨停板历史（容易拉升） （3）形态以及买卖点选好之后开始看它们的日K线 ①平台突破 ②主升浪上攻 ③回踩收到支撑 （4）看分时图分时白线是回踩均线不破并处于上升趋势，且持续有大单买入的 （5）补充尾盘买进的强势个股，次日冲高时获利高抛即可。 2. 早盘选股 （1）选股条件①总股本小于3亿 ②涨幅大于3% ③换手率大于2 ④量比设置1.5倍 ⑤DMI趋势指标ADX值高于30 总股本3亿以下属于小盘股，盘子小好拉升，涨幅、换手率、量比都反映了该股的活跃度，活跃度越高，越容易拉升 （2）内外盘选好之后再看内外盘，要买外盘比内盘大的个股，在没有涨停之前，差距越大越好 然后在去掉已经涨停的，剩下的就是目标股。此方法属于短线选股。 （3）补充早盘选股比尾盘选股收益更大，但风险也比尾盘打，因为有时题材炒作力度不够，加上之前的套牢盘抛售，偶尔也会出现尾盘下跌的情况。第二天应及时止损 3. 热门选股（1）换手率寻找法①打开换手率排序，关注排行榜，换手率高，主力资金关注 ②寻找热门版块，细分行业出现得最多的版块 ③将个股加入自选 ④根据自己的交易系统，把符合的个股留下继续跟踪，寻找建仓机会 （2）涨幅榜寻找法①给涨幅榜排序 ②寻找热门版块和股票 ③接下来的办法同上 4. 题材逻辑选股（1）题材分级大题材通常以月为单位，题材龙头可能有翻倍涨幅；中题材以周为单位，龙头涨幅可能超过50%；小题材通常几天就结束，一般为突发消息刺激。 （2）大题材的光环①政策类：国家政策或地区政策刺激 ②科技稀缺类：锂电池、芯片、虚拟现实等等 ③天生牛股基因类：高转送、填权等 （3）大题材确定①未来市场容量大不大 就是看画饼大不大，饼越大炒作空间越大 ②当前有没有业绩支撑 是否是纯炒作还是有实实在在的业绩支撑 ③博弈难度大不大 有些产业政策很美好，但执行难度大，要谨慎 ④标的物是否好找，市值大不大 不要炒牵强的概念股，否则很容易一个涨停也出不来 如果标的物都是大盘股，以游资的实力，也根本没办法吵起来 ⑤政策力度大不大 一看发文件的单位级别，二看政府投资的力度 ⑥事件持续时间长不长 一般来说，持续时间长的题材，需要利好消息的频繁刺激，容量要足够大 ⑦看事件性质 要么可以改善公司长期业绩，要么可以改善公司短期业绩，要么不能改善业绩，但能改善短期现金流 ⑧方案是否详尽 方案一定要详尽，否则纸上谈兵，无法落实，等于没搞 ⑨是否为首次炒作该概念 通常新出现的概念持续性都很强 （4）总结一个题材能否演变成主线，从它出生的量级大小一看便清楚，如果不清楚，可能就需要上面的这些标准来判断。 5. 价值选股（1）有竞争力的公司 （2）产品单一，一个产品打天下更好 （3）低投入、高产出的公司 （4）利润总额高，盈利确定性高 （5）净资产收益率高的公司 （6）稳定高毛利率的公司 （7）应收款手、预收款多的公司 （8）选择一个行业龙头的公司 （9）每股收益高和借款金额少 （10）选择婴儿的股本、巨人的品牌、行业老大的公司 Source","categories":[{"name":"理财","slug":"理财","permalink":"https://kobingogo.github.io/categories/%E7%90%86%E8%B4%A2/"}],"tags":[{"name":"理财","slug":"理财","permalink":"https://kobingogo.github.io/tags/%E7%90%86%E8%B4%A2/"}]},{"title":"2021前端发展展望","slug":"2021前端发展展望","date":"2021-01-14T18:06:10.000Z","updated":"2022-02-18T02:31:03.807Z","comments":true,"path":"2021前端发展展望/","link":"","permalink":"https://kobingogo.github.io/2021%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E5%B1%95%E6%9C%9B/","excerpt":"又到了年底，想简单谈谈这一年前端的发展，以及21年可能会出现的一些趋势。毋庸置疑，2020年确实是不平凡的一年，对前端来说，私以为可以用“大前端持续深耕，泛前端兼容并包”这十四个字来形容。这里需要明确一下我对“大前端”以及“泛前端”这两个概念的理解：首先大前端可以分为广义的“大前端”和狭义的“大前端”，市面上常...","text":"又到了年底，想简单谈谈这一年前端的发展，以及21年可能会出现的一些趋势。毋庸置疑，2020年确实是不平凡的一年，对前端来说，私以为可以用“大前端持续深耕，泛前端兼容并包”这十四个字来形容。这里需要明确一下我对“大前端”以及“泛前端”这两个概念的理解：首先大前端可以分为广义的“大前端”和狭义的“大前端”，市面上常... 前言 又到了年底，想简单谈谈这一年前端的发展，以及21年可能会出现的一些趋势。毋庸置疑，2020年确实是不平凡的一年，对前端来说，私以为可以用“大前端持续深耕，泛前端兼容并包”这十四个字来形容。这里需要明确一下我对“大前端”以及“泛前端”这两个概念的理解：首先大前端可以分为广义的“大前端”和狭义的“大前端”，市面上常说的大前端主要分为这两类，所谓广义的“大前端”是指以前端技术解决所有本属于其他领域问题的前端技术，这里其实是包含了后边所说的泛前端的概念，也就是说只要是使用前端技术去解决的都可以定义为“大前端”；而狭义的“大前端”是仅指垂直到后端领域的前端技术，其代表是以node.js为主的扩展的去解决后端领域的技术，如出现了诸如express、koa、egg、nest等等配套的后端技术框架，甚至出现了node的微服务框架，我这里不做说明仅指狭义的“大前端”概念。对于“泛前端”，这个概念没有歧义，通常指的都是跨端技术，比如客户端、桌面端，甚至HUB等等，上图中所示的仅仅指一部分框架，并未收录完全，毕竟js/ts的社区实在太太太太活跃了，下面简单分说一下“大前端”和“泛前端”个人的一些见解，是以前端三大框架Vue、React、Angular为核心进行横向和纵向的框架探讨 泛前端技术框架探讨 Vue React Angular web端 Vue全家桶 React全家桶 Angular全家桶 桌面端 Electron/Nw Electron/Nw Electron/Nw/Cordova/Ionic 原生移动端 Weex React Native Cordova/Ionic 小程序端 uniapp/mpvue/mapx taro/Rax 无 大前端技术框架探讨 Vue React Angular web端 Vue全家桶 React全家桶 Angular全家桶 SSR Nuxt Next Universal 服务端 无特定 无特定 可配合Nest 今年阿里前端练习生计划将前端领域划分了七大方向，分别是工程化方向、前端中后台方向、Node.js方向、跨端技术方向、互动技术方向、可视化技术方向、前端智能化方向，个人认为Node.js是一个整体的前端基础，并不能单算做一个方向，因而我将其替换为音视频方向，私以为可将前端方向划分为以下几种，下面我将在这几个不同的方向维度进行个人的一些阐述和拙见： 中后台方向：微前端 可视化方向：antv 智能化方向：imgcook 互动方向：Eva 音视频方向：wasm 工程化方向：severless、全链路工程 跨端方向：kbone、rax 中后台方向 对于中后台方向，这是传统web方向，对于前端来说，2020年对于微前端的落地应用已有很多实践。因此，私以为微前端会作为未来前端大型应用的一种趋势，对于不同团队的不同技术栈的汇总整合是一个比较好的方案，虽然不同于服务端的那种微服务可以微的很彻底，但是前端加持着ts等的特性也是可以实现微化的效果，从而优化工时，提升效率，避免重复劳作； 既然第一点提到了ts，那这里我想说一说关于ts的问题，在19年我对ts的态度尚存观望，但在今年，我认为ts可以作为一种必备技能来考察和实践，并不是因为大家都在用，而是因为随着时间的发展，现在前端要承载的能力越来越重，项目也越来越大，ts可以很好的约定，对于后期的维护以及修改都可以很好的限制，对于大型团队、大型项目来说，ts是不二之选；另外，如果有团队真的要去开发服务端，那我真的建议你去用ts，如果你用过nest.js，你会发现和写java真的没什么区别，而且服务端的很多理念也可以通过ts的各种特性来使用，比如泛型、抽象类等。当然，如果是小团队，而且需要快速开发，对于小而美的应用，个人认为还是js适合，毕竟js是一门灵活的语言，哈哈哈 可视化方向 可视化这里，今年其实没有做多少实践，但是个人认为，这七个大方向而言，最容易出成果，或者说最能出大佬的，可能还真是可视化领域，如果能在可视化领域做到了前5%，那么我相信各大厂肯定会花钱养着你，毕竟我拥有你不一定重要，但是对手不拥有你对我很重要，你的技术壁垒就呈现了出来，也就在这个内卷的江湖获得了一些领先和优势，最起码裁员的优先级也不会那么靠前，哈哈哈 第一点说的有点儿远，说说实在的，个人觉得可以将阿里的antv作为可视化领域的一个标杆，针对各种特定领域进行展开，比如gis等，当然，其实可视化领域研究的深的话还是挺冷门的，这其实也会有一些机会，webGL/webAR/webVR等等都可以作为切入点，配合着下面的音视频领域，这两个的相互结合，确实还是能做出些东西的 智能化方向 智能化领域，个人认为其实核心不在于前端，而在于人工智能，而人工智能领域就不仅仅前端那么些东西了，对于封装好的如TensorFlow.js，我们是直接拿来用的，但是对于领面的模型建立其实才是关键，如果有同学想在智能化领域有所发展，个人建议还是要深钻一下，最好可以深造一下，毕竟这个东西是真的需要学术研究+产业实践的 在产业实践的前端领域，阿里还是比较领先的，比如imgcook，其核心目的是将图片转成前端代码，利用的机器视觉去识别图片中的不同的位置信息等，将其转成前端的代码，也就是所谓的D2C，即：Design to Code，今年的D2大会上又提出了P2C，即：Product to Code，但并不是真的将人类语言直接转换成code，而是对D2C的一个业务扩展，对于D2C某些业务代码利用一些特定的schema进行约定，让机器学习过程中多一些参数约束，从而提升代码实现度。虽然转化的代码还很冗余，但是对于一些初级的项目或页面，确实可以交给机器去实现，个人认为人工智能对低端重复的工作确实会进行替代，也算是对前端内卷做了一定的贡献，摊手... 互动方向 互动方向，目前大头还是在游戏方向，但是我还是认为页游或前端实现游戏主要还是做一些开胃菜的功能，并不能真正的将用户带进沉浸式的体验，对于小游戏引擎，今年阿里好像出了一个eva的引擎，感兴趣的同学可以看看 对于新体验方面，AR/VR/MR等可能在明年5g深化的时候会有一些落地实践，但可能还是不温不火，互动方向配合设计的新理念可能会是一个新的突破点 音视频方向 这里想说一说WebAssembly，虽然都说wasm是会替代掉js，但目前看应该还不太现实，wasm目前主要还是配合音视频领域多一些，另外就是一些额外的优化措施，配合rust进行优化等，如果有志于音视频领域有所建树的同学，wasm确实可以储备起来 webrtc是音视频领域一个绕不开的技术，另外就是播放器的实现，video.js、flv.js等，对于一些视频播放的协议也要了解，如rtmp/rtsp等，今年疫情的关系，带动着直播领域的火热，前端音视频方向说不定会是一个风口 工程化方向 工程化方向就不得不提serverless，这是今年前端最火热的一个话题了，私以为serverless不仅仅是前端领域的变化，它可能改变目前的开发模式，以后没有前后端之分（ps：目前确实是有合的趋势），只有云工程师和端工程师之分，那么对于目前的前端来说，我们就不能仅仅只关注前端领域的一些内容了，docker、k8s等属于传统后端或运维的部分，我们也需要掌握，对于一些后端的思维及名词也需要熟悉，如限流、削峰、服务降级等。当然serverless的前提其实是云原生，如果没有云化，那实现serverless的效果应该不如目前这样，当然个人认为这是一个必然的趋势，从今年的云栖大会以及运营商5g云化来看，云网融合、云边协同应该会是主流 前端工程化另外一个方向就是全链路的工程化，从脚手架、low code、插件市场等全链路的提供，简化前端开发门槛，这里可以参考淘系的飞冰，对low code以及ide的插件提供都有涉及，以及ui组件库的提供等等，形成一个全链路的前端生态。这里可以说说low code和no code，no code是一个无需任何编码的现成的工具，就是完全没有编程的入口；low code是一个需要部分编码的工具，为了是给一些非专业人士但又有编程需要的人员使用，强调开发出来给别人用，常见的比如给运营人员用的h5编辑器，如易企秀、maka、ih5等 跨端方向 跨端方向是一个老生常谈的问题，主流还是要write once，run anywhere，常见的无非就是利用各种框架将各个DSL进行来回转换，但其实这是一个伪命题，本质是不可能达到大一统的局面的，抽象就很难具象，这两者需要有一个平衡，需要对具体常见具体分析 私以为小程序领域是端方向下一个各家大佬追逐的市场，因为app领域的跑马圈地都已基本形成，现在再去开发出一个现象级的app几乎很难很难了，但是将app作为操作系统，以小程序去带动用户，形成用户闭环，还是有很大市场的，类小程序应用，如pwa、快应用等都是这种承载方式的不同展现，对跨端来说，这个不失为一种发展选择。对于小程序的框架也出现了kbone、rax等，可能也会有一个类似w3c这样的一个小程序标准，但是像微信这种巨无霸应用，是否真的会遵守就是另一回事了，总之，其实也不失为一个选择 总结回望2020，展望2021，总结如下： 大前端持续深耕，泛前端兼容并包 中后台微服务化，可视化行业细化 智能侧算法深化，互娱侧形态变化 音视频结构优化，工程侧全面转化 跨端侧具体改化，前端更加内卷化 好了，2021到了，愿大家在这个内卷的时代，都有自己的一技之长，形成自己的核心竞争力，升职加薪，再创辉煌，共勉！！！ 转载自Source","categories":[],"tags":[]},{"title":"css实现两个圆重叠","slug":"css-css实现两个圆重叠","date":"2021-01-07T17:04:27.000Z","updated":"2022-02-18T02:31:03.811Z","comments":true,"path":"css-css实现两个圆重叠/","link":"","permalink":"https://kobingogo.github.io/css-css%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E5%9C%86%E9%87%8D%E5%8F%A0/","excerpt":"工作中有一个需求，实现两个椭圆相交，并且相交区域颜色不同，类似于一个简单的韦恩图，如何用css实现这个效果？ 经过一番探索，找到了答案。","text":"工作中有一个需求，实现两个椭圆相交，并且相交区域颜色不同，类似于一个简单的韦恩图，如何用css实现这个效果？ 经过一番探索，找到了答案。 要实现这个效果，需要用到的神技：css-blend-mode, 它是一个css属性，描述了元素的内容应该与元素的直系父元素的内容和元素的背景如何混合。 有了这个，就可以愉快的直接上代码了： 1234&lt;div class=&quot;isolate&quot;&gt; &lt;div class=&quot;circle circle-1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;circle circle-2&quot;&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223.circle &#123; width: 110px; height: 70px; border-radius: 50% / 35px; mix-blend-mode: color-dodge; position: absolute; border: 1px solid #fff;&#125;.circle-1 &#123; background: #39518A;&#125;.circle-2 &#123; background: #0091FF; top: 40px;&#125;.isolate &#123; isolation: isolate; /* Without isolation, the background color will be taken into account */ position: relative;&#125; 具体效果参见：例子 当然css-blend-mode不仅仅只有这点作用，它还能用作背景混合，纹理叠加，视频混合等场景，具体可参考： 大神的文章 打完收工😊","categories":[{"name":"css","slug":"css","permalink":"https://kobingogo.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://kobingogo.github.io/tags/css/"}]},{"title":"ES6全部特性汇总","slug":"javascript-ES6全部特性汇总","date":"2020-10-23T10:58:51.000Z","updated":"2022-02-18T02:31:03.811Z","comments":true,"path":"javascript-ES6全部特性汇总/","link":"","permalink":"https://kobingogo.github.io/javascript-ES6%E5%85%A8%E9%83%A8%E7%89%B9%E6%80%A7%E6%B1%87%E6%80%BB/","excerpt":"本文的知识点完全是参考或摘录《ES6》里的语句，有部分语句为了方便理解和记忆，进行了相同意思的转义，同时对知识点进行归类划分。为了让大家能集中精力来记住这些特性，全文一句废话和题外话都没有，全部模块以笔记的形式进行书写，如果看得不是很惯建议对照《ES6》的内容来学习。 本文整理出来的笔记都是书中的精华内容，囊括了整个ES6体系的所有特性，非常方便大家重新认识全部ES6特性。半小时的阅读就可对ES6有一个全面的了解，可认为是一本ES6特性小字典，收藏后可随时查阅。即使看不完也要拉到本文末尾喔，有个大彩蛋，嘻嘻！","text":"本文的知识点完全是参考或摘录《ES6》里的语句，有部分语句为了方便理解和记忆，进行了相同意思的转义，同时对知识点进行归类划分。为了让大家能集中精力来记住这些特性，全文一句废话和题外话都没有，全部模块以笔记的形式进行书写，如果看得不是很惯建议对照《ES6》的内容来学习。 本文整理出来的笔记都是书中的精华内容，囊括了整个ES6体系的所有特性，非常方便大家重新认识全部ES6特性。半小时的阅读就可对ES6有一个全面的了解，可认为是一本ES6特性小字典，收藏后可随时查阅。即使看不完也要拉到本文末尾喔，有个大彩蛋，嘻嘻！ 修正ES6是ECMA为JavaScript制定的第6个标准版本，相关历史可查看此章节《ES6-ECMAScript6简介》。 标准委员会最终决定，标准在每年6月正式发布并作为当年的正式版本，接下来的时间里就在此版本的基础上进行改动，直到下一年6月草案就自然变成新一年的版本，这样一来就无需以前的版本号，只要用年份标记即可。ECMAscript 2015是在2015年6月发布ES6的第一个版本。以此类推，ECMAscript 2016是ES6的第二个版本、 ECMAscript 2017是ES6的第三个版本。ES6既是一个历史名词也是一个泛指，含义是5.1版本以后的JavaScript下一代标准，目前涵盖了ES2015、ES2016、ES2017、ES2018、ES2019、ES2020。 所以有些文章上提到的ES7(实质上是ES2016)、ES8(实质上是ES2017)、ES9(实质上是ES2018)、ES10(实质上是ES2019)、ES11(实质上是ES2020)，实质上都是一些不规范的概念。从ES1到ES6，每个标准都是花了好几年甚至十多年才制定下来，你一个ES6到ES7，ES7到ES8，才用了一年，按照这样的定义下去，那不是很快就ES20了。用正确的概念来说ES6目前涵盖了ES2015、ES2016、ES2017、ES2018、ES2019、ES2020。 另外，ES6更新的内容主要分为以下几点 表达式：声明、解构赋值 内置对象：字符串扩展、数值扩展、对象扩展、数组扩展、函数扩展、正则扩展、Symbol、Set、Map、Proxy、Reflect 语句与运算：Class、Module、Iterator 异步编程：Promise、Generator、Async ES2015 声明 const命令：声明常量 let命令：声明变量 作用 作用域 全局作用域 函数作用域：function() &#123;&#125; 块级作用域：&#123;&#125; 作用范围 var命令在全局代码中执行 const命令和let命令只能在代码块中执行 赋值使用 const命令声明常量后必须立马赋值 let命令声明变量后可立马赋值或使用时赋值 声明方法：var、const、let、function、class、import 重点难点 不允许重复声明 未定义就使用会报错：const命令和let命令不存在变量提升 暂时性死区：在代码块内使用const命令和let命令声明变量之前，该变量都不可用 解构赋值 字符串解构：const [a, b, c, d, e] = &quot;hello&quot; 数值解构：const &#123; toString: s &#125; = 123 布尔解构：const &#123; toString: b &#125; = true 对象解构 形式：const &#123; x, y &#125; = &#123; x: 1, y: 2 &#125; 默认：const &#123; x, y = 2 &#125; = &#123; x: 1 &#125; 改名：const &#123; x, y: z &#125; = &#123; x: 1, y: 2 &#125; 数组解构 规则：数据结构具有Iterator接口可采用数组形式的解构赋值 形式：const [x, y] = [1, 2] 默认：const [x, y = 2] = [1] 函数参数解构 数组解构：function Func([x = 0, y = 1]) &#123;&#125; 对象解构：function Func(&#123; x = 0, y = 1 &#125; = &#123;&#125;) &#123;&#125; 应用场景 交换变量值：[x, y] = [y, x] 返回函数多个值：const [x, y, z] = Func() 定义函数参数：Func([1, 2]) 提取JSON数据：const &#123; name, version &#125; = packageJson 定义函数参数默认值：function Func(&#123; x = 1, y = 2 &#125; = &#123;&#125;) &#123;&#125; 遍历Map结构：for (let [k, v] of Map) &#123;&#125; 输入模块指定属性和方法：const &#123; readFile, writeFile &#125; = require(&quot;fs&quot;) 重点难点 匹配模式：只要等号两边的模式相同，左边的变量就会被赋予对应的值 解构赋值规则：只要等号右边的值不是对象或数组，就先将其转为对象 解构默认值生效条件：属性值严格等于undefined 解构遵循匹配模式 解构不成功时变量的值等于undefined undefined和null无法转为对象，因此无法进行解构 字符串扩展 Unicode表示法：大括号包含表示Unicode字符(\\u&#123;0xXX&#125;或\\u&#123;0XXX&#125;) 字符串遍历：可通过for-of遍历字符串 字符串模板：可单行可多行可插入变量的增强版字符串 标签模板：函数参数的特殊调用 **String.raw()**：返回把字符串所有变量替换且对斜杠进行转义的结果 **String.fromCodePoint()**：返回码点对应字符 **codePointAt()**：返回字符对应码点(String.fromCodePoint()的逆操作) **normalize()**：把字符的不同表示方法统一为同样形式，返回新字符串(Unicode正规化) **repeat()**：把字符串重复n次，返回新字符串 **matchAll()**：返回正则表达式在字符串的所有匹配 **includes()**：是否存在指定字符串 **startsWith()**：是否存在字符串头部指定字符串 **endsWith()**：是否存在字符串尾部指定字符串 重点难点 以上扩展方法均可作用于由4个字节储存的Unicode字符上 数值扩展 二进制表示法：0b或0B开头表示二进制(0bXX或0BXX) 八进制表示法：0o或0O开头表示二进制(0oXX或0OXX) Number.EPSILON：数值最小精度 Number.MIN_SAFE_INTEGER：最小安全数值(-2^53) Number.MAX_SAFE_INTEGER：最大安全数值(2^53) **Number.parseInt()**：返回转换值的整数部分 **Number.parseFloat()**：返回转换值的浮点数部分 **Number.isFinite()**：是否为有限数值 **Number.isNaN()**：是否为NaN **Number.isInteger()**：是否为整数 **Number.isSafeInteger()**：是否在数值安全范围内 **Math.trunc()**：返回数值整数部分 **Math.sign()**：返回数值类型(正数1、负数-1、零0) **Math.cbrt()**：返回数值立方根 **Math.clz32()**：返回数值的32位无符号整数形式 **Math.imul()**：返回两个数值相乘 **Math.fround()**：返回数值的32位单精度浮点数形式 **Math.hypot()**：返回所有数值平方和的平方根 **Math.expm1()**：返回e^n - 1 **Math.log1p()**：返回1 + n的自然对数(Math.log(1 + n)) **Math.log10()**：返回以10为底的n的对数 **Math.log2()**：返回以2为底的n的对数 **Math.sinh()**：返回n的双曲正弦 **Math.cosh()**：返回n的双曲余弦 **Math.tanh()**：返回n的双曲正切 **Math.asinh()**：返回n的反双曲正弦 **Math.acosh()**：返回n的反双曲余弦 **Math.atanh()**：返回n的反双曲正切 对象扩展 简洁表示法：直接写入变量和函数作为对象的属性和方法(&#123; prop, method() &#123;&#125; &#125;) 属性名表达式：字面量定义对象时使用[]定义键([prop]，不能与上同时使用) 方法的name属性：返回方法函数名 取值函数(getter)和存值函数(setter)：get/set 函数名(属性的描述对象在get和set上) bind返回的函数：bound 函数名 Function构造函数返回的函数实例：anonymous 属性的可枚举性和遍历：描述对象的enumerable super关键字：指向当前对象的原型对象(只能用在对象的简写方法中method() &#123;&#125;) **Object.is()**：对比两值是否相等 **Object.assign()**：合并对象(浅拷贝)，返回原对象 **Object.getPrototypeOf()**：返回对象的原型对象 **Object.setPrototypeOf()**：设置对象的原型对象 **__proto__**：返回或设置对象的原型对象 属性遍历 描述：自身、可继承、可枚举、非枚举、Symbol 遍历 for-in：遍历对象自身可继承可枚举属性 Object.keys()：返回对象自身可枚举属性键组成的数组 Object.getOwnPropertyNames()：返回对象自身非Symbol属性键组成的数组 Object.getOwnPropertySymbols()：返回对象自身Symbol属性键组成的数组 Reflect.ownKeys()：返回对象自身全部属性键组成的数组 规则 首先遍历所有数值键，按照数值升序排列 其次遍历所有字符串键，按照加入时间升序排列 最后遍历所有Symbol键，按照加入时间升序排列 数组扩展 **扩展运算符(...)**：转换数组为用逗号分隔的参数序列([...arr]，相当于rest/spread参数的逆运算) **Array.from()**：转换具有Iterator接口的数据结构为真正数组，返回新数组 类数组对象：包含length的对象、Arguments对象、NodeList对象 可遍历对象：String、Set结构、Map结构、Generator函数 **Array.of()**：转换一组值为真正数组，返回新数组 **copyWithin()**：把指定位置的成员复制到其他位置，返回原数组 **find()**：返回第一个符合条件的成员 **findIndex()**：返回第一个符合条件的成员索引值 **fill()**：根据指定值填充整个数组，返回原数组 **keys()**：返回以索引值为遍历器的对象 **values()**：返回以属性值为遍历器的对象 **entries()**：返回以索引值和属性值为遍历器的对象 数组空位：ES6明确将数组空位转为undefined(空位处理规不一，建议避免出现) 扩展应用 克隆数组：const arr = [...arr1] 合并数组：const arr = [...arr1, ...arr2] 拼接数组：arr.push(...arr1) 代替apply：Math.max.apply(null, [x, y]) =&gt; Math.max(...[x, y]) 转换字符串为数组：[...&quot;hello&quot;] 转换类数组对象为数组：[...Arguments, ...NodeList] 转换可遍历对象为数组：[...String, ...Set, ...Map, ...Generator] 与数组解构赋值结合：const [x, ...rest/spread] = [1, 2, 3] 计算Unicode字符长度：Array.from(&quot;hello&quot;).length =&gt; [...&quot;hello&quot;].length 重点难点 使用keys()、values()、entries()返回的遍历器对象，可用for-of自动遍历或next()手动遍历 函数扩展 参数默认值：为函数参数指定默认值 形式：function Func(x = 1, y = 2) &#123;&#125; 参数赋值：惰性求值(函数调用后才求值) 参数位置：尾参数 参数作用域：函数作用域 声明方式：默认声明，不能用const或let再次声明 length：返回没有指定默认值的参数个数 与解构赋值默认值结合：function Func(&#123; x = 1, y = 2 &#125; = &#123;&#125;) &#123;&#125; 应用 指定某个参数不得省略，省略即抛出错误：function Func(x = throwMissing()) &#123;&#125; 将参数默认值设为undefined，表明此参数可省略：Func(undefined, 1) **rest/spread参数(...)**：返回函数多余参数 形式：以数组的形式存在，之后不能再有其他参数 作用：代替Arguments对象 length：返回没有指定默认值的参数个数但不包括rest/spread参数 严格模式：在严格条件下运行JS 应用：只要函数参数使用默认值、解构赋值、扩展运算符，那么函数内部就不能显式设定为严格模式 name属性：返回函数的函数名 将匿名函数赋值给变量：空字符串(ES5)、变量名(ES6) 将具名函数赋值给变量：函数名(ES5和ES6) bind返回的函数：bound 函数名(ES5和ES6) Function构造函数返回的函数实例：anonymous(ES5和ES6) **箭头函数(=&gt;)**：函数简写 无参数：() =&gt; &#123;&#125; 单个参数：x =&gt; &#123;&#125; 多个参数：(x, y) =&gt; &#123;&#125; 解构参数：(&#123;x, y&#125;) =&gt; &#123;&#125; 嵌套使用：部署管道机制 this指向固定化 并非因为内部有绑定this的机制，而是根本没有自己的this，导致内部的this就是外层代码块的this 因为没有this，因此不能用作构造函数 尾调用优化：只保留内层函数的调用帧 尾调用 定义：某个函数的最后一步是调用另一个函数 形式：function f(x) &#123; return g(x); &#125; 尾递归 定义：函数尾调用自身 作用：只要使用尾递归就不会发生栈溢出，相对节省内存 实现：把所有用到的内部变量改写成函数的参数并使用参数默认值 箭头函数误区 函数体内的this是定义时所在的对象而不是使用时所在的对象 可让this指向固定化，这种特性很有利于封装回调函数 不可当作构造函数，因此箭头函数不可使用new命令 不可使用yield命令，因此箭头函数不能用作Generator函数 不可使用Arguments对象，此对象在函数体内不存在(可用rest/spread参数代替) 返回对象时必须在对象外面加上括号 正则扩展 变更RegExp构造函数入参：允许首参数为正则对象，尾参数为正则修饰符(返回的正则表达式会忽略原正则表达式的修饰符) 正则方法调用变更：字符串对象的match()、replace()、search()、split()内部调用转为调用RegExp实例对应的RegExp.prototype[Symbol.方法] u修饰符：Unicode模式修饰符，正确处理大于\\uFFFF的Unicode字符 点字符(.) Unicode表示法 量词 预定义模式 i修饰符 转义 y修饰符：粘连修饰符，确保匹配必须从剩余的第一个位置开始全局匹配(与g修饰符作用类似) unicode：是否设置u修饰符 sticky：是否设置y修饰符 flags：返回正则表达式的修饰符 重点难点 y修饰符隐含头部匹配标志^ 单单一个y修饰符对match()只能返回第一个匹配，必须与g修饰符联用才能返回所有匹配 Symbol 定义：独一无二的值 声明：const set = Symbol(str) 入参：字符串(可选) 方法 **Symbol()**：创建以参数作为描述的Symbol值(不登记在全局环境) **Symbol.for()**：创建以参数作为描述的Symbol值，如存在此参数则返回原有的Symbol值(先搜索后创建，登记在全局环境) **Symbol.keyFor()**：返回已登记的Symbol值的描述(只能返回Symbol.for()的key) **Object.getOwnPropertySymbols()**：返回对象中所有用作属性名的Symbol值的数组 内置 Symbol.hasInstance：指向一个内部方法，当其他对象使用instanceof运算符判断是否为此对象的实例时会调用此方法 Symbol.isConcatSpreadable：指向一个布尔，定义对象用于Array.prototype.concat()时是否可展开 Symbol.species：指向一个构造函数，当实例对象使用自身构造函数时会调用指定的构造函数 Symbol.match：指向一个函数，当实例对象被String.prototype.match()调用时会重新定义match()的行为 Symbol.replace：指向一个函数，当实例对象被String.prototype.replace()调用时会重新定义replace()的行为 Symbol.search：指向一个函数，当实例对象被String.prototype.search()调用时会重新定义search()的行为 Symbol.split：指向一个函数，当实例对象被String.prototype.split()调用时会重新定义split()的行为 Symbol.iterator：指向一个默认遍历器方法，当实例对象执行for-of时会调用指定的默认遍历器 Symbol.toPrimitive：指向一个函数，当实例对象被转为原始类型的值时会返回此对象对应的原始类型值 Symbol.toStringTag：指向一个函数，当实例对象被Object.prototype.toString()调用时其返回值会出现在toString()返回的字符串之中表示对象的类型 Symbol.unscopables：指向一个对象，指定使用with时哪些属性会被with环境排除 数据类型 Undefined Null String Number Boolean Object(包含Array、Function、Date、RegExp、Error) Symbol 应用场景 唯一化对象属性名：属性名属于Symbol类型，就都是独一无二的，可保证不会与其他属性名产生冲突 消除魔术字符串：在代码中多次出现且与代码形成强耦合的某一个具体的字符串或数值 遍历属性名：无法通过for-in、for-of、Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回，只能通过Object.getOwnPropertySymbols返回 启用模块的Singleton模式：调用一个类在任何时候返回同一个实例(window和global)，使用Symbol.for()来模拟全局的Singleton模式 重点难点 Symbol()生成一个原始类型的值不是对象，因此Symbol()前不能使用new命令 Symbol()参数表示对当前Symbol值的描述，相同参数的Symbol()返回值不相等 Symbol值不能与其他类型的值进行运算 Symbol值可通过String()或toString()显式转为字符串 Symbol值作为对象属性名时，此属性是公开属性，但不是私有属性 Symbol值作为对象属性名时，只能用方括号运算符([])读取，不能用点运算符(.)读取 Symbol值作为对象属性名时，不会被常规方法遍历得到，可利用此特性为对象定义非私有但又只用于内部的方法 SetSet 定义：类似于数组的数据结构，成员值都是唯一且没有重复的值 声明：const set = new Set(arr) 入参：具有Iterator接口的数据结构 属性 constructor：构造函数，返回Set size：返回实例成员总数 方法 **add()**：添加值，返回实例 **delete()**：删除值，返回布尔 **has()**：检查值，返回布尔 **clear()**：清除所有成员 **keys()**：返回以属性值为遍历器的对象 **values()**：返回以属性值为遍历器的对象 **entries()**：返回以属性值和属性值为遍历器的对象 **forEach()**：使用回调函数遍历每个成员 应用场景 去重字符串：[...new Set(str)].join(&quot;&quot;) 去重数组：[...new Set(arr)]或Array.from(new Set(arr)) 集合数组 声明：const a = new Set(arr1)、const b = new Set(arr2) 并集：new Set([...a, ...b]) 交集：new Set([...a].filter(v =&gt; b.has(v))) 差集：new Set([...a].filter(v =&gt; !b.has(v))) 映射集合 声明：let set = new Set(arr) 映射：set = new Set([...set].map(v =&gt; v * 2))或set = new Set(Array.from(set, v =&gt; v * 2)) 重点难点 遍历顺序：插入顺序 没有键只有值，可认为键和值两值相等 添加多个NaN时，只会存在一个NaN 添加相同的对象时，会认为是不同的对象 添加值时不会发生类型转换(5 !== &quot;5&quot;) keys()和values()的行为完全一致，entries()返回的遍历器同时包括键和值且两值相等 WeakSet 定义：和Set结构类似，成员值只能是对象 声明：const set = new WeakSet(arr) 入参：具有Iterator接口的数据结构 属性 constructor：构造函数，返回WeakSet 方法 **add()**：添加值，返回实例 **delete()**：删除值，返回布尔 **has()**：检查值，返回布尔 应用场景 储存DOM节点：DOM节点被移除时自动释放此成员，不用担心这些节点从文档移除时会引发内存泄漏 临时存放一组对象或存放跟对象绑定的信息：只要这些对象在外部消失，它在WeakSet结构中的引用就会自动消 重点难点 成员都是弱引用，垃圾回收机制不考虑WeakSet结构对此成员的引用 成员不适合引用，它会随时消失，因此ES6规定WeakSet结构不可遍历 其他对象不再引用成员时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于WeakSet结构中 MapMap 定义：类似于对象的数据结构，成员键是任何类型的值 声明：const set = new Map(arr) 入参：具有Iterator接口且每个成员都是一个双元素数组的数据结构 属性 constructor：构造函数，返回Map size：返回实例成员总数 方法 **get()**：返回键值对 **set()**：添加键值对，返回实例 **delete()**：删除键值对，返回布尔 **has()**：检查键值对，返回布尔 **clear()**：清除所有成员 **keys()**：返回以键为遍历器的对象 **values()**：返回以值为遍历器的对象 **entries()**：返回以键和值为遍历器的对象 **forEach()**：使用回调函数遍历每个成员 重点难点 遍历顺序：插入顺序 对同一个键多次赋值，后面的值将覆盖前面的值 对同一个对象的引用，被视为一个键 对同样值的两个实例，被视为两个键 键跟内存地址绑定，只要内存地址不一样就视为两个键 添加多个以NaN作为键时，只会存在一个以NaN作为键的值 Object结构提供字符串—值的对应，Map结构提供值—值的对应 WeakMap 定义：和Map结构类似，成员键只能是对象 声明：const set = new WeakMap(arr) 入参：具有Iterator接口且每个成员都是一个双元素数组的数据结构 属性 constructor：构造函数，返回WeakMap 方法 **get()**：返回键值对 **set()**：添加键值对，返回实例 **delete()**：删除键值对，返回布尔 **has()**：检查键值对，返回布尔 应用场景 储存DOM节点：DOM节点被移除时自动释放此成员键，不用担心这些节点从文档移除时会引发内存泄漏 部署私有属性：内部属性是实例的弱引用，删除实例时它们也随之消失，不会造成内存泄漏 重点难点 成员键都是弱引用，垃圾回收机制不考虑WeakMap结构对此成员键的引用 成员键不适合引用，它会随时消失，因此ES6规定WeakMap结构不可遍历 其他对象不再引用成员键时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于WeakMap结构中 一旦不再需要，成员会自动消失，不用手动删除引用 弱引用的只是键而不是值，值依然是正常引用 即使在外部消除了成员键的引用，内部的成员值依然存在 Proxy 定义：修改某些操作的默认行为 声明：const proxy = new Proxy(target, handler) 入参 target：拦截的目标对象 handler：定制拦截行为 方法 **Proxy.revocable()**：返回可取消的Proxy实例(返回&#123; proxy, revoke &#125;，通过revoke()取消代理) 拦截方式 **get()**：拦截对象属性读取 **set()**：拦截对象属性设置，返回布尔 **has()**：拦截对象属性检查k in obj，返回布尔 **deleteProperty()**：拦截对象属性删除delete obj[k]，返回布尔 **defineProperty()**：拦截对象属性定义Object.defineProperty()、Object.defineProperties()，返回布尔 **ownKeys()**：拦截对象属性遍历for-in、Object.keys()、Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()，返回数组 **getOwnPropertyDescriptor()**：拦截对象属性描述读取Object.getOwnPropertyDescriptor()，返回对象 **getPrototypeOf()**：拦截对象原型读取instanceof、Object.getPrototypeOf()、Object.prototype.__proto__、Object.prototype.isPrototypeOf()、Reflect.getPrototypeOf()，返回对象 **setPrototypeOf()**：拦截对象原型设置Object.setPrototypeOf()，返回布尔 **isExtensible()**：拦截对象是否可扩展读取Object.isExtensible()，返回布尔 **preventExtensions()**：拦截对象不可扩展设置Object.preventExtensions()，返回布尔 **apply()**：拦截Proxy实例作为函数调用proxy()、proxy.apply()、proxy.call() **construct()**：拦截Proxy实例作为构造函数调用new proxy() 应用场景 Proxy.revocable()：不允许直接访问对象，必须通过代理访问，一旦访问结束就收回代理权不允许再次访问 get()：读取未知属性报错、读取数组负数索引的值、封装链式操作、生成DOM嵌套节点 set()：数据绑定(Vue数据绑定实现原理)、确保属性值设置符合要求、防止内部属性被外部读写 has()：隐藏内部属性不被发现、排除不符合属性条件的对象 deleteProperty()：保护内部属性不被删除 defineProperty()：阻止属性被外部定义 ownKeys()：保护内部属性不被遍历 重点难点 要使Proxy起作用，必须针对实例进行操作，而不是针对目标对象进行操作 没有设置任何拦截时，等同于直接通向原对象 属性被定义为不可读写/扩展/配置/枚举时，使用拦截方法会报错 代理下的目标对象，内部this指向Proxy代理 Reflect 定义：保持Object方法的默认行为 方法 **get()**：返回对象属性 **set()**：设置对象属性，返回布尔 **has()**：检查对象属性，返回布尔 **deleteProperty()**：删除对象属性，返回布尔 **defineProperty()**：定义对象属性，返回布尔 **ownKeys()**：遍历对象属性，返回数组(Object.getOwnPropertyNames()+Object.getOwnPropertySymbols()) **getOwnPropertyDescriptor()**：返回对象属性描述，返回对象 **getPrototypeOf()**：返回对象原型，返回对象 **setPrototypeOf()**：设置对象原型，返回布尔 **isExtensible()**：返回对象是否可扩展，返回布尔 **preventExtensions()**：设置对象不可扩展，返回布尔 **apply()**：绑定this后执行指定函数 **construct()**：调用构造函数创建实例 设计目的 将Object属于语言内部的方法放到Reflect上 将某些Object方法报错情况改成返回false 让Object操作变成函数行为 Proxy与Reflect相辅相成 废弃方法 Object.defineProperty() =&gt; Reflect.defineProperty() Object.getOwnPropertyDescriptor() =&gt; Reflect.getOwnPropertyDescriptor() 重点难点 Proxy方法和Reflect方法一一对应 Proxy和Reflect联合使用，前者负责拦截赋值操作，后者负责完成赋值操作 数据绑定：观察者模式 const observerQueue = new Set(); const observe = fn =&gt; observerQueue.add(fn); const observable = obj =&gt; new Proxy(obj, &#123; set(tgt, key, val, receiver) &#123; const result = Reflect.set(tgt, key, val, receiver); observerQueue.forEach(v =&gt; v()); return result; &#125; &#125;); const person = observable(&#123; age: 25, name: &quot;Yajun&quot; &#125;); const print = () =&gt; console.log(`$&#123;person.name&#125; is $&#123;person.age&#125; years old`); observe(print); person.name = &quot;Joway&quot;; 复制代码 Class 定义：对一类具有共同特征的事物的抽象(构造函数语法糖) 原理：类本身指向构造函数，所有方法定义在prototype上，可看作构造函数的另一种写法(Class === Class.prototype.constructor) 方法和关键字 **constructor()**：构造函数，new命令生成实例时自动调用 extends：继承父类 super：新建父类的this static：定义静态属性方法 get：取值函数，拦截属性的取值行为 set：存值函数，拦截属性的存值行为 属性 **__proto__**：构造函数的继承(总是指向父类) **__proto__.__proto__**：子类的原型的原型，即父类的原型(总是指向父类的__proto__) **prototype.__proto__**：属性方法的继承(总是指向父类的prototype) 静态属性：定义类完成后赋值属性，该属性不会被实例继承，只能通过类来调用 静态方法：使用static定义方法，该方法不会被实例继承，只能通过类来调用(方法中的this指向类，而不是实例) 继承 实质 ES5实质：先创造子类实例的this，再将父类的属性方法添加到this上(Parent.apply(this)) ES6实质：先将父类实例的属性方法加到this上(调用super())，再用子类构造函数修改this super 作为函数调用：只能在构造函数中调用super()，内部this指向继承的当前子类(super()调用后才可在构造函数中使用this) 作为对象调用：在普通方法中指向父类的原型对象，在静态方法中指向父类 显示定义：使用constructor() &#123; super(); &#125;定义继承父类，没有书写则显示定义 子类继承父类：子类使用父类的属性方法时，必须在构造函数中调用super()，否则得不到父类的this 父类静态属性方法可被子类继承 子类继承父类后，可从super上调用父类静态属性方法 实例：类相当于实例的原型，所有在类中定义的属性方法都会被实例继承 显式指定属性方法：使用this指定到自身上(使用Class.hasOwnProperty()可检测到) 隐式指定属性方法：直接声明定义在对象原型上(使用Class.__proto__.hasOwnProperty()可检测到) 表达式 类表达式：const Class = class &#123;&#125; name属性：返回紧跟class后的类名 属性表达式：[prop] Generator方法：* mothod() &#123;&#125; Async方法：async mothod() &#123;&#125; this指向：解构实例属性或方法时会报错 绑定this：this.mothod = this.mothod.bind(this) 箭头函数：this.mothod = () =&gt; this.mothod() 属性定义位置 定义在构造函数中并使用this指向 定义在类最顶层 new.target：确定构造函数是如何调用 原生构造函数 String() Number() Boolean() Array() Object() Function() Date() RegExp() Error() 重点难点 在实例上调用方法，实质是调用原型上的方法 Object.assign()可方便地一次向类添加多个方法(Object.assign(Class.prototype, &#123; ... &#125;)) 类内部所有定义的方法是不可枚举的(non-enumerable) 构造函数默认返回实例对象(this)，可指定返回另一个对象 取值函数和存值函数设置在属性的Descriptor对象上 类不存在变量提升 利用new.target === Class写出不能独立使用必须继承后才能使用的类 子类继承父类后，this指向子类实例，通过super对某个属性赋值，赋值的属性会变成子类实例的属性 使用super时，必须显式指定是作为函数还是作为对象使用 extends不仅可继承类还可继承原生的构造函数 私有属性方法 const name = Symbol(&quot;name&quot;); const print = Symbol(&quot;print&quot;); class Person &#123; constructor(age) &#123; this[name] = &quot;Bruce&quot;; this.age = age; &#125; [print]() &#123; console.log(`$&#123;this[name]&#125; is $&#123;this.age&#125; years old`); &#125; &#125; 复制代码 继承混合类 function CopyProperties(target, source) &#123; for (const key of Reflect.ownKeys(source)) &#123; if (key !== &quot;constructor&quot; &amp;&amp; key !== &quot;prototype&quot; &amp;&amp; key !== &quot;name&quot;) &#123; const desc = Object.getOwnPropertyDescriptor(source, key); Object.defineProperty(target, key, desc); &#125; &#125; &#125; function MixClass(...mixins) &#123; class Mix &#123; constructor() &#123; for (const mixin of mixins) &#123; CopyProperties(this, new mixin()); &#125; &#125; &#125; for (const mixin of mixins) &#123; CopyProperties(Mix, mixin); CopyProperties(Mix.prototype, mixin.prototype); &#125; return Mix; &#125; class Student extends MixClass(Person, Kid) &#123;&#125; 复制代码 Module 命令 export：规定模块对外接口 默认导出：export default Person(导入时可指定模块任意名称，无需知晓内部真实名称) 单独导出：export const name = &quot;Bruce&quot; 按需导出：export &#123; age, name, sex &#125;(推荐) 改名导出：export &#123; name as newName &#125; import：导入模块内部功能 默认导入：import Person from &quot;person&quot; 整体导入：import * as Person from &quot;person&quot; 按需导入：import &#123; age, name, sex &#125; from &quot;person&quot; 改名导入：import &#123; name as newName &#125; from &quot;person&quot; 自执导入：import &quot;person&quot; 复合导入：import Person, &#123; name &#125; from &quot;person&quot; 复合模式：export命令和import命令结合在一起写成一行，变量实质没有被导入当前模块，相当于对外转发接口，导致当前模块无法直接使用其导入变量 默认导入导出：export &#123; default &#125; from &quot;person&quot; 整体导入导出：export * from &quot;person&quot; 按需导入导出：export &#123; age, name, sex &#125; from &quot;person&quot; 改名导入导出：export &#123; name as newName &#125; from &quot;person&quot; 具名改默认导入导出：export &#123; name as default &#125; from &quot;person&quot; 默认改具名导入导出：export &#123; default as name &#125; from &quot;person&quot; 继承：默认导出和改名导出结合使用可使模块具备继承性 设计思想：尽量地静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量 严格模式：ES6模块自动采用严格模式(不管模块头部是否添加use strict) 模块方案 CommonJS：用于服务器(动态化依赖) AMD：用于浏览器(动态化依赖) CMD：用于浏览器(动态化依赖) UMD：用于浏览器和服务器(动态化依赖) ESM：用于浏览器和服务器(静态化依赖) 加载方式 运行时加载 定义：整体加载模块生成一个对象，再从对象上获取需要的属性和方法进行加载(全部加载) 影响：只有运行时才能得到这个对象，导致无法在编译时做静态优化 编译时加载 定义：直接从模块中获取需要的属性和方法进行加载(按需加载) 影响：在编译时就完成模块加载，效率比其他方案高，但无法引用模块本身(本身不是对象)，可拓展JS高级语法(宏和类型校验) 加载实现 传统加载：通过&lt;script&gt;进行同步或异步加载脚本 同步加载：&lt;script src=&quot;&quot;&gt;&lt;/script&gt; Defer异步加载：&lt;script src=&quot;&quot; defer&gt;&lt;/script&gt;(顺序加载，渲染完再执行) Async异步加载：&lt;script src=&quot;&quot; async&gt;&lt;/script&gt;(乱序加载，下载完就执行) 模块加载：&lt;script type=&quot;module&quot; src=&quot;&quot;&gt;&lt;/script&gt;(默认是Defer异步加载) CommonJS和ESM的区别 CommonJS输出值的拷贝，ESM输出值的引用 CommonJS一旦输出一个值，模块内部的变化就影响不到这个值 ESM是动态引用且不会缓存值，模块里的变量绑定其所在的模块，等到脚本真正执行时，再根据这个只读引用到被加载的那个模块里去取值 CommonJS是运行时加载，ESM是编译时加载 CommonJS加载模块是对象(即module.exports)，该对象只有在脚本运行完才会生成 ESM加载模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成 Node加载 背景：CommonJS和ESM互不兼容，目前解决方案是将两者分开，采用各自的加载方案 区分：要求ESM采用.mjs后缀文件名 require()不能加载.mjs文件，只有import命令才可加载.mjs文件 .mjs文件里不能使用require()，必须使用import命令加载文件 驱动：node --experimental-modules file.mjs 限制：Node的import命令目前只支持加载本地模块(file:协议)，不支持加载远程模块 加载优先级 脚本文件省略后缀名：依次尝试加载四个后缀名文件(.mjs、.js、.json、node) 以上不存在：尝试加载package.json的main字段指定的脚本 以上不存在：依次尝试加载名称为index四个后缀名文件(.mjs、.js、.json、node) 以上不存在：报错 不存在的内部变量：arguments、exports、module、require、this、__dirname、__filename CommonJS加载ESM 不能使用require()，只能使用import() ESM加载CommonJS 自动将module.exports转化成export default CommonJS输出缓存机制在ESM加载方式下依然有效 采用import命令加载CommonJS模块时，不允许采用按需导入，应使用默认导入或整体导入 循环加载 定义：脚本A的执行依赖脚本B，而脚本A的执行又依赖脚本B 加载原理 CommonJS：require()首次加载脚本就会执行整个脚本，在内存里生成一个对象缓存下来，二次加载脚本时直接从缓存中获取 ESM：import命令加载变量不会被缓存，而是成为一个指向被加载模块的引用 循环加载 CommonJS：只输出已经执行的部分，还未执行的部分不会输出 ESM：需开发者自己保证真正取值时能够取到值(可把变量写成函数形式，函数具有提升作用) 重点难点 ES6模块中，顶层this指向undefined，不应该在顶层代码使用this 一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取 export命令输出的接口与其对应的值是动态绑定关系，即通过该接口可获取模块内部实时的值 import命令大括号里的变量名必须与被导入模块对外接口的名称相同 import命令输入的变量只读(本质是输入接口)，不允许在加载模块的脚本里改写接口 import命令命令具有提升效果，会提升到整个模块的头部，首先执行 重复执行同一句import语句，只会执行一次 export default命令只能使用一次 export default命令导出的整体模块，在执行import命令时其后不能跟大括号 export default命令本质是输出一个名为default的变量，后面不能跟变量声明语句 export default命令本质是将后面的值赋给名为default的变量，可直接将值写在其后 export default命令和export &#123;&#125;命令可同时存在，对应复合导入 export命令和import命令可出现在模块任何位置，只要处于模块顶层即可，不能处于块级作用域 import()加载模块成功后，此模块会作为一个对象，当作then()的参数，可使用对象解构赋值来获取输出接口 同时动态加载多个模块时，可使用Promise.all()和import()相结合来实现 import()和结合async/await来书写同步操作的代码 单例模式：跨模块常量 const NAME = &quot;Bruce&quot;; const AGE = 25; const SEX = &quot;male&quot;; export &#123; AGE, NAME, SEX &#125;; 复制代码 import &#123; AGE &#125; from &quot;person&quot;; console.log(AGE); 复制代码 import &#123; AGE, NAME, SEX &#125; from &quot;person&quot;; console.log(AGE, NAME, SEX); 复制代码 默认导入互换整体导入 import Person from &quot;person&quot;; console.log(Person.AGE); 复制代码 import * as Person from &quot;person&quot;; console.log(Person.default.AGE); 复制代码 Iterator 定义：为各种不同的数据结构提供统一的访问机制 原理：创建一个指针指向首个成员，按照次序使用next()指向下一个成员，直接到结束位置(数据结构只要部署Iterator接口就可完成遍历操作) 作用 为各种数据结构提供一个统一的简便的访问接口 使得数据结构成员能够按某种次序排列 ES6创造了新的遍历命令for-of，Iterator接口主要供for-of消费 形式：for-of(自动去寻找Iterator接口) 数据结构 集合：Array、Object、Set、Map 原生具备接口的数据结构：String、Array、Set、Map、TypedArray、Arguments、NodeList 部署：默认部署在Symbol.iterator(具备此属性被认为可遍历的iterable) 遍历器对象 **next()**：下一步操作，返回&#123; done, value &#125;(必须部署) **return()**：for-of提前退出调用，返回&#123; done: true &#125; **throw()**：不使用，配合Generator函数使用 ForOf循环 定义：调用Iterator接口产生遍历器对象(for-of内部调用数据结构的Symbol.iterator()) 遍历字符串：for-in获取索引，for-of获取值(可识别32位UTF-16字符) 遍历数组：for-in获取索引，for-of获取值 遍历对象：for-in获取键，for-of需自行部署 遍历Set：for-of获取值 =&gt; for (const v of set) 遍历Map：for-of获取键值对 =&gt; for (const [k, v] of map) 遍历类数组：包含length的对象、Arguments对象、NodeList对象(无Iterator接口的类数组可用Array.from()转换) 计算生成数据结构：Array、Set、Map **keys()**：返回遍历器对象，遍历所有的键 **values()**：返回遍历器对象，遍历所有的值 **entries()**：返回遍历器对象，遍历所有的键值对 与for-in区别 有着同for-in一样的简洁语法，但没有for-in那些缺点、 不同于forEach()，它可与break、continue和return配合使用 提供遍历所有数据结构的统一操作接口 应用场景 改写具有Iterator接口的数据结构的Symbol.iterator 解构赋值：对Set进行结构 扩展运算符：将部署Iterator接口的数据结构转为数组 yield*：yield*后跟一个可遍历的数据结构，会调用其遍历器接口 接受数组作为参数的函数：for-of、Array.from()、new Set()、new WeakSet()、new Map()、new WeakMap()、Promise.all()、Promise.race() Promise 定义：包含异步操作结果的对象 状态 进行中：pending 已成功：resolved 已失败：rejected 特点 对象的状态不受外界影响 一旦状态改变就不会再变，任何时候都可得到这个结果 声明：new Promise((resolve, reject) =&gt; &#123;&#125;) 出参 resolve：将状态从未完成变为成功，在异步操作成功时调用，并将异步操作的结果作为参数传递出去 reject：将状态从未完成变为失败，在异步操作失败时调用，并将异步操作的错误作为参数传递出去 方法 **then()**：分别指定resolved状态和rejected状态的回调函数 第一参数：状态变为resolved时调用 第二参数：状态变为rejected时调用(可选) **catch()**：指定发生错误时的回调函数 **Promise.all()**：将多个实例包装成一个新实例，返回全部实例状态变更后的结果数组(齐变更再返回) 入参：具有Iterator接口的数据结构 成功：只有全部实例状态变成fulfilled，最终状态才会变成fulfilled 失败：其中一个实例状态变成rejected，最终状态就会变成rejected **Promise.race()**：将多个实例包装成一个新实例，返回全部实例状态优先变更后的结果(先变更先返回) 入参：具有Iterator接口的数据结构 成功失败：哪个实例率先改变状态就返回哪个实例的状态 **Promise.resolve()**：将对象转为Promise对象(等价于new Promise(resolve =&gt; resolve())) Promise实例：原封不动地返回入参 Thenable对象：将此对象转为Promise对象并返回(Thenable为包含then()的对象，执行then()相当于执行此对象的then()) 不具有then()的对象：将此对象转为Promise对象并返回，状态为resolved 不带参数：返回Promise对象，状态为resolved **Promise.reject()**：将对象转为状态为rejected的Promise对象(等价于new Promise((resolve, reject) =&gt; reject())) 应用场景 加载图片 AJAX转Promise对象 重点难点 只有异步操作的结果可决定当前状态是哪一种，其他操作都无法改变这个状态 状态改变只有两种可能：从pending变为resolved、从pending变为rejected 一旦新建Promise对象就会立即执行，无法中途取消 不设置回调函数，内部抛错不会反应到外部 当处于pending时，无法得知目前进展到哪一个阶段 实例状态变为resolved或rejected时，会触发then()绑定的回调函数 resolve()和reject()的执行总是晚于本轮循环的同步任务 then()返回新实例，其后可再调用另一个then() then()运行中抛出错误会被catch()捕获 reject()的作用等同于抛出错误 实例状态已变成resolved时，再抛出错误是无效的，不会被捕获，等于没有抛出 实例状态的错误具有冒泡性质，会一直向后传递直到被捕获为止，错误总是会被下一个catch()捕获 不要在then()里定义rejected状态的回调函数(不使用其第二参数) 建议使用catch()捕获错误，不要使用then()第二个参数捕获 没有使用catch()捕获错误，实例抛错不会传递到外层代码，即不会有任何反应 作为参数的实例定义了catch()，一旦被rejected并不会触发Promise.all()的catch() Promise.reject()的参数会原封不动地作为rejected的理由，变成后续方法的参数 Generator 定义：封装多个内部状态的异步编程解决方案 形式：调用Generator函数(该函数不执行)返回指向内部状态的指针对象(不是运行结果) 声明：function* Func() &#123;&#125; 方法 **next()**：使指针移向下一个状态，返回&#123; done, value &#125;(入参会被当作上一个yield命令表达式的返回值) **return()**：返回指定值且终结遍历Generator函数，返回&#123; done: true, value: 入参 &#125; **throw()**：在Generator函数体外抛出错误，在Generator函数体内捕获错误，返回自定义的new Errow() yield命令：声明内部状态的值(return声明结束返回的值) 遇到yield命令就暂停执行后面的操作，并将其后表达式的值作为返回对象的value 下次调用next()时，再继续往下执行直到遇到下一个yield命令 没有再遇到yield命令就一直运行到Generator函数结束，直到遇到return语句为止并将其后表达式的值作为返回对象的value Generator函数没有return语句则返回对象的value为undefined yield*命令：在一个Generator函数里执行另一个Generator函数(后随具有Iterator接口的数据结构) 遍历：通过for-of自动调用next() 作为对象属性 全写：const obj = &#123; method: function*() &#123;&#125; &#125; 简写：const obj = &#123; * method() &#123;&#125; &#125; 上下文：执行产生的上下文环境一旦遇到yield命令就会暂时退出堆栈(但并不消失)，所有变量和对象会冻结在当前状态，等到对它执行next()时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行 方法异同 相同点：next()、throw()、return()本质上是同一件事，作用都是让函数恢复执行且使用不同的语句替换yield命令 不同点 **next()**：将yield命令替换成一个值 **return()**：将yield命令替换成一个return语句 **throw()**：将yield命令替换成一个throw语句 应用场景 异步操作同步化表达 控制流管理 为对象部署Iterator接口：把Generator函数赋值给对象的Symbol.iterator，从而使该对象具有Iterator接口 作为具有Iterator接口的数据结构 重点难点 每次调用next()，指针就从函数头部或上次停下的位置开始执行，直到遇到下一个yield命令或return语句为止 函数内部可不用yield命令，但会变成单纯的暂缓执行函数(还是需要next()触发) yield命令是暂停执行的标记，next()是恢复执行的操作 yield命令用在另一个表达式中必须放在圆括号里 yield命令用作函数参数或放在赋值表达式的右边，可不加圆括号 yield命令本身没有返回值，可认为是返回undefined yield命令表达式为惰性求值，等next()执行到此才求值 函数调用后生成遍历器对象，此对象的Symbol.iterator是此对象本身 在函数运行的不同阶段，通过next()从外部向内部注入不同的值，从而调整函数行为 首个next()用来启动遍历器对象，后续才可传递参数 想首次调用next()时就能输入值，可在函数外面再包一层 一旦next()返回对象的done为true，for-of遍历会中止且不包含该返回对象 函数内部部署try-finally且正在执行try，那么return()会导致立刻进入finally，执行完finally以后整个函数才会结束 函数内部没有部署try-catch，throw()抛错将被外部try-catch捕获 throw()抛错要被内部捕获，前提是必须至少执行过一次next() throw()被捕获以后，会附带执行下一条yield命令 函数还未开始执行，这时throw()抛错只可能抛出在函数外部 首次next()可传值 function Wrapper(func) &#123; return function(...args) &#123; const generator = func(...args); generator.next(); return generator; &#125; &#125; const print = Wrapper(function*() &#123; console.log(`First Input: $&#123;yield&#125;`); return &quot;done&quot;; &#125;); print().next(&quot;hello&quot;); 复制代码 ES2016 数值扩展 **指数运算符(**)**：数值求幂(相当于Math.pow()) 数组扩展 **includes()**：是否存在指定成员 ES2017 声明 共享内存和原子操作：由全局对象SharedArrayBuffer和Atomics实现，将数据存储在一块共享内存空间中，这些数据可在JS主线程和web-worker线程之间共享 字符串扩展 **padStart()**：把指定字符串填充到字符串头部，返回新字符串 **padEnd()**：把指定字符串填充到字符串尾部，返回新字符串 对象扩展 **Object.getOwnPropertyDescriptors()**：返回对象所有自身属性(非继承属性)的描述对象 **Object.values()**：返回以值组成的数组 **Object.entries()**：返回以键和值组成的数组 函数扩展 函数参数尾逗号：允许函数最后一个参数有尾逗号 Async 定义：使异步函数以同步函数的形式书写(Generator函数语法糖) 原理：将Generator函数和自动执行器spawn包装在一个函数里 形式：将Generator函数的*替换成async，将yield替换成await 声明 具名函数：async function Func() &#123;&#125; 函数表达式：const func = async function() &#123;&#125; 箭头函数：const func = async() =&gt; &#123;&#125; 对象方法：const obj = &#123; async func() &#123;&#125; &#125; 类方法：class Cla &#123; async Func() &#123;&#125; &#125; await命令：等待当前Promise对象状态变更完毕 正常情况：后面是Promise对象则返回其结果，否则返回对应的值 后随Thenable对象：将其等同于Promise对象返回其结果 错误处理：将await命令Promise对象放到try-catch中(可放多个) Async对Generator改进 内置执行器 更好的语义 更广的适用性 返回值是Promise对象 应用场景 按顺序完成异步操作 重点难点 Async函数返回Promise对象，可使用then()添加回调函数 内部return返回值会成为后续then()的出参 内部抛出错误会导致返回的Promise对象变为rejected状态，被catch()接收到 返回的Promise对象必须等到内部所有await命令Promise对象执行完才会发生状态改变，除非遇到return语句或抛出错误 任何一个await命令Promise对象变为rejected状态，整个Async函数都会中断执行 希望即使前一个异步操作失败也不要中断后面的异步操作 将await命令Promise对象放到try-catch中 await命令Promise对象跟一个catch() await命令Promise对象可能变为rejected状态，最好把其放到try-catch中 多个await命令Promise对象若不存在继发关系，最好让它们同时触发 await命令只能用在Async函数之中，否则会报错 数组使用forEach()执行async/await会失效，可使用for-of和Promise.all()代替 可保留运行堆栈，函数上下文随着Async函数的执行而存在，执行完成就消失 ES2018 字符串扩展 放松对标签模板里字符串转义的限制：遇到不合法的字符串转义返回undefined，并且从raw上可获取原字符串 对象扩展 **扩展运算符(...)**：转换对象为用逗号分隔的参数序列(&#123; ...obj &#125;，相当于rest/spread参数的逆运算) 扩展应用 克隆对象：const obj = &#123; __proto__: Object.getPrototypeOf(obj1), ...obj1 &#125; 合并对象：const obj = &#123; ...obj1, ...obj2 &#125; 转换字符串为对象：&#123; ...&quot;hello&quot; &#125; 转换数组为对象：&#123; ...[1, 2] &#125; 与对象解构赋值结合：const &#123; x, ...rest/spread &#125; = &#123; x: 1, y: 2, z: 3 &#125;(不能复制继承自原型对象的属性) 修改现有对象部分属性：const obj = &#123; x: 1, ...&#123; x: 2 &#125; &#125; 正则扩展 s修饰符：dotAll模式修饰符，使.匹配任意单个字符(dotAll模式) dotAll：是否设置s修饰符 后行断言：x只有在y后才匹配 后行否定断言：x只有不在y后才匹配 Unicode属性转义：匹配符合Unicode某种属性的所有字符 正向匹配：\\p&#123;PropRule&#125; 反向匹配：\\P&#123;PropRule&#125; 限制：\\p&#123;...&#125;和\\P&#123;...&#125;只对Unicode字符有效，使用时需加上u修饰符 具名组匹配：为每组匹配指定名字(?&lt;GroupName&gt;) 形式：str.exec().groups.GroupName 解构赋值替换 声明：const time = &quot;2017-09-11&quot;、const regexp = /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/u 匹配：time.replace(regexp, &quot;$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;&quot;) Promise **finally()**：指定不管最后状态如何都会执行的回调函数 Async **异步迭代器(for-await-of)**：循环等待每个Promise对象变为resolved状态才进入下一步 ES2019 字符串扩展 直接输入U+2028和U+2029：字符串可直接输入行分隔符和段分隔符 JSON.stringify()改造：可返回不符合UTF-8标准的字符串 **trimStart()**：消除字符串头部空格，返回新字符串 **trimEnd()**：消除字符串尾部空格，返回新字符串 对象扩展 **Object.fromEntries()**：返回以键和值组成的对象(Object.entries()的逆操作) 数组扩展 sort()稳定性：排序关键字相同的项目其排序前后的顺序不变，默认为稳定 **flat()**：扁平化数组，返回新数组 **flatMap()**：映射且扁平化数组，返回新数组(只能展开一层数组) 函数扩展 toString()改造：返回函数原始代码(与编码一致) catch()参数可省略：catch()中的参数可省略 Symbol description：返回Symbol值的描述 ES2020 声明 globalThis：作为顶层对象，指向全局环境下的this Browser：顶层对象是window Node：顶层对象是global WebWorker：顶层对象是self 以上三者：通用顶层对象是globalThis 数值扩展 BigInt：任何位数的整数(新增的数据类型，使用n结尾) **BigInt()**：转换普通数值为BigInt类型 **BigInt.asUintN()**：转换BigInt为0到2n-1之间对应的值 **BigInt.asIntN()**：转换BigInt为-2n-1 到2n-1-1 **BigInt.parseInt()**：近似于Number.parseInt()，将一个字符串转换成指定进制的BigInt类型 重点难点 BigInt同样可使用各种进制表示，都要加上后缀 BigInt与普通整数是两种值，它们之间并不相等 typeof运算符对于BigInt类型的数据返回bigint 对象扩展 **链判断操作符(?.)**：是否存在对象属性(不存在返回undefined且不再往下执行) 对象属性：obj?.prop、obj?.[expr] 函数调用：func?.(...args) **空判断操作符(??)**：是否值为undefined或null，是则使用默认值 正则扩展 **matchAll()**：返回所有匹配的遍历器 Module **import()**：动态导入(返回Promise) 背景：import命令被JS引擎静态分析，先于模块内的其他语句执行，无法取代require()的动态加载功能，提案建议引入import()来代替require() 位置：可在任何地方使用 区别：require()是同步加载，import()是异步加载 场景：按需加载、条件加载、模块路径动态化 Iterator for-in遍历顺序：不同的引擎已就如何迭代属性达成一致，从而使行为标准化 Promise **Promise.allSettled()**：将多个实例包装成一个新实例，返回全部实例状态变更后的状态数组(齐变更再返回) 入参：具有Iterator接口的数据结构 成功：成员包含status和value，status为fulfilled，value为返回值 失败：成员包含status和reason，status为rejected，value为错误原因 ES提案 声明 do表达式：封装块级作用域的操作，返回内部最后执行表达式的值(do&#123;&#125;) throw表达式：直接使用throw new Error()，无需()或&#123;&#125;包括 !#命令：指定脚本执行器(写在文件首行) 数值扩展 **数值分隔符(_)**：使用_作为千分位分隔符(增加数值的可读性) **Math.signbit()**：返回数值符号是否设置 函数扩展 函数部分执行：复用函数功能(?表示单个参数占位符，...表示多个参数占位符) **管道操作符(|&gt;)**：把左边表达式的值传入右边的函数进行求值(f(x) =&gt; x |&gt; f) **绑定运算符(::)**：函数绑定(左边是对象右边是函数，取代bind、apply、call调用) bind：bar.bind(foo) =&gt; foo::bar apply：bar.apply(foo, arguments) =&gt; foo::bar(...arguments) Realm 定义：提供沙箱功能，允许隔离代码，防止被隔离的代码拿到全局对象 声明：new Realm().global Class 静态属性：使用static定义属性，该属性不会被实例继承，只能通过类来调用 私有属性：使用#定义属性，该属性只能在类内部访问 私有方法：使用#定义方法，该方法只能在类内部访问 装饰器：使用@注释或修改类和类方法 Module import.meta：返回脚本元信息 Promise **Promise.any()**：将多个实例包装成一个新实例，返回全部实例状态变更后的结果数组(齐变更再返回) 入参：具有Iterator接口的数据结构 成功：其中一个实例状态变成fulfilled，最终状态就会变成fulfilled 失败：只有全部实例状态变成rejected，最终状态才会变成rejected **Promise.try()**：不想区分是否同步异步函数，包装函数为实例，使用then()指定下一步流程，使用catch()捕获错误 Async 顶层Await：允许在模块的顶层独立使用await命令(借用await解决模块异步加载的问题) 原文链接","categories":[{"name":"JavaScript","slug":"javascript","permalink":"https://kobingogo.github.io/categories/javascript/"}],"tags":[{"name":"ES6","slug":"es6","permalink":"https://kobingogo.github.io/tags/es6/"}]},{"title":"IntersectionObserver原理分析","slug":"Chrome源码-IntersectionObserver","date":"2020-10-14T16:35:29.000Z","updated":"2022-02-18T02:31:03.807Z","comments":true,"path":"Chrome源码-IntersectionObserver/","link":"","permalink":"https://kobingogo.github.io/Chrome%E6%BA%90%E7%A0%81-IntersectionObserver/","excerpt":"在介绍IntersectionObserver的时候曾提到过这个接口目前使用的最大问题就是浏览器的兼容性问题。所以，我们平时在使用的时候切记不要忘记判断这个API在我们的宿主环境中是否存在。如果不存在，我们可以通过引入其polyfill来作部分功能的兼容。 IntersectionObserver-polyfill是w3c官方创建的https://github.com/w3c/IntersectionObserver。我们可以在浏览器不支持IntersectionObserver的情况下引入它。当然，你也可以直接引入它，其内部也只会在浏览器不支持其的情况下进行polyfill。","text":"在介绍IntersectionObserver的时候曾提到过这个接口目前使用的最大问题就是浏览器的兼容性问题。所以，我们平时在使用的时候切记不要忘记判断这个API在我们的宿主环境中是否存在。如果不存在，我们可以通过引入其polyfill来作部分功能的兼容。 IntersectionObserver-polyfill是w3c官方创建的https://github.com/w3c/IntersectionObserver。我们可以在浏览器不支持IntersectionObserver的情况下引入它。当然，你也可以直接引入它，其内部也只会在浏览器不支持其的情况下进行polyfill。 IntersectionObserver的使用前面做了简单的叙述 1234567891011const target = document.getElementById(&#x27;target&#x27;)const observer = new IntersectionObserver((entries) =&gt; &#123; const [entry] = entries if (entry.isIntersecting) &#123; console.log(&#x27;元素曝光了&#x27;) &#125;&#125;)observer.observe(target) 下面我们就从其polyfill的源码中来了解其基本原理 IntersectionObserver1234567891011121314151617181920212223242526272829function IntersectionObserver(callback, opt_options) &#123; var options = opt_options || &#123;&#125;; if (typeof callback != &#x27;function&#x27;) &#123; throw new Error(&#x27;callback must be a function&#x27;); &#125; if (options.root &amp;&amp; options.root.nodeType != 1) &#123; throw new Error(&#x27;root must be an Element&#x27;); &#125; // Binds and throttles `this._checkForIntersections`. this._checkForIntersections = throttle( this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT); // Private properties. this._callback = callback; this._observationTargets = []; this._queuedEntries = []; this._rootMarginValues = this._parseRootMargin(options.rootMargin); // Public properties. this.thresholds = this._initThresholds(options.threshold); this.root = options.root || null; this.rootMargin = this._rootMarginValues.map(function(margin) &#123; return margin.value + margin.unit; &#125;).join(&#x27; &#x27;); &#125; IntersectionObserver是一个构造函数。当我们创建其实例的时候，可以传递两个参数。第一个参数必须是一个函数，否则会抛出一个错误。第二个参数是一个可选的对象，唯一的要求就是我们指定的root属性的值必须是一个Element。构造函数会在创建实例的时候添加很多私有属性。有些属性后面用到的时候会讲解，这里我们先看几个用来保存我们传递的选项的属性。 在创建IntersectionObserver实例的时候，我们可以在第二个参数对象中传入以下几个属性 12345&#123; root: Element, rootMargin: string, threshold: number | number[]&#125; 在构造函数中首先会调用私有方法解析我们传入的rootMargin属性，下面是这个方法的基本实现 1234567891011121314151617IntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) &#123; var marginString = opt_rootMargin || &#x27;0px&#x27;; var margins = marginString.split(/\\s+/).map(function(margin) &#123; var parts = /^(-?\\d*\\.?\\d+)(px|%)$/.exec(margin); if (!parts) &#123; throw new Error(&#x27;rootMargin must be specified in pixels or percent&#x27;); &#125; return &#123;value: parseFloat(parts[1]), unit: parts[2]&#125;; &#125;); // Handles shorthand. margins[1] = margins[1] || margins[0]; margins[2] = margins[2] || margins[0]; margins[3] = margins[3] || margins[1]; return margins;&#125; 这个方法就是将我们传入的rootMargin解析成数组，这个数组包含四个元素代表的分别是上，右，下，左边距的值和单位。rootMargin设置的时候和css margin设置的方式一样，可以传入1,2,3,4个值。比如 rootMargin: &#39;10px&#39; --&gt; _parseRootMargin(rootMargin) --&gt; [&#123;value: 10, unit: &#39;px&#39;&#125;,&#123;value: 10, unit: &#39;px&#39;&#125;,&#123;value: 10, unit: &#39;px&#39;&#125;,&#123;value: 10, unit: &#39;px&#39;&#125;] // 传入2，3，4个值的解析规则和css margin的解析规则其实是一样的 解析完rootMargin后，私有属性this._rootMarginValues就是如下形式 [ &#123;value: 10, unit: &#39;px&#39;&#125;, &#123;value: 10, unit: &#39;px&#39;&#125;, &#123;value: 10, unit: &#39;px&#39;&#125;, &#123;value: 10, unit: &#39;px&#39;&#125; ] 后面又将其转化为this.rootMargin的值 123this.rootMargin = this._rootMarginValues.map(function(margin) &#123; return margin.value + margin.unit; &#125;).join(&#x27; &#x27;); 所以，无论我们传入的rootMargin是什么样的形式，构造函数执行结束后都会变成10px 10px 10px 10px的形式。 在构造函数中还有一个步骤是初始化我们传入的threshold。我们知道，threshold可以是一个数字，也可以是由数字组成的数组。构造函数执行的时候，会统一将其转换成数组的形式并保存在this.thresholds属性中 1this.thresholds = this._initThresholds(options.threshold); 下面是解析threshold的_initThreshold方法的实现 1234567891011IntersectionObserver.prototype._initThresholds = function(opt_threshold) &#123; var threshold = opt_threshold || [0]; if (!Array.isArray(threshold)) threshold = [threshold]; return threshold.sort().filter(function(t, i, a) &#123; if (typeof t != &#x27;number&#x27; || isNaN(t) || t &lt; 0 || t &gt; 1) &#123; throw new Error(&#x27;threshold must be a number between 0 and 1 inclusively&#x27;); &#125; return t !== a[i - 1]; &#125;);&#125; 这个方法接收我们传入的options.threshold选项的值作为参数，如果我们没有传入这个值，则默认为0。如果我们传入的不是一个数组，就将其转化为数组。下面的filter是对一个数组进行去重的方法，即如果我们对threshold传入了重复的值，只会取一个。而且threshold中的每一个值都必须是数字，并且在[0, 1]之间。所以，this.threshold最终保存的值是如下形式 this.threshold = [0] this.threshold = [0.25, 0.5, 1] 上面就是IntersectionObserver构造函数大致的执行过程，实例创建好后，我们会调用observe方法监测元素。下面我们看一下observe方法的具体实现 observeobserve方法定义在IntersectionObserver.prototype上 123456789101112131415161718IntersectionObserver.prototype.observe = function(target) &#123; var isTargetAlreadyObserved = this._observationTargets.some(function(item) &#123; return item.element == target; &#125;); if (isTargetAlreadyObserved) &#123; return; &#125; if (!(target &amp;&amp; target.nodeType == 1)) &#123; throw new Error(&#x27;target must be an Element&#x27;); &#125; this._registerInstance(); this._observationTargets.push(&#123;element: target, entry: null&#125;); this._monitorIntersections(); this._checkForIntersections();&#125; 接收的参数就是我们需要监测的dom元素。首先会遍历this._observationTargets，这个属性是一个数组，它也是在初始化IntersectionObserver的时候创建的 this._observationTargets = []; 对这个属性的遍历，其实就是为了判断当前的observer是否已经通过observe方法监测过target元素。如果已经监测过，就直接return，防止同一个observer实例对同一个target元素进行多次监测。 如果没有监测过target元素，这里同样会对target的类型进行判断。如果不是一个dom结点，同样会抛出一个错误。 接着，会调用this._registerInstance方法。这个方法的主要作用就是将当前的observer实例添加到全局数组registry中，主要是为了防止我们的observer实例被垃圾回收进行清除 12345IntersectionObserver.prototype._registerInstance = function() &#123; if (registry.indexOf(this) &lt; 0) &#123; registry.push(this); &#125;&#125; 然后，将我们target元素保存在this._observationTargets中。从上面代码中可以看到，this._observationTargets并不只是保存target元素。它会将target元素作为一个对象的element属性的值进行保存，同时这个对象还有一个entry属性。这个属性初始的时候是一个null，后续是IntersectionObserverEntry的一个实例对象。 之后调用this._monitorIntersections方法，这个方法后面我们会说。它的作用主要就是采用什么样的方式来检测target的状态。 最后调用this._checkForIntersections方法，这个方法同样会在后面讲解。这里它主要就是对target元素的状态进行一次初始的判断。如果target元素在初始的时候已经满足了和root元素的交集的状态，在调用这个方法的时候就会触发我们的回调函数。 _monitorIntersections调用observe方法之后，我们就能够监测target元素的状态了。对target元素状态的监测，就是通过调用上面我们所提到的this._monitorIntersections方法。这里我们来看一下这个方法是怎么实现对元素的监测的 1234567891011121314151617181920212223242526IntersectionObserver.prototype._monitorIntersections = function() &#123; if (!this._monitoringIntersections) &#123; this._monitoringIntersections = true; // If a poll interval is set, use polling instead of listening to // resize and scroll events or DOM mutations. if (this.POLL_INTERVAL) &#123; this._monitoringInterval = setInterval( this._checkForIntersections, this.POLL_INTERVAL); &#125; else &#123; addEvent(window, &#x27;resize&#x27;, this._checkForIntersections, true); addEvent(document, &#x27;scroll&#x27;, this._checkForIntersections, true); if (this.USE_MUTATION_OBSERVER &amp;&amp; &#x27;MutationObserver&#x27; in window) &#123; this._domObserver = new MutationObserver(this._checkForIntersections); this._domObserver.observe(document, &#123; attributes: true, childList: true, characterData: true, subtree: true &#125;); &#125; &#125; &#125;&#125; 这个方法提供了两种方式用来监测元素状态的变化。第一种很简单，也很粗暴 -- polling。这种方式默认是关闭的 IntersectionObserver.prototype.POLL_INTERVAL = null; 如果你想使用polling的方式监测元素的状态，则需要在创建IntersectionObserver实例之后，调用observe方法之前设置observer.POLL_INTERVAL属性，比如 12345const observer = new IntersectionObserver(() =&gt; &#123;&#125;)observer.POLL_INTERVAL = 300observer.observe(target) 如果按照上面代码的设置，浏览器就会开启一个定时器，每300毫秒判断一下元素的状态 12this._monitoringInterval = setInterval( this._checkForIntersections, this.POLL_INTERVAL); 但是，这种方式不推荐；所以在polyfill的源码中默认将这种方式关闭，采用更高效的事件监听的方式来监测元素状态的变化。首先需要监听window的resize和document的scroll事件。监听这两种事件能够满足大多数对元素状态判断的情况。如果一个元素自身的属性没有变化，当窗口滚动或者大小改变的时候都会影响元素和&quot;视窗&quot;的交集。但是，在某些业务场景下这两种事件是无法监测到元素状态的变化的。比如选项卡切换，元素自身的显示和隐藏等。对于这种情况，polyfill中同样采用一种粗暴的方法 123456789if (this.USE_MUTATION_OBSERVER &amp;&amp; &#x27;MutationObserver&#x27; in window) &#123; this._domObserver = new MutationObserver(this._checkForIntersections); this._domObserver.observe(document, &#123; attributes: true, childList: true, characterData: true, subtree: true &#125;);&#125; 通过MutationObserver接口监测document元素下所有节点的attributes，childList和characterData的变化。每当有子节点状态变化的时候都会去检测target元素和root元素的交集状态。这种方式很粗暴，但是某些业务场景下我们也不得不这样做。 上面监测元素所有的方式中，其回调函数都是this._checkForIntersections方法。这个方法在上面也提到过，在调用observe方法的时候同样也会调用这个方法。这个方法到底做了什么，下面就详细的看一下。 _checkForIntersections在详细讲解这个方法之前，先来简单的总结一下这个方法会在什么样的条件下被调用 调用observer.observe(target)方法的时候 采用轮询的方式监测元素，作为setInterval回调函数 采用事件的方式监测元素，作为document的scroll事件的回调函数 采用事件的方式监测元素，作为window的resize事件的回调函数 采用事件的方式监测元素，作为MutationObserver的回调函数 总之，在this._checkForIntersections方法被调用的时候，主要就是为了判断target元素和root元素的交集状态有没有发生变化，如果交集状态发生了变化，就会触发我们的回调函数。下面就详细的看一下这个方法到底做了哪些事情 123456789101112131415161718192021222324252627282930313233343536373839404142IntersectionObserver.prototype._checkForIntersections = function() &#123; var rootIsInDom = this._rootIsInDom(); var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect(); this._observationTargets.forEach(function(item) &#123; var target = item.element; var targetRect = getBoundingClientRect(target); var rootContainsTarget = this._rootContainsTarget(target); var oldEntry = item.entry; var intersectionRect = rootIsInDom &amp;&amp; rootContainsTarget &amp;&amp; this._computeTargetAndRootIntersection(target, rootRect); var newEntry = item.entry = new IntersectionObserverEntry(&#123; time: now(), target: target, boundingClientRect: targetRect, rootBounds: rootRect, intersectionRect: intersectionRect &#125;); if (!oldEntry) &#123; this._queuedEntries.push(newEntry); &#125; else if (rootIsInDom &amp;&amp; rootContainsTarget) &#123; // If the new entry intersection ratio has crossed any of the // thresholds, add a new entry. if (this._hasCrossedThreshold(oldEntry, newEntry)) &#123; this._queuedEntries.push(newEntry); &#125; &#125; else &#123; // If the root is not in the DOM or target is not contained within // root but the previous entry for this target had an intersection, // add a new record indicating removal. if (oldEntry &amp;&amp; oldEntry.isIntersecting) &#123; this._queuedEntries.push(newEntry); &#125; &#125; &#125;, this); if (this._queuedEntries.length) &#123; this._callback(this.takeRecords(), this); &#125;&#125; 首先会判断root元素是不是在dom结构中 1234567891011121314151617181920212223242526272829IntersectionObserver.prototype._rootIsInDom = function() &#123; return !this.root || containsDeep(document, this.root);&#125;function containsDeep(parent, child) &#123; var node = child; while (node) &#123; if (node == parent) return true; node = getParentNode(node); &#125; return false;&#125;function getParentNode(node) &#123; var parent = node.parentNode; if (parent &amp;&amp; parent.nodeType == 11 &amp;&amp; parent.host) &#123; // If the parent is a shadow root, return the host element. return parent.host; &#125; if (parent &amp;&amp; parent.assignedSlot) &#123; // If the parent is distributed in a &lt;slot&gt;, return the parent of a slot. return parent.assignedSlot.parentNode; &#125; return parent;&#125; 上面的代码主要就是用来判断root元素是不是在dom结构中。所以这就要求我们传入的options.root选项一定要是target的祖先元素。 接着会获取root元素的区域数据 12345678910111213141516171819IntersectionObserver.prototype._getRootRect = function() &#123; var rootRect; if (this.root) &#123; rootRect = getBoundingClientRect(this.root); &#125; else &#123; // Use &lt;html&gt;/&lt;body&gt; instead of window since scroll bars affect size. var html = document.documentElement; var body = document.body; rootRect = &#123; top: 0, left: 0, right: html.clientWidth || body.clientWidth, width: html.clientWidth || body.clientWidth, bottom: html.clientHeight || body.clientHeight, height: html.clientHeight || body.clientHeight &#125;; &#125; return this._expandRectByRootMargin(rootRect);&#125; 如果我们自己传递了root元素，就会通过root.getBoundingClientRect方法获取到root的区域数据。如果采用默认的document元素，则会使用视窗的区域数据。后面又调用了_expandRectByRootMargin方法，这个方法主要是用来将我们传入的rootMargin和rootRect数据结合得出新的newRootRect数据。 12345678910111213141516IntersectionObserver.prototype._expandRectByRootMargin = function(rect) &#123; var margins = this._rootMarginValues.map(function(margin, i) &#123; return margin.unit == &#x27;px&#x27; ? margin.value : margin.value * (i % 2 ? rect.width : rect.height) / 100; &#125;); var newRect = &#123; top: rect.top - margins[0], right: rect.right + margins[1], bottom: rect.bottom + margins[2], left: rect.left - margins[3] &#125;; newRect.width = newRect.right - newRect.left; newRect.height = newRect.bottom - newRect.top; return newRect;&#125; _expandRectByRootMargin方法很好理解，就是将rootRect和rootMargin结合计算出新的rootRect区域的大小。 在root的区域确定后，会遍历this._observationTargets属性。这个属性上面我们也提过，它用来保存被observer所监测的所有的target元素。遍历的过程先不看，后面还有一小段代码 123if (this._queuedEntries.length) &#123; this._callback(this.takeRecords(), this);&#125; this._queuedEntries这个属性一个数组，其中每一个元素都是IntersectionObserverEntry实例对象。只有当这个属性的长度大于0的时候，才会触发回调函数。在讲解IntersectionObserver方法的基本使用的时候我们曾经说过，callback的第一个参数是由IntersectionObserverEntry实例组成的数组，那这里是通过this.takeRecords()方法获取的，这个方法做了什么？ 12345IntersectionObserver.prototype.takeRecords = function() &#123; var records = this._queuedEntries.slice(); this._queuedEntries = []; return records;&#125; 这个方法很简单，就是通过slice方法对this._queuedEntries数据做个备份，然后清空this._queuedEntries。这表示在这个时间段内和root发生交集变化的target会在调用this._checkForIntersections后交给我们的callback统一处理。也就是说，每个时间段都是重新收集发生变化的target的。 下面我们来看一下对this._observationTargets的遍历会做哪些事情？估计大家也能想到，它主要就是用来收集在这个阶段中和root元素发生交集变化的target元素，并将新的交集状态(IntersectionObserverEntry实例对象) 保存在this._queuedEntries队列中 123456789101112131415161718192021222324252627282930313233this._observationTargets.forEach(function(item) &#123; var target = item.element; var targetRect = getBoundingClientRect(target); var rootContainsTarget = this._rootContainsTarget(target); var oldEntry = item.entry; var intersectionRect = rootIsInDom &amp;&amp; rootContainsTarget &amp;&amp; this._computeTargetAndRootIntersection(target, rootRect); var newEntry = item.entry = new IntersectionObserverEntry(&#123; time: now(), target: target, boundingClientRect: targetRect, rootBounds: rootRect, intersectionRect: intersectionRect &#125;); if (!oldEntry) &#123; this._queuedEntries.push(newEntry); &#125; else if (rootIsInDom &amp;&amp; rootContainsTarget) &#123; // If the new entry intersection ratio has crossed any of the // thresholds, add a new entry. if (this._hasCrossedThreshold(oldEntry, newEntry)) &#123; this._queuedEntries.push(newEntry); &#125; &#125; else &#123; // If the root is not in the DOM or target is not contained within // root but the previous entry for this target had an intersection, // add a new record indicating removal. if (oldEntry &amp;&amp; oldEntry.isIntersecting) &#123; this._queuedEntries.push(newEntry); &#125; &#125;&#125;, this); 在遍历的过程中，首先获取每个target元素的区域数据，然后调用this._rootContainsTarget方法，这个方法就是用来判断root元素是不是target元素的祖先元素 123IntersectionObserver.prototype._rootContainsTarget = function(target) &#123; return containsDeep(this.root || document, target);&#125; 下面，我们先看一下这段代码做了啥，后面再看看item.entry是什么 12var intersectionRect = rootIsInDom &amp;&amp; rootContainsTarget &amp;&amp; this._computeTargetAndRootIntersection(target, rootRect); 如果rootIsInDom为真（表示root元素在dom结构中）且rootContainsTarget为真（表示root是target元素的祖先元素），就调用this._computeTargetAndRootIntersection方法。这个方法从名称上应该都能理解它的作用：计算target元素和root元素的相交区域。其实就是用来计算相交面积intersectionRect的大小。 123456789101112131415161718192021222324252627282930313233343536373839404142434445IntersectionObserver.prototype._computeTargetAndRootIntersection = function(target, rootRect) &#123; // If the element isn&#x27;t displayed, an intersection can&#x27;t happen. if (window.getComputedStyle(target).display == &#x27;none&#x27;) return; var targetRect = getBoundingClientRect(target); var intersectionRect = targetRect; var parent = getParentNode(target); var atRoot = false; while (!atRoot) &#123; var parentRect = null; var parentComputedStyle = parent.nodeType == 1 ? window.getComputedStyle(parent) : &#123;&#125;; // If the parent isn&#x27;t displayed, an intersection can&#x27;t happen. if (parentComputedStyle.display == &#x27;none&#x27;) return; if (parent == this.root || parent == document) &#123; atRoot = true; parentRect = rootRect; &#125; else &#123; // If the element has a non-visible overflow, and it&#x27;s not the &lt;body&gt; // or &lt;html&gt; element, update the intersection rect. // Note: &lt;body&gt; and &lt;html&gt; cannot be clipped to a rect that&#x27;s not also // the document rect, so no need to compute a new intersection. if (parent != document.body &amp;&amp; parent != document.documentElement &amp;&amp; parentComputedStyle.overflow != &#x27;visible&#x27;) &#123; parentRect = getBoundingClientRect(parent); &#125; &#125; // If either of the above conditionals set a new parentRect, // calculate new intersection data. if (parentRect) &#123; intersectionRect = computeRectIntersection(parentRect, intersectionRect); if (!intersectionRect) break; &#125; parent = getParentNode(parent); &#125; return intersectionRect;&#125; 这个方法接收的两个参数分别是target元素和root元素区域的大小。如果元素是隐藏的，是不可能存在相交的，所以直接返回就行了。接着会获取target区域数据和其parentNode元素，并设置一个标志位用来表示下面的while循环是否循环到了this.root或者是document。在while循环中先会判断target.parentNode是否显示，如果其隐藏的话，target和root元素同样是不可能存在交集的。这里我们先假设我们采用默认的root即document，而且parentNode就是document，那么循环将会进入if分支，并将parentRect设置rootRect的大小，atRoot设置为true。接着会执行如下代码 123456if (parentRect) &#123; intersectionRect = computeRectIntersection(parentRect, intersectionRect); if (!intersectionRect) break;&#125;parent = getParentNode(parent); 在这个分支中会执行computeRectIntersection函数，这个函数才是真正的计算target和root相交区域的大小 1234567891011121314151617function computeRectIntersection(rect1, rect2) &#123; var top = Math.max(rect1.top, rect2.top); var bottom = Math.min(rect1.bottom, rect2.bottom); var left = Math.max(rect1.left, rect2.left); var right = Math.min(rect1.right, rect2.right); var width = right - left; var height = bottom - top; return (width &gt;= 0 &amp;&amp; height &gt;= 0) &amp;&amp; &#123; top: top, bottom: bottom, left: left, right: right, width: width, height: height &#125;;&#125; 我们将这段代码用下面的图片来表示，就能看出它到底在做啥 上图中红色的线段就是相交区域的上，下，左，右的长度。所以，相交区域的大小就是图中橙色实心部分的大小。如果target位于root的区域外，则表示width或者height至少有一个&lt;=0。那么计算出来的相交区域的大小也就为0。 假设target.parentNode不是document，那么while循环会执行else分支。其中执行else分支有一个条件parentComputedStyle.overflow != &#39;visible&#39;。如果parentComputedStyle.overflow的值为visible，那么target和root最大的交叉面积就是target的大小，如果parentComputedStyle.overflow的值不为visible，那么target和root最大的交叉面积是多少呢？最大的交叉面积就是target最大能显示出来的面积的大小。 交叉面积计算出来后，我们接着分析下面的代码 123456789var oldEntry = item.entry;var newEntry = item.entry = new IntersectionObserverEntry(&#123; time: now(), target: target, boundingClientRect: targetRect, rootBounds: rootRect, intersectionRect: intersectionRect&#125;); 先看对newEntry的赋值。我们上面说过this._observationTargets保存的数据的结构为&#123;element: target, entry: null&#125;这种类型。从这里就能看到entry就是通过new IntersectionObserverEntry就是创建的实例对象。那oldEntry是什么呢？oldEntry就是上一次调用this._checkForIntersections方法的时候所创建的entry对象。这里为什么取新老两次entry对象，后面我们会分析。这里我们先看一下IntersectionObserverEntry构造函数的执行流程 123456789101112131415161718192021222324function IntersectionObserverEntry(entry) &#123; this.time = entry.time; this.target = entry.target; this.rootBounds = entry.rootBounds; this.boundingClientRect = entry.boundingClientRect; this.intersectionRect = entry.intersectionRect || getEmptyRect(); this.isIntersecting = !!entry.intersectionRect; // Calculates the intersection ratio. var targetRect = this.boundingClientRect; var targetArea = targetRect.width * targetRect.height; var intersectionRect = this.intersectionRect; var intersectionArea = intersectionRect.width * intersectionRect.height; // Sets intersection ratio. if (targetArea) &#123; // Round the intersection ratio to avoid floating point math issues: // https://github.com/w3c/IntersectionObserver/issues/324 this.intersectionRatio = Number((intersectionArea / targetArea).toFixed(4)); &#125; else &#123; // If area is zero and is intersecting, sets to 1, otherwise to 0 this.intersectionRatio = this.isIntersecting ? 1 : 0; &#125;&#125; IntersectionObserverEntry函数的执行流程十分简单，就是计算出其各个属性的值。其它的属性我们就不多说了，这里我们主要看以下三个属性值 1234567891011this.intersectionRect = entry.intersectionRect || getEmptyRect();this.isIntersecting = !!entry.intersectionRect;if (targetArea) &#123; // Round the intersection ratio to avoid floating point math issues: // https://github.com/w3c/IntersectionObserver/issues/324 this.intersectionRatio = Number((intersectionArea / targetArea).toFixed(4)); &#125; else &#123; // If area is zero and is intersecting, sets to 1, otherwise to 0 this.intersectionRatio = this.isIntersecting ? 1 : 0; &#125; 其中this.intersectionRect就是上面通过this._computeTargetAndRootIntersection方法计算出来的。this.isIntersecting的判定也十分简单，如果存在相交面积，就表示相交。不存在相交面积，就表示不想交。最后是相交比this.intersectionRatio的计算，正常情况下(target的width和height都不为0)就是intersectionArea和target区域面积的比值。 然后就会判断oldEntry是否存在，oldEntry在什么状态下不会存在？在初始调用，也就是调用observer.observe方法监测target元素的时候item.entry是不存在的。然后就会将newEntry添加到this._queuedEntries队列中，当执行到 123if (this._queuedEntries.length) &#123; this._callback(this.takeRecords(), this);&#125; 的时候，就会调用我们传入的回调函数。 如果不是在初始状态下，在rootIsInDom &amp;&amp; rootContainsTarget为真的时候，会调用this._hasCrossedThreshold方法，那这个方法是干啥的？我们在介绍IntersectionObserver的时候曾经提到在创建IntersectionObserver实例的时候，我们传入一个选项，可以通过这个选项的threshold属性指定相交比达到什么样的条件才需要触发我们的回调函数。this._hasCrossedThreshold就是用来判断这种情况的。 123456789101112131415161718192021222324IntersectionObserver.prototype._hasCrossedThreshold = function(oldEntry, newEntry) &#123; // To make comparing easier, an entry that has a ratio of 0 // but does not actually intersect is given a value of -1 var oldRatio = oldEntry &amp;&amp; oldEntry.isIntersecting ? oldEntry.intersectionRatio || 0 : -1; var newRatio = newEntry.isIntersecting ? newEntry.intersectionRatio || 0 : -1; // Ignore unchanged ratios if (oldRatio === newRatio) return; for (var i = 0; i &lt; this.thresholds.length; i++) &#123; var threshold = this.thresholds[i]; // Return true if an entry matches a threshold or if the new ratio // and the old ratio are on the opposite sides of a threshold. if (threshold == oldRatio || threshold == newRatio || threshold &lt; oldRatio !== threshold &lt; newRatio) &#123; return true; &#125; &#125;&#125; 从_hasCrossedThreshold代码中我们可以看到。如果target完全没有显示oldRatio === newRatio === -1，直接return。这种情况下是不会执行我们的回调函数的。如果target完全显示oldRatio === newRatio === newEntry.intersectionRatio，这种情况下也不会执行我们的回调函数。那什么时候才会执行我们的回调函数呢，从这段代码的for循环中我们可以总结出只有当threshold设置的值在oldRatio和newRatio之间的时候才会执行我们的回调。这里大家可以画图分析一下。 上面就是关于怎么监测target和执行回调函数时机的分析，下面我们看一下unobserve的过程 unobserve1234567891011IntersectionObserver.prototype.unobserve = function(target) &#123; this._observationTargets = this._observationTargets.filter(function(item) &#123; return item.element != target; &#125;); if (!this._observationTargets.length) &#123; this._unmonitorIntersections(); this._unregisterInstance(); &#125;&#125; unobserve的执行流程十分简单，首先是从this._observationTargets将target删除。如果this._observationTargets队列长度为0，表示当前的observer没有监听任何target，那么就可以将当前observer从全局的registry数组中删除。如果registry也为空，那么就可以卸载相关事件。这个过程主要是通过this._unmonitorIntersections和this._unregisterInstance方法来实现的 123456789101112131415161718192021222324IntersectionObserver.prototype._unmonitorIntersections = function() &#123; if (this._monitoringIntersections) &#123; this._monitoringIntersections = false; clearInterval(this._monitoringInterval); this._monitoringInterval = null; removeEvent(window, &#x27;resize&#x27;, this._checkForIntersections, true); removeEvent(document, &#x27;scroll&#x27;, this._checkForIntersections, true); if (this._domObserver) &#123; this._domObserver.disconnect(); this._domObserver = null; &#125; &#125;&#125;IntersectionObserver.prototype._unregisterInstance = function() &#123; var index = registry.indexOf(this); if (index != -1) registry.splice(index, 1);&#125; disconnectdisconnect可以一次性取消observer对所有target的监测，这个方法的实现同样很简单 12345IntersectionObserver.prototype.disconnect = function() &#123; this._observationTargets = []; this._unmonitorIntersections(); this._unregisterInstance();&#125; 上面就是对IntersectionObserver polyfill源码的大致分析。如有错误，欢迎指正。 使用IntersectionObserver实现一个简单的无限滚动1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .img-area &#123; width: 500px; height: 320px; margin: 0 auto; &#125; .my-photo &#123; width: 500px; height: 300px; opacity: 0; -webkit-transition: opacity 0.25s ease-in-out; -moz-transition: opacity 0.25s ease-in-out; -o-transition: opacity 0.25s ease-in-out; transition: opacity 0.25s ease-in-out; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body class=&quot;body&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;img-area&quot;&gt;&lt;img class=&quot;my-photo&quot; alt=&quot;loading&quot; data-src=&quot;./img/1.png&quot; /&gt;&lt;/div&gt; &lt;div class=&quot;img-area&quot;&gt;&lt;img class=&quot;my-photo&quot; alt=&quot;loading&quot; data-src=&quot;./img/1.png&quot; /&gt;&lt;/div&gt; &lt;div class=&quot;img-area&quot;&gt;&lt;img class=&quot;my-photo&quot; alt=&quot;loading&quot; data-src=&quot;./img/1.png&quot; /&gt;&lt;/div&gt; &lt;div class=&quot;img-area&quot;&gt;&lt;img class=&quot;my-photo&quot; alt=&quot;loading&quot; data-src=&quot;./img/1.png&quot; /&gt;&lt;/div&gt; &lt;div class=&quot;img-area&quot;&gt;&lt;img class=&quot;my-photo&quot; alt=&quot;loading&quot; data-src=&quot;./img/1.png&quot; /&gt;&lt;/div&gt; &lt;div class=&quot;img-area&quot;&gt;&lt;img class=&quot;my-photo&quot; alt=&quot;loading&quot; data-src=&quot;./img/1.png&quot; /&gt;&lt;/div&gt; &lt;div class=&quot;img-area&quot;&gt;&lt;img class=&quot;my-photo&quot; alt=&quot;loading&quot; data-src=&quot;./img/1.png&quot; /&gt;&lt;/div&gt; &lt;div class=&quot;img-area&quot;&gt;&lt;img class=&quot;my-photo&quot; alt=&quot;loading&quot; data-src=&quot;./img/1.png&quot; /&gt;&lt;/div&gt; &lt;div class=&quot;img-area&quot;&gt;&lt;img class=&quot;my-photo&quot; alt=&quot;loading&quot; data-src=&quot;./img/1.png&quot; /&gt;&lt;/div&gt; &lt;div class=&quot;img-area&quot;&gt;&lt;img class=&quot;my-photo&quot; alt=&quot;loading&quot; data-src=&quot;./img/1.png&quot; /&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;&lt;/div&gt; &lt;!-- 页尾标志，判断是否需要新添加节点到文档流中 --&gt; &lt;script&gt; function loadItems(io, count = 10) &#123; let container = document.querySelector(&#x27;.container&#x27;) const fragment = document.createDocumentFragment(); for (let i = 0; i &lt; count; i++) &#123; const li = document.createElement(&#x27;div&#x27;) li.className = &#x27;img-area&#x27;; const img = document.createElement(&#x27;img&#x27;) img.className = &#x27;my-photo&#x27; img.alt = &#x27;loading&#x27; img.dataset.src = &#x27;./img/1.png&#x27; li.appendChild(img); fragment.appendChild(li); io.observe(img) &#125; container.appendChild(fragment) &#125; function lazyLoad(imgClassName) &#123; const imgList = Array.from(document.querySelectorAll(imgClassName)); var opts = &#123; root: document, rootMargin: &quot;500px 0px&quot; &#125;; const io = new IntersectionObserver(function (ioes) &#123; ioes.forEach(function (ioe) &#123; const el = ioe.target; const cn = el.className; // const intersectionRatio = ioe.intersectionRatio; if (cn === &#x27;footer&#x27;) &#123; if (!ioe.isIntersecting) return; loadItems(io); console.log(&#x27;loaded new items&#x27;); &#125; else if (ioe.isIntersecting) &#123; //对于图片节点，当其进入范围内，则load其src if (!el.src) &#123; el.src = el.dataset.src; el.onload = function (e) &#123; el.style.opacity = 1 &#125; io.unobserve(el); //加载图片后停止观察该节点 &#125; &#125; &#125;) &#125;, opts); imgList.forEach(function (item) &#123; io.observe(item) &#125;); io.observe(document.querySelector(&quot;.footer&quot;)) //观察footer节点，判断添加新节点的时机 &#125; lazyLoad(&#x27;.my-photo&#x27;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果图：","categories":[{"name":"浏览器","slug":"浏览器","permalink":"https://kobingogo.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"IntersectionObserver","slug":"intersectionobserver","permalink":"https://kobingogo.github.io/tags/intersectionobserver/"}]},{"title":"男士洗面奶","slug":"生活-男士洗面奶推荐","date":"2020-09-30T17:37:27.000Z","updated":"2022-02-18T02:31:03.811Z","comments":true,"path":"生活-男士洗面奶推荐/","link":"","permalink":"https://kobingogo.github.io/%E7%94%9F%E6%B4%BB-%E7%94%B7%E5%A3%AB%E6%B4%97%E9%9D%A2%E5%A5%B6%E6%8E%A8%E8%8D%90/","excerpt":"作为全虎扑拥有洗面奶最多的男人，我评价一款洗面奶永远不是嘴上说好用不好用那么简单。好用要有好用的理由，不好用也要说出不好用的地方。","text":"作为全虎扑拥有洗面奶最多的男人，我评价一款洗面奶永远不是嘴上说好用不好用那么简单。好用要有好用的理由，不好用也要说出不好用的地方。 今天就虎扑权威男性洗面奶排行榜，来说一说到底哪些洗面奶值得买。我会从成分分析、酸碱测试、使用体验和适用肤质4个方面来具体盘一盘。 不懂选择的，对比虎扑洗面奶排行榜，参考文章，对应肤质和预算，直接入就完事了！ OK，上菜单： 个人建议，选择购入产品，直接选择天猫官方店，价格透明，买的放心，其他平台容易出假，仿货！ ◎NO.1芙丽芳丝 （150元/100g）1【成分分析】 成分分析这块儿讲的会有点小枯燥，不喜欢看的直接跳到下一趴！ 这几年芙丽芳丝应该没少在广告上砸钱，洁面界第一网红的称号不是白来的。 宣传适合敏感肌的洁面，没有刺激性香精防腐剂，靠柠檬酸+丁二醇来防腐，还算靠谱。 清洁方面主要靠的是氨基酸表活-椰油酰甘氨酸钾，中等偏上清洁力。甘油排位第一为了保湿。添加有两种致痘风险的乳化剂，从消费者反馈来说，有一定致痘风险，我自己用着期间，还没长嘿嘿。 从烟酰胺开始的各种活性成分，添加量很低很低，而且不在脸上停留，不说也罢！ 2【酸碱测试】 PH值介于6-7之间，还算过关！比较温和，对肌肤基本没什么刺激。我换季过敏用都毫无压力。 3【使用体验】 乳膏质地，洗出来的泡泡跟棉花一样，细密温和。味道有点像宝宝身上的奶香味儿，个人能接受，但是看淘宝评价有人说像塑料……让人有点方。 洗的干净，洗完不绷，是一款过敏或日常用都可的安全洗面奶。 4【适用肤质】 除了塔克拉玛干和大庆油田，基本所有肤质都适用。但是含有烟酰胺，重敏皮要避雷。 ◎NO.2 简男六角瓶 （39.9元） 这是我多次回购的，油性肌肤用它没错了！ 1【成分分析】 作为新型氨基酸粉末洁面，有着比传统乳状洗面奶更明显的优势，溶解速度快，上脸不黏腻，不担心像乳状一样可能会残留，用着舒心方便 备案没有任何乱七八糟的防腐剂香精成分，巨巨巨温和！甘露糖醇复配聚乙二醇负责保湿，氨基酸表活负责清洁，用之后才知道什么叫真正嫩滑不拔干，学术派护肤党我爱了。 2【酸碱测试】 跟皮肤贴合的完美酸碱值，接近于6，上脸一点刺激也没有。 3【使用体验】 相比于膏状和乳状以及泡泡洁面，粉状洁面使用感上升了好几个档次，用过的人都懂。 每次洗脸用一小盒，携带方便，干净卫生，出差日常都可。清洁效果的确挺神奇，每次都能感到颗粒感的粉质能够搓出来一些死皮和附着在毛孔表面的小白头，太加分了！ 没有用过洁颜粉的，墙裂建议试试。 4【适用肤质】 尤其适合油皮男士！ ◎NO3. 旁氏米粹洗面奶（29.9-59元之间）上榜的那位，虽然便宜量足。但是含有二氧化钛，洗完假白。相对来说旁氏米粹洁面泡泡这个亲兄弟更值得入。 不吹说，也就旁氏泡泡能摊得上便宜大碗，30块钱这么大一管，其他牌子就别来凑热闹了行么？ 因为便宜，表活用的也是最便宜的椰油酰甘氨酸钾，氨基酸类，温和。 插一句，氨基酸洗面奶真的是很普通的一种洗面奶类型，工作关系总是看到各种洗面奶用氨基酸给自己抬身价，没啥稀罕的呀。 2【酸碱测试】 作为一款老实本分的温和型洁面，pH在6～7之间，接近皮肤本身的pH值，无论油皮干皮敏感肌都可以放心pick。 3【使用体验】 按压出来就是泡泡，不像珂润，旁氏的泡泡挤出来啥样上脸还啥样，不会变虚变薄。洗的时候有淡淡的淘米水味，搞得我每次洗脸都感到有点饿怎么肥四。洗完不干不紧绷，价格也很学生党，是我大学时期回购次数最多的洗面奶，谁让我穷呢～～ 4【适用肤质】 只要不是两极分化的大庆油田或撒哈拉沙漠，大部分肤质都可。有香精，重敏的人不要用。 篇幅有限，其他洗面奶就来简单说一说。 ◎NO4. 日本UNO洗面奶 （55元）NUO？我傻了。 UNO吾诺男士洗面奶有黑管、蓝管、绿管三种颜色，这76个泡泡值估计都是投给黑管的。 成分分析：皂基表活，清洁力强大。添加辣薄荷，洗感清凉。 使用体验：一个字爽，两个字凉爽。夏天用还好，秋冬真的有种抹风油精的感觉。洗完略紧绷，需要及时补水。 适用肤质：油性耐受肌。 ◎NO5. 碧欧泉洗面奶说实话，碧欧泉排行第五有点亏，可能价格有点小贵，用的人不多。所以给他投票的人也不多。 成分分析：同为皂基表活，但是整体比UNO要温和得多，添加了很多活性成分，贵有贵的理由。 使用体验：调香高级，淡淡的茶香，清洁力、温和性也平衡得很好，洗完完全不会感到拔干。 适用肤质：中性-油性耐受肌。 ◎NO.6 Elta MD（80-188元）这款洗面奶JR用得不多，但在小红书上可是火的一塌糊涂。是美国各大皮肤科医生也会推荐的温和型洁面。 成分分析：典型的氨基酸洁面，加入了沸点很低的醚类，上脸30秒后可自动起泡。 使用体验：成也萧何，败也萧何。虽然这款洗面奶的亮点是可以自动发泡。但麻烦的是每次用完都要旋转泵头锁住洗面奶，不然它会吐泡泡到你怀疑人生。 适用肤质：全肤质适用。 ◎NO.7理肤泉洗面奶相信很多人都是从理肤泉雅漾这类外国牌子开始接触药妆的。这款理肤泉特安洁面，从名字就能看出来非常适合敏感肌。 成分分析：宣传适合敏感肌的洁面却含有5种皂基表活成分，我有点方。感觉这个洁面更适合油皮才对。 适用体验：清洁力好，无香精防腐剂，虽然是皂基表活，但还算温和。 适用肤质：油皮、油皮敏感肌 ◎NO.8欧莱雅火山泥在JR心中是永远的神和永远的shi。 成分分析：典型的皂基表活，含有水杨酸，红色质地来自于高岭土。 使用体验：所谓男性去油系列，就是挂掉你脸上的油，刮油效果不是盖的，用完绷的感觉自己像干尸。油皮瞬间变干皮。对付直男就是要狠。但是这种刮油的方式只会加重痘痘，刺激痘痘，搞不好就会引起外油内干的情况出现。 适用肤质：油皮，不推荐。 ◎NO.9雅诗兰黛白金洗面奶雅诗兰黛白金洗面奶号称可以温和卸妆。这款分为有泡板和无泡板。看包装，有泡foam，无泡creme. 成分分析：氨基酸系贵妇洗面奶。大牌们可能是商量好的，只要出氨基酸洗面奶就要可着劲儿的添加活性成分，不管这些活性成分有没有用，加上去就能宣传卖高价。 适用体验：贵妇洗面奶使用感就是好呀，质地、泡沫、调香没得说。但是这些活性成分没卵用，要知道洗面奶只在脸上停留几十秒钟，这么短的时间内，活性成分是不可能被吸收的。 适用肤质：全肤质适用 ◎NO.10丝塔芙洗面奶没有想到丝塔芙这种毫无清洁力的洗面奶，还能在JR心中占有一席之地。 成分分析：备案成分一共8种。清洁剂一种，防腐剂三种，神了。清洁剂虽然是我们常说的刺激性较大的SLS，但是添加量较低，对皮肤造不成什么伤害。 使用体验：个人油性皮肤，对这种几乎无泡无清洁力的洗面奶不感冒，洗完感觉滑滑的，一点都没洗干净。可能干皮会比较喜欢它的温和吧。 适用肤质：干皮 Source","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"https://kobingogo.github.io/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"npm依赖管理中容易被忽略细节","slug":"node-2020-09-15-npm依赖管理中容易被忽略细节","date":"2020-09-15T23:38:27.000Z","updated":"2022-02-18T02:31:03.811Z","comments":true,"path":"node-2020-09-15-npm依赖管理中容易被忽略细节/","link":"","permalink":"https://kobingogo.github.io/node-2020-09-15-npm%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E4%B8%AD%E5%AE%B9%E6%98%93%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%BB%86%E8%8A%82/","excerpt":"提起 npm，大家第一个想到的应该就是 npm install 了，但是 npm install 之后生成的 node_modules 大家有观察过吗？package-lock.json 文件的作用大家知道吗？除了 dependencies 和 devDependencies，其他的依赖有什么作用呢？接下来，本文将针对 npm 中的你可能忽略的细节和大家分享一些经验 。","text":"提起 npm，大家第一个想到的应该就是 npm install 了，但是 npm install 之后生成的 node_modules 大家有观察过吗？package-lock.json 文件的作用大家知道吗？除了 dependencies 和 devDependencies，其他的依赖有什么作用呢？接下来，本文将针对 npm 中的你可能忽略的细节和大家分享一些经验 。 npm 安装机制A 和 B 同时依赖 C，C 这个包会被安装在哪里呢？C 的版本相同和版本不同时安装会有什么差异呢？package.json 中包的前后顺序对于安装时有什么影响吗？这些问题平时大家可能没有注意过，今天我们就来一起研究一下吧。 A 和 B 同时依赖 C，这个包会被安装在哪里呢？假如有 A 和 B 两个包，两个包都依赖 C 这个包，npm 2 会依次递归安装 A 和 B 两个包及其子依赖包到 node_modules 中。\b执行完毕后，我们会看到 ./node_modules 这层目录只含有这两个子目录： node_modules/├─┬ A│ ├── C├─┬ B│ └── C 如果使用 npm 3 来进行安装的话，./node_modules 下的目录将会包含三个子目录： node_modules/├─┬ A├─┬ B├─┬ C 为什么会出现这样的区别呢？这就要从 npm 的工作方式说起了： npm 2 和 npm 3 模块安装机制的差异虽然目前最新的 npm 版本是 npm 6，但 npm 2 到 npm 3 的版本变更中实现了目录打平，与其他版本相比差别较大。因此，让我们具体看下这两个版本的差异​。 npm 2 在安装依赖包时，采用\b简单的递归安装方法。执行 npm install 后，npm 根据 dependencies 和 devDependencies 属性中指定的包来确定第一层依赖，npm 2 会根据第一层依赖的子依赖，递归安装各个包到子依赖的 node_modules 中，直到子依赖不再依赖其他模块。\b执行完毕后，我们会看到 ./node_modules 这层目录中包含有我们 package.json 文件中所有的依赖包，而这些依赖包的子依赖包都安装在了自己的 node_modules 中 ，形成类似于下面的依赖树： 这样的目录有较为明显的好处： 层级结构非常明显，可以清楚的在第一层的 node_modules 中看到我们安装的所有包的子目录； 在已知自己所需包的名字以及版本号时，可以复制粘贴相应的文件到 node_modules 中，然后手动更改 package.json 中的配置； 如果想要删除某个包，只需要简单的删除 package.json 文件中相应的某一行，然后删除 node_modules 中该包的目录； 但是这样的层级结构也有较为明显的缺陷，当我的 A，B，C 三个包中有相同的依赖 D 时，执行 npm install 后，D 会被重复下载三次，而随着我们的项目越来越复杂，node_modules 中的依赖树也会越来越复杂，像 D 这样的包也会越来越多，造成了大量的冗余；在 windows 系统中，甚至会因为目录的层级太深导致文件的路径过长，触发文件路径不能超过 280 个字符的错误； ​ 为了解决以上问题，npm 3 的 node_modules 目录改成了更为扁平状的层级结构，尽量把依赖以及依赖的依赖平铺在 node_modules 文件夹下共享使用。 npm 3 对于同一依赖的不同版本会怎么处理呢？npm 3 会遍历所有的节点，逐个将模块放在 node_modules 的第一层，当发现有重复模块时，则丢弃， 如果遇到某些依赖版本不兼容的问题，则继续采用 npm 2 的处理方式，前面的放在 node_modules 目录中，后面的放在依赖树中。举个例子： A，B，依赖 D(v 0.0.1)，C 依赖 D(v 0.0.2): 但是 npm 3 会带来一个新的问题：由于在执行 npm install 的时候，按照 package.json 里依赖的顺序依次解析，上图如果 C 的顺序在 A，B 的前边，node_modules 树则会改变，会出现下边的情况： 由此可见，npm 3 并未完全解决冗余的问题，甚至还会带来新的问题。 为什么会出现 package-lock.json 呢？为什么会有 package-lock.json 文件呢？这个我们就要先从 package.json 文件说起了。 package.json 的不足之处npm install 执行后，会生成一个 node_modules 树，在理想情况下， 希望对于同一个 package.json 总是生成完全相同 node_modules 树。在某些情况下，确实如此。但在多数情况下，npm 无法做到这一点。有以下两个原因： 1）某些依赖项自上次安装以来，可能已发布了新版本 。比如：A 包在团队中第一个人安装的时候是 1.0.5 版本，package.json 中的配置项为 A: &#39;^1.0.5&#39; ；团队中第二个人把代码拉下来的时候，A 包的版本已经升级成了 1.0.8，根据 package.json 中的 semver-range version 规范，此时第二个人 npm install 后 A 的版本为 1.0.8； 可能会造成因为依赖版本不同而导致的 bug； 2）针对 1）中的问题，可能有的小伙伴会想，把 A 的版本号固定为 A: &#39;1.0.5&#39; 不就可以了吗？但是这样的做法其实并没有解决问题， 比如 A 的某个依赖在第一个人下载的时候是 2.1.3 版本，但是第二个人下载的时候已经升级到了 2.2.5 版本，此时生成的 node_modules 树依旧不完全相同 ，固定版本只是固定来自身的版本，依赖的版本无法固定。 针对 package.json 不足的解决方法为了解决上述问题以及 npm 3 的问题，在 npm 5.0 版本后，npm install 后都会自动生成一个 package-lock.json 文件 ，当包中有 package-lock.json 文件时，npm install 执行时，如果 package.json 和 package-lock.json 中的版本兼容，会根据 package-lock.json 中的版本下载；如果不兼容，将会根据 package.json 的版本，更新 package-lock.json 中的版本，已保证 package-lock.json 中的版本兼容 package.json。 package-lock.json 文件的结构package-lock.json 文件中的 name、version 与 package.json 中的 name、version 一样，描述了当前包的名字和版本，dependencies 是一个对象，该对象和 node_modules 中的包结构一一对应，对象的 key 为包的名称，值为包的一些描述信息， 根据 package-lock-json官方文档，主要的结构如下： version ：包版本，即这个包当前安装在 node_modules 中的版本 resolved ：包具体的安装来源 integrity ：包 hash 值，验证已安装的软件包是否被改动过、是否已失效 requires ：对应子依赖的依赖，与子依赖的 package.json 中 dependencies 的依赖项相同 dependencies ：结构和外层的 dependencies 结构相同，存储安装在子依赖 node_modules 中的依赖包 需要注意的是，并不是所有的子依赖都有 dependencies 属性，只有子依赖的依赖和当前已安装在根目录的 node_modules 中的依赖冲突之后，才会有这个属性。 package-lock.json 文件的作用 在团队开发中，确保每个团队成员安装的依赖版本是一致的，确定一棵唯一的 node_modules 树； node_modules 目录本身是不会被提交到代码库的，但是 package-lock.json 可以提交到代码库，如果开发人员想要回溯到某一天的目录状态，只需要把 package.json 和 package-lock.json 这两个文件回退到那一天即可 。 由于 package-lock.json 和 node_modules 中的依赖嵌套完全一致，可以更加清楚的了解树的结构及其变化。 在安装时，npm 会比较 node_modules 已有的包，和 package-lock.json 进行比较，如果重复的话，就跳过安装 ，从而优化了安装的过程。 依赖的区别与使用场景npm 目前支持以下几类依赖包管理包括 dependencies devDependencies optionalDependencies 可选择的依赖包 peerDependencies 同等依赖 bundledDependencies 捆绑依赖包 下面我们来看一下这几种依赖的区别以及各自的应用场景： dependenciesdependencies 是无论在开发环境还是在生产环境都必须使用的依赖，是我们最常用的依赖包管理对象，例如 React，Loadsh，Axios 等，通过 npm install XXX 下载的包都会默认安装在 dependencies 对象中，也可以使用 npm install XXX --save 下载 dependencies 中的包； devDependenciesdevDependencies 是指可以在开发环境使用的依赖，例如 eslint，debug 等，通过 npm install packageName --save-dev 下载的包都会在 devDependencies 对象中； dependencies 和 devDependencies 最大的区别是在打包运行时，执行 npm install 时默认会把所有依赖全部安装，但是如果使用 npm install --production 时就只会安装 dependencies 中的依赖，如果是 node 服务项目，就可以采用这样的方式用于服务运行时安装和打包，减少包大小。 optionalDependenciesoptionalDependencies 指的是可以选择的依赖，当你希望某些依赖即使下载失败或者没有找到时，项目依然可以正常运行或者 npm 继续运行的时，就可以把这些依赖放在 optionalDependencies 对象中，但是 optionalDependencies 会覆盖 dependencies 中的同名依赖包，所以不要把一个包同时写进两个对象中。 optionalDependencies 就像是我们的代码的一种保护机制一样，如果包存在的话就走存在的逻辑，不存在的就走不存在的逻辑。 12345678910try &#123; var axios = require(&#x27;axios&#x27;) var fooVersion = require(&#x27;axios/package.json&#x27;).version&#125; catch (er) &#123; foo = null&#125;// .. then later in your program ..if (foo) &#123; foo.doFooThings()&#125; peerDependenciespeerDependencies 用于指定你当前的插件兼容的宿主必须要安装的包的版本，这个是什么意思呢？举个例子🌰：我们常用的 react 组件库 &#97;&#110;&#x74;&#x2d;&#x64;&#x65;&#115;&#x69;&#x67;&#x6e;&#64;&#51;&#46;&#x78; 的 package.json 中的配置如下： 1234&quot;peerDependencies&quot;: &#123; &quot;react&quot;: &quot;&gt;=16.9.0&quot;, &quot;react-dom&quot;: &quot;&gt;=16.9.0&quot; &#125;, 假设我们创建了一个名为 project 的项目，在此项目中我们要使用 &#97;&#110;&#x74;&#45;&#x64;&#101;&#115;&#105;&#x67;&#x6e;&#64;&#x33;&#46;&#x78; 这个插件，此时我们的项目就必须先安装 React &gt;= 16.9.0 和 React-dom &gt;= 16.9.0 的版本。​ 在 npm 2 中，当我们下载 &#x61;&#x6e;&#116;&#45;&#100;&#101;&#x73;&#105;&#103;&#110;&#x40;&#x33;&#x2e;&#x78; 时，peerDependencies 中指定的依赖会随着 &#97;&#110;&#116;&#45;&#x64;&#x65;&#x73;&#x69;&#103;&#x6e;&#64;&#x33;&#46;&#x78; 一起被强制安装，所以我们不需要在宿主项目的 package.json 文件中指定 peerDependencies 中的依赖，但是在 npm 3 中，不会再强制安装 peerDependencies 中所指定的包，而是通过警告的方式来提示我们，此时就需要手动在 package.json 文件中手动添加依赖； bundledDependencies这个依赖项也可以记为 bundleDependencies，与其他几种依赖项不同，他不是一个键值对的对象，而是一个数组，数组里是包名的字符串，例如： 12345678&#123; &quot;name&quot;: &quot;project&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;bundleDependencies&quot;: [ &quot;axios&quot;, &quot;lodash&quot; ]&#125; 当使用 npm pack 的方式来打包时，上述的例子会生成一个 project-1.0.0.tgz 的文件，在使用了 bundledDependencies 后，打包时会把 Axios 和 Lodash 这两个依赖一起放入包中，之后有人使用 npm install project-1.0.0.tgz 下载包时，Axios 和 Lodash 这两个依赖也会被安装。需要注意的是安装之后 Axios 和 Lodash 这两个包的信息在 dependencies 中，并且不包括版本信息。 12345678&quot;bundleDependencies&quot;: [ &quot;axios&quot;, &quot;lodash&quot;],&quot;dependencies&quot;: &#123; &quot;axios&quot;: &quot;*&quot;, &quot;lodash&quot;: &quot;*&quot;&#125; 如果我们使用常规的 npm publish 来发布的话，这个属性是不会生效的，所以日常情况中使用的较少。 总结本文介绍的是 npm 2，npm 3，package-lock.json 以及几种依赖的区别和使用场景，希望能够让大家对 npm 的了解更加多一点，有什么不清楚的地方或者不足之处欢迎大家在评论区留言。 原文转载自：https://www.zoo.team/article/npm-details","categories":[{"name":"npm","slug":"npm","permalink":"https://kobingogo.github.io/categories/npm/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://kobingogo.github.io/tags/npm/"}]},{"title":"在 React 中实现 keep alive","slug":"framework-react-keep-alive","date":"2020-09-15T23:25:43.000Z","updated":"2022-02-18T02:31:03.811Z","comments":true,"path":"framework-react-keep-alive/","link":"","permalink":"https://kobingogo.github.io/framework-react-keep-alive/","excerpt":"本文介绍一种在react中实现Vue的keep alive功能的方案。","text":"本文介绍一种在react中实现Vue的keep alive功能的方案。 什么是 keep alive在 Vue 中，我们可以使用 keep-alive 包裹一个动态组件，从而缓存不活跃的实例，而不是直接销毁他们： 123&lt;keep-alive&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt; 这对于某些路由切换等场景非常好用，例如，如果我们需要实现一个列表页和详情页，但在用户从详情页返回列表的时候，我们不希望重新请求接口获取，也不希望重置列表的过滤、排序等条件，那这时就可以对列表页的组件用 keep-alive 包裹一下，这样，当路由切换时，Vue 会将这个组件“失活”并缓存起来，而不是直接卸载掉。 最简单的方案而在 React 中，其实一直以来都没有官方的 keep alive 解决方案，大部分开发者可能都会直接使用 display: none 来将 DOM 隐藏： 123&lt;div style=&#123;shouldHide ? &#123;display: &#x27;none&#x27;&#125; : &#123;&#125;&#125;&gt; &lt;Foo/&gt;&lt;/div&gt; 但这种方案其实只是在“视觉上”将元素隐藏起来了，并没有真正的移除，那有没有可能把 DOM 树真的移除掉，同时又让组件不被销毁呢？ Portal实现 Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。 这是 React 官方文档上对 Portal 特性的介绍，值得注意的是，这里只是说“父组件以外的 DOM 节点”，但没有要求这个 DOM 节点是真的在页面上，还是只是存在于内存中。 因此，我们可以先通过 document.createElement 在内存中创建一个元素，然后再通过 React.createPoral 把 React 子节点渲染到这个元素上，这样就实现了“空渲染”。 12const targetElement = document.createElement(&#x27;div&#x27;)ReactDOM.createPortal(child, targetElement) 基于这种方案，我们可以进一步封装出一个 Conditional 组件，从而实现通用性的条件渲染逻辑： 12345678910111213141516171819export const Conditional = props =&gt; &#123; const [targetElement] = useState(() =&gt; document.createElement(&#x27;div&#x27;)) const containerRef = useRef() useLayoutEffect(() =&gt; &#123; if (props.active) &#123; containerRef.current.appendChild(targetElement) &#125; else &#123; try &#123; containerRef.current.removeChild(targetElement) &#125; catch (e) &#123;&#125; &#125; &#125;, [props.active]) return ( &lt;&gt; &lt;div ref=&#123;containerRef&#125; /&gt; &#123;ReactDOM.createPortal(props.children, targetElement)&#125; &lt;/&gt; )&#125; 首先，我们创建了一个 targetElement ，并且通过 createPortal 将 children 渲染到 targetElement 。 然后，我们会创建一个容器 div 元素，并且通过 containerRef 拿到它的引用。 最后，当 active 为 true 时，我们会把 targetElement 手动添加到 containerRef.current 的内部，反之，则会从其内部移除掉 targetElement 。 实际使用的方式如下： 123&lt;Conditional active=&#123;!shouldHide&#125;&gt; &lt;Foo/&gt;&lt;/Conditional&gt; 懒加载细心的读者可能会发现，目前我们的 Conditional 组件还有一点小小的瑕疵：当组件初次渲染时，不论当前的 active 是 true 还是 false ， Conditional 组件都会将 props.children 渲染。这对大型应用可能会带来非常明显的性能问题，所以，我们可以为其增加“懒加载”的特性： 1234567891011121314151617181920212223242526export const Conditional = props =&gt; &#123; const [targetElement] = useState(() =&gt; document.createElement(&#x27;div&#x27;)) const containerRef = useRef() // 增加一个 ref 记录组件是否“被激活过” const activatedRef = useRef(false) activatedRef.current = activatedRef.current || props.active useLayoutEffect(() =&gt; &#123; if (props.active) &#123; containerRef.current.appendChild(targetElement) &#125; else &#123; try &#123; containerRef.current.removeChild(targetElement) &#125; catch (e) &#123;&#125; &#125; &#125;, [props.active]) return ( &lt;&gt; &lt;div ref=&#123;containerRef&#125; /&gt; &#123;activatedRef.current &amp;&amp; ( // 如果“被激活过”，才渲染 children ReactDOM.createPortal(props.children, targetElement) )&#125; &lt;/&gt; )&#125; 一些遗憾不得不承认的是，基于 Portal 方案的 Conditional 组件并不能包治百病，和 Vue 的 keep-alive 相比，也存在不少缺憾： 需要手动控制 active ，不能直接基于子组件销毁/创建的生命周期事件 缺少失活/激活的生命周期时间，子组件无法感知自己是不是被缓存起来了 依赖了 ReactDOM ，对 SSR 不够友好 原文转载自知乎：在 React 中实现 keep alive","categories":[{"name":"react","slug":"react","permalink":"https://kobingogo.github.io/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"https://kobingogo.github.io/tags/react/"},{"name":"keep alice","slug":"keep-alice","permalink":"https://kobingogo.github.io/tags/keep-alice/"}]},{"title":"数据结构与算法知识点汇总","slug":"algorithms-开篇","date":"2020-06-22T18:09:54.000Z","updated":"2022-02-18T02:31:03.807Z","comments":true,"path":"algorithms-开篇/","link":"","permalink":"https://kobingogo.github.io/algorithms-%E5%BC%80%E7%AF%87/","excerpt":"数据结构与算法知识点汇总","text":"","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kobingogo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kobingogo.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"LeetCode题解记录","slug":"algorithms-leetcode","date":"2020-06-21T21:56:01.000Z","updated":"2022-02-18T02:31:03.807Z","comments":true,"path":"algorithms-leetcode/","link":"","permalink":"https://kobingogo.github.io/algorithms-leetcode/","excerpt":"汇集LeetCode题解思路，方便日后回忆","text":"leetCode题解记录 leetCode题解记录 数组类 常用方法总结： 两数之和 15. 三数之和 16. 最接近的三数之和 最大子序和 239. 滑动窗口最大值 合并两个有序数组 14. 最长公共前缀 链表类 常用方法总结： 合并两个有序链表 141. 环形链表 142. 环形链表 II 反转链表 19. 删除链表的倒数第N个节点 876. 链表的中间结点 动态规划类 309. 最佳买卖股票时机含冷冻期 面试题 17.13. 恢复空格 96. 不同的二叉搜索树 数组类常用方法总结： 结合Object(Map/set)等数据结构来解题； 滑动窗口方法（最小（大）子集等问题适用） Trie 树 两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例: 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 方法一： 1234567891011121314151617/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */var twoSum = function(nums, target) &#123; let result = []; for(let i = 0, length = nums.length; i &lt; length; i++)&#123; const left = target - nums[i]; const leftIndex = nums.lastIndexOf(left); if(leftIndex &gt; i)&#123; result = [i ,leftIndex]; break; &#125; &#125; return result;&#125;; 复杂度分析： 时间复杂度：O(n2) 空间复杂度：o(1) 方法二： 1234567891011var twoSum = function(nums, target) &#123; let map = new Map() for(let i = 0; i&lt; nums.length; i++) &#123; let k = target-nums[i] if(map.has(k)) &#123; return [map.get(k), i] &#125; map.set(nums[i], i) &#125; return [];&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：o(n) 15. 三数之和解题思路： 首先对数组从大到小进行排序； 遍历数组，设置左右俩指针初始位置在数组左右边界（first = i + 1,last = length -1）; 如果i, first, last 三个数值大于0，则last左移，如果小于0，则first右移； 使得最终三数之和等于0，则成功找出一组。重复步骤2。 实现代码: 123456789101112131415161718192021222324252627var threeSum = function (nums) &#123; let res = []; let length = nums.length; nums.sort((a, b) =&gt; a - b); // 先排个队，最左边是最弱（小）的，最右边是最强(大)的 if (nums[0] &gt; 0 || nums[length - 1] &lt; 0) &#123; return res; &#125; for (let i = 0; i &lt; length - 2; i) &#123; if (nums[i] &gt; 0) break; let first = i + 1, last = length - 1, sum; while (first &lt; last) &#123; sum = nums[i] + nums[first] + nums[last]; if (sum === 0) &#123; res.push([nums[i], nums[first], nums[last]]); while (first &lt; last &amp;&amp; nums[first] === nums[++first]) &#123; &#125; &#125; else if (sum &lt; 0) &#123; while (first &lt; last &amp;&amp; nums[first] === nums[++first]) &#123; &#125; &#125; else &#123; while (first &lt; last &amp;&amp; nums[last] === nums[--last]) &#123; &#125; &#125; &#125; while (nums[i] === nums[++i]) &#123; &#125; &#125; return res;&#125;; 复杂度分析 时间复杂度： O(n2) 16. 最接近的三数之和解题思路 思路同上一题类似，不同点在于此题是求最接近给定值的解。 实现代码 123456789101112131415161718var threeSumClosest = function (nums, target) &#123; nums.sort((a, b) =&gt; a - b); let length = nums.length; let result = nums[0] + nums[1] + nums[length - 1]; for (let i = 0; i &lt; length - 2; i++) &#123; let first = i + 1; let last = length - 1; let sum; while (first &lt; last) &#123; sum = nums[i] + nums[first] + nums[last]; sum &gt; target ? last-- : first++; if (Math.abs(target - result) &gt; Math.abs(target - sum)) &#123; result = sum; &#125; &#125; &#125; return result;&#125;; 复杂度分析 时间复杂度： O(n2) 最大子序和算法： 在整个数组或在固定大小的滑动窗口中找到总和或最大值或最小值的问题可以通过动态规划（DP）在线性时间内解决。有两种标准 DP 方法适用于数组： 常数空间，沿数组移动并在原数组修改。 线性空间，首先沿 left-&gt;right 方向移动，然后再沿 right-&gt;left 方向移动。 合并结果。 我们在这里使用第一种方法，因为可以修改数组跟踪当前位置的最大和。下一步是在知道当前位置的最大和后更新全局最大和。 1234567891011121314/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var maxSubArray = function (nums) &#123; if (nums.length === 1) &#123; return nums[0]; &#125; let maxSum = nums[0]; for (let i = 1, length = nums.length; i &lt; length; i++) &#123; if (nums[i - 1] &gt; 0) nums[i] += nums[i - 1]; // index位上的值变为到这位为止的最大值 maxSum = Math.max(nums[i], maxSum); // 取当前位与历史位的最大值 &#125; return maxSum;&#125;; 复杂度分析: 时间复杂度：O(N)。只遍历了一次数组。 空间复杂度：O(1)，使用了常数的空间。 239. 滑动窗口最大值解题思路 使用 队列 方式维护一个滑动窗口内的数值索引，并确保队列队首值是当前滑动窗口的最大值索引 对应索引i来说，在i前面并且比i的值小的数值是没有价值的，可以剔除掉 实现代码 1234567891011121314151617181920var maxSlidingWindow = function (nums, k) &#123; //queue保存 SlidingWindow 数据，其中首位是最大值的索引 const queue = [], result = []; for (let i = 0; i &lt; nums.length; i++) &#123; //剔除SlidingWindow外的数据 if (i - queue[0] &gt;= k) &#123; queue.shift(); &#125; // 剔除queue元素，确保queue首位保存的是最大值的索引 while (nums[i] &gt; nums[queue[queue.length - 1]]) &#123; queue.pop() &#125; queue.push(i) //从k-1开始输出结果 if (i &gt;= k - 1) &#123; result.push(nums[queue[0]]) &#125; &#125; return result;&#125; 合并两个有序数组给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。示例: 12345输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出: [1,2,2,3,5,6] 思路分析：nums1 、 nums2 有序，若把 nums2 全部合并到 nums1 ，则合并后的 nums1 长度为 m+n我们可以从下标 m+n-1 的位置填充 nums1，循环比较 nums1[len1] 与 nums2[len2] 的大小，将最大值写入 nums1[len]。边界条件： 若 len1 &lt; 0， len2 &gt;= 0 ，此时 nums1 已重写入， nums2 还未合并完，只需将 nums2 的剩余元素写入 nums1 即可，写入后，合并完成； 若 len2 &lt; 0，此时 nums2 已全部合并到 nums1 ，合并完成。 实现代码： 123456789101112131415161718192021/** * @param &#123;number[]&#125; nums1 * @param &#123;number&#125; m * @param &#123;number[]&#125; nums2 * @param &#123;number&#125; n * @return &#123;void&#125; Do not return anything, modify nums1 in-place instead. */var merge = function (nums1, m, nums2, n) &#123; let len1 = m - 1, len2 = n - 1, len = m + n - 1; //若len2 &lt; 0,说明 nums2 已全部合并到 nums1 ，合并完成 while (len2 &gt;= 0) &#123; if (len1 &lt; 0) &#123; // 此时 nums1 已重写入， nums2 还未合并完，仅仅需要将 nums2 的剩余元素写入 nums1 即可 nums1[len--] = nums2[len2--]; continue; &#125; nums1[len--] = nums1[len1] &gt;= nums2[len2] ? nums1[len1--] : nums2[len2--] &#125;&#125;; 复杂度分析： 时间复杂度为 O(m+n) 空间复杂度为 O(1） 14. 最长公共前缀编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot;。示例 1: 12输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot; 示例 2: 123输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。 解题思路： 本题的解题方法很多，比如： 直接逐个比较; 寻找最大字符串与最小字符串，将问题化解为比较这两个字符串的大小（ace &gt; acd &gt; abc =&gt; 这三个字符串的最长公共前缀一定是ace与abc两者的最长公共前缀） 分治/归并策略： 将问题分解为每两个字符串的最长公共前缀，再归并为一，求得最后值。如下图： 利用Trie 树（字典树）Trie 树，也称为字典树或前缀树，顾名思义，它是用来处理字符串匹配问题的数据结构，以及用来解决集合中查找固定前缀字符串的数据结构。 下面以Trie树方式为例来实现，思路如下：构建一个 Trie 树，字符串数组的最长公共序列就为从根节点开始遍历树，直到： 遍历节点存在超过一个子节点的节点 或遍历节点为一个字符串的结束字符 为止，走过的字符为字符串数组的最长公共前缀。 如图，以[&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]为例，最终结果为&quot;fl&quot; 实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var longestCommonPrefix = function (strs) &#123; if (strs === null || strs.length === 0) return &quot;&quot;; // 初始化 Trie 树 let trie = new Trie() // 构建 Trie 树 for (let i = 0; i &lt; strs.length; i++) &#123; if (!trie.insert(strs[i])) return &quot;&quot; &#125; // 返回最长公共前缀 return trie.searchLongestPrefix()&#125;;var TrieNode = function () &#123; // next 放入当前节点的子节点 this.next = &#123;&#125;; // 当前是否是结束节点 this.isEnd = false;&#125;;// Trie 树var Trie = function () &#123; this.root = new TrieNode()&#125;;Trie.prototype.insert = function (word) &#123; if (!word) return false let node = this.root for (let i = 0; i &lt; word.length; i++) &#123; if (!node.next[word[i]]) &#123; node.next[word[i]] = new TrieNode() &#125; node = node.next[word[i]] &#125; node.isEnd = true return true&#125;;Trie.prototype.searchLongestPrefix = function () &#123; let node = this.root let prevs = &#x27;&#x27; while (node.next) &#123; let keys = Object.keys(node.next) if (keys.length !== 1) break; //超过一个子节点的节点 if (node.next[keys[0]].isEnd) &#123; //节点为一个字符串的结束字符 prevs += keys[0] break &#125; prevs += keys[0] node = node.next[keys[0]] &#125; return prevs&#125;const res = longestCommonPrefix([&quot;flower&quot;, &quot;flow&quot;, &quot;flight&quot;])console.log(res); 链表类常用方法总结： 快慢指针 标记位法 合并两个有序链表将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。示例： 12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 思路从链表头开始比较，l1 与 l2 是有序递增的，所以比较 l1.val 与 l2.val 的较小值就是合并后链表的最小值，次小值就是小节点的 next.val 与大节点的 val 比较的较小值，依次递归，直到递归到 l1 l2 均为 null 确定边界条件： 当递归到任意链表为 null ，直接将 next 指向另外的链表即可，不需要继续递归了 代码实现： 123456789101112131415function mergeTwoLists(l1, l2) &#123; if(l1 === null) &#123; return l2 &#125; if(l2 === null) &#123; return l1 &#125; if(l1.val &lt;= l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2) return l1 &#125; else &#123; l2.next = mergeTwoLists(l2.next, l1) return l2 &#125;&#125; 141. 环形链表给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例 1： 123输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 123输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 123输入：head = [1], pos = -1输出：false解释：链表中没有环。 方法一：标志法给每个已遍历过的节点加标志位，遍历链表，当出现下一个节点已被标志时，则证明单链表有环 12345678910111213141516171819202122/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;boolean&#125; */var hasCycle = function(head) &#123; while(head)&#123; if(head.flag)&#123; return true; &#125; head.flag = 1; head = head.next; &#125; return false&#125;; 方法二： 快慢指针法设置快慢两个指针，遍历单链表，快指针一次走两步，慢指针一次走一步，如果单链表中存在环，则快慢指针终会指向同一个节点，否则直到快指针指向 null 时，快慢指针都不可能相遇。 1234567891011121314var hasCycle = function(head) &#123; if(!head || !head.next) &#123; return false &#125; let fast = head.next.next, slow = head.next; while(fast &amp;&amp; fast.next)&#123; // fast.next为null说明fast是链表终点，无环 if(fast === slow )&#123; return true &#125; fast = fast.next.next; slow = slow.next; &#125; return false;&#125;; 方法三： 利用 JSON.stringify() 不能序列化含有循环引用的结构 123456789var hasCycle = function(head) &#123; try&#123; JSON.stringify(head); return false; &#125; catch(err)&#123; return true; &#125;&#125;; 142. 环形链表 II给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 说明：不允许修改给定的链表。 解题思路： 本题与上一题类似，增加的难度在于需要返回入环点。所以无法基于JSON.stringify()来实现了。方法一： 标志法此方法实现代码与上一题基本一样，只是返回值有所区别。 12345678910111213141516171819202122/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var detectCycle = function (head) &#123; while(head)&#123; if(head.flag)&#123; return head; &#125; head.flag = 1; head = head.next; &#125; return null;&#125;; 方法二： 快慢指针法 上一题中快慢指针相遇点（即fast === slow）肯定是环内某一点（注意不一定是入环点，所以本题不能直接返回这个节点）。 所以接下去主要工作是如何判断入环点？ 基于上一题，我们设置fast指针速度是2，slow指针速度是1, fast速度是slow速度的2倍，所以最终相遇（fast === slow）时，fast走的距离也是slow走的距离的2倍。具体分析如下： 123456A - 起点B - 第一次相遇点X - 入环点d1 - A-X距离d2 - X-B距离d3 - B-X距离 最后得出d1 = d3。那么就可以在上题基础上进行寻找入环点： 当fast和slow在B点相遇后，将fast重回A点。将两个指针均以速度1向前走，最终会在X点相遇（距离一样，速度一样，所以到X点的时间也一样），相遇时返回节点即可。 实现代码： 12345678910111213141516171819var detectCycle = function (head) &#123; if(!head || !head.next) &#123; return null &#125; let fast = head.next.next, slow = head.next; while(fast &amp;&amp; fast.next)&#123;//fast.next为null说明fast是链表终点，无环 if(fast === slow )&#123; fast = head; while(fast !== slow)&#123; fast = fast.next; slow = slow.next; &#125; return slow; &#125; fast = fast.next.next; slow = slow.next; &#125; return null;&#125;; 反转链表解题思路： 定义一个反转链表prev, 循环head指针，将当前head指向prev，实现反转效果。 123456789101112131415161718192021222324/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var reverseList = function(head) &#123; let prev = null; while(head)&#123; //临时存放下一个指针 let next = head.next; //将当前节点指向prev，实现反转效果 head.next = prev; // 变更prev、head prev = head; head = next; &#125; return prev;&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：O(1) 19. 删除链表的倒数第N个节点给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。示例： 123给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 解题思路：需要删除链表中的倒数第 n 个节点，我们需要知道的就是倒数第 n+1 个节点，然后删除删除倒数第 n+1 节点的后继节点即可. 使用快慢指针思想来解决此问题： 12345678910111213141516var removeNthFromEnd = function(head, n) &#123; let fast = head, slow = head // 快先走 n - 1 步 while(--n) &#123; fast = fast.next &#125; if(!fast.next) return head.next;//说明列表长度为n,删除头结点 fast = fast.next // fast、slow 一起前进 while(fast &amp;&amp; fast.next) &#123; fast = fast.next slow = slow.next &#125; slow.next = slow.next.next return head&#125;; 876. 链表的中间结点解题思路：使用快慢指针方法： 快指针速度2，慢指针速度1，当快指针到达终点时，慢指针刚好在中间节点。 12345678var middleNode = function(head) &#123; let fast = head, slow = head; while(fast &amp;&amp; fast.next)&#123; fast = fast.next.next; slow = slow.next; &#125; return slow;&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：O(1) 动态规划类309. 最佳买卖股票时机含冷冻期分析： 第i天主要有三种情况，当天收益取三者最大值： 当天持有此股票，那么股票可能是：a. 前一天就持有的, 取值(dp[i - 1][0])，b. 或者当天刚买的,取值(dp[i - 1][2] - prices[i]))，这种情况的最大收益为： Math.max(dp[i - 1][0], dp[i - 1][2] - prices[i]); 当天卖出股票，则收益为前一天的持有收益 + 当天的股票价格收益， 即： dp[i - 1][0] + prices[i]; 当天未持有，并且当天未卖出过，则有两种情况：a. 前一天卖出过，dp[i-1][1]b. 前一天未卖出， dp[i-1][2]。这种情况的最大收益为： Math.max(dp[i - 1][1], dp[i - 1][2]); 第一天的初始值：dp[0] = [-prices[0], 0, 0]; 代码实现： 1234567891011121314151617181920/* * 最终的收益是当天的三种情况取最大 * @param &#123;number[]&#125; prices * @return &#123;number&#125; */var maxProfit = function (prices) &#123; const len = prices.length; if (len &lt; 2) return 0 const dp = []; dp.push([-prices[0], 0, 0]); let t0, t1, t2; for (let i = 1; i &lt; len; i++) &#123; t0 = Math.max(dp[i - 1][0], dp[i - 1][2] - prices[i]); // 当天持有此股票 t1 = dp[i - 1][0] + prices[i]; // 当天未持有，并且当天卖出 t2 = Math.max(dp[i - 1][1], dp[i - 1][2]); //当天未持有，并且不是当天卖出 dp.push([t0, t1, t2]); &#125; return Math.max(...dp.pop())&#125;; 面试题 17.13. 恢复空格分析： 遍历 sentence，如果i-1结尾的子字符串 等于 dictionary的某个word, 说明dp[i] 可以等于 dp[i - word.length]； 代码实现： 12345678910111213141516171819202122/** * @param &#123;Array&#125; dictionary * @param &#123;String&#125; sentence * @return &#123;number&#125; */const respace = (dictionary, sentence) =&gt; &#123; const len = sentence.length; if (len === 0) return 0; const dp = new Array(len + 1); dp[0] = 0; for (let i = 1; i &lt;= len; i++) &#123; //i代表 Length(sentence) dp[i] = dp[i - 1] + 1; for (const word of dictionary) &#123; if (word === sentence.substring(i - word.length, i)) &#123; dp[i] = Math.min(dp[i], dp[i - word.length]) &#125; &#125; &#125; return dp[len]&#125;; 96. 不同的二叉搜索树 思路:标签：动态规划假设n个节点存在二叉排序树的个数是dp(n)，令f(i)为以i为根的二叉搜索树的个数，则dp(n) = f(1) + f(2) + f(3) + f(4) + ... + f(n) 当i为根节点时，其左子树节点个数为i-1个，右子树节点为n-i，则f(i) = dp(i-1)*dp(n-i) 综合两个公式可以得到 卡特兰数 公式dp(n) = dp(0)dp(n-1)+dp(1)(n-2)+...+dp(n-1)*dp(0) 代码实现： 1234567891011var numTrees = function (n) &#123; const dp = new Array(n + 1).fill(0); dp[0] = 1; dp[1] = 1; for (let i = 2; i &lt;= n; i++) &#123; for (let j = 1; j &lt;= i; j++) &#123; //以j为顶点的个数计算 dp[i] += dp[j - 1] * dp[i - j]; &#125; &#125; return dp[n];&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kobingogo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://kobingogo.github.io/tags/leetcode/"}]},{"title":"从Chrome源码看JS Array的底层实现","slug":"Chrome源码-array-knowledge","date":"2020-06-17T22:41:59.000Z","updated":"2022-02-18T02:31:03.807Z","comments":true,"path":"Chrome源码-array-knowledge/","link":"","permalink":"https://kobingogo.github.io/Chrome%E6%BA%90%E7%A0%81-array-knowledge/","excerpt":"作为前端er，我们都知道，JS 的数组可以存放不同类型的元素、并且数组长度是可变的。不像其他的语言，比如C，创建的时候要决定数组的大小，如果数组满了，就要重新申请内存空间。 知道归知道，但是要想弄清楚其中原因，就得从Chrome源码去探究了。","text":"作为前端er，我们都知道，JS 的数组可以存放不同类型的元素、并且数组长度是可变的。不像其他的语言，比如C，创建的时候要决定数组的大小，如果数组满了，就要重新申请内存空间。 知道归知道，但是要想弄清楚其中原因，就得从Chrome源码去探究了。 JS Array为什么可以保存不同类型先看下Chrome V8对JSArray的定义： 123456789101112131415// The JSArray describes JavaScript Arrays// Such an array can be in one of two modes:// - fast, backing storage is a FixedArray and length &lt;= elements.length();// Please note: push and pop can be used to grow and shrink the array.// - slow, backing storage is a HashTable with numbers as keys.class JSArray: public JSObject &#123; public: // [length]: The length property. DECL_ACCESSORS(length, Object) // ... // Number of element slots to pre-allocate for an empty array. static const int kPreallocatedArrayElements = 4;&#125;; 我们可以看到 JSArray 是继承自 JSObject 的，所以在 JavaScript 中，数组可以是一个特殊的对象，内部是以 key-value 形式存储数据，所以 JavaScript 中的数组可以存放不同类型的值。 JS Array如何存储从上述 V8 源码注释中可以看出，JSArray有两种存储方式： fast：存储结构是 FixedArray ，并且数组长度 &lt;= elements.length() ，push 或 pop 时可能会伴随着动态扩容或减容，源码里叫 FastElements; slow：存储结构是 HashTable，并且数组下标作为 key,源码里叫 SlowElements; 快数组（FastElements）FixedArray 是 V8 实现的一个类似于数组的类，它表示一段连续的内存，可以使用索引直接定位。新创建的空数组默认就是快数组。当数组满（数组的长度达到数组在内存中申请的内存容量最大值）的时候，继续 push 时， JSArray 会进行动态的扩容，以存储更多的元素。 慢数组（SlowElements）慢数组以哈希表的形式存储在内存空间里，它不需要开辟连续的存储空间,节省了内存，但需要额外维护一个哈希表，性能相对较差。 什么时候会从 fast 转变为 slow 123456789101112131415161718192021222324252627282930313233343536373839404142434445// src/objects/js-objects.hstatic const uint32_t kMaxGap = 1024;// src/objects/dictionary.h// JSObjects prefer dictionary elements if the dictionary saves this much// memory compared to a fast elements backing store.static const uint32_t kPreferFastElementsSizeFactor = 3;// src/objects/js-objects-inl.h// If the fast-case backing storage takes up much more memory than a dictionary// backing storage would, the object should have slow elements.// staticstatic inline bool ShouldConvertToSlowElements(uint32_t used_elements, uint32_t new_capacity) &#123; uint32_t size_threshold = NumberDictionary::kPreferFastElementsSizeFactor * NumberDictionary::ComputeCapacity(used_elements) * NumberDictionary::kEntrySize; // 快数组新容量是扩容后的容量3倍之多时，也会被转成慢数组 return size_threshold &lt;= new_capacity;&#125;static inline bool ShouldConvertToSlowElements(JSObject object, uint32_t capacity, uint32_t index, uint32_t* new_capacity) &#123; STATIC_ASSERT(JSObject::kMaxUncheckedOldFastElementsLength &lt;= JSObject::kMaxUncheckedFastElementsLength); if (index &lt; capacity) &#123; *new_capacity = capacity; return false; &#125; // 当加入的索引值（例如例3中的2000）比当前容量capacity 大于等于 1024时， // 返回true，转为慢数组 if (index - capacity &gt;= JSObject::kMaxGap) return true; *new_capacity = JSObject::NewElementsCapacity(index + 1); DCHECK_LT(index, *new_capacity); // TODO(ulan): Check if it works with young large objects. if (*new_capacity &lt;= JSObject::kMaxUncheckedOldFastElementsLength || (*new_capacity &lt;= JSObject::kMaxUncheckedFastElementsLength &amp;&amp; ObjectInYoungGeneration(object))) &#123; return false; &#125; return ShouldConvertToSlowElements(object.GetFastElementsUsage(), *new_capacity);&#125; 从上述源码看出，当处于以下情况时，快数组会被转变为慢数组： 当加入的索引值 index 比当前容量 capacity 差值大于等于 1024 时（index - capacity &gt;= 1024） 快数组新容量是扩容后的容量 3 倍之多时 增加一个2000的索引时，array就会被转成慢数组: 12var array = [1, 2, 3]array[2000] = 1000; 什么时候会从 slow 转变为 fast 123456789101112131415161718192021222324static bool ShouldConvertToFastElements(JSObject object, NumberDictionary dictionary, uint32_t index, uint32_t* new_capacity) &#123; // If properties with non-standard attributes or accessors were added, we // cannot go back to fast elements. if (dictionary.requires_slow_elements()) return false; // Adding a property with this index will require slow elements. if (index &gt;= static_cast&lt;uint32_t&gt;(Smi::kMaxValue)) return false; if (object.IsJSArray()) &#123; Object length = JSArray::cast(object).length(); if (!length.IsSmi()) return false; *new_capacity = static_cast&lt;uint32_t&gt;(Smi::ToInt(length)); &#125; else if (object.IsJSArgumentsObject()) &#123; return false; &#125; else &#123; *new_capacity = dictionary.max_number_key() + 1; &#125; *new_capacity = Max(index + 1, *new_capacity); uint32_t dictionary_size = static_cast&lt;uint32_t&gt;(dictionary.Capacity()) * NumberDictionary::kEntrySize; // Turn fast if the dictionary only saves 50% space. return 2 * dictionary_size &gt;= *new_capacity;&#125; 当慢数组的元素可存放在快数组中且长度在 smi 之间且仅节省了50%的空间(用慢数组节省的空间不大于50%),则会转变为快数组 smi在64位平台为-231 到 231 -1，在32位平台为-230 到 230 -1 12345let a = [1,2];a[1030] = 1;for (let i = 200; i &lt; 1030; i++) &#123; a[i] = i;&#125; 在 1030 的位置上面添加一个值，会造成多于 1024 个空洞，数组变成慢数组；然后往这个数组中 200-1029 这些位置上赋值，使慢数组不再比快数组节省 50% 的空间，则数组变成快数组。 总结 快数组就是以空间换时间的方式，申请了大块连续内存，提高效率。 慢数组以时间换空间，不必申请连续的空间，节省了内存，但需要付出效率变差的代价。 数组的动态扩容与减容默认空数组初始化大小为 4 : 12// Number of element slots to pre-allocate for an empty array.static const int kPreallocatedArrayElements = 4; 在 Chrome 源码中， push 的操作是用汇编实现的，在 c++ 里嵌入的汇编，以提高执行效率，并且在汇编的基础上用 c++ 封装了一层，在编译执行的时候，会将这些 c++ 代码转成汇编代码。 计算新容量的函数： 12345678910111213// js-objects.hstatic const uint32_t kMinAddedElementsCapacity = 16;// code-stub-assembler.ccNode* CodeStubAssembler::CalculateNewElementsCapacity(Node* old_capacity, ParameterMode mode) &#123; CSA_SLOW_ASSERT(this, MatchesParameterMode(old_capacity, mode)); Node* half_old_capacity = WordOrSmiShr(old_capacity, 1, mode); Node* new_capacity = IntPtrOrSmiAdd(half_old_capacity, old_capacity, mode); Node* padding = IntPtrOrSmiConstant(JSObject::kMinAddedElementsCapacity, mode); return IntPtrOrSmiAdd(new_capacity, padding, mode);&#125; 所以扩容后新容量计公式为： 1new_capacity = old_capacity /2 + old_capacity + 16 即老的容量的 1.5 倍加上 16 。初始化为 4 个，当 push 第 5 个的时候，容量将会变成： 1new_capacity = 4 / 2 + 4 + 16 = 22 接着申请一块这么大的内存，把老的数据拷过去，把新元素放在当前 length 位置，然后将数组的 length + 1，并返回 length。 整个过程，用户是无感知的，不像 C，需用用户手动申请内存空间。 当数组执行 pop 操作时，会判断 pop 后数组的容量，是否需要进行减容。 不同于数组的 push 使用汇编实现的， pop 使用 c++ 实现的。 判断是否进行减容： 1234567if (2 * length &lt;= capacity) &#123; // If more than half the elements won&#x27;t be used, trim the array. isolate-&gt;heap()-&gt;RightTrimFixedArray(*backing_store, capacity - length);&#125; else &#123; // Otherwise, fill the unused tail with holes. BackingStore::cast(*backing_store)-&gt;FillWithHoles(length, old_length);&#125; 所以，当数组 pop 后，如果数组容量大于等于 length 的 2 倍，则进行容量调整，使用 RightTrimFixedArray 函数，计算出需要释放的空间大小，做好标记，等待 GC 回收；如果数组容量小于 length 的 2 倍，则用 holes 对象填充。 总结JavaScript 中， JSArray 继承自 JSObject ，是一个特殊的对象，内部是以 key-value 形式存储数据，所以 JavaScript 中的数组可以存放不同类型的值。 JSArray有两种存储方式，快数组与慢数组，初始化空数组时，使用快数组，快数组使用连续的内存空间，当快数组长度达到最大时，JSArray 会进行动态的扩容，以存储更多的元素，相对慢数组，性能要好得多。 当数组中 hole 太多时，会转变成慢数组，即以哈希表的方式（ key-value 的形式）存储数据，以节省内存空间。 一道面试题 - 数组扁平化假如有个数组： 1var arr = [ [1, 2, 2], [3, 4, [5, 5]], 10] 如何将其扁平化为： 1[1, 2, 2, 3, 4, 5, 5, 10] 核心思想： 遍历数组arr，若arr[i]为数组则递归遍历，直至arr[i]不为数组然后与之前的结果concat。 ES6 flat 1arr.flat(Infinity) reduce 12345function flatten(arr) &#123; return arr.reduce((result, item)=&gt; &#123; return result.concat(Array.isArray(item) ? flatten(item) : item); &#125;, []);&#125; toString / join 123456function flatten(arr) &#123; return arr.toString().split(&#x27;,&#x27;).map(function(item) &#123; return Number(item); &#125;)&#125; 递归 1234567891011function flatten(arr) &#123; var res = []; arr.map(item =&gt; &#123; if(Array.isArray(item)) &#123; res = res.concat(flatten(item)); &#125; else &#123; res.push(item); &#125; &#125;); return res;&#125; 扩展运算符 es6的扩展运算符能将二维数组变为一维 123456function flatten(arr) &#123; while(arr.some(item=&gt;Array.isArray(item))) &#123; arr = [].concat(...arr); &#125; return arr;&#125; 参考链接：前端进阶算法2：从Chrome V8源码看JavaScript数组","categories":[{"name":"Chrome源码","slug":"chrome源码","permalink":"https://kobingogo.github.io/categories/chrome%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"array","slug":"array","permalink":"https://kobingogo.github.io/tags/array/"}]},{"title":"常用系统命令汇总","slug":"others-常用系统命令汇总","date":"2020-06-12T18:50:05.000Z","updated":"2022-02-18T02:31:03.811Z","comments":true,"path":"others-常用系统命令汇总/","link":"","permalink":"https://kobingogo.github.io/others-%E5%B8%B8%E7%94%A8%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/","excerpt":"各个系统常用终端命令汇总之地","text":"端口检查 linux 1telnet 192.168.1.102 3306 mac 1nc -vz -w 2 192.168.1.104 3306 查看端口占用 Centos7+ 1234567891011lsof -i tcp:80 # 查看80端口占用情况netstat -ntlp # 列出所有端口firewall-cmd --query-port=3306/tcp # 查询是否开启3306端口firewall-cmd --zone=public --add-port=3306/tcp --permanent # 开启端口firewall-cmd --zone=public --remove-port=3306/tcp --permanent # 关闭端口firewall-cmd --reload #重启防火墙 杀掉进程 Centos 123netstat -tpnul # 查看当前所有正在运行的进程ps aux |grep httpd # 查看 httpd 进程kill -9 6732 # 6732为httpd进程对应的进程ID","categories":[{"name":"others","slug":"others","permalink":"https://kobingogo.github.io/categories/others/"}],"tags":[{"name":"命令","slug":"命令","permalink":"https://kobingogo.github.io/tags/%E5%91%BD%E4%BB%A4/"}]},{"title":"Vulter + v2ray / Trojan 使用教程","slug":"others-v2ray-manual","date":"2020-06-11T18:25:33.000Z","updated":"2022-02-18T02:31:03.811Z","comments":true,"path":"others-v2ray-manual/","link":"","permalink":"https://kobingogo.github.io/others-v2ray-manual/","excerpt":"最近一直在使用的梯子服务临近到期，想要续费发现价格又涨了一波，再加上平时使用中并不是很稳定。就萌生了自建一个梯子的想法。","text":"最近一直在使用的梯子服务临近到期，想要续费发现价格又涨了一波，再加上平时使用中并不是很稳定。就萌生了自建一个梯子的想法。 前言要想自建梯子有两个前提： 境外VPS服务器(虚拟专用服务器) 科学上网工具 VPS服务器对比了阿里云国际版、谷歌云、AWS等巨头产品，以及VULTR、搬瓦工等服务商，最终选择了VULTR，主要原因在于： 价格便宜： 最便宜的有$2.5/月的服务，价格是王道； 机房众多：拥有日本、美国、欧洲等 17 个机房； 架构优秀：全部采用 KVM 架构、SSD 固态硬盘、500G/月流量起步； 后台强大 ：拥有系统快照、一键装机部署脚本、备份、防火墙等强大功能，从 VPS 这点丝毫不输给阿里云。 计费灵活 : 采用小时计费模式，可以任意的添加和删除机器 , 并且是单向流量收费 , 也就是只计算下载的的流量; 支持支付宝/微信支付，国内用户购买方便； 注册购买请进入官网自行操作：vultr官网 科学上网工具本文主要实现v2ray 和 Trojan 两个工具的搭建 SSH免密登录vultr服务器 在本机生成密钥（如果已经有了不用重复生成）： 1ssh-keygen -t rsa 将本地公钥拷贝到服务器的~/.ssh/authorized_keys目录中： 12345678910111213# 方法一ssh-copy-id user@ip# 法二# 将 本机 ~/.ssh目录中的 id_rsa.pub 这个文件拷贝到服务器 的~/.ssh目录中scp ~/.ssh/id_rsa.pub user@ip:~/.ssh/# 在服务器运行以下命令来将公钥导入到~/.ssh/authorized_keys这个文件中cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys# authorized_keys的权限要是600。chmod 600 .ssh/authorized_keys user: 服务器用户名，默认为rootip: 服务器公网IP 至此，就可以用下面命令免密登录了： 1ssh user@ip v2ray安装与配置登录了云服务后，就可以开始下载安装v2ray了，执行以下命令： 12345wget https://install.direct/go.shchmod +x go.sh./go.sh 执行成功后，会输出 V2Ray v4.24.2 is installed. 等字样。 安装V2Ray后， 会在/etc/v2ray/config.json默认生成配置文件，我们需要编辑这个文件： 1vi /etc/v2ray/config.json 然后连续按 d 键，将原本的文件内容清空，然后按 i 键开启编辑模式，复制以下配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&#123; &quot;log&quot;: &#123; &quot;access&quot;: &quot;/var/log/v2ray/access.log&quot;, &quot;error&quot;: &quot;/var/log/v2ray/error.log&quot;, &quot;loglevel&quot;: &quot;warning&quot; &#125;, &quot;inbound&quot;: &#123; &quot;port&quot;: 9751, &quot;protocol&quot;: &quot;vmess&quot;, &quot;settings&quot;: &#123; &quot;clients&quot;: [ &#123; &quot;id&quot;: &quot;392029fa-a9e0-42e3-93cb-97a9288795ed&quot;, &quot;level&quot;: 1, &quot;alterId&quot;: 100 &#125; ] &#125;, &quot;streamSettings&quot;: &#123; &quot;network&quot;: &quot;tcp&quot; &#125;, &quot;detour&quot;: &#123; &quot;to&quot;: &quot;vmess-detour-118345&quot; &#125; &#125;, &quot;outbound&quot;: &#123; &quot;protocol&quot;: &quot;freedom&quot;, &quot;settings&quot;: &#123;&#125; &#125;, &quot;inboundDetour&quot;: [ &#123; &quot;protocol&quot;: &quot;vmess&quot;, &quot;port&quot;: &quot;10000-10010&quot;, &quot;tag&quot;: &quot;vmess-detour-118345&quot;, &quot;settings&quot;: &#123;&#125;, &quot;allocate&quot;: &#123; &quot;strategy&quot;: &quot;random&quot;, &quot;concurrency&quot;: 5, &quot;refresh&quot;: 5 &#125;, &quot;streamSettings&quot;: &#123; &quot;network&quot;: &quot;kcp&quot; &#125; &#125; ], &quot;outboundDetour&quot;: [ &#123; &quot;protocol&quot;: &quot;blackhole&quot;, &quot;settings&quot;: &#123;&#125;, &quot;tag&quot;: &quot;blocked&quot; &#125; ], &quot;routing&quot;: &#123; &quot;strategy&quot;: &quot;rules&quot;, &quot;settings&quot;: &#123; &quot;rules&quot;: [ &#123; &quot;type&quot;: &quot;field&quot;, &quot;ip&quot;: [ &quot;0.0.0.0/8&quot;, &quot;10.0.0.0/8&quot;, &quot;100.64.0.0/10&quot;, &quot;127.0.0.0/8&quot;, &quot;169.254.0.0/16&quot;, &quot;172.16.0.0/12&quot;, &quot;192.0.0.0/24&quot;, &quot;192.0.2.0/24&quot;, &quot;192.168.0.0/16&quot;, &quot;198.18.0.0/15&quot;, &quot;198.51.100.0/24&quot;, &quot;203.0.113.0/24&quot;, &quot;::1/128&quot;, &quot;fc00::/7&quot;, &quot;fe80::/10&quot; ], &quot;outboundTag&quot;: &quot;blocked&quot; &#125; ] &#125; &#125;&#125; 上述配置中可根据自己的喜好进行相应修改，也可直接使用不做修改。 保存并退出编辑模式，再启动v2ray服务，服务端的配置就完成了。 1systemctl start v2ray v2ray进程管理命令： 1234567891011# 查看 v2ray 进程状态systemctl status v2ray# 启动systemctl start v2ray# 重启systemctl restart v2ray# 关闭systemctl stop v2ray 配置防火墙CentOS 7 系统默认会开启防火墙，需要开放上面配置的端口： 123firewall-cmd --permanent --add-service=https# 或者firewall-cmd --zone=public --add-port=9751/tcp --permanent – zone #作用域 – add-port=80/tcp #添加端口，格式为：端口/通讯协议 – permanent #永久生效，没有此参数重启后失效 防火墙其他相关命令： 12345678systemctl status firewalld # 查看防火墙状态firewall-cmd --reload #重启firewallsystemctl restart firewalld # 重启2systemctl stop firewalld.service #停止firewallsystemctl disable firewalld.service #禁止firewall开机启动firewall-cmd --state #查看默认防火墙状态（关闭后显示notrunning，开启后显示running）firewall-cmd --list-ports # 查看已经开放的端口 至此，服务端部分就算完成了。下面开始客户端配置。 V2Ray 客户端 Mac端 Mac端使用的是ClashX客户端。安装下载后打开配置文件夹： 新建一个.yaml配置文件，具体配置如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481port: 7890socks-port: 7891redir-port: 7892allow-lan: falsemode: Rulelog-level: infoexternal-controller: 127.0.0.1:9090secret: &quot;&quot;cfw-bypass: - localhost - 127.* - 10.* - 172.16.* - 172.17.* - 172.18.* - 172.19.* - 172.20.* - 172.21.* - 172.22.* - 172.23.* - 172.24.* - 172.25.* - 172.26.* - 172.27.* - 172.28.* - 172.29.* - 172.30.* - 172.31.* - 192.168.* - &lt;local&gt;cfw-latency-timeout: 3000Proxy: - name: V2-NewJersey type: vmess server: 208.167.222.200 # 服务器公网IP port: &quot;9751&quot; # v2ray配置的端口 uuid: 392029fa-a9e0-42e3-93cb-97a9288795ed # v2ray的uuid alterId: &quot;100&quot; # v2ray的额外ID cipher: auto network: tcp # 传输协议Proxy Group: - name: CroLAX type: select proxies: - V2-NewJerseyRule: - DOMAIN,hls.itunes.apple.com,CroLAX - DOMAIN,itunes.apple.com,CroLAX - DOMAIN,itunes.com,CroLAX - DOMAIN-SUFFIX,icloud.com,DIRECT - DOMAIN-SUFFIX,icloud-content.com,DIRECT - DOMAIN-SUFFIX,me.com,DIRECT - DOMAIN-SUFFIX,mzstatic.com,DIRECT - DOMAIN-SUFFIX,akadns.net,DIRECT - DOMAIN-SUFFIX,aaplimg.com,DIRECT - DOMAIN-SUFFIX,cdn-apple.com,DIRECT - DOMAIN-SUFFIX,apple.com,DIRECT ## 国内网站 - DOMAIN-SUFFIX,cn,DIRECT - DOMAIN-KEYWORD,-cn,DIRECT - DOMAIN-SUFFIX,126.com,DIRECT - DOMAIN-SUFFIX,126.net,DIRECT - DOMAIN-SUFFIX,127.net,DIRECT - DOMAIN-SUFFIX,163.com,DIRECT - DOMAIN-SUFFIX,360buyimg.com,DIRECT - DOMAIN-SUFFIX,36kr.com,DIRECT - DOMAIN-SUFFIX,acfun.tv,DIRECT - DOMAIN-SUFFIX,air-matters.com,DIRECT - DOMAIN-SUFFIX,aixifan.com,DIRECT - DOMAIN-SUFFIX,akamaized.net,DIRECT - DOMAIN-KEYWORD,alicdn,DIRECT - DOMAIN-KEYWORD,alipay,DIRECT - DOMAIN-KEYWORD,taobao,DIRECT - DOMAIN-SUFFIX,amap.com,DIRECT - DOMAIN-SUFFIX,autonavi.com,DIRECT - DOMAIN-KEYWORD,baidu,DIRECT - DOMAIN-SUFFIX,bdimg.com,DIRECT - DOMAIN-SUFFIX,bdstatic.com,DIRECT - DOMAIN-SUFFIX,bilibili.com,DIRECT - DOMAIN-SUFFIX,caiyunapp.com,DIRECT - DOMAIN-SUFFIX,clouddn.com,DIRECT - DOMAIN-SUFFIX,cnbeta.com,DIRECT - DOMAIN-SUFFIX,cnbetacdn.com,DIRECT - DOMAIN-SUFFIX,cootekservice.com,DIRECT - DOMAIN-SUFFIX,csdn.net,DIRECT - DOMAIN-SUFFIX,ctrip.com,DIRECT - DOMAIN-SUFFIX,dgtle.com,DIRECT - DOMAIN-SUFFIX,dianping.com,DIRECT - DOMAIN-SUFFIX,douban.com,DIRECT - DOMAIN-SUFFIX,doubanio.com,DIRECT - DOMAIN-SUFFIX,duokan.com,DIRECT - DOMAIN-SUFFIX,easou.com,DIRECT - DOMAIN-SUFFIX,ele.me,DIRECT - DOMAIN-SUFFIX,feng.com,DIRECT - DOMAIN-SUFFIX,fir.im,DIRECT - DOMAIN-SUFFIX,frdic.com,DIRECT - DOMAIN-SUFFIX,g-cores.com,DIRECT - DOMAIN-SUFFIX,godic.net,DIRECT - DOMAIN-SUFFIX,gtimg.com,DIRECT - DOMAIN-SUFFIX,hongxiu.com,DIRECT - DOMAIN-SUFFIX,hxcdn.net,DIRECT - DOMAIN-SUFFIX,iciba.com,DIRECT - DOMAIN-SUFFIX,ifeng.com,DIRECT - DOMAIN-SUFFIX,ifengimg.com,DIRECT - DOMAIN-SUFFIX,ipip.net,DIRECT - DOMAIN-SUFFIX,iqiyi.com,DIRECT - DOMAIN-SUFFIX,jd.com,DIRECT - DOMAIN-SUFFIX,jianshu.com,DIRECT - DOMAIN-SUFFIX,knewone.com,DIRECT - DOMAIN-SUFFIX,le.com,DIRECT - DOMAIN-SUFFIX,lecloud.com,DIRECT - DOMAIN-SUFFIX,lemicp.com,DIRECT - DOMAIN-SUFFIX,licdn.com,DIRECT - DOMAIN-SUFFIX,linkedin.com,DIRECT - DOMAIN-SUFFIX,luoo.net,DIRECT - DOMAIN-SUFFIX,meituan.com,DIRECT - DOMAIN-SUFFIX,meituan.net,DIRECT - DOMAIN-SUFFIX,mi.com,DIRECT - DOMAIN-SUFFIX,miaopai.com,DIRECT - DOMAIN-SUFFIX,microsoft.com,DIRECT - DOMAIN-SUFFIX,microsoftonline.com,DIRECT - DOMAIN-SUFFIX,miui.com,DIRECT - DOMAIN-SUFFIX,miwifi.com,DIRECT - DOMAIN-SUFFIX,mob.com,DIRECT - DOMAIN-SUFFIX,netease.com,DIRECT - DOMAIN-SUFFIX,office.com,DIRECT - DOMAIN-KEYWORD,officecdn,DIRECT - DOMAIN-SUFFIX,office365.com,DIRECT - DOMAIN-SUFFIX,oschina.net,DIRECT - DOMAIN-SUFFIX,ppsimg.com,DIRECT - DOMAIN-SUFFIX,pstatp.com,DIRECT - DOMAIN-SUFFIX,qcloud.com,DIRECT - DOMAIN-SUFFIX,qdaily.com,DIRECT - DOMAIN-SUFFIX,qdmm.com,DIRECT - DOMAIN-SUFFIX,qhimg.com,DIRECT - DOMAIN-SUFFIX,qhres.com,DIRECT - DOMAIN-SUFFIX,qidian.com,DIRECT - DOMAIN-SUFFIX,qihucdn.com,DIRECT - DOMAIN-SUFFIX,qiniu.com,DIRECT - DOMAIN-SUFFIX,qiniucdn.com,DIRECT - DOMAIN-SUFFIX,qiyipic.com,DIRECT - DOMAIN-SUFFIX,qq.com,DIRECT - DOMAIN-SUFFIX,qqurl.com,DIRECT - DOMAIN-SUFFIX,rarbg.to,DIRECT - DOMAIN-SUFFIX,ruguoapp.com,DIRECT - DOMAIN-SUFFIX,segmentfault.com,DIRECT - DOMAIN-SUFFIX,sinaapp.com,DIRECT - DOMAIN-SUFFIX,smzdm.com,DIRECT - DOMAIN-SUFFIX,sogou.com,DIRECT - DOMAIN-SUFFIX,sogoucdn.com,DIRECT - DOMAIN-SUFFIX,sohu.com,DIRECT - DOMAIN-SUFFIX,soku.com,DIRECT - DOMAIN-SUFFIX,speedtest.net,DIRECT - DOMAIN-SUFFIX,sspai.com,DIRECT - DOMAIN-SUFFIX,suning.com,DIRECT - DOMAIN-SUFFIX,taobao.com,DIRECT - DOMAIN-SUFFIX,tencent.com,DIRECT - DOMAIN-SUFFIX,tenpay.com,DIRECT - DOMAIN-SUFFIX,tianyancha.com,DIRECT - DOMAIN-SUFFIX,tmall.com,DIRECT - DOMAIN-SUFFIX,tudou.com,DIRECT - DOMAIN-SUFFIX,umetrip.com,DIRECT - DOMAIN-SUFFIX,upaiyun.com,DIRECT - DOMAIN-SUFFIX,upyun.com,DIRECT - DOMAIN-SUFFIX,v2ex.com,DIRECT - DOMAIN-SUFFIX,veryzhun.com,DIRECT - DOMAIN-SUFFIX,weather.com,DIRECT - DOMAIN-SUFFIX,weibo.com,DIRECT - DOMAIN-SUFFIX,xiami.com,DIRECT - DOMAIN-SUFFIX,xiami.net,DIRECT - DOMAIN-SUFFIX,xiaomicp.com,DIRECT - DOMAIN-SUFFIX,ximalaya.com,DIRECT - DOMAIN-SUFFIX,xmcdn.com,DIRECT - DOMAIN-SUFFIX,xunlei.com,DIRECT - DOMAIN-SUFFIX,yhd.com,DIRECT - DOMAIN-SUFFIX,yihaodianimg.com,DIRECT - DOMAIN-SUFFIX,yinxiang.com,DIRECT - DOMAIN-SUFFIX,ykimg.com,DIRECT - DOMAIN-SUFFIX,youdao.com,DIRECT - DOMAIN-SUFFIX,youku.com,DIRECT - DOMAIN-SUFFIX,zealer.com,DIRECT - DOMAIN-SUFFIX,zhihu.com,DIRECT - DOMAIN-SUFFIX,zhimg.com,DIRECT - DOMAIN-SUFFIX,zimuzu.tv,DIRECT - DOMAIN-KEYWORD,netflix,CroLAX - DOMAIN-KEYWORD,nflx,CroLAX ## 抗 DNS 污染 - DOMAIN-KEYWORD,amazon,CroLAX - DOMAIN-KEYWORD,google,CroLAX - DOMAIN-KEYWORD,gmail,CroLAX - DOMAIN-KEYWORD,youtube,CroLAX - DOMAIN-KEYWORD,facebook,CroLAX - DOMAIN-SUFFIX,fb.me,CroLAX - DOMAIN-SUFFIX,fbcdn.net,CroLAX - DOMAIN-KEYWORD,twitter,CroLAX - DOMAIN-KEYWORD,instagram,CroLAX - DOMAIN-KEYWORD,dropbox,CroLAX - DOMAIN-SUFFIX,twimg.com,CroLAX - DOMAIN-KEYWORD,blogspot,CroLAX - DOMAIN-SUFFIX,youtu.be,CroLAX - DOMAIN-KEYWORD,whatsapp,CroLAX ## 国外网站 - DOMAIN-SUFFIX,9to5mac.com,CroLAX - DOMAIN-SUFFIX,abpchina.org,CroLAX - DOMAIN-SUFFIX,adblockplus.org,CroLAX - DOMAIN-SUFFIX,adobe.com,CroLAX - DOMAIN-SUFFIX,alfredapp.com,CroLAX - DOMAIN-SUFFIX,amplitude.com,CroLAX - DOMAIN-SUFFIX,ampproject.org,CroLAX - DOMAIN-SUFFIX,android.com,CroLAX - DOMAIN-SUFFIX,angularjs.org,CroLAX - DOMAIN-SUFFIX,aolcdn.com,CroLAX - DOMAIN-SUFFIX,apkpure.com,CroLAX - DOMAIN-SUFFIX,appledaily.com,CroLAX - DOMAIN-SUFFIX,appshopper.com,CroLAX - DOMAIN-SUFFIX,appspot.com,CroLAX - DOMAIN-SUFFIX,arcgis.com,CroLAX - DOMAIN-SUFFIX,archive.org,CroLAX - DOMAIN-SUFFIX,armorgames.com,CroLAX - DOMAIN-SUFFIX,aspnetcdn.com,CroLAX - DOMAIN-SUFFIX,att.com,CroLAX - DOMAIN-SUFFIX,awsstatic.com,CroLAX - DOMAIN-SUFFIX,azureedge.net,CroLAX - DOMAIN-SUFFIX,azurewebsites.net,CroLAX - DOMAIN-SUFFIX,bing.com,CroLAX - DOMAIN-SUFFIX,bintray.com,CroLAX - DOMAIN-SUFFIX,bit.com,CroLAX - DOMAIN-SUFFIX,bit.ly,CroLAX - DOMAIN-SUFFIX,bitbucket.org,CroLAX - DOMAIN-SUFFIX,bjango.com,CroLAX - DOMAIN-SUFFIX,bkrtx.com,CroLAX - DOMAIN-SUFFIX,blog.com,CroLAX - DOMAIN-SUFFIX,blogcdn.com,CroLAX - DOMAIN-SUFFIX,blogger.com,CroLAX - DOMAIN-SUFFIX,blogsmithmedia.com,CroLAX - DOMAIN-SUFFIX,blogspot.com,CroLAX - DOMAIN-SUFFIX,blogspot.hk,CroLAX - DOMAIN-SUFFIX,bloomberg.com,CroLAX - DOMAIN-SUFFIX,box.com,CroLAX - DOMAIN-SUFFIX,box.net,CroLAX - DOMAIN-SUFFIX,cachefly.net,CroLAX - DOMAIN-SUFFIX,chromium.org,CroLAX - DOMAIN-SUFFIX,cl.ly,CroLAX - DOMAIN-SUFFIX,cloudflare.com,CroLAX - DOMAIN-SUFFIX,cloudfront.net,CroLAX - DOMAIN-SUFFIX,cloudmagic.com,CroLAX - DOMAIN-SUFFIX,cmail19.com,CroLAX - DOMAIN-SUFFIX,cnet.com,CroLAX - DOMAIN-SUFFIX,cocoapods.org,CroLAX - DOMAIN-SUFFIX,comodoca.com,CroLAX - DOMAIN-SUFFIX,crashlytics.com,CroLAX - DOMAIN-SUFFIX,culturedcode.com,CroLAX - DOMAIN-SUFFIX,d.pr,CroLAX - DOMAIN-SUFFIX,danilo.to,CroLAX - DOMAIN-SUFFIX,dayone.me,CroLAX - DOMAIN-SUFFIX,db.tt,CroLAX - DOMAIN-SUFFIX,deskconnect.com,CroLAX - DOMAIN-SUFFIX,disq.us,CroLAX - DOMAIN-SUFFIX,disqus.com,CroLAX - DOMAIN-SUFFIX,disquscdn.com,CroLAX - DOMAIN-SUFFIX,dnsimple.com,CroLAX - DOMAIN-SUFFIX,docker.com,CroLAX - DOMAIN-SUFFIX,dribbble.com,CroLAX - DOMAIN-SUFFIX,droplr.com,CroLAX - DOMAIN-SUFFIX,duckduckgo.com,CroLAX - DOMAIN-SUFFIX,dueapp.com,CroLAX - DOMAIN-SUFFIX,dytt8.net,CroLAX - DOMAIN-SUFFIX,edgecastcdn.net,CroLAX - DOMAIN-SUFFIX,edgekey.net,CroLAX - DOMAIN-SUFFIX,edgesuite.net,CroLAX - DOMAIN-SUFFIX,engadget.com,CroLAX - DOMAIN-SUFFIX,entrust.net,CroLAX - DOMAIN-SUFFIX,eurekavpt.com,CroLAX - DOMAIN-SUFFIX,evernote.com,CroLAX - DOMAIN-SUFFIX,fabric.io,CroLAX - DOMAIN-SUFFIX,fast.com,CroLAX - DOMAIN-SUFFIX,fastly.net,CroLAX - DOMAIN-SUFFIX,fc2.com,CroLAX - DOMAIN-SUFFIX,feedburner.com,CroLAX - DOMAIN-SUFFIX,feedly.com,CroLAX - DOMAIN-SUFFIX,feedsportal.com,CroLAX - DOMAIN-SUFFIX,fiftythree.com,CroLAX - DOMAIN-SUFFIX,firebaseio.com,CroLAX - DOMAIN-SUFFIX,flexibits.com,CroLAX - DOMAIN-SUFFIX,flickr.com,CroLAX - DOMAIN-SUFFIX,flipboard.com,CroLAX - DOMAIN-SUFFIX,g.co,CroLAX - DOMAIN-SUFFIX,gabia.net,CroLAX - DOMAIN-SUFFIX,geni.us,CroLAX - DOMAIN-SUFFIX,gfx.ms,CroLAX - DOMAIN-SUFFIX,ggpht.com,CroLAX - DOMAIN-SUFFIX,ghostnoteapp.com,CroLAX - DOMAIN-SUFFIX,git.io,CroLAX - DOMAIN-KEYWORD,github,CroLAX - DOMAIN-SUFFIX,globalsign.com,CroLAX - DOMAIN-SUFFIX,gmodules.com,CroLAX - DOMAIN-SUFFIX,godaddy.com,CroLAX - DOMAIN-SUFFIX,golang.org,CroLAX - DOMAIN-SUFFIX,gongm.in,CroLAX - DOMAIN-SUFFIX,goo.gl,CroLAX - DOMAIN-SUFFIX,goodreaders.com,CroLAX - DOMAIN-SUFFIX,goodreads.com,CroLAX - DOMAIN-SUFFIX,gravatar.com,CroLAX - DOMAIN-SUFFIX,gstatic.com,CroLAX - DOMAIN-SUFFIX,gvt0.com,CroLAX - DOMAIN-SUFFIX,hockeyapp.net,CroLAX - DOMAIN-SUFFIX,hotmail.com,CroLAX - DOMAIN-SUFFIX,icons8.com,CroLAX - DOMAIN-SUFFIX,ift.tt,CroLAX - DOMAIN-SUFFIX,ifttt.com,CroLAX - DOMAIN-SUFFIX,iherb.com,CroLAX - DOMAIN-SUFFIX,imageshack.us,CroLAX - DOMAIN-SUFFIX,img.ly,CroLAX - DOMAIN-SUFFIX,imgur.com,CroLAX - DOMAIN-SUFFIX,imore.com,CroLAX - DOMAIN-SUFFIX,instapaper.com,CroLAX - DOMAIN-SUFFIX,ipn.li,CroLAX - DOMAIN-SUFFIX,is.gd,CroLAX - DOMAIN-SUFFIX,issuu.com,CroLAX - DOMAIN-SUFFIX,itgonglun.com,CroLAX - DOMAIN-SUFFIX,itun.es,CroLAX - DOMAIN-SUFFIX,ixquick.com,CroLAX - DOMAIN-SUFFIX,j.mp,CroLAX - DOMAIN-SUFFIX,js.revsci.net,CroLAX - DOMAIN-SUFFIX,jshint.com,CroLAX - DOMAIN-SUFFIX,jtvnw.net,CroLAX - DOMAIN-SUFFIX,justgetflux.com,CroLAX - DOMAIN-SUFFIX,kat.cr,CroLAX - DOMAIN-SUFFIX,klip.me,CroLAX - DOMAIN-SUFFIX,libsyn.com,CroLAX - DOMAIN-SUFFIX,linode.com,CroLAX - DOMAIN-SUFFIX,lithium.com,CroLAX - DOMAIN-SUFFIX,littlehj.com,CroLAX - DOMAIN-SUFFIX,live.com,CroLAX - DOMAIN-SUFFIX,live.net,CroLAX - DOMAIN-SUFFIX,livefilestore.com,CroLAX - DOMAIN-SUFFIX,llnwd.net,CroLAX - DOMAIN-SUFFIX,macid.co,CroLAX - DOMAIN-SUFFIX,macromedia.com,CroLAX - DOMAIN-SUFFIX,macrumors.com,CroLAX - DOMAIN-SUFFIX,mashable.com,CroLAX - DOMAIN-SUFFIX,mathjax.org,CroLAX - DOMAIN-SUFFIX,medium.com,CroLAX - DOMAIN-SUFFIX,mega.co.nz,CroLAX - DOMAIN-SUFFIX,mega.nz,CroLAX - DOMAIN-SUFFIX,megaupload.com,CroLAX - DOMAIN-SUFFIX,microsofttranslator.com,CroLAX - DOMAIN-SUFFIX,mindnode.com,CroLAX - DOMAIN-SUFFIX,mobile01.com,CroLAX - DOMAIN-SUFFIX,modmyi.com,CroLAX - DOMAIN-SUFFIX,msedge.net,CroLAX - DOMAIN-SUFFIX,myfontastic.com,CroLAX - DOMAIN-SUFFIX,name.com,CroLAX - DOMAIN-SUFFIX,nextmedia.com,CroLAX - DOMAIN-SUFFIX,nsstatic.net,CroLAX - DOMAIN-SUFFIX,nssurge.com,CroLAX - DOMAIN-SUFFIX,nyt.com,CroLAX - DOMAIN-SUFFIX,nytimes.com,CroLAX - DOMAIN-SUFFIX,omnigroup.com,CroLAX - DOMAIN-SUFFIX,onedrive.com,CroLAX - DOMAIN-SUFFIX,onenote.com,CroLAX - DOMAIN-SUFFIX,ooyala.com,CroLAX - DOMAIN-SUFFIX,openvpn.net,CroLAX - DOMAIN-SUFFIX,openwrt.org,CroLAX - DOMAIN-SUFFIX,orkut.com,CroLAX - DOMAIN-SUFFIX,osxdaily.com,CroLAX - DOMAIN-SUFFIX,outlook.com,CroLAX - DOMAIN-SUFFIX,ow.ly,CroLAX - DOMAIN-SUFFIX,paddleapi.com,CroLAX - DOMAIN-SUFFIX,parallels.com,CroLAX - DOMAIN-SUFFIX,parse.com,CroLAX - DOMAIN-SUFFIX,pdfexpert.com,CroLAX - DOMAIN-SUFFIX,periscope.tv,CroLAX - DOMAIN-SUFFIX,pinboard.in,CroLAX - DOMAIN-SUFFIX,pinterest.com,CroLAX - DOMAIN-SUFFIX,pixelmator.com,CroLAX - DOMAIN-SUFFIX,pixiv.net,CroLAX - DOMAIN-SUFFIX,playpcesor.com,CroLAX - DOMAIN-SUFFIX,playstation.com,CroLAX - DOMAIN-SUFFIX,playstation.com.hk,CroLAX - DOMAIN-SUFFIX,playstation.net,CroLAX - DOMAIN-SUFFIX,playstationnetwork.com,CroLAX - DOMAIN-SUFFIX,pushwoosh.com,CroLAX - DOMAIN-SUFFIX,rime.im,CroLAX - DOMAIN-SUFFIX,servebom.com,CroLAX - DOMAIN-SUFFIX,sfx.ms,CroLAX - DOMAIN-SUFFIX,shadowsocks.org,CroLAX - DOMAIN-SUFFIX,sharethis.com,CroLAX - DOMAIN-SUFFIX,shazam.com,CroLAX - DOMAIN-SUFFIX,skype.com,CroLAX - DOMAIN-SUFFIX,smartdnsProxy.com,CroLAX - DOMAIN-SUFFIX,smartmailcloud.com,CroLAX - DOMAIN-SUFFIX,sndcdn.com,CroLAX - DOMAIN-SUFFIX,sony.com,CroLAX - DOMAIN-SUFFIX,soundcloud.com,CroLAX - DOMAIN-SUFFIX,sourceforge.net,CroLAX - DOMAIN-SUFFIX,spotify.com,CroLAX - DOMAIN-SUFFIX,squarespace.com,CroLAX - DOMAIN-SUFFIX,sstatic.net,CroLAX - DOMAIN-SUFFIX,st.luluku.pw,CroLAX - DOMAIN-SUFFIX,stackoverflow.com,CroLAX - DOMAIN-SUFFIX,startpage.com,CroLAX - DOMAIN-SUFFIX,staticflickr.com,CroLAX - DOMAIN-SUFFIX,steamcommunity.com,CroLAX - DOMAIN-SUFFIX,symauth.com,CroLAX - DOMAIN-SUFFIX,symcb.com,CroLAX - DOMAIN-SUFFIX,symcd.com,CroLAX - DOMAIN-SUFFIX,tapbots.com,CroLAX - DOMAIN-SUFFIX,tapbots.net,CroLAX - DOMAIN-SUFFIX,tdesktop.com,CroLAX - DOMAIN-SUFFIX,techcrunch.com,CroLAX - DOMAIN-SUFFIX,techsmith.com,CroLAX - DOMAIN-SUFFIX,thepiratebay.org,CroLAX - DOMAIN-SUFFIX,theverge.com,CroLAX - DOMAIN-SUFFIX,time.com,CroLAX - DOMAIN-SUFFIX,timeinc.net,CroLAX - DOMAIN-SUFFIX,tiny.cc,CroLAX - DOMAIN-SUFFIX,tinypic.com,CroLAX - DOMAIN-SUFFIX,tmblr.co,CroLAX - DOMAIN-SUFFIX,todoist.com,CroLAX - DOMAIN-SUFFIX,trello.com,CroLAX - DOMAIN-SUFFIX,trustasiassl.com,CroLAX - DOMAIN-SUFFIX,tumblr.co,CroLAX - DOMAIN-SUFFIX,tumblr.com,CroLAX - DOMAIN-SUFFIX,tweetdeck.com,CroLAX - DOMAIN-SUFFIX,tweetmarker.net,CroLAX - DOMAIN-SUFFIX,twitch.tv,CroLAX - DOMAIN-SUFFIX,txmblr.com,CroLAX - DOMAIN-SUFFIX,typekit.net,CroLAX - DOMAIN-SUFFIX,ubertags.com,CroLAX - DOMAIN-SUFFIX,ublock.org,CroLAX - DOMAIN-SUFFIX,ubnt.com,CroLAX - DOMAIN-SUFFIX,ulyssesapp.com,CroLAX - DOMAIN-SUFFIX,urchin.com,CroLAX - DOMAIN-SUFFIX,usertrust.com,CroLAX - DOMAIN-SUFFIX,v.gd,CroLAX - DOMAIN-SUFFIX,vimeo.com,CroLAX - DOMAIN-SUFFIX,vimeocdn.com,CroLAX - DOMAIN-SUFFIX,vine.co,CroLAX - DOMAIN-SUFFIX,vivaldi.com,CroLAX - DOMAIN-SUFFIX,vox-cdn.com,CroLAX - DOMAIN-SUFFIX,vsco.co,CroLAX - DOMAIN-SUFFIX,vultr.com,CroLAX - DOMAIN-SUFFIX,w.org,CroLAX - DOMAIN-SUFFIX,w3schools.com,CroLAX - DOMAIN-SUFFIX,webtype.com,CroLAX - DOMAIN-SUFFIX,wikiwand.com,CroLAX - DOMAIN-SUFFIX,wikileaks.org,CroLAX - DOMAIN-SUFFIX,wikimedia.org,CroLAX - DOMAIN-SUFFIX,wikipedia.com,CroLAX - DOMAIN-SUFFIX,wikipedia.org,CroLAX - DOMAIN-SUFFIX,windows.com,CroLAX - DOMAIN-SUFFIX,windows.net,CroLAX - DOMAIN-SUFFIX,wire.com,CroLAX - DOMAIN-SUFFIX,wordpress.com,CroLAX - DOMAIN-SUFFIX,workflowy.com,CroLAX - DOMAIN-SUFFIX,wp.com,CroLAX - DOMAIN-SUFFIX,wsj.com,CroLAX - DOMAIN-SUFFIX,wsj.net,CroLAX - DOMAIN-SUFFIX,xda-developers.com,CroLAX - DOMAIN-SUFFIX,xeeno.com,CroLAX - DOMAIN-SUFFIX,xiti.com,CroLAX - DOMAIN-SUFFIX,yahoo.com,CroLAX - DOMAIN-SUFFIX,yimg.com,CroLAX - DOMAIN-SUFFIX,ying.com,CroLAX - DOMAIN-SUFFIX,yoyo.org,CroLAX - DOMAIN-SUFFIX,ytimg.com,CroLAX - DOMAIN-SUFFIX,telegram.me,CroLAX - IP-CIDR,91.108.4.0/22,CroLAX - IP-CIDR,91.108.8.0/22,CroLAX - IP-CIDR,91.108.56.0/22,CroLAX - IP-CIDR,109.239.140.0/24,CroLAX - IP-CIDR,149.154.160.0/20,CroLAX - IP-CIDR,127.0.0.0/8,DIRECT - IP-CIDR,172.16.0.0/12,DIRECT - IP-CIDR,192.168.0.0/16,DIRECT - IP-CIDR,10.0.0.0/8,DIRECT - IP-CIDR,17.0.0.0/8,DIRECT - IP-CIDR,100.64.0.0/10,DIRECT - GEOIP,CN,DIRECT - MATCH,,CroLAX 主要关注注释代码部分，更加详细的ClashX配置说明请参加 此文。 windows端 windows端使用v2rayN软件，安装后点击服务器 -&gt; 添加[VMess]服务器, 具体配置如下： 配置 BBR 加速TCP BBR 是谷歌在 2016 年 9 月开源的一个优化 TCP 拥塞的算法，并且 Linux 内核从 4.9 版本开始集成该算法，据多方网友反馈，网速甚至可以提升好几个数量级， 一般新版的Linux操作系统以及自带了BBR，不需要手动安装，如果是老系统，可以执行下面命令： 12345678# 下载脚本wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh# 添加可执行权限chmod +x bbr.sh# 运行bbr脚本./bbr.sh 12345wget --no-check-certificate https://raw.githubusercontent.com/cx9208/Linux-NetSpeed/master/tcp.shchmod +x tcp.sh./tcp.sh 我这边系统以及自带，运行bbr脚本后提示已经安装了，结果如下： 可以验证一下是否成功安装最新内核并开启 TCP BBR，输入以下命令： 123456789uname -r # &gt;&gt; 4.18.0-147.8.1.el8_1.x86_64sysctl net.ipv4.tcp_available_congestion_control # &gt;&gt; net.ipv4.tcp_available_congestion_control = reno cubic bbrsysctl net.ipv4.tcp_congestion_control # &gt;&gt; net.ipv4.tcp_congestion_control = bbrsysctl net.core.default_qdisc # &gt;&gt; net.core.default_qdisc = fqlsmod | grep bbr # &gt;&gt; tcp_bbr 20480 9 返回值有 tcp_bbr 模块即说明bbr已启动。 Trojan安装教程Trojan是一个近两年兴起的网络工具，项目官网（https://github.com/trojan-gfw）。与强调加密和混淆的SS/SSR等工具不同，trojan将通信流量伪装成互联网上最常见的https流量，从而有效防止流量被检测和干扰。 使用Trojan需要一个指向服务器IP的域名以及域名证书。 使用Let’s Encrypt获取免费证书 开发端口 certbot 默认使用http方式对域名所有权进行验证，该操作需要绑定vps的80端口。需要开发防火墙端口 12firewall-cmd --zone=public --add-port=80/tcp --permanentfirewall-cmd --zone=public --add-port=443/tcp --permanent 如果80端口已被占用，请先停止占用的进程，例如停止Nginx： 1killall nginx 安装certbot 1yum install -y python3 &amp;&amp; pip3 install certbot 查看certbot使用方法： 1certbot --help 为指定域名生成证书： 1certbot certonly --standalone -d 域名1 -d 域名2 查看域名证书的路径和国旗时间 1certbot certificates 安装trojan服务端1sudo bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/trojan-gfw/trojan-quickstart/master/trojan-quickstart.sh)&quot; 该命令会下载最新版的trojan并安装。安装完毕后，trojan配置文件路径是 /usr/local/etc/trojan/config.json，其初始内容为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&#123; &quot;run_type&quot;: &quot;server&quot;, &quot;local_addr&quot;: &quot;0.0.0.0&quot;, &quot;local_port&quot;: 443, &quot;remote_addr&quot;: &quot;127.0.0.1&quot;, &quot;remote_port&quot;: 80, &quot;password&quot;: [ &quot;password1&quot;, &quot;password2&quot; ], &quot;log_level&quot;: 1, &quot;ssl&quot;: &#123; &quot;cert&quot;: &quot;/path/to/certificate.crt&quot;, &quot;key&quot;: &quot;/path/to/private.key&quot;, &quot;key_password&quot;: &quot;&quot;, &quot;cipher&quot;: &quot;ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384&quot;, &quot;cipher_tls13&quot;: &quot;TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384&quot;, &quot;prefer_server_cipher&quot;: true, &quot;alpn&quot;: [ &quot;http/1.1&quot; ], &quot;reuse_session&quot;: true, &quot;session_ticket&quot;: false, &quot;session_timeout&quot;: 600, &quot;plain_http_response&quot;: &quot;&quot;, &quot;curves&quot;: &quot;&quot;, &quot;dhparam&quot;: &quot;&quot; &#125;, &quot;tcp&quot;: &#123; &quot;prefer_ipv4&quot;: false, &quot;no_delay&quot;: true, &quot;keep_alive&quot;: true, &quot;reuse_port&quot;: false, &quot;fast_open&quot;: false, &quot;fast_open_qlen&quot;: 20 &#125;, &quot;mysql&quot;: &#123; &quot;enabled&quot;: false, &quot;server_addr&quot;: &quot;127.0.0.1&quot;, &quot;server_port&quot;: 3306, &quot;database&quot;: &quot;trojan&quot;, &quot;username&quot;: &quot;trojan&quot;, &quot;password&quot;: &quot;&quot; &#125;&#125; local_port：监听的端口，默认是443，除非端口被墙，不建议改成其他端口； remote_addr和remote_port：非trojan协议时，将请求转发处理的地址和端口。可以是任意有效的ip/域名和端口号，默认是本机和80端口； password：密码。需要几个密码就填几行，最后一行结尾不能有逗号； cert和key：域名的证书和密钥，Let’s Encrypt申请的证书可用 certbot certificates 查看证书路径； key_password：默认没有密码（如果证书文件有密码就要填上）； alpn：建议填两行：http/1.1和h2，保持默认也没有问题。 根据自己的情况修改配置，保存，然后设置开机启动： 1systemctl enable trojan 启动Trojan： 1systemctl start trojan 检查是否运行： 1ss -lp | grep trojan 证书自动更新Let’s Encrypt证书的有效期是三个月，超过期限则需要续签。证书续期可以手动完成，例如： 123systemctl stop trojancertbot renewsystemctl restart trojan 也可以配置crontab任务自动续签，在/etc/crontab文件末添加一行： 10 0 1 */2 0 root systemctl stop trojan; /usr/local/bin/certbot renew; systemctl restart trojan Trojan客户端以Mac端使用ClashX客户端为例，配置如下： 123456789101112Proxy: - name: trojan_NJ5 type: trojan server: nj5.kobingo.xyz port: 443 password: OF54OAJN3WZ66882 # udp: true # sni: example.com # aka server name alpn: - h2 - http/1.1 # skip-cert-verify: true 参考文章 Trojan官网 trojan教程 https://github.com/hijkpw/scripts trojan一键脚本 Namesilo购买域名详细教程","categories":[{"name":"others","slug":"others","permalink":"https://kobingogo.github.io/categories/others/"}],"tags":[{"name":"梯子","slug":"梯子","permalink":"https://kobingogo.github.io/tags/%E6%A2%AF%E5%AD%90/"}]},{"title":"打造赏心悦目的Mac终端","slug":"others-zsh","date":"2020-06-10T11:36:19.000Z","updated":"2022-02-18T02:31:03.811Z","comments":true,"path":"others-zsh/","link":"","permalink":"https://kobingogo.github.io/others-zsh/","excerpt":"本文主要讲解如何基于iTerm2 + Oh My Zsh 打造赏心悦目的Mac终端，以及如何配置终端代理等。","text":"本文主要讲解如何基于iTerm2 + Oh My Zsh 打造赏心悦目的Mac终端，以及如何配置终端代理等。 下载iTerm2可以直接去官网下载：https://www.iterm2.com/ 安装完成后，在/bin目录下会多出一个zsh的文件。 Mac系统自带很多Shell，可以通过命令查看： 1cat /etc/shells 结果如下： 由于Mac默认使用dash作为终端，所以首先修改为默认使用zsh： 1chsh -s /bin/zsh 这就是iTerm2初始的样子，下面我们来美化它，让它变得好用又好看！ 安装Oh my zshoh-my-zsh开源地址：https://github.com/robbyrussell/oh-my-zsh 主要有curl和wget两种安装方式，可任选一种进行安装： 12# curl 安装方式sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 12# wget 安装方式sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot; 安装命令和安装完成后的截图： 安装PowerLinePowerline是agnoster主题的依赖。具体可以在repo里查询到：https://github.com/agnoster/agnoster-zsh-theme 安装powerline的方式依然简单，也只需要一条命令： 1pip install powerline-status --user 没有安装pip的同学可能会碰到zsh: command not found: pip。 使用命令安装pip即可： 1sudo easy_install pip 安装后再次执行安装powerline的命令即可。 安装PowerFonts安装字体库需要首先将项目git clone至本地，然后执行源码中的install.sh。 在你习惯的位置新建一个文件夹，如：~/Desktop/OpenSource/ 在此文件夹下执行git clone命令： 123456# git clonegit clone https://github.com/powerline/fonts.git --depth=1# cd to foldercd fonts# run install shell./install.sh 执行结果如下： 安装好字体库之后，我们来设置iTerm2的字体，具体的操作是iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Text，在Font区域选中Change Font，然后找到Meslo LG字体。有L、M、S可选，看个人喜好： 安装配色方案配色方案在使用VIM或Colorful Log时会变得非常有用，同时界面也不会一片黑绿一样死板。 同样使用git clone的方式下载源码进行安装： 1234cd ~/Desktop/OpenSourcegit clone https://github.com/altercation/solarizedcd solarized/iterm2-colors-solarized/open . 在打开的finder窗口中，双击Solarized Dark.itermcolors和Solarized Light.itermcolors即可安装明暗两种配色： 再次进入iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Colors -&gt; Color Presets中根据个人喜好选择这两种配色中的一种即可： 安装主题下载agnoster主题，执行脚本安装： 1234cd ~/Desktop/OpenSourcegit clone https://github.com/fcamblor/oh-my-zsh-agnoster-fcamblor.gitcd oh-my-zsh-agnoster-fcamblor/./install 执行上面的命令会将主题拷贝到oh my zsh的themes中： 拷贝完成后，执行命令打开zshrc配置文件，将ZSH_THEME后面的字段改为agnoster。 1vi ~/.zshrc 修改完成后按一下esc调出vi命令，输入:wq保存并退出vi模式。 此时command+Q或source配置文件后，iTerm2变了模样： 安装高亮插件这是oh my zsh的一个插件，安装方式与theme大同小异： 123cd ~/.oh-my-zsh/custom/plugins/git clone https://github.com/zsh-users/zsh-syntax-highlighting.gitvi ~/.zshrc 这时我们再次打开zshrc文件进行编辑。找到plugins，此时plugins中应该已经有了git，我们需要把高亮插件也加上： 请务必保证插件顺序，zsh-syntax-highlighting必须在最后一个。 然后在文件的最后一行添加：source ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh 按一下esc调出vi命令，输入:wq保存并退出vi模式。 执行命令使刚才的修改生效： 1source ~/.zshrc 至此大功告成，请看最终效果图： 背景图片取自微软Surface Studio的4K壁纸(将近12MB大小)，非常漂亮，需要的可以自取： https://pan.baidu.com/s/1LKd4ghGyyNI6UwHhOHvfaA提取码: snrd 更换背景图片方式：iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Window -&gt; BackGround Image勾选图片即可。 可选择、命令补全跟代码高亮的安装方式一样，这也是一个zsh的插件，叫做zsh-autosuggestion，用于命令建议和补全。 123cd ~/.oh-my-zsh/custom/plugins/git clone https://github.com/zsh-users/zsh-autosuggestionsvi ~/.zshrc 找到plugins，加上这个插件即可： 插件效果： 有同学说补全命令的字体不太清晰，与背景颜色太过相近，其实可以自己调整一下字体颜色。 Preferences -&gt; Profiles -&gt; Colors 中有Foreground是标准字体颜色，ANSI Colors中Bright的第一个是补全的字体颜色。 VScode显示异常问题在经过上面配置后，发现VScode上的终端显示异常，主要原因是前面配置的agnoster主题需要PowerFonts字体的支持。 所以需要在VScode里设置字体（比如：Meslo LG L for Powerline）： 完成后，显示正常： 使用代理由于GFW的存在，平时用终端安装npm包，或者clone GitHub上的仓库等操作时，经常速度是可怜的10K/s甚至不到的速度，即便开了 SS / V2Ray 等代理服务，貌似在终端上没什么卵用😭（其实主要原因是这些代理服务走的是会话层，而item的命令走在网络层，层级更低，所以流量无法用过代理转发）。 如果你用的是VPN方式代理，那么估计你没有这个烦恼 原因是主流的VPN协议（包括PPTP / L2TP / OPENVPN / SSTP）跑在第二层（数据链路层）和第三层（网络层），基本可以说是全流量代理。 那有没有什么方法可以让iterm上的流量能走代理从而提高下载速度呢？ 答案是有的！ 下面的操作的前提是你自己有有可用的代理服务 编辑~/.zshrc: 1vim ~/.zshrc 在配置的最下面添加如下代码： 1234567891011121314151617function useProxy() &#123; export https_proxy=http://127.0.0.1:7890; export http_proxy=http://127.0.0.1:7890; export all_proxy=socks5://127.0.0.1:7891; echo &#x27;open proxy successful&#x27;;&#125;function closeProxy() &#123; unset https_proxy; unset http_proxy; unset all_proxy; echo &#x27;close proxy successful&#x27;;&#125;alias openP=&#x27;useProxy&#x27;alias closeP=&#x27;closeProxy&#x27; 保存更改，执行： 1source ~/.zshrc 接着只要在终端执行openP就能打开终端代理，执行closeP就能关闭终端代理 ZSH常用技能 自动补全 ZSH的补全功能非常贴心，按TAB可以补全命令、路径还有参数。 杀进程 Bash杀进程需要先用ps aux | grep xxx查找进程的PID，然后才能用kill PID。ZSH可以直接就kill xxx后按TAB会显示对应的PID，非常方便。 历史记录 ZSH的history可以跨session，可以共享，这样就一进行历史记录的受限查询。比如，输入git，再按向上箭头，会搜索前面所有的git命令。 通配符搜索 l *.png查找当前目录下所有png文件，l **/*.png递归查找。","categories":[{"name":"others","slug":"others","permalink":"https://kobingogo.github.io/categories/others/"}],"tags":[{"name":"Mac终端","slug":"mac终端","permalink":"https://kobingogo.github.io/tags/mac%E7%BB%88%E7%AB%AF/"}]},{"title":"常用软件大全","slug":"others-常用软件推荐","date":"2020-05-27T22:51:15.000Z","updated":"2022-02-18T02:31:03.811Z","comments":true,"path":"others-常用软件推荐/","link":"","permalink":"https://kobingogo.github.io/others-%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/","excerpt":"在此记录一些堪称神器的软件","text":"windows篇1. Listary它不仅可以在本地非常快速的搜索，还可以打开网站、在搜索引擎中搜索、随时随地打开快捷菜单、文件快速定位、快速打开cmd窗口等等优秀的功能； 比如输入 cmd打开cmd窗口，输入 cmda使用管理员权限打开cmd窗口，输入 wyyyy打开网易云音乐，找到某个文件的时候 Enter直接打开， Ctrl+Enter 是打开文件所在文件夹； 值得一提的是搜索关键词功能，让我们可以非常便捷的打开相应网站或在对应网站搜索，比如输入 gg我的存款呢？就可以直接使用默认浏览器在谷歌搜索中搜索了，我们还可以自定义输入其他关键字，只需把搜索链接中的关键字换成 {query} ~ 2. uTools可以作为程序启动器外，uTools最大的特点就是拥有强大的插件系统，每个插件都有简洁美观、易于操作的界面，输入plugins进入插件管理，你就可以根据自己的需求挑选安装，组合成自己最趁手的工具合集，为各种日常操作提供便利。不断产生的新插件，也将为你带来无限可能。 个人常用图床、剪切板、todo、各种技术文档等 3. DittoDitto 是一款免费开源的windows剪切板管理工具，作为 CtrlC V工程师，复制粘贴少不了，更厉害的是，可以用它来批量的复制， Ctrl+C一堆别人的代码，一次性全粘上，岂不美哉； 使用快捷键打开剪切板历史，然后 Ctrl/Shift来选择你希望粘贴的内容， Enter即可选择性的粘贴多行内容；另外剪切板历史还可以搜索，快速找到复制内容； 只需设置寥寥几个快捷键，就可以很方便的操作剪切板，带来极大幸福~ 4. Winsnap看到上面的截图没，旁边都有很骚包的阴影，怎么做到的？不需要各种高大上的图片处理软件，只需 Winsnap ，它可以在截图的时候自动帮你加上背景阴影，然后帮你自动复制到剪切板； 它可以使用全屏、应用程序、窗口、对象等捕捉模式，更牛的是它还可以在截图的时候同时选择和捕捉多个对象，按住 Ctrl或 Shift选择多个窗口或对象...这个就比较厉害了，不信你试试？ 5. CmderCmder 是一个美观又实用的命令行工具，它支持大部分Linux命令，支持ssh连Linux，还可以在它的窗口中新建cmd和powershell，更多玩法等你来战~ 比较方便的是在安装目录下 \\config\\user-aliases.cmd设置 alias 别名，比如参见的 Git 操作： 12345678910111213ga=git add $*gb=git branch $*gc=git commit $*gch=git checkout $*gd=git diff $*gl=git log $*gs=git status $* 还可以将cmder配置到右键菜单，快捷在当前目录打开cmder，方法是先把这个地址加到系统的path环境变量里面，比如我的是 D:cmder，然后右键 Cmder.exe属性-兼容性-以管理员身份运行此程序，再重新打开 Cmder.exe输入 Cmder.exe/REGISTER ALL就行了~ 记得安装完在配置 Setting-Startup-Environment里面加上 setLANG=zh_CN.UTF8，否则输出的一些中文会乱码； 6. Typora使用过很多 Markdown 编辑器，最后选择了 Typora，与主流编辑器一边编辑一边预览的形式，Typora 是将编辑和预览合并到一起，简洁大方，目光也不需要在复杂的编辑区和预览区中来回切换了，只有当焦点移入的时候才显示 Markdown 语法； 另外 Typora 还支持 Latex、 [TOC]动态目录、拖拽图片自动生成本地预览链接、自定义主题等方便的功能； 7. Quick LookQuickLook 是在 Microsoft Store 里面下载的一个速览工具，有时候打开一个PDF、TXT、图片之类的需要等关联程序启动半天，有了它之后只要选中目标文件，按空格，就可以快速预览了，速度非常快，支持图片、视频、音频、压缩包、PDF、文本文件、Markdown、HTML等格式； 用它来看一些代码什么的，甚至不需要 Sublime\\VSCode 启动就可以直接看了，如果只是速览一下的话是非常适合的了。 8. Myper SplashMyper Splash 也是可以在 Microsoft Store 里面下载的一款高质量壁纸库，所有壁纸来源 Unsplash 网站，均无版权可以免费使用，再加上简洁美观的UI/UX设计，让你体验一见钟情的感觉。 另外 MyperSplash 可以设置自动每天自动更换壁纸或锁屏，每天早晨来到办公室点亮屏幕就可以看到 Awesome 的锁屏或壁纸，让你带着好心情开启一天的工作。 9. GifCam / ScreenToGif相信大家都有过需要截一个 Gif 的时候，这里有两个免费 Gif 屏幕录制工具都很不错，小而美的 GifCam 和开源强大的 ScreenToGif ； 10. Free Download ManageFree Download Manage (FDM) 是一款免费的下载工具，如果你已经受够了国内一些软件的广告和限速，那么 FDM 是一个不错的选择，另外多线程、断点续传、计划任务等功能让 FDM 值得推介。 11. SourcetreeSourcetree 是跨平台免费的 Git 客户端管理工具，如果受够了手打各种 Git 操作命令，那么 Sourcetree 是一个不错的选择； Sourcetree 可以大大简化你的代码操作，特别是对于一些不甚熟悉 Git 命令的人来说灰常实用；一些对 Git 操作比较熟练的用户也可以用它来提升效率，减少出错。","categories":[{"name":"others","slug":"others","permalink":"https://kobingogo.github.io/categories/others/"}],"tags":[{"name":"software","slug":"software","permalink":"https://kobingogo.github.io/tags/software/"},{"name":"软件","slug":"软件","permalink":"https://kobingogo.github.io/tags/%E8%BD%AF%E4%BB%B6/"}]},{"title":"centOS7安装Java环境","slug":"others-centOS7安装Java环境","date":"2020-05-22T16:28:42.000Z","updated":"2022-02-18T02:31:03.811Z","comments":true,"path":"others-centOS7安装Java环境/","link":"","permalink":"https://kobingogo.github.io/others-centOS7%E5%AE%89%E8%A3%85Java%E7%8E%AF%E5%A2%83/","excerpt":"记录一次在阿里云（系统CentOS 7.4 64位）安装配置Java环境的过程","text":"记录一次在阿里云（系统CentOS 7.4 64位）安装配置Java环境的过程 1. 选择合适的jdk版本 jdk下载地址 选择一下版本获取下载链接 2. 下载1wget https://download.oracle.com/otn/java/jdk/8u251-b08/3d5a2bb8f8d4428bbe94aed7ec7ae784/jdk-8u251-linux-x64.tar.gz?AuthParam=1590135363_2f6dbe12605da3b1164a50e7c1a8db7b 此链接地址可能失效，请自行在步骤1中获取最新下载链接 下载后检查安装包大小是否符合预期（判断安装包是否损坏） 1ls -lht 3. 安装3.1. 创建安装目录： 1mkdir /usr/local/java/ 3.2 解压到安装目录： 1tar -zxvf jdk-8u251-linux-x64.tar.gz?AuthParam=1590135363_2f6dbe12605da3b1164a50e7c1a8db7b -C /usr/local/java 4. 配置环境变量打开profile文件 1vim /etc/profile 在末尾添加一下代码： 1234export JAVA_HOME=/usr/local/java/jdk1.8.0_251export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 使环境变量生效 1source /etc/profile 添加软链接 1ln -s /usr/local/java/jdk1.8.0_251/bin/java /usr/bin/java 验证是否安装成功 1java -version","categories":[{"name":"others","slug":"others","permalink":"https://kobingogo.github.io/categories/others/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://kobingogo.github.io/tags/linux/"},{"name":"centOS","slug":"centos","permalink":"https://kobingogo.github.io/tags/centos/"},{"name":"java","slug":"java","permalink":"https://kobingogo.github.io/tags/java/"}]},{"title":"ECMAScript新特性","slug":"javascript-ECMAScript特性分析","date":"2020-05-22T14:59:54.000Z","updated":"2022-02-18T02:31:03.811Z","comments":true,"path":"javascript-ECMAScript特性分析/","link":"","permalink":"https://kobingogo.github.io/javascript-ECMAScript%E7%89%B9%E6%80%A7%E5%88%86%E6%9E%90/","excerpt":"2015年6月发布了ES 6，也就是我们今天广泛使用的版本。这之后每年6月发布一个极小更新的ES版本，比如2016年6月发布的 ES 2016 叫做ES 7，而这个版本只增加了两个新特性。截止目前，ES 11的提案已经定稿了。","text":"2015年6月发布了ES 6，也就是我们今天广泛使用的版本。这之后每年6月发布一个极小更新的ES版本，比如2016年6月发布的 ES 2016 叫做ES 7，而这个版本只增加了两个新特性。截止目前，ES 11的提案已经定稿了。 ES 7 新特性 功能点 说明 Array.prototype.includes 查找数组 Exponentiation operator 指数函数的中缀表示法 Array.prototype.includesincludes是一个Array上很有用的方法，用于快速查找数组中是否包含某个元素，包括NaN（和indexOf不一样的点)。 1234567891011121314let arr = [1, 2, 3, NaN];if (arr.includes(2)) &#123; //查找2是否存在于arr数组中 console.log(&quot;找到了!&quot;); //&gt;&gt; 找到了！&#125;if (!arr.includes(2, 3)) &#123; //第二个参数3表示数组下标为3的项，也即第4项开始查找 console.warn(&quot;不存在!&quot;); //&gt;&gt; 不存在！&#125;//下面两句说明incluedes和indexOf的区别console.log(arr.includes(NaN)); //trueconsole.log(arr.indexOf(NaN) != -1); //false 指数函数用法JavaScript采用两个星符号**来表示Math.pow，相对于Math.pow的好处： 中缀表示法比函数表示法更简洁，这使它更可取。 方便数学、物理、机器人学等领域的计算。 12345678910//用法一：x ** ylet squared = 2 ** 2;//等同于: 2 * 2let cubed = 2 ** 3;//等同于: 2 * 2 * 2//用法二：x **= ylet a = 2;a **= 2;//等同于: a = a * a;let b = 3;b **= 3;//等同于: b = b * b * b; ES 8 新特性 功能点 说明 Object.values / Object.entries String padding 字符串追加 Object.getOwnPropertyDescriptors 返回指定对象自己所有的属性内容 Async functions 异步函数 Shared memory and atomics 共享内存和 Atomics 对象 Object.values() / Object.entries Object.values(obj)，obj 参数是对目标对象的操作，它可以是一个对象或者数组 12345678910const obj = &#123; x: &#x27;xxx&#x27;, y: 1 &#125;;Object.values(obj); // [&#x27;xxx&#x27;, 1]const obj = [&#x27;e&#x27;, &#x27;s&#x27;, &#x27;8&#x27;]; // 等同于 &#123; 0: &#x27;e&#x27;, 1: &#x27;s&#x27;, 2: &#x27;8&#x27; &#125;;Object.values(obj); // [&#x27;e&#x27;, &#x27;s&#x27;, &#x27;8&#x27;]//当把数字对象的当键的时候，返回的数组以键的值升序排序const obj = &#123; 10: &#x27;xxx&#x27;, 1: &#x27;yyy&#x27;, 3: &#x27;zzz&#x27; &#125;;Object.values(obj); // [&#x27;yyy&#x27;, &#x27;zzz&#x27;, &#x27;xxx&#x27;]Object.values(&#x27;es8&#x27;); // [&#x27;e&#x27;, &#x27;s&#x27;, &#x27;8&#x27;] Object.entries方法返回一个给定对象可枚举属性值的数组[key, value]，与Object.values类似 123456789const obj = &#123; x: &#x27;xxx&#x27;, y: 1 &#125;;Object.entries(obj); // [[&#x27;x&#x27;, &#x27;xxx&#x27;], [&#x27;y&#x27;, 1]]const obj = [&#x27;e&#x27;, &#x27;s&#x27;, &#x27;8&#x27;];Object.entries(obj); // [[&#x27;0&#x27;, &#x27;e&#x27;], [&#x27;1&#x27;, &#x27;s&#x27;], [&#x27;2&#x27;, &#x27;8&#x27;]]const obj = &#123; 10: &#x27;xxx&#x27;, 1: &#x27;yyy&#x27;, 3: &#x27;zzz&#x27; &#125;;Object.entries(obj); // [[&#x27;1&#x27;, &#x27;yyy&#x27;], [&#x27;3&#x27;, &#x27;zzz&#x27;], [&#x27;10&#x27;, &#x27;xxx&#x27;]]Object.entries(&#x27;es8&#x27;); // [[&#x27;0&#x27;, &#x27;e&#x27;], [&#x27;1&#x27;, &#x27;s&#x27;], [&#x27;2&#x27;, &#x27;8&#x27;]] 字符串追加在 ES 8 中String新增了两个实例函数String.prototype.padStart和String.prototype.padEnd，允许将空字符串或其他字符串添加到原始字符串的开头或结尾。String.padStart(targetLength,[padString])targetLength：当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。padString：(可选)填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断，此参数的缺省值为空格。String.padEnd(targetLength,padString]) 参数释义同上。 1234567891011&#x27;es8&#x27;.padStart(2); // &#x27;es8&#x27;&#x27;es8&#x27;.padStart(5); // &#x27; es8&#x27;&#x27;es8&#x27;.padStart(6, &#x27;1891&#x27;); // &#x27;189es8&#x27;&#x27;es8&#x27;.padStart(14, &#x27;coffe&#x27;); // &#x27;coffecoffecoffes8&#x27;&#x27;es8&#x27;.padStart(7, &#x27;0&#x27;); // &#x27;0000es8&#x27;&#x27;es8&#x27;.padEnd(2); // &#x27;es8&#x27;&#x27;es8&#x27;.padEnd(5); // &#x27;es8 &#x27;&#x27;es8&#x27;.padEnd(6, &#x27;1891&#x27;); // &#x27;es81891&#x27;&#x27;es8&#x27;.padEnd(14, &#x27;coffe&#x27;); // &#x27;es8coffecoffecoff&#x27;&#x27;es8&#x27;.padEnd(7, &#x27;9&#x27;); // &#x27;es89999&#x27; Object.getOwnPropertyDescriptorsgetOwnPropertyDescriptors方法返回指定对象自己所有的属性内容，并且属性内容只是自身直接定义的，而不是从object的原型继承而来的。定义是：Object.getOwnPropertyDescriptors(obj)，obj 是指目标对象，这个方法返回的值可能是 configurable、enumerable、writable、get、set 和 value。 12345678910111213141516171819const obj = &#123; get es7() &#123; return 7; &#125;, get es8() &#123; return 8; &#125;&#125;;Object.getOwnPropertyDescriptors(obj);// &#123;// es7: &#123;// configurable: true,// enumerable: true,// get: function es7()&#123;&#125;, //the getter function// set: undefined// &#125;,// es8: &#123;// configurable: true,// enumerable: true,// get: function es8()&#123;&#125;, //the getter function// set: undefined// &#125;// &#125; getOwnPropertyDescriptors可以用来创建子类： 12345678function superclass() &#123;&#125;superclass.prototype = &#123; // 在这里定义方法和属性&#125;;function subclass() &#123;&#125;subclass.prototype = Object.create(superclass.prototype, Object.getOwnPropertyDescriptors(&#123; // 在这里定义方法和属性&#125;)); 异步函数Async Functions也就是我们常说的Async/Await,已经用的很频繁了，在此不再赘述。 SharedArrayBuffer &amp; AtomicsSharedArrayBuffer 对象用来表示一个通用的，固定长度的原始二进制数据缓冲区，类似于 ArrayBuffer 对象，它们都可以用来在共享内存（shared memory）上创建视图。与 ArrayBuffer 不同的是，SharedArrayBuffer 不能被分离。 请注意，作为对Spectre的响应，所有主流浏览器均默认于2018年1月5日禁用SharedArrayBuffer。 Chrome在启用了网站隔离功能的平台上的v67中重新启用了该功能，以防止出现Spectre风格的漏洞。 语法： 123456/** * * @param &#123;*&#125; length 所创建的数组缓冲区的大小，以字节(byte)为单位。 * @returns &#123;SharedArrayBuffer&#125; 一个大小指定的新 SharedArrayBuffer 对象。其内容被初始化为 0。 */new SharedArrayBuffer(length) 共享内存能被同时创建和更新于工作者线程或主线程。依赖于系统（CPU，操作系统，浏览器），变化传递给所有上下文环境需要一段时间。需要通过 atomic 操作来进行同步。 Atomics 对象提供了一组静态方法用来对 SharedArrayBuffer 对象进行原子操作。这些原子操作属于 Atomics 模块。与一般的全局对象不同，Atomics 不是构造函数，因此不能使用 new 操作符调用，也不能将其当作函数直接调用。Atomics 的所有属性和方法都是静态的（与 Math 对象一样）。 多个共享内存的线程能够同时读写同一位置上的数据。原子操作会确保正在读或写的数据的值是符合预期的，即下一个原子操作一定会在上一个原子操作结束后才会开始，其操作过程不会中断。 方法名 说明 Atomics.add() 将指定位置上的数组元素与给定的值相加，并返回相加前该元素的值 Atomics.and() 将指定位置上的数组元素与给定的值相与，并返回与操作前该元素的值。 Atomics.compareExchange() 如果数组中指定的元素与给定的值相等，则将其更新为新的值，并返回该元素原先的值。 Atomics.exchange() 将数组中指定的元素更新为给定的值，并返回该元素更新前的值。 Atomics.load() 返回数组中指定元素的值。 Atomics.or() 将指定位置上的数组元素与给定的值相或，并返回或操作前该元素的值。 Atomics.store() 将数组中指定的元素设置为给定的值，并返回该值。 Atomics.sub() 将指定位置上的数组元素与给定的值相减，并返回相减前该元素的值。 Atomics.xor() 将指定位置上的数组元素与给定的值相异或，并返回异或操作前该元素的值。 Atomics.wait() 检测数组中某个指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒或超时。返回值为 &quot;ok&quot;、&quot;not-equal&quot; 或 &quot;time-out&quot;。调用时，如果当前线程不允许阻塞，则会抛出异常（大多数浏览器都不允许在主线程中调用 wait()）。 Atomics.wake() 唤醒等待队列中正在数组指定位置的元素上等待的线程。返回值为成功唤醒的线程数量。 Atomics.isLockFree(size) 可以用来检测当前系统是否支持硬件级的原子操作。对于指定大小的数组，如果当前系统支持硬件级的原子操作，则返回 true；否则就意味着对于该数组，Atomics 对象中的各原子操作都只能用锁来实现。此函数面向的是技术专家。 ES 9 新特性 新特性 中文说明 Asynchronous Iteration 异步迭代器 Promise.prototype.finally Lifting template literal restriction 重新修订了字面量的转义 Rest/Spread Properties Rest/Spread 属性 s (dotAll) flag for regular expressions 正则表达式dotAll模式 RegExp named capture groups 正则表达式命名捕获组 RegExp Lookbehind Assertions 正则表达式反向断言 RegExp Unicode Property Escapes 正则表达式 Unicode 转义 异步迭代器在async/await的某些时刻，你可能尝试在同步循环中调用异步函数。例如： 12345async function func(array) &#123; for (let i of array) &#123; await someFunc(i); &#125;&#125; 这段代码不会达到预期目的，下面这段同样也不会： 12345async function func(array) &#123; array.forEach(async i =&gt; &#123; await someFunc(i); &#125;);&#125; 上面这段代码中，循环本身依旧保持同步，并在内部异步函数之前全部调用完成。 引入异步迭代器后，就像常规迭代器，除了next()方法返回一个Promise。因此await可以和for...of循环一起使用，以串行的方式运行异步操作。 12345async function func(array) &#123; for await (let i of array) &#123;//异步迭代 someFunc(i); &#125;&#125; 更多详细论述见“壹.2.12”。 Promise.prototype.finally一个Promise调用链要么成功到达最后一个.then()，要么失败触发.catch()。在某些情况下，你想要在无论Promise运行成功还是失败，运行相同的代码，例如清除数组、删除对话、关闭数据库连接等，.finally()允许实现这样的目的。 1234567891011function func() &#123; promiseFunc() //返回一个Promise对象 .then(() =&gt; &#123;&#125;) .then(() =&gt; &#123;&#125;) .catch(err =&gt; &#123; console.log(err); &#125;) .finally(() =&gt; &#123; //无论promiseFunc()运行成功还是失败，这里的代码会被调用到 &#125;);&#125; 更多详细论述见“壹.2.12”。 重新修订了字面量的转义ES9 之前，\\u表示 unicode 转义，\\x表示十六进制转义，\\后跟一个数字表示八进制转义，这使得创建特定的字符串变得不可能，例如Windows文件路径C:\\uuu\\xxx\\111。 要取消转义序列的语法限制，可在模板字符串之前使用标记函数String.raw。 12345let s = `\\u&#123;54&#125;` //会转义成unicode &quot;T&quot;console.log(s);//&gt;&gt; Tlet str = String.raw`\\u&#123;54&#125;`; //不会被转义console.log(str);//&gt;&gt; \\u&#123;54&#125; Rest / Spread 属性这个就是我们通常所说的三个点...，在=左边的是rest参数，放在=右边或者作为参数的是扩展运算符，这项特性在ES6中已经引入，但是ES6中的作用对象仅限于数组。在ES9中，为对象提供了像数组一样的rest参数和扩展运算符： 12345678910111213const obj = &#123; a: 1, b: 2, c: 3&#125;;const &#123; a, ...param &#125; = obj; //这里...是rest参数console.log(a); //&gt;&gt; 1console.log(param); //&gt;&gt; &#123;b: 2, c: 3&#125;function foo(&#123; a, ...param &#125;) &#123;//这里...是扩展运算符 console.log(a); //&gt;&gt; 1 console.log(param); //&gt;&gt; &#123;b: 2, c: 3&#125;&#125; 正则表达式dotAll模式正则表达式中点.匹配除回车外的任何单字符，标记s改变这种行为，允许匹配回车换行。 1234/hello.world/.test(&#x27;hello\\nworld&#x27;); // false/hello.world/s.test(&#x27;hello\\nworld&#x27;); // trueconsole.log(/hello.world/s.test(`helloworld`)) //&gt;&gt; true 正则表达式命名捕获组Javascript正则表达式中使用exec()匹配后，能够返回一个包含匹配字符串的类数组对象。 12345678const reDate = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/, match = reDate.exec(&quot;2018-08-06&quot;);console.log(match);//&gt;&gt; [2018-08-06, 2018, 08, 06]//这样就可以直接用索引来获取年月日：let year = match[1]; //&gt;&gt; 2018let month = match[2]; //&gt;&gt; 08let day = match[3]; //&gt;&gt; 06 返回数组的第0项为与正则表达式相匹配的文本，第 1 项是与 reDate 的第 1 个分组\\d&#123;4&#125;相匹配的文本（如果有的话），第 2 项是与 reDate 的第 2 个分组\\d&#123;2&#125;相匹配的文本（如果有的话），以此类推。正则表达式的组以()包起来。 上面的案例，若是日期格式变成月日年，那么改变正则表达式的结构后，还有可能会改变变量的赋值部分的代码。如下示例： 12345678const reDate = /(\\d&#123;2&#125;)-(\\d&#123;2&#125;)-(\\d&#123;4&#125;)/,//表达式结构变化了 match = reDate.exec(&quot;08-06-2018&quot;);console.log(match);//&gt;&gt; [08-06-2018, 08, 06, 2018]//此时年月日的赋值代码也要改了,改的地方真多啊！怎么办？let year = match[3]; //&gt;&gt; 2018let month = match[1]; //&gt;&gt; 08let day = match[2]; //&gt;&gt; 06 可以发现上面的写法改的地方太多了，有没有办法少改点代码省省事呢？有！ ES9 允许使用符号?&lt;name&gt;来命名捕获组（也即“匹配到的组”），示例如下： 123456789const reDate = /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/, match = reDate.exec(&quot;2018-08-06&quot;);console.log(match);//&gt;&gt; [2018-08-06, 08, 06, 2018, groups: &#123;day: 06, month: 08, year: 2018&#125;]//此时用groups对象来获取年月日，无论正则表达式怎么变换，这下面三行不用改了，省事！let year = match.groups.year; //&gt;&gt; 2018let month = match.groups.month; //&gt;&gt; 08let day = match.groups.day; //&gt;&gt; 06 命名捕获组的写法相当于是把每个捕获组都定义了一个名字，然后存储到返回值的groups属性中。 正则表达式后行断言先看看正则表达式先行断言示例： 123456const re1 = /\\D(\\d+)/, re2 = /\\D(?=\\d+)/,//&quot;?=&quot;是正向先行断言 match1 = re1.exec(&quot;$123.45&quot;), match2 = re2.exec(&quot;$123.45&quot;);console.log(match1[0]); //&gt;&gt; $123console.log(match2[0]); //&gt;&gt; $ (?=pattern) 零宽正向先行断言(zero-width positive lookahead assertion)代表字符串中的一个位置，紧接该位置之后的字符序列能够匹配pattern； (?!pattern) 零宽负向先行断言(zero-width negative lookahead assertion)代表字符串中的一个位置，紧接该位置之后的字符序列不能匹配pattern； (?&lt;=pattern) 零宽正向后行断言(zero-width positive lookbehind assertion)代表字符串中的一个位置，紧接该位置之前的字符序列能够匹配pattern； (?&lt;!pattern) 零宽负向后行断言(zero-width negative lookbehind assertion)代表字符串中的一个位置，紧接该位置之前的字符序列不能匹配pattern。 在ES9中，可以允许使用?&lt;=进行正向后行断言，可以获取货币的价格而忽略货币符号。 123const re= /(?&lt;=\\D)[\\d\\.]+/, match = re.exec(&quot;$123.45&quot;);console.log(match[0]); //&gt;&gt; 123.45 上面的正向后行断言，也就是说\\D这个条件必须满足，但\\D匹配的字符不会作为结果输出（因为先行/后行断言其实只是匹配了一个位置）。如果是下面这样： 12345const re= /(?&lt;=\\D)[\\d\\.]+/, match1 = re.exec(&quot;123.45&quot;), match2 = re.exec(&quot;12345&quot;);console.log(match1 &amp;&amp; match1[0]); //&gt;&gt; 45console.log(match2 &amp;&amp; match1[0]); //&gt;&gt; null 可以看到match1匹配到的是45,这是由于在.前面没有任何符合\\D的匹配内容，它会一直找到符合\\D的内容，也就是.然后返回后面的内容。而match2若是没有满足前面肯定反向断言的条件的话，则结果返回null。 正则表达式 Unicode 转义ES9 之前，在正则表达式中本地访问 Unicode 字符属性是不被允许的。ES9 添加了 Unicode 属性转义，形式为\\p&#123;...&#125;和\\P&#123;...&#125;，在正则表达式中使用标记 u (unicode) 设置，在\\p的&#123;...&#125;内，可用键值对的方式设置需要匹配的属性而非具体内容。 123const regex = /\\p&#123;Script=Greek&#125;/u;//Greek为希腊语的意思console.log(regex.test(&#x27;a&#x27;)); //&gt;&gt; flaseconsole.log(regex.test(&#x27;Σ&#x27;)); //&gt;&gt; true ES 10 新特性 新特性 中文说明 Optional catch binding 可选的 catch 变量绑定 JSON superset JSON超集 Symbol.prototype.description Symbol 对象的 description 属性 Function.prototype.toString revision 修订Function.prototype.toString Object.fromEntries Well-formed JSON.stringify 更加友好的JSON.stringify String.prototype.&#123;trimStart,trimEnd&#125; Array.prototype.&#123;flat,flatMap&#125; 可选的 catch 变量绑定在 ES10 之前，我们必须通过语法为 catch 子句绑定异常变量，无论是否有必要。很多时候 catch 块是多余的，而 ES10 使我们能够简单的把变量省略掉。 12345//之前是try &#123;&#125; catch(e) &#123;&#125;//ES10之后可以写成，try &#123;&#125; catch &#123;&#125;//省掉了变量e JSON超集什么是 JSON 超集？简单来说就是 JSON 是 ECMAScript 的子集，也就是说让 ECMAScript 兼容 JSON 的内容所支持的全部文本。 ECMAScript 在标准 JSON.parse 部分阐明了 JSON 确为其一个子集，但由于 JSON 的内容可以正常包含 U+2028 行分隔符与 U+2029 段落分隔符，而 ECMAScript 却不行，所以，该草案旨在解决这一问题。在这之前，如果你使用 JSON.parse() 执行带如上特殊字符的字符串时，只会收到 SyntaxError 的错误提示。该草案同样是向后兼容的，其对用户唯一的影响是保持原样，即在暂不支持特殊字符解析的运行环境中保持报错 SyntaxError 。 Symbol 对象的 description 属性ES10 中为 Symbol 对象添加了只读属性 description ，该对象返回包含 Symbol 描述的字符串。在创建Symbol时向其添加description (描述)，能够直接访问description ，对调试是很有用的。 123456789101112let sym = Symbol(&#x27;foo&#x27;);//添加的描述内容为“foo”console.log(sym.description);//&gt;&gt; foosym = Symbol();console.log(sym.description);//&gt;&gt; undefined//和 Symbol() 不同的是，用 Symbol.for() 方法创建的的 symbol 会被放入一个全局//symbol 注册表中。Symbol.for() 并不是每次都会创建一个新的 symbol，它会首先检//查给定的 key 是否已经在注册表中了。假如是，则会直接返回上次存储的那个。否则，它//会再新建一个。sym = Symbol.for(&#x27;bar&#x27;);console.log(sym.description);//&gt;&gt; bar 修订Function.prototype.toString函数原型上的方法toString()现在返回精确字符，包括空格和注释。 123456789101112function /* comment */ foo /* another comment */() &#123;&#125;//ES10之前不会打印注释部分console.log(foo.toString()); //&gt;&gt; function foo()&#123;&#125;//ES10里，会把注释一同打印console.log(foo.toString()); //&gt;&gt; function /* comment */ foo /* another comment */ ()&#123;&#125;//注意：//箭头函数是个例外const bar /* comment */ = /* another comment */ () =&gt; &#123;&#125;;console.log(bar.toString()); //&gt;&gt; () =&gt; &#123;&#125; Object.fromEntries在 JavaScript 操作中，数据在各种数据结构之间的转换都是很容易的，比如 Map 到数组、Map 到 Set、对象到 Map 等等。 12345678let map = new Map().set(&#x27;foo&#x27;, true).set(&#x27;bar&#x27;, false);let arr = Array.from(map);let set = new Set(map.values());let obj = &#123; foo: true, bar: false &#125;;//下一句 Object.entries() 方法返回给定对象 obj 自身可枚举属性的键值对数组,//形如：[[&quot;foo&quot;,true],[&quot;bar&quot;,false]]let newMap = new Map(Object.entries(obj)); 但是如果我们需要将一个键值对列表转换为对象，就要写点费劲的代码了。 123456let map = new Map().set(&quot;foo&quot;, true).set(&quot;bar&quot;, false);let obj = Array.from(map).reduce((acc, [key, val]) =&gt; &#123; return Object.assign(acc, &#123; [key]: val &#125;);&#125;, &#123;&#125;); 该特性的目的在于为对象添加一个新的静态方法 Object.fromEntries，用于将符合键值对的列表（例如 Map、数组等）转换为一个对象。上一块的代码中的转换逻辑，现在我们只需要一行代码即可搞定。 12const map = new Map().set(&quot;foo&quot;, true).set(&quot;bar&quot;, false);let obj = Object.fromEntries(map); 更加友好的 JSON.stringifyES10 之前，当你使用 JSON.stringify() 处理无法用 UTF-8 编码表示的字符时（U+D800 至 U+DFFF），返回的结果会是一个乱码 Unicode 字符“�”。该特性提出用JSON.stringify()来安全的表示这些不正常的UTF-8字符。 123456789101112let r;r = JSON.stringify(&quot;❤&quot;); //正常的UTF-8字符原样输出console.log(r); //&gt;&gt; &quot;❤&quot;r = JSON.stringify(&#x27;\\u2764&#x27;); //正常的UTF-8字符编码，输出解码之后的模样console.log(r); //&gt;&gt; &quot;❤&quot;r = JSON.stringify(&quot;\\uDF06\\uD834&quot;); //不正常的UTF-8字符编码，则以unicode形式输出console.log(r); //&gt;&gt; &quot;\\udf06\\ud834&quot;r = JSON.stringify(&quot;\\uDEAD&quot;); //不正常的UTF-8字符编码，则以unicode形式输出console.log(r); //&gt;&gt; &quot;\\udead&quot; String.prototype.{trimStart,trimEnd}新增了String的trimStart()方法和trimEnd()方法，这两个方法很好理解，分别去除字符串首、尾的空白字符，就不举例占篇幅了。 Array.prototype.{flat,flatMap}这个特性新创造了两个方法，其中： Array.prototype.flat 数组的所有项会以指定的维度降维（扁平化），然后组成新数组返回； Array.prototype.flatMap 首先会执行一次map()方法，然后再通过类似flat()方法扁平化数组。它等同于执行完 map() 后再执行一次 flat() 方法，所以当你执行 map() 返回的结果如果是个数组，然后又要将其扁平化时，这个方法会显得方便。 来看几个例子解释一下，首先 flat() 方法支持多维数组的扁平化，其中Infinity可以将多维数组压扁成一维数组。 123456789let r;r = [&quot;1&quot;, [&quot;8&quot;, [&quot;9&quot;, [&quot;1&quot;]]]].flat();//4维数组，默认降维1，变成3维数组console.log(r); //&gt;&gt; [ &#x27;1&#x27;, &#x27;8&#x27;, [ &#x27;9&#x27;, [&#x27;1&#x27;] ] ]r = [&quot;1&quot;, [&quot;8&quot;, [&quot;9&quot;, [&quot;1&quot;]]]].flat(2); //4维数组，降维2，变成2维数组console.log(r); //&gt;&gt; [ &#x27;1&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, [&#x27;1&#x27;] ]r = [&quot;1&quot;, [&quot;8&quot;, [&quot;9&quot;, [&quot;1&quot;]]]].flat(Infinity);//4维数组，最多变成1维数组console.log(r); //&gt;&gt; [ &#x27;1&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;1&#x27; ] 接着来看看flatMap() 123456let r;r = [&quot;I love&quot;, &quot;coffe 1891&quot;].map(item =&gt; item.split(&quot; &quot;));console.log(r); //&gt;&gt; [ [ &#x27;I&#x27;, &#x27;love&#x27; ], [ &#x27;coffe&#x27;, &#x27;1891&#x27; ] ]r = [&quot;I love&quot;, &quot;coffe 1891&quot;].flatMap(item =&gt; item.split(&quot; &quot;));console.log(r); //&gt;&gt;[ &#x27;I&#x27;, &#x27;love&#x27;, &#x27;coffe&#x27;, &#x27;1891&#x27; ] ES 11 新特性一览 新特性 中文说明 String.prototype.matchAll import() import()函数 Promise.allSettled String.prototype.matchAllmatchAll() 方法返回一个包含所有匹配正则表达式及分组捕获结果的迭代器（iterator）。 在 matchAll 出现之前，通过在循环中调用Regexp.exec来获取所有匹配项信息（Regexp需使用/g标志）： 12345678const regexp = RegExp(&#x27;foo*&#x27;,&#x27;g&#x27;);const str = &#x27;coffe football, foosball&#x27;;while ((matches = regexp.exec(str)) !== null) &#123; console.log(`找到 $&#123;matches[0]&#125;，下一轮循环从位置 $&#123;regexp.lastIndex&#125; 开始`); //&gt;&gt; 找到 foo，下一轮循环从位置 9 开始 //&gt;&gt; 找到 foo，下一轮循环从位置 19 开始&#125; 如果使用matchAll ，就可以不必使用while循环加exec方式（且正则表达式需使用/g标志）。使用matchAll 会得到一个迭代器的返回值，配合 for...of，array spread，Array.from() 可以更方便实现功能。 123456789101112131415161718const regexp = RegExp(&#x27;foo*&#x27;,&#x27;g&#x27;);const str = &#x27;coffe football, foosball&#x27;;let matches = str.matchAll(regexp);for (const match of matches) &#123; console.log(match);&#125;//&gt;&gt; [ &quot;foo&quot; ]//&gt;&gt; [ &quot;foo&quot; ]//注意：//matches的迭代器在for..of之后已经被消耗掉了，//需要再次调用matchAll创建一个新的迭代器matches = str.matchAll(regexp);let arr = Array.from(matches, m =&gt; m[0]);console.log(arr);//&gt;&gt; [ &quot;foo&quot;, &quot;foo&quot; ] import()函数这个特性为JavaScript添加了一个类函数（function-like）的import()功能，以便可以像函数传参那样传入参数实现动态（没错，import是静态引用的）引用模块（module）。下面有个单页应用简单示例，演示了用import()开启懒加载。 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;nav&gt; &lt;a href=&quot;books.html&quot; data-entry-module=&quot;books&quot;&gt;书籍&lt;/a&gt; &lt;a href=&quot;movies.html&quot; data-entry-module=&quot;movies&quot;&gt;电影&lt;/a&gt; &lt;a href=&quot;video-games.html&quot; data-entry-module=&quot;video-games&quot;&gt;电视游戏&lt;/a&gt;&lt;/nav&gt;&lt;main&gt;内容将会加载到这里！&lt;/main&gt;&lt;script&gt; const main = document.querySelector(&quot;main&quot;); for (const link of document.querySelectorAll(&quot;nav &gt; a&quot;)) &#123; link.addEventListener(&quot;click&quot;, e =&gt; &#123; e.preventDefault(); import(`./section-modules/$&#123;link.dataset.entryModule&#125;.js`)//动态引用 .then(module =&gt; &#123;//加载模块成功以后，该模块会当作then方法的参数 module.loadPageInto(main); &#125;) .catch(err =&gt; &#123;//捕捉异常 main.textContent = err.message; &#125;); &#125;); &#125;&lt;/script&gt; 请注意import()和import的区别： import() 可以用在script脚本区，不止是模块内； 如果在模块内使用import()，它可以在任何地方任何级别执行，而不是被提升到顶级（优先执行）； import() 是运行时执行，也即什么时候运行到这句，就会加载参数指定的模块；参数也可以是动态可变的，不止是静态参数； import() 不建立可静态分析的依赖关系（静态分析的情况下可以做很多优化），但是，在一些比较简单的情况下，比如import（“/foo.js”）中，实现仍然可以执行静态分析优化。 如果模块采用default的形式对外暴露接口，则可用default属性直接获得。 1234import(&#x27;./module.js&#x27;).then(module =&gt; &#123; console.log(module.default);//直接通过default属性获得模块暴露的接口&#125;); Promise.allSettled为什么要有Promise.allSettled()？ 举例说明，比如各位用户在页面上面同时填了3个独立的表单，这三个表单分三个接口提交到后端，三个接口独立，没有顺序依赖，这个时候我们需要等到请求全部完成后给与用户提示表单提交的情况。 在多个promise同时进行时咱们很快会想到使用Promise.all来进行包装，但是由于Promise.all的一票否决的特性，三个提交中若前面任意一个提交失败，则后面的表单也不会进行提交了，这就与咱们需求不符合。 Promise.allSettled跟Promise.all类似，其参数接受一个Promise的数组，返回一个新的Promise，唯一的不同在于，其没有一票否决的特性，也就是说当Promise全部处理完成后我们可以拿到每个Promise的状态，而不管其是否处理成功。 123456Promise.allSettled([Promise.resolve(&quot;coffe&quot;), Promise.reject(&quot;1891&quot;)]).then( arr =&gt; &#123; console.log(arr); //&gt;&gt; [ &#123; status: &quot;fulfilled&quot;, value: &quot;coffe&quot;&#125;, //&gt;&gt; &#123; status: &quot;rejected&quot;, reason: &quot;1891&quot; &#125; ] &#125;); 本篇结语很显然ECMAScript接下来会持续不断地更新，按TC39的计划是每年都会发一个新版本。虽然节奏很快，但是我们完全没必要担心跟不上节奏。除了ES6这个史无前例的版本带来了超大量的新特性外，之后每年发的版本都仅仅带有少量的增量更新，你只需要花45分钟就能搞明白这一年更新的特性。保持一颗好奇的心，你会不断进步，变得更强！","categories":[{"name":"JavaScript","slug":"javascript","permalink":"https://kobingogo.github.io/categories/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://kobingogo.github.io/tags/javascript/"}]},{"title":"post","slug":"framework-virtual-dom","date":"2020-05-13T17:28:22.000Z","updated":"2022-02-18T02:31:03.811Z","comments":true,"path":"framework-virtual-dom/","link":"","permalink":"https://kobingogo.github.io/framework-virtual-dom/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"typeof 实现原理","slug":"javascript-typeof","date":"2020-05-06T23:11:22.000Z","updated":"2022-02-18T02:31:03.811Z","comments":true,"path":"javascript-typeof/","link":"","permalink":"https://kobingogo.github.io/javascript-typeof/","excerpt":"typeof 一般被用于判断一个变量的类型，我们可以利用 typeof 来判断 number, string, object, boolean, function, undefined,symbol 这七种类型，这种判断能帮助我们搞定一些问题，比如在判断不是 object 类型的数据的时候，typeof 能比较清楚的告诉我们具体是哪一类的类型。但是，很遗憾的一点是，typeof在判断一个 object 的数据的时候只能告诉我们这个数据是 object, 而不能细致的具体到是哪一种 object, 比如","text":"typeof 一般被用于判断一个变量的类型，我们可以利用 typeof 来判断 number, string, object, boolean, function, undefined,symbol 这七种类型，这种判断能帮助我们搞定一些问题，比如在判断不是 object 类型的数据的时候，typeof 能比较清楚的告诉我们具体是哪一类的类型。但是，很遗憾的一点是，typeof在判断一个 object 的数据的时候只能告诉我们这个数据是 object, 而不能细致的具体到是哪一种 object, 比如 123let s = new String(&quot;abc&quot;);typeof s === &quot;object&quot;; // trues instanceof String; // true 要想判断一个数据具体是哪一种 object 的时候，我们需要利用 instanceof 这个操作符来判断，这个我们后面会说到。 来谈谈关于 typeof 的原理吧，我们可以先想一个很有意思的问题，js 在底层是怎么存储数据的类型信息呢？或者说，一个 js 的变量，在它的底层实现中，它的类型信息是怎么实现的呢？ 其实，js 在底层存储变量的时候，会在变量的机器码的低位 1-3 位存储其类型信息 000：对象 010：浮点数 100：字符串 110：布尔 1：整数 but, 对于 undefined 和 null 来说，这两个值的信息存储是有点特殊的。 `null`：所有机器码均为0 `undefined`：用 −2^30 整数来表示 所以，typeof 在判断 null 的时候就出现问题了，由于 null 的所有机器码均为 0，因此直接被当做了对象来看待。 然而用 instanceof 来判断的话 1null instanceof null; // TypeError: Right-hand side of &#x27;instanceof&#x27; is not an object null 直接被判断为不是 object，这也是 JavaScript 的历史遗留 bug，可以参考 typeof. 因此在用 typeof 来判断变量类型的时候，我们需要注意，最好是用 typeof 来判断基本数据类型（包括 symbol），避免对 null 的判断。 还有一个不错的判断类型的方法，就是 Object.prototype.toString，我们可以利用这个方法来对一个变量的类型来进行比较准确的判断 123456789Object.prototype.toString.call(1); // &quot;[object Number]&quot;Object.prototype.toString.call(&quot;hi&quot;); // &quot;[object String]&quot;Object.prototype.toString.call(&#123; a: &quot;hi&quot; &#125;); // &quot;[object Object]&quot;Object.prototype.toString.call([1, &quot;a&quot;]); // &quot;[object Array]&quot;Object.prototype.toString.call(true); // &quot;[object Boolean]&quot;Object.prototype.toString.call(() =&gt; &#123;&#125;); // &quot;[object Function]&quot;Object.prototype.toString.call(null); // &quot;[object Null]&quot;Object.prototype.toString.call(undefined); // &quot;[object Undefined]&quot;Object.prototype.toString.call(Symbol(1)); // &quot;[object Symbol]&quot; instanceof 操作符的实现原理之前我们提到了 instanceof 来判断对象的具体类型，其实 instanceof 主要的作用就是判断一个实例是否属于某种类型 123let person = function () &#123;&#125;;let nicole = new person();nicole instanceof person; // true 当然，instanceof 也可以判断一个实例是否是其父类型或者祖先类型的实例。 123456let person = function () &#123;&#125;;let programmer = function () &#123;&#125;;programmer.prototype = new person();let nicole = new programmer();nicole instanceof person; // truenicole instanceof programmer; // true instanceof 实现原理： 12345678910111213function new_instance_of(leftVaule, rightVaule) &#123; let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值 leftVaule = leftVaule.__proto__; // 取左表达式的__proto__值 while (true) &#123; if (leftVaule === null) &#123; return false; &#125; if (leftVaule === rightProto) &#123; return true; &#125; leftVaule = leftVaule.__proto__; &#125;&#125; 总结简单来说，我们使用 typeof 来判断基本数据类型是 ok 的，不过需要注意当用 typeof 来判断 null 类型时的问题，如果想要判断一个对象的具体类型可以考虑用 instanceof，但是 instanceof 也可能判断不准确，比如一个数组，他可以被 instanceof 判断为 Object。所以我们要想比较准确的判断对象实例的类型时，可以采取 Object.prototype.toString.call 方法。","categories":[{"name":"JavaScript","slug":"javascript","permalink":"https://kobingogo.github.io/categories/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://kobingogo.github.io/tags/javascript/"}]},{"title":"一些 JS 关键技术的底层实现汇总","slug":"javascript-js-basic-implementation","date":"2020-05-06T22:40:35.000Z","updated":"2022-02-18T02:31:03.811Z","comments":true,"path":"javascript-js-basic-implementation/","link":"","permalink":"https://kobingogo.github.io/javascript-js-basic-implementation/","excerpt":"在这里汇总一些 JS 常用技术的源码实现，通过源码了解其内部原理，可以加深对其的理解。","text":"在这里汇总一些 JS 常用技术的源码实现，通过源码了解其内部原理，可以加深对其的理解。 Function.prototype.call() Function.prototype.apply() Function.prototype.bind() new 的原理 reduce 实现原理 双向绑定 继承 Object.create instanceof 实现 Array.isArray 实现 getOwnPropertyNames 实现 Promise 实现 防抖/节流 函数柯里化实现 实现简单深拷贝 Function.prototype.call()call() 方法调用一个函数, 其具有一个指定的 this 值和分别地提供的参数。 语法：fun.call(thisArg, arg1, arg2, ...) 123456789101112131415161718192021222324252627282930313233/** * call的实现原理 */const getGlobal = function () &#123; if (typeof self !== &quot;undefined&quot;) return self; if (typeof window !== &quot;undefined&quot;) return window; if (typeof global !== &quot;undefined&quot;) return global;&#125;;Function.prototype.mcall = function (context) &#123; context = context ? Object(context) : getGlobal(); const fn = Symbol(&quot;anything&quot;); //创建一个不重复的常量 context[fn] = this; let args = [...arguments].slice(1); let r = context[fn](...args); delete context[fn]; return r;&#125;;/** * 一个用call实现继承的例子 * @param &#123;*&#125; name * @param &#123;*&#125; price */function Product(name, price) &#123; this.name = name; this.price = price;&#125;function Fruit(name, price) &#123; Product.mcall(this, name, price); this.category = &quot;fruit&quot;;&#125;var apple = new Fruit(&quot;apple&quot;, 5);console.log(apple); Function.prototype.apply()apply()调用一个指定 this 值的函数, 接收作为一个数组或者类数组对象提供的参数. 语法： func.apply(thisArg, [argsArray]) 1234567891011121314151617181920212223242526272829303132333435const getGlobal = function () &#123; if (typeof self !== &quot;undefined&quot;) return self; if (typeof window !== &quot;undefined&quot;) return window; if (typeof global !== &quot;undefined&quot;) return global;&#125;;/** * apply原理 */Function.prototype.apply = function (context, arr) &#123; context = context ? Object(context) : getGlobal(); console.log(&quot;context&quot;, context); const fn = Symbol(&quot;anything&quot;); //创建一个不重复的常量 context[fn] = this; // let args = [...arguments][1]; if (!arr) &#123; let r = context[fn](); delete context[fn]; return r; &#125; let r = context[fn](...arr); delete context[fn]; return r;&#125;;//使用例子var array = [&quot;a&quot;, &quot;b&quot;];var elements = [0, 1, 2];array.push.apply(array, elements);console.log(&quot;array&quot;, array); // [&quot;a&quot;, &quot;b&quot;, 0, 1, 2]function A(x, y) &#123; console.log(this.b + &quot; &quot; + x + &quot; &quot; + y);&#125;var B = &#123; b: 1 &#125;;A.apply(B, [2, 3]); Function.prototype.bind()bind()方法创建一个新函数, 在调用时设置 this 关键字为提供的值。 语法：fun.bind(thisArg, arg1, arg2, ...) 12345678910111213141516171819202122const getGlobal = function () &#123; if (typeof self !== &quot;undefined&quot;) return self; if (typeof window !== &quot;undefined&quot;) return window; if (typeof global !== &quot;undefined&quot;) return global;&#125;;/** * bind实现原理 */Function.prototype.bind = function (context) &#123; context = context ? Object(context) : getGlobal(); const me = this; const args = [...arguments].slice(1); return function () &#123; me.apply(context, [...args, ...arguments]); &#125;;&#125;;function A(x, y) &#123; console.log(this.b + &quot;, &quot; + x + &quot;, &quot; + y);&#125;var B = &#123; b: 1 &#125;;let fnc = A.bind(B, 2); //1 2 3fnc(3); new 的原理在了解 new 原理之前先看看 js 的内部机制图 我们需要知道当 new 的时候做了什么事情 创建一个新对象； 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象） 执行构造函数中的代码（为这个新对象添加属性） 返回新对象。 new 没法重写，这里是有 mockNew 函数来模拟 1234567891011121314151617181920212223242526272829303132/** * new实现原理 */function mockNew() &#123; //创建一个实例 const obj = &#123;&#125;; //获得构造器 const constructor = [].shift.call(arguments); //实现继承，实例可以访问构造器熟悉 obj.__proto__ = constructor.prototype; //调用构造器，改变this指向为实例 const res = constructor.apply(obj, arguments); //如果构造器函数返回值为对象，则返回这个对象，否则返回新的实例对象 return res instanceof Object ? res : obj;&#125;/** * 使用例子 * @param &#123;*&#125; color * @param &#123;*&#125; name */function Car(color, name) &#123; this.color = color; return &#123; name: name, &#125;;&#125;let car = mockNew(Car, &quot;black&quot;, &quot;BMW&quot;);console.log(car.color);// undefinedconsole.log(car.name);// &quot;BMW&quot; reduce 实现原理12345678910111213141516171819202122232425262728293031323334/** * 实现原理 */Array.prototype.mockReduce = function (callback) &#123; const length = this.length; let reducer = undefined, //累加器，最终返回这个值 k = 0, //数组下标 initVal = [...arguments].length &gt; 1 ? [...arguments][1] : undefined; //传入reduce的初始值 if (typeof callback !== &quot;function&quot;) &#123; throw new TypeError(callback + &quot; is not a function&quot;); &#125; if (length === 0 &amp;&amp; !initVal) &#123; throw new TypeError(&quot;Reduce of empty array with no initial value&quot;); &#125; if (initVal) &#123; reducer = initVal; &#125; else &#123; reducer = this[0]; k++; &#125; while (k &lt; length) &#123; if (this.hasOwnProperty(k)) &#123; const kValue = this[k]; reducer = callback(reducer, kValue); &#125; k++; &#125; return reducer;&#125;;const rReduce = [].reduce((a, b) =&gt; a + b, 3);const mReduce = [].mockReduce((a, b) =&gt; a + b);console.log(rReduce, mReduce); 双向绑定defineProperty实现 123456789101112131415161718// 数据const data = &#123; text: &quot;hello&quot;,&#125;;const input = document.getElementById(&quot;input&quot;);const p = document.getElementById(&quot;p&quot;);// 数据劫持Object.defineProperty(data, &quot;text&quot;, &#123; // 数据变化 --&gt; 修改视图 set(newVal) &#123; input.value = newVal; p.innerHTML = newVal; &#125;,&#125;);// 视图更改 --&gt; 数据变化input.addEventListener(&quot;keyup&quot;, function (e) &#123; data.text = e.target.value;&#125;); proxy实现 12345678910111213141516171819202122// 数据const data = &#123; text: &quot;default&quot;,&#125;;const input = document.getElementById(&quot;input&quot;);const p = document.getElementById(&quot;p&quot;);// 数据劫持const handler = &#123; set(target, key, value) &#123; target[key] = value; // 数据变化 --&gt; 修改视图 input.value = value; p.innerHTML = value; return value; &#125;,&#125;;const proxy = new Proxy(data, handler);// 视图更改 --&gt; 数据变化input.addEventListener(&quot;keyup&quot;, function (e) &#123; proxy.text = e.target.value;&#125;); 继承12345678910111213141516171819202122232425function inheritPrototype(subType, superType) &#123; var protoType = Object.create(superType.prototype); //创建对象 protoType.constructor = subType; //增强对象 subType.prototype = protoType; //指定对象&#125;function SuperType(name) &#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;SuperType.prototype.sayName = function () &#123; alert(this.name);&#125;;function SubType(name, age) &#123; SuperType.call(this, name); this.age = age;&#125;inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function () &#123; alert(this.age);&#125;;var instance = new SubType(&quot;Bob&quot;, 18);instance.sayName();instance.sayAge(); Object.create1234567891011121314151617181920if (typeof Object.create !== &quot;function&quot;) &#123; Object.create = function (prototype, properties) &#123; if (typeof prototype !== &quot;object&quot;) &#123; throw TypeError(); &#125; function Ctor() &#123;&#125; Ctor.prototype = prototype; var o = new Ctor(); if (prototype) &#123; o.constructor = Ctor; &#125; if (properties !== undefined) &#123; if (properties !== Object(properties)) &#123; throw TypeError(); &#125; Object.defineProperties(o, properties); &#125; return o; &#125;;&#125; instanceof 实现原理： L 的 __proto__ 是不是等于 R.prototype，不等于再找 L.__proto__.__proto__ 直到 __proto__ 为 null 1234567891011// L 表示左表达式，R 表示右表达式function instance_of(L, R) &#123; var O = R.prototype; L = L.__proto__; while (true) &#123; if (L === null) return false; // 这里重点：当 O 严格等于 L 时，返回 true if (O === L) return true; L = L.__proto__; &#125;&#125; Array.isArray 实现12345Array.myIsArray = function (o) &#123; return Object.prototype.toString.call(Object(o)) === &quot;[object Array]&quot;;&#125;;console.log(Array.myIsArray([])); // true getOwnPropertyNames 实现123456789101112131415if (typeof Object.getOwnPropertyNames !== &quot;function&quot;) &#123; Object.getOwnPropertyNames = function (o) &#123; if (o !== Object(o)) &#123; throw TypeError(&quot;Object.getOwnPropertyNames called on non-object&quot;); &#125; var props = [], p; for (p in o) &#123; if (Object.prototype.hasOwnProperty.call(o, p)) &#123; props.push(p); &#125; &#125; return props; &#125;;&#125; Promise 实现实现原理：其实就是一个发布订阅者模式 构造函数接收一个 executor 函数，并会在 new Promise() 时立即执行该函数 then 时收集依赖，将回调函数收集到 成功/失败队列 executor 函数中调用 resolve/reject 函数 resolve/reject 函数被调用时会通知触发队列中的回调 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210const isFunction = variable =&gt; typeof variable === &#x27;function&#x27;;// 定义Promise的三种状态常量const PENDING = &#x27;pending&#x27;;const FULFILLED = &#x27;fulfilled&#x27;;const REJECTED = &#x27;rejected&#x27;;class MyPromise &#123; // 构造函数，new 时触发 constructor(handle: Function) &#123; try &#123; handle(this._resolve, this._reject); &#125; catch (err) &#123; this._reject(err); &#125; &#125; // 状态 pending fulfilled rejected private _status: string = PENDING; // 储存 value，用于 then 返回 private _value: string | undefined = undefined; // 失败队列，在 then 时注入，resolve 时触发 private _rejectedQueues: any = []; // 成功队列，在 then 时注入，resolve 时触发 private _fulfilledQueues: any = []; // resovle 时执行的函数 private _resolve = val =&gt; &#123; const run = () =&gt; &#123; if (this._status !== PENDING) return; this._status = FULFILLED; // 依次执行成功队列中的函数，并清空队列 const runFulfilled = value =&gt; &#123; let cb; while ((cb = this._fulfilledQueues.shift())) &#123; cb(value); &#125; &#125;; // 依次执行失败队列中的函数，并清空队列 const runRejected = error =&gt; &#123; let cb; while ((cb = this._rejectedQueues.shift())) &#123; cb(error); &#125; &#125;; /* * 如果resolve的参数为Promise对象， * 则必须等待该Promise对象状态改变后当前Promsie的状态才会改变 * 且状态取决于参数Promsie对象的状态 */ if (val instanceof MyPromise) &#123; val.then( value =&gt; &#123; this._value = value; runFulfilled(value); &#125;, err =&gt; &#123; this._value = err; runRejected(err); &#125; ); &#125; else &#123; this._value = val; runFulfilled(val); &#125; &#125;; // 异步调用 setTimeout(run); &#125;; // reject 时执行的函数 private _reject = err =&gt; &#123; if (this._status !== PENDING) return; // 依次执行失败队列中的函数，并清空队列 const run = () =&gt; &#123; this._status = REJECTED; this._value = err; let cb; while ((cb = this._rejectedQueues.shift())) &#123; cb(err); &#125; &#125;; // 为了支持同步的Promise，这里采用异步调用 setTimeout(run); &#125;; // then 方法 then(onFulfilled?, onRejected?) &#123; const &#123; _value, _status &#125; = this; // 返回一个新的Promise对象 return new MyPromise((onFulfilledNext, onRejectedNext) =&gt; &#123; // 封装一个成功时执行的函数 const fulfilled = value =&gt; &#123; try &#123; if (!isFunction(onFulfilled)) &#123; onFulfilledNext(value); &#125; else &#123; const res = onFulfilled(value); if (res instanceof MyPromise) &#123; // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调 res.then(onFulfilledNext, onRejectedNext); &#125; else &#123; //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数 onFulfilledNext(res); &#125; &#125; &#125; catch (err) &#123; // 如果函数执行出错，新的Promise对象的状态为失败 onRejectedNext(err); &#125; &#125;; // 封装一个失败时执行的函数 const rejected = error =&gt; &#123; try &#123; if (!isFunction(onRejected)) &#123; onRejectedNext(error); &#125; else &#123; const res = onRejected(error); if (res instanceof MyPromise) &#123; // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调 res.then(onFulfilledNext, onRejectedNext); &#125; else &#123; //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数 onFulfilledNext(res); &#125; &#125; &#125; catch (err) &#123; // 如果函数执行出错，新的Promise对象的状态为失败 onRejectedNext(err); &#125; &#125;; switch (_status) &#123; // 当状态为pending时，将then方法回调函数加入执行队列等待执行 case PENDING: this._fulfilledQueues.push(fulfilled); this._rejectedQueues.push(rejected); break; // 当状态已经改变时，立即执行对应的回调函数 case FULFILLED: fulfilled(_value); break; case REJECTED: rejected(_value); break; &#125; &#125;); &#125; // catch 方法 catch(onRejected) &#123; return this.then(undefined, onRejected); &#125; // finally 方法 finally(cb) &#123; return this.then( value =&gt; MyPromise.resolve(cb()).then(() =&gt; value), reason =&gt; MyPromise.resolve(cb()).then(() =&gt; &#123; throw reason; &#125;) ); &#125; // 静态 resolve 方法 static resolve(value) &#123; // 如果参数是MyPromise实例，直接返回这个实例 if (value instanceof MyPromise) return value; return new MyPromise(resolve =&gt; resolve(value)); &#125; // 静态 reject 方法 static reject(value) &#123; return new MyPromise((resolve, reject) =&gt; reject(value)); &#125; // 静态 all 方法 static all(list) &#123; return new MyPromise((resolve, reject) =&gt; &#123; // 返回值的集合 let values = []; let count = 0; for (let [i, p] of list.entries()) &#123; // 数组参数如果不是MyPromise实例，先调用MyPromise.resolve this.resolve(p).then( res =&gt; &#123; values[i] = res; count++; // 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled if (count === list.length) resolve(values); &#125;, err =&gt; &#123; // 有一个被rejected时返回的MyPromise状态就变成rejected reject(err); &#125; ); &#125; &#125;); &#125; // 添加静态race方法 static race(list) &#123; return new MyPromise((resolve, reject) =&gt; &#123; for (let p of list) &#123; // 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变 this.resolve(p).then( res =&gt; &#123; resolve(res); &#125;, err =&gt; &#123; reject(err); &#125; ); &#125; &#125;); &#125;&#125; 防抖/节流防抖函数 onscroll 结束时触发一次，延迟执行 123456789101112131415function debounce(callback, wait) &#123; let timeout; return function () &#123; let context = this; let args = arguments; if (timeout) clearTimeout(timeout); timeout = setTimeout(() =&gt; &#123; callback.apply(context, args); &#125;, wait); &#125;;&#125;// 使用window.onscroll = debounce(function () &#123; console.log(&quot;debounce&quot;);&#125;, 1000); 节流函数 onscroll 时，每隔一段时间触发一次，像水滴一样 1234567891011121314function throttle(callback, delay) &#123; var prevTime = Date.now(); return function () &#123; var curTime = Date.now(); if (curTime - prevTime &gt; delay) &#123; callback.apply(this, arguments); prevTime = curTime; &#125; &#125;;&#125;// 使用window.onscroll = throttle(function () &#123; console.log(&quot;throtte&quot;);&#125;, 1000); 函数柯里化实现其实我们无时无刻不在使用柯里化函数，只是没有将它总结出来而已。它的本质就是将一个参数很多的函数分解成单一参数的多个函数。 应用场景： 延迟计算 （用闭包把传入参数保存起来，当传入参数的数量足够执行函数时，开始执行函数） 动态创建函数 （参数不够时会返回接受剩下参数的函数） 参数复用（每个参数可以多次复用） 123456789101112const curry = (fn) =&gt; (judge = (...args) =&gt; args.length &gt;= fn.length ? fn(...args) : (...arg) =&gt; judge(...args, ...arg));const sum = (a, b, c, d) =&gt; a + b + c + d;const currySum = curry(sum);currySum(1)(2)(3)(4); // 10currySum(1, 2)(3)(4); // 10currySum(1)(2, 3)(4); // 10 实现简单深拷贝1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function getType(obj) &#123; const str = Object.prototype.toString.call(obj); const map = &#123; &quot;[object Boolean]&quot;: &quot;boolean&quot;, &quot;[object Number]&quot;: &quot;number&quot;, &quot;[object String]&quot;: &quot;string&quot;, &quot;[object Function]&quot;: &quot;function&quot;, &quot;[object Array]&quot;: &quot;array&quot;, &quot;[object Date]&quot;: &quot;date&quot;, &quot;[object RegExp]&quot;: &quot;regExp&quot;, &quot;[object Undefined]&quot;: &quot;undefined&quot;, &quot;[object Null]&quot;: &quot;null&quot;, &quot;[object Object]&quot;: &quot;object&quot;, &#125;; if (obj instanceof Element) &#123; // 判断是否是dom元素，如div等 return &quot;element&quot;; &#125; return map[str];&#125;function deepCopy(original) &#123; const type = getType(original); let copy; switch (type) &#123; case &quot;array&quot;: return copyArray(original, copy); case &quot;object&quot;: return copyObject(original, copy); case &quot;function&quot;: return copyFunction(original, copy); default: return original; &#125;&#125;function copyArray(original, copy = []) &#123; for (const [index, value] of original.entries()) &#123; copy[index] = deepCopy(value); &#125; return copy;&#125;function copyObject(original, copy = &#123;&#125;) &#123; for (const [key, value] of Object.entries(original)) &#123; copy[key] = deepCopy(value); &#125; return copy;&#125;function copyFunction(original, copy = () =&gt; &#123;&#125;) &#123; const fn = eval(original.toString()); fn.prototype = original.prototype; return fn;&#125;const arr1 = [1, 2, [3, 4], &#123; i: 6, j: 6 &#125;, (k, m) =&gt; k + m];console.log(deepCopy(arr1));","categories":[{"name":"JavaScript","slug":"javascript","permalink":"https://kobingogo.github.io/categories/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://kobingogo.github.io/tags/javascript/"}]},{"title":"前端如何学数据结构与算法 - 一篇讲完关于`堆`的一切","slug":"algorithms-heap-knowledge","date":"2020-02-17T15:01:41.000Z","updated":"2022-02-18T02:31:03.807Z","comments":true,"path":"algorithms-heap-knowledge/","link":"","permalink":"https://kobingogo.github.io/algorithms-heap-knowledge/","excerpt":"对于前端来说，堆是一个不好理解的知识，但也是必不可少的知识点，是面试时经常考的重难点，本文是笔者自身学习堆的心得记录，意在能对堆有个更加系统的了解。","text":"对于前端来说，堆是一个不好理解的知识，但也是必不可少的知识点，是面试时经常考的重难点，本文是笔者自身学习堆的心得记录，意在能对堆有个更加系统的了解。 一、什么是堆在了解什么是堆前，需要先了解什么是完全二叉树。 完全二叉树 一种特殊的二叉树，叶子节点都在最底下两层，最后一层叶子节都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫做完全二叉树。 堆 堆是一种特殊的完全二叉树，堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。如果堆上的任意节点都大于等于子节点值，则称为 大顶堆;如果堆上的任意节点都小于等于子节点值，则称为 小顶堆; 二、堆的存储完全二叉树可以用数组存储，如果一个节点存储在数组中的下标为 i（ i从1开始） ，那么它的左子节点的存储下标为 2 * i ，右子节点的下标为 2 * i + 1，反过来，下标 i / 2 位置存储的就是该节点的父节点。完全二叉树用数组来存储是最省内存的方式。 因为堆是一种特殊的完全二叉树，所以堆也适用于上面的存储方法。 三、如何创建堆常用的创建堆方式有两种： 插入式创建：每次插入一个节点，实现一个大顶堆（或小顶堆） 原地创建：又称堆化，给定一组节点，实现一个大顶堆（或小顶堆） 下面都已创建大顶堆为例。 3.1 插入式建堆步骤： 将元素插入到队尾； 将插入节点与其父节点比较，如果插入节点大于父节点（对于大顶堆）或插入节点小于父节点（对于小顶堆），则插入节点与父节点调换位置。 如果需要调换位置，则调换后继续第2步向上比较，直到达到根节点，或者不需要调换为止。 实现代码： 12345678910111213141516171819202122232425262728//插入式建堆function MaxHeap(params) &#123; let heaps = [,]; //初始化一个堆，从1开始 this.insert = function (value) &#123; heaps.push(value); let i = heaps.length - 1; while (Math.floor(i / 2) &gt; 0 &amp;&amp; heaps[i] &gt; heaps[Math.floor(i / 2)]) &#123; [heaps[i], heaps[Math.floor(i / 2)]] = [ heaps[Math.floor(i / 2)], heaps[i], ]; // 交换 i = Math.floor(i / 2); &#125; &#125;; this.get = function (params) &#123; return heaps &#125;&#125;let maxHeap = new MaxHeap();maxHeap.insert(3);maxHeap.insert(5);maxHeap.insert(1);maxHeap.insert(2);maxHeap.insert(3);maxHeap.insert(4);let result = maxHeap.get();console.log(result);// =&gt; [empty, 5, 3, 4, 2, 3, 1] 3.2 原地建堆原地建堆有两种思路： 自下而上式堆化 ：将节点与其父节点比较，如果节点大于父节点（大顶堆）或节点小于父节点（小顶堆），则节点与父节点调整位置 自上往下式堆化 ：将节点与其左右子节点比较，如果存在左右子节点大于该节点（大顶堆）或小于该节点（小顶堆），则将子节点的最大值（大顶堆）或最小值（小顶堆）与之交换 自下而上式堆是调整节点与父节点（往上走），自上往下式堆化是调整节点与其左右子节点（往下走）。 3.2.1. 从前往后、自下而上式堆化建堆。假设有个序列： 1let arr = [,4,2,1,3,5,6]; 实现代码： 123456789101112131415161718function buildHeap(items, heapSize = 1) &#123; while (heapSize &lt; items.length - 1) &#123; heapSize++; heapify(items, heapSize); &#125;&#125;function heapify(items, i) &#123; while (Math.floor(i / 2) &gt; 0 &amp;&amp; items[i] &gt; items[Math.floor(i / 2)]) &#123; [items[i], items[Math.floor(i / 2)]] = [items[Math.floor(i / 2)], items[i]]; //利用解构方式交换元素 i = Math.floor(i / 2); &#125;&#125;let arr = [, 4, 2, 1, 3, 5, 6];buildHeap(arr);console.log(arr);// =&gt; [ empty, 6, 4, 5, 2, 3, 1 ] 3.2.2. 从后往前、自上而下式堆化建堆因为叶子节点没有子节点，不需要自上而下式堆化，所以从后往前是从序列的最后一个非叶子节点开始（即 n/2）。 假设有个序列： 1let arr = [,4,2,1,3,5,6]; 实现代码： 123456789101112131415161718192021222324252627function buildHeap(items) &#123; let heapSize = items.length - 1; // 从最后一个非叶子节点开始遍历 for (let i = Math.floor(heapSize / 2); i &gt;= 1; i--) &#123; heapify(items, heapSize, i); &#125;&#125;function heapify(items, heapSize, i) &#123; while (true) &#123; let maxIndex = i; // 用maxIndex表示 i 的最大子节点的下标 if (2 * i &lt;= heapSize &amp;&amp; items[i] &lt; items[2 * i]) &#123; maxIndex = 2 * i; &#125; if (2 * i + 1 &lt;= heapSize &amp;&amp; items[maxIndex] &lt; items[2 * i + 1]) &#123; maxIndex = 2 * i + 1; &#125; if (maxIndex === i) break; [items[maxIndex], items[i]] = [items[i], items[maxIndex]]; //交换 i 与其最大的子节点 i = maxIndex; &#125;&#125;let arr = [, 4, 2, 1, 3, 5, 6];buildHeap(arr);console.log(arr);// =&gt; [ empty, 6, 5, 4, 3, 2, 1 ] 四、堆排序由于大顶堆的堆顶点（i=1）存放的是最大值，所以可以每次让堆顶与最后一个节点交换数据，此时最大值放入了有效序列的最后一位，并且有效序列减1，有效堆依然保持完全二叉树的结构，然后堆化，成为新的大顶堆，重复此操作，直到有效堆的长度为 0，排序完成。 详细步骤： 将原序列转化成一个大顶堆； 设置堆的有效序列长度为 heapSize； 将堆顶元素与最后一个子元素（最后一个有效序列）交换，并有效序列长度减1； 堆化有效序列，使有效序列重新称为一个大顶堆； 重复以上2、3步，直到有效序列的长度为 1，排序完成； 实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function heapSort(items) &#123; // 设置堆的初始有效序列长度为 items.length - 1 let heapSize = items.length - 1; // 构建大顶堆 buildHeap(items, heapSize); while (heapSize &gt; 1) &#123; // 交换堆顶元素与最后一个有效子元素 [items[1], items[heapSize]] = [items[heapSize], items[1]]; // 有效序列长度减 1 heapSize--; heapify(items, heapSize, 1); &#125; return items;&#125;/** * 原地建堆: 自上而下建堆， * @param &#123;原始序列&#125; items * @param &#123;有效序列长度&#125; heapSize */function buildHeap(items, heapSize) &#123; // 从最后一个非叶子节点开始，自上而下式堆化 for (let i = Math.floor(heapSize / 2); i &gt;= 1; --i) &#123; heapify(items, heapSize, i); &#125;&#125;/** * 这里不适合用自下而上方式，因为交换过后，有效序列里唯一没有堆化的是堆顶元素， * 所以直接从堆顶开始自上而下堆化是最快的 */function heapify(items, heapSize, i) &#123; while (true) &#123; let maxIndex = i; // 用maxIndex表示 i 的最大子节点的下标 if (2 * i &lt;= heapSize &amp;&amp; items[i] &lt; items[2 * i]) &#123; maxIndex = 2 * i; &#125; if (2 * i + 1 &lt;= heapSize &amp;&amp; items[maxIndex] &lt; items[2 * i + 1]) &#123; maxIndex = 2 * i + 1; &#125; if (maxIndex === i) break; [items[maxIndex], items[i]] = [items[i], items[maxIndex]]; //交换 i 与其最大的子节点 i = maxIndex; &#125;&#125;// 测试var items = [, 8, 3, 4, 2, 6, 7, 1, 9, 5]heapSort(items)console.log(items);// =&gt; [ empty, 1, 2, 3, 4, 5, 6, 7, 8, 9 ] 复杂度分析： 时间复杂度： 建堆 - O(nlogn), 排序 - O(nlogn), 整体 - O(nlogn); 空间复杂度： O(1); 堆的典型应用场景： Top K 问题 什么是 Top K 问题？简单来说就是在一组数据里面找到频率出现最高的前K个数，或前K大（或前K小）的数。 下面以取前K大为例来讲解： 从数组中取前 K 个数，构造成小顶堆； 从 K+1 位开始遍历数组，每一个数据都和小顶堆的堆顶元素进行比较，如果小于堆顶元素，则不做任何处理，继续遍历下一元素；如果大于堆顶元素，则将这个元素替换掉堆顶元素，然后再堆化成一个小顶堆。 遍历完成后，堆中的数据就是前 K 大的数据； 实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445function findKthLargest(nums, k) &#123; nums.splice(0, 0, null); buildHeap(nums, k); for (let i = k + 1; i &lt; nums.length; i++) &#123; if (nums[i] &gt; nums[1]) &#123; nums[1] = nums[i]; heapify(nums, k, 1) &#125; &#125; return nums[1]&#125;/** * 原地建堆: 自上而下建堆， * 这里不适合用自下而上方式，因为交换过后，有效序列里唯一没有堆化的是堆顶元素， * 所以直接从堆顶开始自上而下堆化是最快的 * @param &#123;原始序列&#125; items * @param &#123;有效序列长度&#125; heapSize */function buildHeap(items, heapSize) &#123; // 从最后一个非叶子节点开始，自上而下式堆化 for (let i = Math.floor(heapSize / 2); i &gt;= 1; --i) &#123; heapify(items, heapSize, i); &#125;&#125;function heapify(items, heapSize, i) &#123; while (true) &#123; let minIndex = i; // 用minIndex表示 i 的最小子节点的下标 if (2 * i &lt;= heapSize &amp;&amp; items[i] &gt; items[2 * i]) &#123; minIndex = 2 * i; &#125; if (2 * i + 1 &lt;= heapSize &amp;&amp; items[minIndex] &gt; items[2 * i + 1]) &#123; minIndex = 2 * i + 1; &#125; if (minIndex === i) break; [items[minIndex], items[i]] = [items[i], items[minIndex]]; //交换 i = minIndex; &#125;&#125;// 测试var nums = [2, 1]let kth = findKthLargest(nums, 2)console.log(kth); 复杂度分析： 时间复杂度：遍历数组需要 O(n) 的时间复杂度，一次堆化需要 O(logk) 时间复杂度，所以利用堆求 Top k 问题的时间复杂度为 O(nlogk) 空间复杂度：O(k) 当然，topK的最简单实现是用排序，但是用堆方式的话，最大好处就是求动态数组的topK。如果用排序方式的话，每次进来一个新元素都得重新排序，这是非常不可取的，而堆方式可以有效处理这个问题。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kobingogo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"堆","slug":"堆","permalink":"https://kobingogo.github.io/tags/%E5%A0%86/"}]},{"title":"前端如何学数据结构与算法 - 一篇讲完经典排序算法","slug":"algorithms-二叉树","date":"2020-02-01T14:34:09.000Z","updated":"2022-02-18T02:31:03.807Z","comments":true,"path":"algorithms-二叉树/","link":"","permalink":"https://kobingogo.github.io/algorithms-%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"二叉树通常作为数据结构应用，典型用法是对节点定义一个标记函数，将一些值与每个节点相关系。这样标记的二叉树就可以实现二叉查找树和二叉堆，并应用于高效率的搜索和排序。","text":"二叉树通常作为数据结构应用，典型用法是对节点定义一个标记函数，将一些值与每个节点相关系。这样标记的二叉树就可以实现二叉查找树和二叉堆，并应用于高效率的搜索和排序。 什么是二叉树二叉树（英语：Binary tree）是每个节点最多只有两个分支（即不存在分支度大于2的节点）的树结构。通常分支被称作“左子树”或“右子树”。二叉树的分支具有左右次序，不能随意颠倒。 二叉树的分类 满二叉树 一种特殊的二叉树，除了叶子节点外，每个节点都有左右两个子节点，这种二叉树叫做满二叉树。满二叉树中，第i层拥有2i-1个节点。 完全二叉树 一种特殊的二叉树，叶子节点都在最底下两层，最后一层叶子节都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫做完全二叉树。 堆 堆是一个完全二叉树, 并且堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值。对于每个节点的值都大于等于子树中每个节点值的堆，我们叫作大顶堆。对于每个节点的值都小于等于子树中每个节点值的堆，我们叫作小顶堆。 二叉查找树（Binary Search Tree） 一种特殊的二叉树，相对较小的值保存在左节点中，较大的值保存在右节点中，叫二叉查找树，也叫二叉搜索树。 二叉查找树是一种有序的树，所以支持快速查找、快速插入、删除一个数据。 下图中， 3 个都是二叉查找树 平衡二叉查找树 一种特殊的二叉树, 二叉树中任意一个节点的左右子树的高度相差不能大于 1。 完全二叉树、满二叉树其实都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树. 平衡二叉查找树中平衡的意思，其实就是让整棵树左右看起来比较对称、比较平衡，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。 完全二叉树的存储 二叉链表存储 每个节点由 3 个字段，其中一个存储数据，另外两个是指向左右子节点的指针。 我们只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。 这种存储方式比较常用，大部分二叉树代码都是通过这种方式实现的。 顺序存储 用数组来存储，对于完全二叉树，如果节点 X 存储在数组中的下标为 i ，那么它的左子节点的存储下标为 2 * i ，右子节点的下标为 2 * i + 1，反过来，下标 i / 2 位置存储的就是该节点的父节点。 注意，根节点存储在下标为 1 的位置。完全二叉树用数组来存储是最省内存的方式。 实现二叉查找树实现以下方法： insert(key)：向树中插入一个新的键。 search(key)：在树中查找一个键，如果节点存在，则返回 true；如果不存在，则返回 false。 min：返回树中最小的值/键。 max：返回树中最大的值/键。 remove(key)：从树中移除某个键。 实现二叉查找树类1234567891011function BinarySearchTree() &#123; // 节点结构 const Node = function (key) &#123; this.key = key; this.left = null; this.right = null; &#125;; //根节点 let root = null;&#125; 插入节点 遍历树，将插入节点的键值与遍历到的节点键值比较，如果前者大于后者，继续递归遍历右子节点，反之，继续遍历左子节点，直到找到一个空的节点，在该位置插入。 123456789101112131415161718192021222324252627282930313233// 插入新节点this.insert = function (key) &#123; //创建节点 const node = new Node(key); if (root === null) &#123; //判断是否为根节点 root = node; &#125; else &#123; // 不是根节点则新增节点 insertNode(root, node); &#125;&#125;;//新增节点const insertNode = function (node, newNode) &#123; //约定右孩子都大于左孩子节点 if (newNode.key &lt; node.key) &#123; if (node.left === null) &#123; //没有左孩子，则新增左孩子 node.left = newNode; &#125; else &#123; //如果有左孩子则递归算法实现插入左孩子节点 insertNode(node.left, newNode); &#125; &#125; else &#123; //如果没有右孩子，则新增右孩子 if (node.right === null) &#123; node.right = newNode; &#125; else &#123; //如果有右孩子则递归算法实现插入右孩子节点 insertNode(node.right, newNode); &#125; &#125;&#125;; 搜索最小值在二叉搜索树里，不管是整个树还是其子树，最小值一定在树最左侧的最底层。 因此给定一颗树或其子树，只需要一直向左节点遍历到底就行了。 123456789this.min = function (node) &#123; // min方法允许传入子树 node = node || root; // 一直遍历左侧子节点，直到底部 while (node &amp;&amp; node.left !== null) &#123; node = node.left; &#125; return node;&#125;; 搜索最大值搜索最大值与搜索最小值类似，只是沿着树的右侧遍历。 123456789this.max = function (node) &#123; // max方法允许传入子树 node = node || root; // 一直遍历左侧子节点，直到底部 while (node &amp;&amp; node.right !== null) &#123; node = node.right; &#125; return node;&#125;; 搜索指定节点遍历树，将要搜索的值与遍历到的节点比较，如果前者大于后者，则递归遍历右子树，反之，则递归遍历左子树。 123456789101112131415161718192021this.search = function (key, node) &#123; // 同样的，search方法允许在子树中查找值 node = node || root; return searchNode(key, node);&#125;;const searchNode = function (key, node) &#123; // 如果node是null，说明树中没有要查找的值，返回false if (node === null) &#123; return false; &#125; if (key &lt; node.key) &#123; // 如果要查找的值小于该节点，继续递归遍历其左侧节点 return searchNode(key, node.left); &#125; else if (key &gt; node.key) &#123; // 如果要查找的值大于该节点，继续递归遍历其右侧节点 return searchNode(key, node.right); &#125; else &#123; // 如果要查找的值等于该节点，说明查找成功，返回该节点 return node; &#125;&#125;; 删除节点1234567891011121314151617181920212223242526272829303132333435363738this.remove = function (key, node) &#123; // 同样的，允许仅在子树中删除节点 node = node || root; return removeNode.call(this, key, node);&#125;;const removeNode = function (key, node) &#123; if (node == null) &#123; return null; &#125; if (key == node.key) &#123; // 没有子节点（子树） if (node.left == null &amp;&amp; node.right == null) &#123; return null; &#125; // 只有右子节点（子树） else if (node.left == null) &#123; return node.right; &#125; // 只有左子节点（子树） else if (node.right == null) &#123; return node.left; &#125; // 有两个子节点（子树） else &#123; const tempNode = this.min(node.right); node.key = tempNode.key; node.right = removeNode.call(this, tempNode.key, node.right); return node; &#125; &#125; else if (key &lt; node.key) &#123; node.left = removeNode.call(this, key, node.left); return node; &#125; else &#123; node.right = removeNode.call(this, key, node.right); return node; &#125;&#125;; 二叉树的遍历深度优先遍历 前序遍历 先处理中节点，接着处理左节点再处理右节点，递归遍历所有所有节点。 123456789101112this.preOrderTraverse = function (callback) &#123; // 同样的，callback用于对遍历到的节点做操作 preOrderTraverseNode(root, callback);&#125;;const preOrderTraverseNode = function (node, callback) &#123; // 遍历到node为null为止 if (node !== null) &#123; callback(node.key); // 先处理当前节点 preOrderTraverseNode(node.left, callback); // 再继续遍历左子节点 preOrderTraverseNode(node.right, callback); // 最后遍历右子节点 &#125;&#125;; 中序遍历 先处理左节点，接着处理中节点再处理右节点，递归遍历所有所有节点。 123456789101112131415this.inOrderTraverse = function (callback) &#123; // callback用于对遍历到的节点做操作 inOrderTraverseNode(root, callback);&#125;;const inOrderTraverseNode = function (node, callback) &#123; // 遍历到node为null为止 if (node !== null) &#123; // 优先遍历左边节点，保证从小到大遍历 inOrderTraverseNode(node.left, callback); // 处理当前的节点 callback(node.key); // 遍历右侧节点 inOrderTraverseNode(node.right, callback); &#125;&#125;; 后序遍历 先处理左节点，接着处理右节点再处理中节点，递归遍历所有所有节点。 12345678910this.postOrderTraverse = function (callback) &#123; postOrderTraverseNode(root, callback); &#125;; const postOrderTraverseNode = function (node, callback) &#123; if (node !== null) &#123; postOrderTraverseNode(node.left, callback); postOrderTraverseNode(node.right, callback); callback(node.key); &#125; &#125;; 广度遍历123456789101112131415161718//广度遍历BFSthis.BFS = function () &#123; if (!root) return []; const res = [], queue = [root]; while (queue.length &gt; 0) &#123; const rows = []; const size = queue.length; for (let i = 0; i &lt; size; i++) &#123; const item = queue.shift(); rows.push(item.key); if (item.left) queue.push(item.left); if (item.right) queue.push(item.right); &#125; res.push(rows); &#125; return res;&#125;; 附：完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194//js实现二叉查找树function BinarySearchTree() &#123; // 节点结构 const Node = function (key) &#123; this.key = key; this.left = null; this.right = null; &#125;; //根节点 let root = null; // 插入新节点 this.insert = function (key) &#123; //创建节点 const node = new Node(key); if (root === null) &#123; //判断是否为根节点 root = node; &#125; else &#123; // 不是根节点则新增节点 insertNode(root, node); &#125; &#125;; //新增节点 const insertNode = function (node, newNode) &#123; //约定右孩子都大于左孩子节点 if (newNode.key &lt; node.key) &#123; if (node.left === null) &#123; //没有左孩子，则新增左孩子 node.left = newNode; &#125; else &#123; //如果有左孩子则递归算法实现插入左孩子节点 insertNode(node.left, newNode); &#125; &#125; else &#123; //如果没有右孩子，则新增右孩子 if (node.right === null) &#123; node.right = newNode; &#125; else &#123; //如果有右孩子则递归算法实现插入右孩子节点 insertNode(node.right, newNode); &#125; &#125; &#125;; //获取最小节点 this.min = function (node) &#123; // min方法允许传入子树 node = node || root; // 一直遍历左侧子节点，直到底部 while (node &amp;&amp; node.left !== null) &#123; node = node.left; &#125; return node; &#125;; //获取最大节点 this.max = function (node) &#123; // min方法允许传入子树 node = node || root; // 一直遍历左侧子节点，直到底部 while (node &amp;&amp; node.right !== null) &#123; node = node.right; &#125; return node; &#125;; //搜索指定节点 this.search = function (key, node) &#123; // 同样的，search方法允许在子树中查找值 node = node || root; return searchNode(key, node); &#125;; const searchNode = function (key, node) &#123; // 如果node是null，说明树中没有要查找的值，返回false if (node === null) &#123; return false; &#125; if (key &lt; node.key) &#123; // 如果要查找的值小于该节点，继续递归遍历其左侧节点 return searchNode(key, node.left); &#125; else if (key &gt; node.key) &#123; // 如果要查找的值大于该节点，继续递归遍历其右侧节点 return searchNode(key, node.right); &#125; else &#123; // 如果要查找的值等于该节点，说明查找成功，返回该节点 return node; &#125; &#125;; this.remove = function (key, node) &#123; // 同样的，允许仅在子树中删除节点 node = node || root; return removeNode.call(this, key, node); &#125;; const removeNode = function (key, node) &#123; if (node == null) &#123; return null; &#125; if (key == node.key) &#123; // 没有子节点（子树） if (node.left == null &amp;&amp; node.right == null) &#123; return null; &#125; // 只有右子节点（子树） else if (node.left == null) &#123; return node.right; &#125; // 只有左子节点（子树） else if (node.right == null) &#123; return node.left; &#125; // 有两个子节点（子树） else &#123; const tempNode = this.min(node.right); node.key = tempNode.key; node.right = removeNode.call(this, tempNode.key, node.right); return node; &#125; &#125; else if (key &lt; node.key) &#123; node.left = removeNode.call(this, key, node.left); return node; &#125; else &#123; node.right = removeNode.call(this, key, node.right); return node; &#125; &#125;; //先序遍历 this.preOrderTraverse = function (callback) &#123; // 同样的，callback用于对遍历到的节点做操作 preOrderTraverseNode(root, callback); &#125;; const preOrderTraverseNode = function (node, callback) &#123; // 遍历到node为null为止 if (node !== null) &#123; callback(node.key); // 先处理当前节点 preOrderTraverseNode(node.left, callback); // 再继续遍历左子节点 preOrderTraverseNode(node.right, callback); // 最后遍历右子节点 &#125; &#125;; //中序遍历 this.inOrderTraverse = function (callback) &#123; // callback用于对遍历到的节点做操作 inOrderTraverseNode(root, callback); &#125;; const inOrderTraverseNode = function (node, callback) &#123; // 遍历到node为null为止 if (node !== null) &#123; // 优先遍历左边节点，保证从小到大遍历 inOrderTraverseNode(node.left, callback); // 处理当前的节点 callback(node.key); // 遍历右侧节点 inOrderTraverseNode(node.right, callback); &#125; &#125;; //后序遍历 this.postOrderTraverse = function (callback) &#123; postOrderTraverseNode(root, callback); &#125;; const postOrderTraverseNode = function (node, callback) &#123; if (node !== null) &#123; postOrderTraverseNode(node.left, callback); postOrderTraverseNode(node.right, callback); callback(node.key); &#125; &#125;; //广度遍历BFS this.BFS = function () &#123; if (!root) return []; const res = [], queue = [root]; while (queue.length &gt; 0) &#123; const rows = []; const size = queue.length; for (let i = 0; i &lt; size; i++) &#123; const item = queue.shift(); rows.push(item.key); if (item.left) queue.push(item.left); if (item.right) queue.push(item.right); &#125; res.push(rows); &#125; return res; &#125;; this.print = function () &#123; console.log(&quot;root :&quot;, root); return root; &#125;;&#125;module.exports = BinarySearchTree;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kobingogo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kobingogo.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"前端如何学数据结构与算法 - JavaScript里的栈与堆","slug":"algorithms-JavaScript里的栈内存与堆内存","date":"2019-12-07T15:37:25.000Z","updated":"2022-02-18T02:31:03.807Z","comments":true,"path":"algorithms-JavaScript里的栈内存与堆内存/","link":"","permalink":"https://kobingogo.github.io/algorithms-JavaScript%E9%87%8C%E7%9A%84%E6%A0%88%E5%86%85%E5%AD%98%E4%B8%8E%E5%A0%86%E5%86%85%E5%AD%98/","excerpt":"本文主要介绍堆与栈，以及他们在JavaScript语言底层的应用。","text":"本文主要介绍堆与栈，以及他们在JavaScript语言底层的应用。 栈 定义 后进者先出，先进者后出，简称 后进先出（LIFO），这就是典型的栈结构。 在栈里，新元素都靠近栈顶，旧元素都接近栈底。 从栈的操作特性来看，是一种 操作受限的线性表，只允许在一端插入和删除数据。 不包含任何元素的栈称为空栈。 栈被用在编程语言的编译器和内存中保存变量、方法调用等，比如函数的调用栈、前端路由等。 堆 定义 堆数据结构是一种树状结构 它的存取数据的方式，与书架相似：我们不关心书的放置顺序是怎样的，只需知道书的名字就可以取出我们想要的书 堆与栈比较 栈，线性结构，后进先出，便于管理。 堆，非线性结构，杂乱无章，方便存储和开辟内存空间。 堆是动态分配内存，内存大小不一，不会自动释放。 栈是自动分配相对固定大小的内存空间，并由系统自动释放。 JS在浏览器上的运行机制我们知道 JavaScript 是单线程的，所谓单线程，是指在 JavaScript 引擎中负责解释和执行 JavaScript 代码的线程唯一，同一时间上只能执行一件任务。 为什么是单线程？这是因为 JavaScript 可以修改 DOM 结构，如果 JavaScript 引擎线程不是单线程的，那么可以同时执行多段 JavaScript，如果这多段 JavaScript 都修改 DOM，那么就会出现 DOM 冲突。 为了避免 DOM 渲染的冲突，可以采用单线程或者死锁，JavaScript 采用了单线程方案。 但单线程有一个问题：如果任务队列里有一个任务耗时很长，导致这个任务后面的任务一直排队等待，就会发生页面卡死，严重影响用户体验。 为了解决这个问题，JavaScript 将任务的执行模式分为两种：同步和异步。 同步 123// 同步任务let a = 1console.log(a) // 1 异步 1234// 异步任务setTimeout(() =&gt; &#123; console.log(1)&#125;, 1000) 同步任务都在主线程（ JavaScript 引擎线程）上执行，会形成一个 调用栈(执行栈)； 除了主线程外，还有一个任务队列（也称消息队列），用于管理异步任务的 事件回调 ，在 调用栈 的任务执行完毕之后，系统会检查任务队列，看是否有可以执行的异步任务。 注意：任务队列存放的是异步任务的事件回调 例如上例： 123setTimeout(() =&gt; &#123; console.log(1)&#125;, 1000) 在执行这段代码时，并不会立刻打印 ，只有定时结束后（1s）才打印。 setTimeout 本身是同步执行的，放入任务队列的是它的回调函数。 下面我们重点看一下主线程上的调用栈。 调用栈调用栈是用来管理函数调用关系的一种栈结构 。 下面通过一个简单例子说明调用栈如何管理函数调用关系： 123456789var a = 1function add(a) &#123; var b = 2 let c = 3 return a + b + c&#125;// 函数调用add(a) 在执行这段代码之前，JavaScript 引擎会先创建一个全局执行上下文，包含所有已声明的函数与变量： 从图中可以看出，代码中的全局变量 a 及函数 add 保存在变量环境中。 执行上下文准备好后，开始执行全局代码，首先执行 a = 1 的赋值操作， 赋值完成后 a 的值由 undefined 变为 1，然后执行 add 函数，JavaScript 判断出这是一个函数调用，然后执行以下操作： 首先，从全局执行上下文中，取出 add 函数代码其次，对 add 函数的这段代码进行编译，并创建该函数的执行上下文和可执行代码，并将执行上下文压入栈中 然后，执行代码，返回结果，并将 add 的执行上下文也会从栈顶部弹出，此时调用栈中就只剩下全局上下文了。 至此，整个函数调用执行结束了。 所以说，调用栈是 JavaScript 用来管理函数执行上下文的一种数据结构，它记录了当前函数执行的位置，哪个函数正在被执行。 如果我们执行一个函数，就会为函数创建执行上下文并放入栈顶。 如果我们从函数返回，就将它的执行上下文从栈顶弹出。 也可以说调用栈是用来管理这种执行上下文的栈，或称执行上下文栈（执行栈）。 了解了什么是调用栈，就能方便的理解栈溢出了，因为调用栈是一个栈结构，它有容量上限，当入栈的上下文过多的时候，它就会报栈溢出。 可以通过console.trace()来查看函数的调用栈路径 栈内存与堆内存JavaScript 中的变量分为基本类型和引用类型。 基本类型是保存在栈内存中的简单数据段，它们的值都有固定的大小，通过按值访问，并由系统自动分配和自动释放。 这样带来的好处就是，内存可以及时得到回收，相对于堆来说，更加容易管理内存空间。 JavaScript 中的 Boolean、Null、Undefined、Number、String、Symbol 都是基本类型。 引用类型（如对象、数组、函数等）是保存在堆内存中的对象，值大小不固定，栈内存中存放的该对象的访问地址指向堆内存中的对象，JavaScript 不允许直接访问堆内存中的位置，因此操作对象时，实际操作对象的引用。 JavaScript 中的 Object、Array、Function、RegExp、Date 是引用类型。 示例： 12345678var a = 1function foo() &#123; var b = 2 var c = &#123; name: &#x27;an&#x27; &#125;&#125;// 函数调用foo() 当我们要访问堆内存中的引用数据类型时: 从栈中获取该对象的地址引用; 再从堆内存中取得我们需要的数据; 复制基本类型 1234let a = 20;let b = a;b = 30;console.log(a); // 20 在栈内存中的数据发生复制行为时，系统会自动为新的变量分配一个新值，最后这些变量都是 相互独立，互不影响的。 复制引用类型 1234let a = &#123; x: 10, y: 20 &#125;let b = a;b.x = 5;console.log(a.x); // 5 引用类型的复制，同样为新的变量 b 分配一个新的值，保存在栈内存中，不同的是，这个值仅仅是引用类型的一个地址指针。他们两个指向同一个堆内存空间，在堆内存中访问到的具体对象实际上是同一个。因此改变 b.x 时，a.x 也发生了变化，这就是引用类型的特性。 总结 栈内存 堆内存 存储基础数据类型 存储引用数据类型 按值访问 按引用访问 存储的值大小固定 存储的值大小不定，可动态调整 由系统自动分配内存空间 由代码进行指定分配 空间小，运行效率高 空间大，运行效率相对较低 先进后出，后进先出 无序存储，可根据引用直接获取 浅拷贝 与 深拷贝上面讲的引用类型的复制就是浅拷贝，复制得到的访问地址都指向同一个内存空间。所以修改了其中一个的值，另外一个也跟着改变了。 深拷贝：复制得到的访问地址指向不同的内存空间，互不相干。所以修改其中一个值，另外一个不会改变。 浅拷贝的优势在于性能出色，但是并不能都满足日常需求，很多时候我们需要改变拷贝数组的时候，原数组不受影响，这时候就需要用到深拷贝了。 一个通用深拷贝的实现主要思想： 通过判断拷贝对象的类型，如果是基本类型，直接赋值，如果是引用类型(array/object/function),则进入核心步骤 深拷贝的实现最重要的是处理循环引用的问题，以下用WeakMap的方式阻止循环引用:12345// 阻止循环引用if (cache.has(target)) &#123; return cache.get(target);&#125;cache.set(target, copy); 完整实现代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677function getType(obj) &#123; const str = Object.prototype.toString.call(obj); const map = &#123; &quot;[object Boolean]&quot;: &quot;boolean&quot;, &quot;[object Number]&quot;: &quot;number&quot;, &quot;[object String]&quot;: &quot;string&quot;, &quot;[object Function]&quot;: &quot;function&quot;, &quot;[object Array]&quot;: &quot;array&quot;, &quot;[object Date]&quot;: &quot;date&quot;, &quot;[object RegExp]&quot;: &quot;regExp&quot;, &quot;[object Undefined]&quot;: &quot;undefined&quot;, &quot;[object Null]&quot;: &quot;null&quot;, &quot;[object Object]&quot;: &quot;object&quot;, &#125;; return map[str];&#125;function deepCopy(target, cache = new WeakMap()) &#123; const type = getType(target); // 值类型数组 const valTypes = [ &quot;undefined&quot;, &quot;null&quot;, &quot;boolean&quot;, &quot;number&quot;, &quot;string&quot;, &quot;symbol&quot;, &quot;bigInt&quot;, ]; if (valTypes.includes(type)) &#123; return target; &#125; let copy; // 初始化clone值 if (type === &quot;function&quot;) &#123; copy = &#123;&#125;; &#125; else &#123; copy = new target.constructor(); &#125; // 阻止循环引用 if (cache.has(target)) &#123; return cache.get(target); &#125; cache.set(target, copy); switch (type) &#123; case &quot;array&quot;: return copyArray(target, copy, cache); case &quot;object&quot;: return copyObject(target, copy, cache); case &quot;function&quot;: return copyFunction(target, cache); default: return target; &#125;&#125;function copyArray(target, copy = [], cache) &#123; for (const [index, value] of target.entries()) &#123; copy[index] = deepCopy(value, cache); &#125; return copy;&#125;function copyObject(target, copy = &#123;&#125;, cache) &#123; for (const [key, value] of Object.entries(target)) &#123; copy[key] = deepCopy(value, cache); &#125; return copy;&#125;function copyFunction(target, copy = () =&gt; &#123;&#125;) &#123; const fn = eval(target.toString()); fn.prototype = target.prototype; return fn;&#125; 垃圾回收JavaScript 中的垃圾数据都是由垃圾回收器自动回收的，不需要手动释放。 回收栈空间在 JavaScript 执行代码时，主线程上会存在 ESP 指针，用来指向调用栈中当前正在执行的上下文。 当 foo 函数执行完成后，ESP 向下指向全局执行上下文，foo 函数执行上下文就变成无效的，当有新的执行上下文进来时，可以直接覆盖这块内存空间。 JavaScript 引擎通过向下移动 ESP 指针来销毁存放在栈空间中的执行上下文。 回收堆空间V8 中把堆分成新生代与老生代两个区域： 新生代：用来存放生存周期较短的小对象，一般只支持1～8M的容量 老生代：用来存放生存周期较长的对象或大对象 V8 对这两块区域使用了不同的回收器： 新生代使用副垃圾回收器 老生代使用主垃圾回收器 副垃圾回收器: 采用 Scavenge 算法及对象晋升策略来进行垃圾回收 所谓 Scavenge 算法，即把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域。 新加入的对象都加入对象区域，当对象区满的时候，就执行一次垃圾回收，执行流程如下： 标记：首先要对区域内的对象进行标记（活动对象、非活动对象） 垃圾清理：将对象区的活动对象复制到空闲区域，并进行有序的排列，当复制完成后，对象区域与空闲区域进行翻转，空闲区域晋升为对象区域，对象区域为空闲区域 翻转后，对象区域是没有碎片的，此时不需要进行内存整理。 所谓对象晋升策略，因为新生代区域很小的，一般1～8M的容量，所以它很容易满，所以，JavaScript 引擎采用对象晋升策略来处理: 即只要对象经过 两次 垃圾回收之后依然继续存活，就会被晋升到老生代区域中。 主垃圾回收器： 老生代区域里有两块对象： 从新生代晋升来的存活时间久的对象 大对象（直接分配到老生代） V8 中主垃圾回收器主要采用标记-清除法进行垃圾回收。 主要流程如下： 标记：遍历调用栈，看老生代区域堆中的对象是否被引用，被引用的对象标记为活动对象，没有被引用的对象（待清理）标记为垃圾数据。 垃圾清理：将所有垃圾数据清理掉 内存整理：标记-整理策略，将活动对象整理到一起 增量标记： V8 浏览器会自动执行垃圾回收，但由于 垃圾回收 也是运行在主线程上的，一旦执行垃圾回收，就要打断 JavaScript 的运行，可能会造成页面的卡顿，影响用户体验，所以 V8 采用增量 标记算法回收： 即把垃圾回收拆成一个个小任务，穿插在 JavaScript 中执行。 总结本文内容回顾： 栈与堆的定义与对比： 栈：线性结构，LIFO 堆：非线性结构，杂乱无章，方便存储与开辟内存空间 以及JS的运行机制： 调用栈 任务队列 调用栈 调用栈是 JavaScript 用来管理函数执行上下文的一种数据结构，它记录了当前函数执行的位置，哪个函数正在被执行 栈内存与堆内存 栈内存： 基本类型（Boolean、Null、Undefined、Number、String、Symbol） 堆内存： 引用类型（Object、Array、Function、RegExp、Date） 浅拷贝 与 深拷贝 垃圾回收 回收栈空间： JavaScript 引擎通过向下移动 ESP 指针来销毁存放在栈空间中的执行上下文。 回收堆空间： 副垃圾回收器 与 主垃圾回收器 的区别 增量标记： 解决阻塞主进程问题","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kobingogo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://kobingogo.github.io/tags/%E6%A0%88/"},{"name":"堆","slug":"堆","permalink":"https://kobingogo.github.io/tags/%E5%A0%86/"}]},{"title":"前端如何学数据结构与算法 - 线性表","slug":"algorithms-线性表基础汇总","date":"2019-12-05T14:25:24.000Z","updated":"2022-02-18T02:31:03.807Z","comments":true,"path":"algorithms-线性表基础汇总/","link":"","permalink":"https://kobingogo.github.io/algorithms-%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%9F%BA%E7%A1%80%E6%B1%87%E6%80%BB/","excerpt":"数据结构和算法是编程的内功，深厚的内功可以有效保障写出的代码性能良好，可以提前预估代码运行达到预期目的，提高工作产出，也能让学习其他编程语言和框架变得事半功倍。 本系列所有示例均采用JavaScript，旨在入门数据结构与算法。 本节主要是讲解下基础数据结构 - 线性表 相关的内容。","text":"数据结构和算法是编程的内功，深厚的内功可以有效保障写出的代码性能良好，可以提前预估代码运行达到预期目的，提高工作产出，也能让学习其他编程语言和框架变得事半功倍。 本系列所有示例均采用JavaScript，旨在入门数据结构与算法。 本节主要是讲解下基础数据结构 - 线性表 相关的内容。 线性表 与 非线性表线性表（Linear List）：就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。数组、链表、队列、栈 等就是典型线性表结构。 非线性表：数据之间并不是简单的前后关系。二叉树、堆、图 就是非线性表。 数组 定义数组 (Array) 是一个有序的数据集合，我们可以通过数组名称 (name) 和索引 (index) 进行访问。数组的索引是从 0 开始的。 特点数组是用一组连续的内存空间来存储的。 所以数组支持 随机访问，根据下标随机访问的时间复杂度为 O(1)。 低效的插入和删除。 数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效，因为底层通常是要进行大量的数据搬移来保持数据的连续性。 插入与删除的时间复杂度如下： 插入：从最好 O(1) ，最坏 O(n) ，平均 O(n) 删除：从最好 O(1) ，最坏 O(n) ，平均 O(n) 实现JavaScript 原生支持数组，而且提供了很多操作方法，JavaScript数组支持的方法可见下表： 方法 描述 concat() 连接两个或更多的数组，并返回结果。 copyWithin() 从数组的指定位置拷贝元素到数组的另一个指定位置中。 entries() 返回数组的可迭代对象。 every() 检测数值元素的每个元素是否都符合条件。 fill() 使用一个固定值来填充数组。 filter() 检测数值元素，并返回符合条件所有元素的数组。 find() 返回符合传入测试（函数）条件的数组元素。 findIndex() 返回符合传入测试（函数）条件的数组元素索引。 forEach() 数组每个元素都执行一次回调函数。 from() 通过给定的对象中创建一个数组。 includes() 判断一个数组是否包含一个指定的值。 indexOf() 搜索数组中的元素，并返回它所在的位置。 isArray() 判断对象是否为数组。 join() 把数组的所有元素放入一个字符串。 keys() 返回数组的可迭代对象，包含原始数组的键(key)。 lastIndexOf() 搜索数组中的元素，并返回它最后出现的位置。 map() 通过指定函数处理数组的每个元素，并返回处理后的数组。 pop() 删除数组的最后一个元素并返回删除的元素。 push() 向数组的末尾添加一个或更多元素，并返回新的长度。 reduce() 将数组元素计算为一个值（从左到右）。 reduceRight() 将数组元素计算为一个值（从右到左）。 reverse() 反转数组的元素顺序。 shift() 删除并返回数组的第一个元素。 slice() 选取数组的的一部分，并返回一个新数组。 some() 检测数组元素中是否有元素符合指定条件。 sort() 对数组的元素进行排序。 splice() 从数组中添加或删除元素。 toString() 把数组转换为字符串，并返回结果。 unshift() 向数组的开头添加一个或更多元素，并返回新的长度。 valueOf() 返回数组对象的原始值。 栈 定义 后进者先出，先进者后出，简称 后进先出（LIFO），这就是典型的栈结构。 在栈里，新元素都靠近栈顶，旧元素都接近栈底。 从栈的操作特性来看，是一种 操作受限的线性表，只允许在一端插入和删除数据。 不包含任何元素的栈称为空栈。 栈被用在编程语言的编译器和内存中保存变量、方法调用等，比如函数的调用栈、前端路由等。 实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344function Stack() &#123; this.data = []; /** * 添加一个（或几个）新元素到栈顶。 */ this.push = function (element) &#123; this.data.push(element); &#125;; /** * 移除栈顶的元素，同时返回被移除的元素。 */ this.pop = function () &#123; return this.data.pop(); &#125;; /** * 返回栈顶的元素，不对栈做任何修改。 */ this.peek = function () &#123; return this.data[this.data.length - 1]; &#125;; /** * 如果栈里没有任何元素就返回 true，否则返回 false */ this.isEmpty = function () &#123; return this.data.length === 1; &#125;; /** * 移除栈里的所有元素 */ this.clear = function () &#123; this.data = []; &#125;; /** * 返回栈里的元素个数。 */ this.size = function () &#123; return this.data.length; &#125;; // 打印栈里的元素 this.print = function () &#123; console.log(this.data.toString()); &#125;;&#125; 使用场景 举一个判断回文的例子： 12345678910111213141516function isPalindrome(word) &#123; var s = new Stack(); for (var i = 0; i &lt; word.length; i++) &#123; s.push(word[i]); &#125; var rword = &quot;&quot;; while (s.length() &gt; 0) &#123; rword += s.pop(); &#125; return word == rword;&#125;console.log(isPalindrome(&quot;level&quot;)); // trueconsole.log(isPalindrome(&quot;1001&quot;)); // trueconsole.log(isPalindrome(&quot;word&quot;)); // false 队列 定义 队列是遵循 FIFO（First In First Out，先进先出）原则的一组有序的项。 队列在尾部添加新元素，并从顶部移除元素。 最新添加的元素必须排在队列的末尾。 队列只有 入队 push() 和出队 pop()。 队列又可以细分为普通队列、优先队列、循环队列。 普通队列 实现 123456789101112131415161718192021222324252627282930313233343536373839// Queue类function Queue() &#123; this.data = []; // 向队列尾部添加元素 this.enqueue = function (element) &#123; this.data.push(element); &#125;; // 移除队列的第一个元素，并返回被移除的元素 this.dequeue = function () &#123; return this.data.shift(); &#125;; // 返回队列的第一个元素 this.front = function () &#123; return this.data[0]; &#125;; // 判断是否为空队列 this.isEmpty = function () &#123; return this.data.length === 0; &#125;; // 获取队列的长度 this.size = function () &#123; return this.data.length; &#125;; // 清空队列 this.clear = function () &#123; this.data = []; &#125;; // 打印队列里的元素 this.print = function () &#123; console.log(this.data.toString()); &#125;;&#125; 优先队列 定义优先队列中元素的添加和移除会根据优先级来处理 场景优先队列一个典型的场景就是机场登机，头等舱和商务舱乘客的优先级要高于经济舱乘客。 分类 最小优先队列，优先级值越小的元素在越前面 最大优先队列，优先级值越大的元素在越前面 实现实现最小优先队列 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// MinPriorityQueue类function MinPriorityQueue() &#123; this.data = []; // 向队列尾部添加元素 this.enqueue = function (element, priority) &#123; //若队列为空则直接将元素入列，否则需要比较该元素与其他元素的优先级 if (this.isEmpty()) &#123; this.data.push(&#123; element, priority &#125;); &#125; else &#123; let added = false; for (let i = 0, length = this.size(); i &lt; length; i++) &#123; if (priority &lt; this.data[i].priority) &#123; this.data.splice(i, 0, &#123; element, priority &#125;); added = true; break; &#125; &#125; if (!added) &#123; this.data.push(&#123; element, priority &#125;); &#125; &#125; &#125;; // 移除队列的第一个元素，并返回被移除的元素 this.dequeue = function () &#123; return this.data.shift(); &#125;; // 返回队列的第一个元素 this.front = function () &#123; return this.data[0]; &#125;; // 判断是否为空队列 this.isEmpty = function () &#123; return this.data.length === 0; &#125;; // 获取队列的长度 this.size = function () &#123; return this.data.length; &#125;; // 清空队列 this.clear = function () &#123; this.data = []; &#125;; // 打印队列里的元素 this.print = function () &#123; const info = this.data.map((item) =&gt; `$&#123;item.priority&#125;: $&#123;item.element&#125;`); console.log(info.toString()); &#125;;&#125; 实现最大优先队列 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// MaxPriorityQueue类function MaxPriorityQueue() &#123; this.data = []; // 向队列尾部添加元素 this.enqueue = function (element, priority) &#123; //若队列为空则直接将元素入列，否则需要比较该元素与其他元素的优先级 if (this.isEmpty()) &#123; this.data.push(&#123; element, priority &#125;); &#125; else &#123; let added = false; for (let i = 0, length = this.size(); i &lt; length; i++) &#123; if (priority &gt; this.data[i].priority) &#123; this.data.splice(i, 0, &#123; element, priority &#125;); added = true; break; &#125; &#125; if (!added) &#123; this.data.push(&#123; element, priority &#125;); &#125; &#125; &#125;; // 移除队列的第一个元素，并返回被移除的元素 this.dequeue = function () &#123; return this.data.shift(); &#125;; // 返回队列的第一个元素 this.front = function () &#123; return this.data[0]; &#125;; // 判断是否为空队列 this.isEmpty = function () &#123; return this.data.length === 0; &#125;; // 获取队列的长度 this.size = function () &#123; return this.data.length; &#125;; // 清空队列 this.clear = function () &#123; this.data = []; &#125;; // 打印队列里的元素 this.print = function () &#123; const info = this.data.map((item) =&gt; `$&#123;item.priority&#125;: $&#123;item.element&#125;`); console.log(info.toString()); &#125;;&#125; 循环队列循环队列的一个例子就是击鼓传花游戏（Hot Potato）。在这个游戏中，孩子们围城一个圆圈，击鼓的时候把花尽快的传递给旁边的人。某一时刻击鼓停止，这时花在谁的手里，谁就退出圆圈直到游戏结束。重复这个过程，直到最后一个孩子为最后胜利者。 基于上面的普通队列，实现这个游戏： 1234567891011121314151617181920212223242526272829303132333435// 实现击鼓传花function hotPotato(nameList, num) &#123; var queue = new Queue(); for (var i = 0; i &lt; nameList.length; i++) &#123; queue.enqueue(nameList[i]); &#125; var eliminated = &quot;&quot;; while (queue.size() &gt; 1) &#123; // 循环 num 次，队首出来去到队尾 for (var i = 0; i &lt; num; i++) &#123; queue.enqueue(queue.dequeue()); &#125; // 循环 num 次过后，移除当前队首的元素 eliminated = queue.dequeue(); console.log(`$&#123;eliminated&#125; 在击鼓传花中被淘汰！`); &#125; // 最后只剩一个元素 return queue.dequeue();&#125;// 测试var nameList = [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;, &quot;马六&quot;, &quot;牛七&quot;];var winner = hotPotato(nameList, 5);console.log(`最后的胜利者是：$&#123;winner&#125;`);// =&gt; 牛七 在击鼓传花中被淘汰！// =&gt; 张三 在击鼓传花中被淘汰！// =&gt; 王五 在击鼓传花中被淘汰！// =&gt; 马六 在击鼓传花中被淘汰！// =&gt; 最后的胜利者是：李四 链表 定义链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的，它是通过 指针 将 零散的内存块 串连起来的。 每个元素由一个存储元素本身的 节点和一个指向下一个元素的 指针组成。 简单的链接结构图: 上图中，data 中保存着数据，next 保存着下一个链表的指针。 上图中，我们说 data2 跟在 data1 后面，而不是说 data2 是链表中的第二个元素。需要注意的是，我们将链表的尾元素指向了 null 节点，表示链接结束的位置。 特点 低效的访问： 链表是通过指针将零散的内存块串连起来的。 所以链表不支持 随机访问，如果要找特定的项，只能从头开始遍历，直到找到某个项。 所以访问的时间复杂度为 O(n)。 高效的插入和删除。 链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移节点，因为链表的存储空间本身就不是连续的，只需要考虑相邻节点的指针改变。 所以，在链表中插入和删除一个数据是非常快速的，时间复杂度为 O(1)。 分类常见列表可以分为三类： 单向链表 双向链表 循环链表 单向链表 定义 由于链表的起始点的确定比较麻烦，因此很多链表的实现都会在链表的最前面添加一个特殊的节点，称为 头节点，表示链表的头部。 特点 只能单向遍历，操作灵活性不高 实现 需要实现的以下常用操作： 方法名 描述 append(element) 尾部添加元素。 insert(position, element) 特定位置插入一个新的项。 removeAt(position) 特定位置移除一项。 remove(element) 移除一项。 indexOf(element) 返回元素在链表中的索引。如果链表中没有该元素则返回 -1。 isEmpty() 如果链表中不包含任何元素，返回 true，如果链表长度大于 0，返回 false。 size() 返回链表包含的元素个数，与数组的 length 属性类似。 getHead() 返回链表的第一个元素。 toString() 由于链表使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString() 方法，让其只输出元素的值。 print() 打印链表的所有元素。 list() 获取整个链表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157// 单链表function SinglyLinkedList() &#123; // 节点 function Node(element) &#123; this.element = element; // 当前节点的元素 this.next = null; // 下一个节点指针 &#125; let length = 0; // 链表的长度 let head = null; // 链表的头节点 // 向链表尾部添加一个新的节点 this.append = function (element) &#123; let node = new Node(element); // 判断是否为空链表 if (head === null) &#123; // 是空链表，就把当前节点作为头部节点 head = node; &#125; else &#123; let currentNode = head; // 从 head 开始一直找到最后一个 node while (currentNode.next) &#123; // 后面还有 node currentNode = currentNode.next; &#125; // 把最后一个节点的 next 指针指向新的节点 currentNode.next = node; &#125; // 链表的长度加 1 length++; &#125;; // 向链表特定位置插入一个新节点 this.insert = function (position, element) &#123; if (position &lt; 0 || position &gt; length) &#123; // 越界 return false; &#125; else &#123; let node = new Node(element); let index = 0; let currentNode = head; let previousNode; // 在最前插入节点 if (position === 0) &#123; node.next = currentNode; head = node; &#125; else &#123; // 循环找到位置 while (index &lt; position) &#123; index++; previousNode = currentNode; currentNode = currentNode.next; &#125; // 把前一个节点的指针指向新节点，新节点的指针指向当前节点，保持连接性 previousNode.next = node; node.next = currentNode; &#125; length++; return true; &#125; &#125;; // 从链表的特定位置移除一项 this.removeAt = function (position) &#123; if ((position &lt; 0 || position &gt;= length) || length === 0) &#123; // 越界 return false; &#125; else &#123; let currentNode = head; let index = 0; let previousNode; if (position === 0) &#123; head = currentNode.next; &#125; else &#123; // 循环找到位置 while (index &lt; position) &#123; index++; previousNode = currentNode; currentNode = currentNode.next; &#125; // 把当前节点的 next 指针 指向 当前节点的 next 指针，即是 删除了当前节点 previousNode.next = currentNode.next; &#125; length--; return true; &#125; &#125;; // 从链表中移除指定项 this.remove = function (element) &#123; let index = this.indexOf(element); return this.removeAt(index); &#125;; // 返回元素在链表的索引，如果链表中没有该元素则返回 -1 this.indexOf = function (element) &#123; let currentNode = head; let index = 0; while (currentNode) &#123; if (currentNode.element === element) &#123; return index; &#125; index++; currentNode = currentNode.next; &#125; return -1; &#125;; // 如果链表中不包含任何元素，返回 true，如果链表长度大于 0，返回 false this.isEmpty = function () &#123; return length === 0; &#125;; // 返回链表包含的元素个数，与数组的 length 属性类似 this.size = function () &#123; return length; &#125;; // 获取链表头部元素 this.getHead = function () &#123; return head.element; &#125;; // 由于链表使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString() 方法，让其只输出元素的值 this.toString = function (cur) &#123; let currentNode = cur || head; let string = &quot;&quot;; while (currentNode) &#123; string += &quot;,&quot; + currentNode.element; currentNode = currentNode.next; &#125; return string.slice(1); &#125;; // 打印链表数据 this.print = function (cur) &#123; console.log(this.toString(cur)); &#125;; // 获取整个链表 this.list = function () &#123; console.log(&quot;head: &quot;, head); return head; &#125;;&#125; 双向链表上面说的单向链表只有一个方向，节点只有一个后继指针 next 指向后面的节点。 最为对比，双向链表就有两个方向的指针，每个节点不止有一个后继指针 next 指向后面的节点，还有一个前驱指针 prev 指向前面的节点。 与单向列表比较 内存空间比单向链表大，双向链表需要额外的两个空间来存储后继结点和前驱结点的地址 可以双向操作，灵活性更高，查找/插入/删除更高效 实现在实现了单向链表后，双向链表就没那么难了，直接上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216// 创建双向链表 DoublyLinkedList 类function DoublyLinkedList() &#123; function Node(element) &#123; this.element = element; //当前节点的元素 this.next = null; //下一个节点指针 this.previous = null; //上一个节点指针 &#125; let length = 0; // 链表长度 let head = null; // 链表头部 let tail = null; // 链表尾部 // 向链表尾部添加一个新的项 this.append = function (element) &#123; let node = new Node(element); let currentNode = tail; // 判断是否为空链表 if (currentNode === null) &#123; // 空链表 head = node; tail = node; &#125; else &#123; currentNode.next = node; node.previous = currentNode; tail = node; &#125; length++; &#125;; // 向链表特定位置插入一个新的项 this.insert = function (position, element) &#123; if (position &lt; 0 || position &gt; length) &#123; // 越界 return false; &#125; else &#123; let node = new Node(element); let index = 0; let currentNode = head; let previousNode; if (position === 0) &#123; //在头部添加 if (!head) &#123; head = node; tail = node; &#125; else &#123; node.next = currentNode; currentNode.previous = node; head = node; &#125; &#125; else if (position === length) &#123; //在末尾添加 this.append(element); return true; &#125; else if (length - 1 - position &gt; position) &#123; //position离head更近 while (index &lt; position) &#123; index++; previousNode = currentNode; currentNode = currentNode.next; &#125; previousNode.next = node; node.next = currentNode; node.previous = previousNode; currentNode.previous = node; &#125; else &#123; //position离tail更近，则从tail开始向前查找 index = length - 1; currentNode = tail; while (index &gt; position) &#123; index--; currentNode = currentNode.previous; previousNode = currentNode.previous; &#125; previousNode.next = node; node.next = currentNode; node.previous = previousNode; currentNode.previous = node; &#125; length++; return true; &#125; &#125;; // 从链表的特定位置移除一项 this.removeAt = function (position) &#123; if (position &lt; 0 || position &gt;= length || length === 0) &#123; // 越界 return false; &#125; else &#123; let currentNode = head; let index = 0; let previousNode; if (position === 0) &#123; // 移除第一项 if (length === 1) &#123; head = null; tail = null; &#125; else &#123; head = currentNode.next; head.previous = null; &#125; &#125; else if (position === length - 1) &#123; // 移除最后一项 if (length === 1) &#123; head = null; tail = null; &#125; else &#123; currentNode = tail; tail = currentNode.previous; tail.next = null; &#125; &#125; else if (length - 1 - position &gt; position) &#123; //position离head更近 while (index &lt; position) &#123; index++; previousNode = currentNode; currentNode = currentNode.next; &#125; previousNode.next = currentNode.next; currentNode.next.previous = previousNode; &#125; else &#123; //position离tail更近，则从tail开始向前查找 index = length - 1; currentNode = tail; while (index &gt; position) &#123; index--; currentNode = currentNode.previous; previousNode = currentNode.previous; &#125; previousNode.next = currentNode.next; currentNode.next.previous = previousNode; &#125; length--; return true; &#125; &#125;; // 从链表中移除指定项 this.remove = function (element) &#123; let index = this.indexOf(element); return this.removeAt(index); &#125;; // 返回元素在链表的索引，如果链表中没有该元素则返回 -1 this.indexOf = function (element) &#123; let currentNode = head; let index = 0; let currentNode2 = tail; let index2 = length - 1; while (currentNode) &#123; if (currentNode.element === element) &#123; return index; &#125; if (currentNode2.element === element) &#123; return index2; &#125; index++; currentNode = currentNode.next; index2--; currentNode2 = currentNode2.previous; &#125; return -1; &#125;; // 如果链表中不包含任何元素，返回 true ，如果链表长度大于 0 ，返回 false this.isEmpty = function () &#123; return length == 0; &#125;; // 返回链表包含的元素个数，与数组的 length 属性类似 this.size = function () &#123; return length; &#125;; // 获取链表头部元素 this.getHead = function () &#123; return head.element; &#125;; // 由于链表使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString() 方法，让其只输出元素的值 this.toString = function () &#123; let currentNode = head; let string = &quot;&quot;; while (currentNode) &#123; string += &quot;,&quot; + currentNode.element; currentNode = currentNode.next; &#125; return string.slice(1); &#125;; this.print = function () &#123; console.log(this.toString()); &#125;; // 获取整个链表 this.list = function () &#123; console.log(&quot;head: &quot;, head); return head; &#125;;&#125; 单向链表 VS 双向链表 性能对比123456789101112131415161718let singlyList = new SinglyLinkedList();console.time(&quot;singlyList-time&quot;);for (let i = 0; i &lt; 100000; i++) &#123; singlyList.insert(i, &quot;Tom&quot; + i);&#125;console.timeEnd(&quot;singlyList-time&quot;);let doublyList = new DoublyLinkedList();console.time(&quot;doublyLinked-time&quot;);for (let i = 0; i &lt; 100000; i++) &#123; doublyList.insert(i, &quot;Tom&quot; + i);&#125;console.timeEnd(&quot;doublyList-time&quot;);// &gt;&gt; singlyList-time: 34532.815ms// &gt;&gt; doublyList-time: 64.111ms 结论： 同样插入100000条数据，双向链表的速度优势明显； 循环链表循环链表是一种特殊的单链表。 循环链表和单链表相似，节点类型都是一样。 唯一的区别是，循环链表的尾节点指向了头节点，形成了一个循环。如下图所示: 实现基于单向链表实现循环链表，主要区别在于要将循环链表的尾节点指向头节点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170// 循环链表function CircularLinkedList() &#123; // 节点 function Node(element) &#123; this.element = element; // 当前节点的元素 this.next = null; // 下一个节点指针 &#125; let length = 0; // 链表的长度 let head = null; // 链表的头节点 let tail = null; // 链表的尾节点 // 向链表尾部添加一个新的节点 this.append = function (element) &#123; let node = new Node(element); // 判断是否为空链表 if (head === null) &#123; // 是空链表，就把当前节点作为头部节点 head = node; head.next = head; tail = head;//区别于单向链表的点 &#125; else &#123; let currentNode = head; // 从 head 开始一直找到最后一个 node while (currentNode.next !== head) &#123; // 后面还有 node currentNode = currentNode.next; &#125; // 把最后一个节点的 next 指针指向新的节点 currentNode.next = node; // 把新插入的节点的next指向head node.next = head; tail = node; // 把新加入的节点设为尾节点 &#125; // 链表的长度加 1 length++; &#125;; // 向链表特定位置插入一个新节点 this.insert = function (position, element) &#123; if (position &lt; 0 || position &gt; length) &#123; // 越界 return false; &#125; else if (length === 0) &#123; //空链表时使用append插入第一个节点 this.append(element); &#125; else &#123; let node = new Node(element); let index = 0; let currentNode = head; let previousNode; // 在最前插入节点 if (position === 0) &#123; node.next = head; head = node; tail.next = head; //区别于单向链表的点 &#125; else &#123; // 循环找到位置 while (index &lt; position) &#123; index++; previousNode = currentNode; currentNode = currentNode.next; &#125; // 把前一个节点的指针指向新节点，新节点的指针指向当前节点，保持连接性 previousNode.next = node; node.next = currentNode; &#125; length++; return true; &#125; &#125;; // 从链表的特定位置移除一项 this.removeAt = function (position) &#123; if (position &lt; 0 || position &gt;= length || length === 0) &#123; // 越界 return false; &#125; else &#123; let currentNode = head; let index = 0; let previousNode; if (position === 0) &#123; head = head.next; tail.next = head; //区别于单向链表的点 &#125; else &#123; // 循环找到位置 while (index &lt; position) &#123; index++; previousNode = currentNode; currentNode = currentNode.next; &#125; // 把当前节点的 next 指针 指向 当前节点的 next 指针，即是 删除了当前节点 previousNode.next = currentNode.next; &#125; length--; return true; &#125; &#125;; // 从链表中移除指定项 this.remove = function (element) &#123; let index = this.indexOf(element); return this.removeAt(index); &#125;; // 返回元素在链表的索引，如果链表中没有该元素则返回 -1 this.indexOf = function (element) &#123; let currentNode = head; let index = 0; while (currentNode) &#123; if (currentNode.element === element) &#123; return index; &#125; index++; currentNode = currentNode.next; &#125; return -1; &#125;; // 如果链表中不包含任何元素，返回 true，如果链表长度大于 0，返回 false this.isEmpty = function () &#123; return length === 0; &#125;; // 返回链表包含的元素个数，与数组的 length 属性类似 this.size = function () &#123; return length; &#125;; // 获取链表头部元素 this.getHead = function () &#123; return head.element; &#125;; // 由于链表使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString() 方法，让其只输出元素的值 this.toString = function () &#123; let currentNode = head; let string = &quot;&quot;; let index = 0; while (currentNode &amp;&amp; index &lt; length) &#123; string += &quot;,&quot; + currentNode.element; currentNode = currentNode.next; index++; &#125; return string.slice(1); &#125;; // 打印链表数据 this.print = function (cur) &#123; console.log(this.toString(cur)); &#125;; // 获取整个链表 this.list = function () &#123; console.log(&quot;head: &quot;, head); return head; &#125;;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kobingogo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kobingogo.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"Nodejs读取控制台输入(stdin)的方法总结","slug":"node-node-stdin","date":"2019-09-23T14:35:46.000Z","updated":"2022-02-18T02:31:03.811Z","comments":true,"path":"node-node-stdin/","link":"","permalink":"https://kobingogo.github.io/node-node-stdin/","excerpt":"在用 Nodejs 写 CLI 应用或者做OJ的时候经常会遇到要从 stdin 读取输入的情况，这里总结了几种不依赖第三方库来按行读取输入的方法。","text":"在用 Nodejs 写 CLI 应用或者做OJ的时候经常会遇到要从 stdin 读取输入的情况，这里总结了几种不依赖第三方库来按行读取输入的方法。 Readline基础使用 优点：简洁方便，平台无关。可用于编写 REPL 应用。 缺点：某些 OJ 的 node 版本可能不支持readline，对此请参考OJ专用的方法。 123456789require(&quot;readline&quot;) .createInterface(&#123; input: process.stdin, output: process.stdout, &#125;) .on(&quot;line&quot;, function (line) &#123; console.log(&quot;the input is: &quot;, line.trim()); this.close(); &#125;); 实现互动问答 优点：便于引导用户正确输入。 1234567891011121314151617181920212223242526const rl = require(&quot;readline&quot;).createInterface(&#123; input: process.stdin, output: process.stdout,&#125;);const wait = (ms) =&gt; new Promise((resolve) =&gt; setTimeout(resolve, ms));const question = (query) =&gt; new Promise((resolve) =&gt; rl.question(query, (answer) =&gt; resolve(answer)));(async () =&gt; &#123; let answer = await question(&quot;你觉得node是最棒的吗？ &quot;); console.log(`您的答案是：$&#123;answer&#125;`); answer = await question(&quot;async/await好不好用啊 &quot;); console.log(`您的答案是：$&#123;answer&#125;`); answer = await question(&quot;等待多少秒继续执行？ &quot;); rl.pause(); await wait(parseInt(answer) * 1000); rl.resume(); while ((await question(&quot;输入bye退出 &quot;)).trim() !== &quot;bye&quot;); console.log(&quot;Good day.&quot;); rl.close();&#125;)(); process.stdin1234567891011121314151617181920process.stdin.setEncoding(&quot;utf8&quot;);process.stdin.on(&quot;readable&quot;, () =&gt; &#123; var chunk = process.stdin.read(); if (typeof chunk === &quot;string&quot;) &#123; chunk = chunk.slice(0, -1); process.stdout.write(`stringLength:$&#123;chunk.length&#125;\\n`); &#125; if (chunk === &quot;&quot;) &#123; process.stdin.emit(&quot;end&quot;); return; &#125; if (chunk !== null) &#123; process.stdout.write(`data: $&#123;chunk&#125;\\n`); &#125;&#125;);process.stdin.on(&quot;end&quot;, () =&gt; &#123; process.stdout.write(&quot;end&quot;);&#125;);","categories":[{"name":"node","slug":"node","permalink":"https://kobingogo.github.io/categories/node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://kobingogo.github.io/tags/node/"},{"name":"stdin","slug":"stdin","permalink":"https://kobingogo.github.io/tags/stdin/"}]},{"title":"promise高级用法","slug":"javascript-promise高级用法","date":"2019-08-02T22:49:39.000Z","updated":"2022-02-18T02:31:03.811Z","comments":true,"path":"javascript-promise高级用法/","link":"","permalink":"https://kobingogo.github.io/javascript-promise%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/","excerpt":"对于Promise高级用法的使用汇总，包括多个promise串行执行、多个promise并行执行以及限制并行等","text":"实现多个promise串行执行在 async/await 以前 Promise 串行执行还是比较麻烦的，除了依赖 async、promise-fun 等工具库，我们还可以使用 Array.prototype.reduce() 自己实现一个简单的串行Promise了： 123456789/** * 核心代码 **/function runPromiseByQueue(myPromises) &#123; myPromises.reduce( (previousPromise, nextPromise) =&gt; previousPromise.then(() =&gt; nextPromise()), Promise.resolve() );&#125; 当上一个 Promise 开始执行（previousPromise.then），当其执行完毕后再调用下一个 Promise，并作为一个新 Promise 返回，下次迭代就会继续这个循环。 举个例子： 12345678910111213141516171819const createPromise = (time, id) =&gt; () =&gt; new Promise((solve) =&gt; &#123; console.time(&quot;time&quot; + id); setTimeout(() =&gt; &#123; console.log(&quot;promise&quot;, id); console.timeEnd(&quot;time&quot; + id); if (id == 3) &#123; console.timeEnd(&quot;timeall&quot;); &#125; solve(); &#125;, time); &#125;);console.time(&quot;timeall&quot;);runPromiseByQueue([ createPromise(3000, 1), createPromise(2000, 2), createPromise(1000, 3),]); 最后的输出结果如下： 说明确实是串行依次执行了三个promise。 实现多个promise并行执行这个目前ES官方已经实现了promise.all/promise.allSettled/promise.race等方法，以promise.all()为例： 12345678910const promise1 = Promise.resolve(3);const promise2 = 42;const promise3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 100, &#x27;foo&#x27;);&#125;);Promise.all([promise1, promise2, promise3]).then((values) =&gt; &#123; console.log(values);&#125;);// expected output: Array [3, 42, &quot;foo&quot;] Promise.all可以保证，promises数组中所有promise对象都达到resolve状态，才执行then回调。 那么如果promises数组是包含几十个甚至几百个http请求，直接用Promise.all的话，会瞬间发出所有的http请求，造成请求拥堵甚至失败。 这时候就需要对Promise.all做并发限制。 promise.all并行限制首先需要明白的是，promise并不是在调用Promise.all才执行，而是在实例化promise对象的时候就执行了，在理解这一点的基础上，就可以从promise实例化上下手实现并发限制。具体实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940/** * Promise并发限制 * @param &#123;Array&#125; array * @param &#123;Number&#125; poolLimit */function LimitPromiseAll(array, poolLimit) &#123; let i = 0; //待执行元素的数组下标 const results = []; // promise.all的promises数组 const executing = []; // 存放正在执行 const enqueue = function () &#123; // 边界处理，array为空数组 if (i === array.length) &#123; return Promise.resolve(); &#125; // 每调一次enqueue，初始化一个promise const fn = array[i++]; // 如果curPromise不是Promise对象。则转成Promise 对象 // 等同于 const p = Promise.resolve(fn()); const p = Promise.resolve().then(() =&gt; fn()); // 放入promises数组 results.push(p); // promise执行完毕，从executing数组中删除 const e = p.then((res) =&gt; &#123; executing.splice(executing.indexOf(e), 1); &#125;); //正在执行的promise, 插入executing数组 executing.push(e); // 当executing数组中promise数量低于poolLimit，就实例化新的promise并执行, // 否则调用promise.race()获取到最快执行完成的promise（将其从executing数组删除，便可继续后续执行） let r = Promise.resolve(); if (executing.length &gt;= poolLimit) &#123; r = Promise.race(executing); &#125; // 递归，直到遍历完array return r.then(() =&gt; enqueue()); &#125;; return enqueue().then(() =&gt; Promise.all(results));&#125; 使用例子： 1234567891011121314151617181920console.time(&quot;all-time&quot;);const timeout = (i) =&gt; new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(i), i));LimitPromiseAll( [ timeout.bind(null, 1000), timeout.bind(null, 5000), timeout.bind(null, 2000), timeout.bind(null, 4000), ], 2).then((res) =&gt; &#123; console.log(res); console.timeEnd(&quot;all-time&quot;);&#125;);/**输出： [ 1000, 5000, 2000, 4000 ] all-time: 7037.285ms **/ 其实，目前社区里已经有一些开源包实现了这个功能，比如async-pool、es6-promise-pool、p-limit。上述实现代码也是参考async-pool的实现。 使用Promise实现fetch超时处理因为fetch默认没有请求超时设置，以及中断请求操作，在这里我们尝试使用Promise结合AbortController封装一个简单的请求超时和中断请求的fetch。 AbortController接口代表一个控制器对象，允许你在需要时中止一个或多个DOM请求目前IE外的主流浏览器基本都实现了AbortController功能； AbortController的浏览器兼容情况： 核心代码如下： 12345678910111213141516171819202122232425262728293031323334353637function TimeoutFetch(params) &#123; this.controller = new AbortController(); //实例化AbortController this.signal = this.controller.signal; //signal用来 abort 请求 this.timeout = 5000; //默认超时时间&#125;/** * 设置超时时间 */TimeoutFetch.prototype.setTimeout = function (ms) &#123; this.timeout = ms;&#125;;/** * 封装fetch请求 */TimeoutFetch.prototype.fetch = function (url, data = &#123;&#125;) &#123; const timeoutPromise = new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#123; code: 1, msg: `timeout of $&#123;this.timeout&#125;ms`, &#125;); this.controller.abort(); &#125;, this.timeout); &#125;); const fetchPromise = fetch(url, &#123; signal: this.signal, //设置信号 ...data, &#125;); return Promise.race([fetchPromise, timeoutPromise]);&#125;;/** * 手动中断请求 */TimeoutFetch.prototype.abort = function () &#123; this.controller.abort();&#125;; 使用例子： 12345const timeoutFetch = new TimeoutFetch();timeoutFetch.setTimeout(30);timeoutFetch.fetch(&quot;http://localhost/data&quot;).then((res) =&gt; &#123; console.log(res);&#125;);","categories":[{"name":"JavaScript","slug":"javascript","permalink":"https://kobingogo.github.io/categories/javascript/"}],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://kobingogo.github.io/tags/javascript/"},{"name":"promise","slug":"promise","permalink":"https://kobingogo.github.io/tags/promise/"}]},{"title":"通过iframe下载文件如何判断下载完成","slug":"javascript-iframe-download-complete","date":"2019-07-06T22:24:20.000Z","updated":"2022-02-18T02:31:03.811Z","comments":true,"path":"javascript-iframe-download-complete/","link":"","permalink":"https://kobingogo.github.io/javascript-iframe-download-complete/","excerpt":"当使用 iframe 作为文件下载的载体时，如何知道文件已经下载完毕。现有的 iframe 的 onLoad 方法具有兼容性问题，在 chrome、IE 下无法监听 onLoad 事件监听文件下载完毕，因为 onLoad 事件本身也是对 iframe 中的 html 结构的加载进度监听。","text":"问题当使用 iframe 作为文件下载的载体时，如何知道文件已经下载完毕。现有的 iframe 的 onLoad 方法具有兼容性问题，在 chrome、IE 下无法监听 onLoad 事件监听文件下载完毕，因为 onLoad 事件本身也是对 iframe 中的 html 结构的加载进度监听。 123456789var url = &quot;http://www.example.com/file.zip&quot;;var iframe = document.createElement(&quot;iframe&quot;);iframe.src = url;iframe.style.display = &quot;none&quot;;iframe.onload = function () &#123; console.debug(&quot;start downloading...&quot;); document.body.removeAttribute(iframe);&#125;;document.body.appendChild(iframe); 当 chrome、IE 下时，如果 HTTP 文件头中包含 Content-disposition: attachment；即下载文件的链接的话，不会触发这个事件 onLoad 事件。 这里说一下 Content-disposition： Content-disposition 是 MIME 协议的扩展，MIME 协议指示 MIME 用户代理如何显示附加的文件。Content-disposition其实可以控制用户请求所得的内容存为一个文件的时候提供一个默认的文件名，文件直接在浏览器上显示或者在访问时弹出文件下载对话框。 Content-Disposition为属性名disposition-type是以什么方式下载，如attachment为以附件方式下载disposition-parm为默认保存时的文件名服务端向客户端游览器发送文件时，如果是浏览器支持的文件类型，一般会默认使用浏览器打开，比如txt、jpg等，会直接在浏览器中显示 注意事项： 1.当代码里面使用Content-Disposition来确保浏览器弹出下载对话框的时候。 response.addHeader(&#39;Content-Disposition&#39;, &#39;attachment&#39;);一定要确保没有做过关于禁止浏览器缓存的操作。 代码如下: response.setHeader(&#39;Pragma&#39;, &#39;No-cache&#39;); response.setHeader(&#39;Cache-Control&#39;, &#39;No-cache&#39;); response.setDateHeader(&#39;Expires&#39;, 0); 不然会发现下载功能在opera和firefox里面好好的没问题，在IE下面就是不行 解决思路一：利用 cookie后端将文件下载进度放在 cookie 中，通过轮询 cookie 的方式，对文件下载进度进行获取，判断文件是否已经下载完毕。 缺陷： 1、需要后端配合 2、如果客户端禁用了 cookie，则该方案完全失效；在无痕浏览模式下，读取 cookie，甚至代码报错。 解决思路二：添加 header 配置123456// 不让浏览器自动检测文件类型// 说明资料：http://drops.wooyun.org/tips/1166response.addHeader(&quot;X-Content-Type-Options&quot;, &quot;nosniff&quot;);// 提示浏览器不让其在frame或iframe中加载资源的文件内容// https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Optionsresponse.addHeader(&quot;X-Frame-Options&quot;, &quot;deny&quot;); 但是在 chorome v58 版本将 header 的 X-Frame-Options 设为 deny 会报错。并且下载的时候网络连接会出现失败。 解决思路三：轮询监听 readyState定时器轮询监听 readyState 的状态，如果是 complete 或者 interactive 说明文件加载完成。 12345678910111213var timer = setInterval(function () &#123; iframe = document.getElementById(&quot;iframedownload&quot;); var iframeDoc = iframe.contentDocument || iframe.contentWindow.document; // Check if loading is complete if ( iframeDoc.readyState == &quot;complete&quot; || iframeDoc.readyState == &quot;interactive&quot; ) &#123; loadingOff(); clearInterval(timer); return; &#125;&#125;, 4000); 总结第三种方法比较好，因为不需要后端进行配合，且不依赖与 cookie 等变量带来的问题，能更好实现我们的需求。","categories":[{"name":"JavaScript","slug":"javascript","permalink":"https://kobingogo.github.io/categories/javascript/"}],"tags":[{"name":"iframe","slug":"iframe","permalink":"https://kobingogo.github.io/tags/iframe/"},{"name":"download","slug":"download","permalink":"https://kobingogo.github.io/tags/download/"}]},{"title":"前端如何学数据结构与算法 - 一篇讲完经典排序算法","slug":"algorithms-sort-knowledge","date":"2019-06-30T16:48:08.000Z","updated":"2022-02-18T02:31:03.807Z","comments":true,"path":"algorithms-sort-knowledge/","link":"","permalink":"https://kobingogo.github.io/algorithms-sort-knowledge/","excerpt":"文中包含了 十大经典排序算法 的思想、代码实现、一些例子、复杂度分析、动画、还有算法可视化工具。","text":"文中包含了 十大经典排序算法 的思想、代码实现、一些例子、复杂度分析、动画、还有算法可视化工具。 1. 前言 算法为王。 想学好前端，先练好内功，内功不行，就算招式练的再花哨，终究成不了高手；只有内功深厚者，前端之路才会走得更远。 笔者写的 JavaScript 数据结构与算法之美 系列用的语言是 JavaScript ，旨在入门数据结构与算法和方便以后复习。 文中包含了 十大经典排序算法 的思想、代码实现、一些例子、复杂度分析、动画、还有算法可视化工具。 这应该是目前最全的 JavaScript 十大经典排序算法 的讲解了吧。 2. 如何分析一个排序算法复杂度分析是整个算法学习的精髓。 时间复杂度: 一个算法执行所耗费的时间。 空间复杂度: 运行完一个程序所需内存的大小。 时间和空间复杂度的详解，请看 JavaScript 数据结构与算法之美 - 时间和空间复杂度。 学习排序算法，我们除了学习它的算法原理、代码实现之外，更重要的是要学会如何评价、分析一个排序算法。 分析一个排序算法，要从 执行效率、内存消耗、稳定性 三方面入手。 2.1 执行效率1. 最好情况、最坏情况、平均情况时间复杂度 我们在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度。 除此之外，你还要说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。 2. 时间复杂度的系数、常数 、低阶 我们知道，时间复杂度反应的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。 但是实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。 3. 比较次数和交换（或移动）次数 这一节和下一节讲的都是基于比较的排序算法。基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。 所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。 2.2 内存消耗也就是看空间复杂度。 还需要知道如下术语： 内排序：所有排序操作都在内存中完成； 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； 原地排序：原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。 2.3 稳定性 稳定：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。 比如： a 原本在 b 前面，而 a = b，排序之后，a 仍然在 b 的前面； 不稳定：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序改变。 比如：a 原本在 b 的前面，而 a = b，排序之后， a 在 b 的后面； 3. 十大经典排序算法3.1 冒泡排序（Bubble Sort） 思想 冒泡排序只会操作相邻的两个数据。 每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。 一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。 特点 优点：排序算法的基础，简单实用易于理解。 缺点：比较次数多，效率较低。 实现 const bubbleSort = arr =&gt; &#123; console.time(&#39;改进前冒泡排序耗时&#39;); const length = arr.length; if (length &lt;= 1) return; for (let i = 0; i &lt; length - 1; i++) &#123; for (let j = 0; j &lt; length - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; const temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; console.log(&#39;改进前 arr :&#39;, arr); console.timeEnd(&#39;改进前冒泡排序耗时&#39;); &#125;; 优化：当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。 const bubbleSort2 = arr =&gt; &#123; console.time(&#39;改进后冒泡排序耗时&#39;); const length = arr.length; if (length &lt;= 1) return; for (let i = 0; i &lt; length - 1; i++) &#123; let hasChange = false; for (let j = 0; j &lt; length - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; const temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; hasChange = true; &#125; &#125; if (!hasChange) break; &#125; console.log(&#39;改进后 arr :&#39;, arr); console.timeEnd(&#39;改进后冒泡排序耗时&#39;); &#125;; 测试 // 测试 const arr = [7, 8, 4, 5, 6, 3, 2, 1]; bubbleSort(arr); // 改进前 arr : [1, 2, 3, 4, 5, 6, 7, 8] // 改进前冒泡排序耗时: 0.43798828125ms const arr2 = [7, 8, 4, 5, 6, 3, 2, 1]; bubbleSort2(arr2); // 改进后 arr : [1, 2, 3, 4, 5, 6, 7, 8] // 改进后冒泡排序耗时: 0.318115234375ms 分析 第一，冒泡排序是原地排序算法吗 ？ 冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。 第二，冒泡排序是稳定的排序算法吗 ？ 在冒泡排序中，只有交换才可以改变两个元素的前后顺序。 为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序。 所以冒泡排序是稳定的排序算法。 第三，冒泡排序的时间复杂度是多少 ？ 最佳情况：T(n) = O(n)，当数据已经是正序时。 最差情况：T(n) = O(n2)，当数据是反序时。 平均情况：T(n) = O(n2)。 动画 3.2 插入排序（Insertion Sort）插入排序又为分为 直接插入排序 和优化后的 拆半插入排序 与 希尔排序，我们通常说的插入排序是指直接插入排序。 一、直接插入 思想 一般人打扑克牌，整理牌的时候，都是按牌的大小（从小到大或者从大到小）整理牌的，那每摸一张新牌，就扫描自己的牌，把新牌插入到相应的位置。 插入排序的工作原理：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 步骤 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤 2 ~ 5。 实现 const insertionSort = array =&gt; &#123; const len = array.length; if (len &lt;= 1) return let preIndex, current; for (let i = 1; i &lt; len; i++) &#123; preIndex = i - 1; current = array[i]; while (preIndex &gt;= 0 &amp;&amp; array[preIndex] &gt; current) &#123; array[preIndex + 1] = array[preIndex]; preIndex--; &#125; if (preIndex + 1 != i) &#123; array[preIndex + 1] = current; console.log(&#39;array :&#39;, array); &#125; &#125; return array; &#125;; 测试 // 测试 const array = [5, 4, 3, 2, 1]; console.log(&quot;原始 array :&quot;, array); insertionSort(array); // 原始 array: [5, 4, 3, 2, 1] // array: [4, 5, 3, 2, 1] // array: [3, 4, 5, 2, 1] // array: [2, 3, 4, 5, 1] // array: [1, 2, 3, 4, 5] 分析 第一，插入排序是原地排序算法吗 ？ 插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，所以，这是一个原地排序算法。 第二，插入排序是稳定的排序算法吗 ？ 在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。 第三，插入排序的时间复杂度是多少 ？ 最佳情况：T(n) = O(n)，当数据已经是正序时。 最差情况：T(n) = O(n2)，当数据是反序时。 平均情况：T(n) = O(n2)。 动画 二、拆半插入 插入排序也有一种优化算法，叫做拆半插入。 思想 折半插入排序是直接插入排序的升级版，鉴于插入排序第一部分为已排好序的数组，我们不必按顺序依次寻找插入点，只需比较它们的中间值与待插入元素的大小即可。 步骤 取 0 ~ i-1 的中间点 ( m = (i-1) &gt;&gt; 1 )，array[i] 与 array[m] 进行比较，若 array[i] &lt; array[m]，则说明待插入的元素 array[i] 应该处于数组的 0 ~ m 索引之间；反之，则说明它应该处于数组的 m ~ i-1 索引之间。 重复步骤 1，每次缩小一半的查找范围，直至找到插入的位置。 将数组中插入位置之后的元素全部后移一位。 在指定位置插入第 i 个元素。 注：x &gt;&gt; 1 是位运算中的右移运算，表示右移一位，等同于 x 除以 2 再取整，即 x &gt;&gt; 1 == Math.floor(x/2) 。 const binaryInsertionSort = array =&gt; &#123; const len = array.length; if (len &lt;= 1) return; let current, i, j, low, high, m; for (i = 1; i &lt; len; i++) &#123; low = 0; high = i - 1; current = array[i]; while (low &lt;= high) &#123; m = (low + high) &gt;&gt; 1; if (array[i] &gt;= array[m]) &#123; low = m + 1; &#125; else &#123; high = m - 1; &#125; &#125; for (j = i; j &gt; low; j--) &#123; array[j] = array[j - 1]; console.log(&#39;array2 :&#39;, JSON.parse(JSON.stringify(array))); &#125; array[low] = current; &#125; console.log(&#39;array2 :&#39;, JSON.parse(JSON.stringify(array))); return array; &#125;; 测试 const array2 = [5, 4, 3, 2, 1]; console.log(&#39;原始 array2:&#39;, array2); binaryInsertionSort(array2); // 原始 array2: [5, 4, 3, 2, 1] // array2 : [5, 5, 3, 2, 1] // array2 : [4, 5, 5, 2, 1] // array2 : [4, 4, 5, 2, 1] // array2 : [3, 4, 5, 5, 1] // array2 : [3, 4, 4, 5, 1] // array2 : [3, 3, 4, 5, 1] // array2 : [2, 3, 4, 5, 5] // array2 : [2, 3, 4, 4, 5] // array2 : [2, 3, 3, 4, 5] // array2 : [2, 2, 3, 4, 5] // array2 : [1, 2, 3, 4, 5] 注意：和直接插入排序类似，折半插入排序每次交换的是相邻的且值为不同的元素，它并不会改变值相同的元素之间的顺序，因此它是稳定的。 三、希尔排序 希尔排序是一个平均时间复杂度为 O(n log n) 的算法，会在下一个章节和 归并排序、快速排序、堆排序 一起讲，本文就不展开了。 3.3 选择排序（Selection Sort）思路 选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。 步骤 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第二步，直到所有元素均排序完毕。 实现 const selectionSort = array =&gt; &#123; const len = array.length; let minIndex, temp; for (let i = 0; i &lt; len - 1; i++) &#123; minIndex = i; for (let j = i + 1; j &lt; len; j++) &#123; if (array[j] &lt; array[minIndex]) &#123; minIndex = j; &#125; &#125; temp = array[i]; array[i] = array[minIndex]; array[minIndex] = temp; console.log(&#39;array: &#39;, array); &#125; return array; &#125;; 测试 // 测试 const array = [5, 4, 3, 2, 1]; console.log(&#39;原始array:&#39;, array); selectionSort(array); // 原始 array: [5, 4, 3, 2, 1] // array: [1, 4, 3, 2, 5] // array: [1, 2, 3, 4, 5] // array: [1, 2, 3, 4, 5] // array: [1, 2, 3, 4, 5] 分析 第一，选择排序是原地排序算法吗 ？ 选择排序空间复杂度为 O(1)，是一种原地排序算法。 第二，选择排序是稳定的排序算法吗 ？ 选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。所以，选择排序是一种不稳定的排序算法。 第三，选择排序的时间复杂度是多少 ？ 无论是正序还是逆序，选择排序都会遍历 n2 / 2 次来排序，所以，最佳、最差和平均的复杂度是一样的。 最佳情况：T(n) = O(n2)。 最差情况：T(n) = O(n2)。 平均情况：T(n) = O(n2)。 动画 3.4 归并排序（Merge Sort）思想 排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。 归并排序采用的是分治思想。 分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。 注：x &gt;&gt; 1 是位运算中的右移运算，表示右移一位，等同于 x 除以 2 再取整，即 x &gt;&gt; 1 === Math.floor(x / 2) 。 实现 const mergeSort = arr =&gt; &#123; const len = arr.length; if (len &lt; 2) &#123; return arr; &#125; let middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right)); &#125;; const merge = (left, right) =&gt; &#123; const result = []; while (left.length &amp;&amp; right.length) &#123; if (left[0] &lt;= right[0]) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; while (left.length) result.push(left.shift()); while (right.length) result.push(right.shift()); return result; &#125;; 测试 // 测试 const arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48]; console.time(&#39;归并排序耗时&#39;); console.log(&#39;arr :&#39;, mergeSort(arr)); console.timeEnd(&#39;归并排序耗时&#39;); // arr : [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] // 归并排序耗时: 0.739990234375ms 分析 第一，归并排序是原地排序算法吗 ？ 这是因为归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。 实际上，尽管每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 O(n)。 所以，归并排序不是原地排序算法。 第二，归并排序是稳定的排序算法吗 ？ merge 方法里面的 left[0] &lt;= right[0] ，保证了值相同的元素，在合并前后的先后顺序不变。归并排序是稳定的排序方法。 第三，归并排序的时间复杂度是多少 ？ 从效率上看，归并排序可算是排序算法中的佼佼者。假设数组长度为 n，那么拆分数组共需 logn 步，又每步都是一个普通的合并子数组的过程，时间复杂度为 O(n)，故其综合时间复杂度为 O(n log n)。 最佳情况：T(n) = O(n log n)。 最差情况：T(n) = O(n log n)。 平均情况：T(n) = O(n log n)。 动画 3.5 快速排序 （Quick Sort）快速排序的特点就是快，而且效率高！它是处理大数据最快的排序算法之一。 思想 先找到一个基准点（一般指数组的中部），然后数组被该基准点分为两部分，依次与该基准点数据比较，如果比它小，放左边；反之，放右边。 左右分别用一个空数组去存储比较后的数据。 最后递归执行上述操作，直到数组长度 &lt;= 1; 特点：快速，常用。 缺点：需要另外声明两个数组，浪费了内存空间资源。 实现 方法一： const quickSort1 = arr =&gt; &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; const midIndex = Math.floor(arr.length / 2); const valArr = arr.splice(midIndex, 1); const midIndexVal = valArr[0]; const left = []; const right = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &lt; midIndexVal) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort1(left).concat(midIndexVal, quickSort1(right)); &#125;; const array2 = [5, 4, 3, 2, 1]; console.log(&#39;quickSort1 &#39;, quickSort1(array2)); 方法二： const quickSort = (arr, left, right) =&gt; &#123; let len = arr.length, partitionIndex; left = typeof left != &#39;number&#39; ? 0 : left; right = typeof right != &#39;number&#39; ? len - 1 : right; if (left &lt; right) &#123; partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex - 1); quickSort(arr, partitionIndex + 1, right); &#125; return arr; &#125;; const partition = (arr, left, right) =&gt; &#123; let pivot = left, index = pivot + 1; for (let i = index; i &lt;= right; i++) &#123; if (arr[i] &lt; arr[pivot]) &#123; swap(arr, i, index); index++; &#125; &#125; swap(arr, pivot, index - 1); return index - 1; &#125;; const swap = (arr, i, j) =&gt; &#123; let temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;; 测试 // 测试 const array = [5, 4, 3, 2, 1]; console.log(&#39;原始array:&#39;, array); const newArr = quickSort(array); console.log(&#39;newArr:&#39;, newArr); // 原始 array: [5, 4, 3, 2, 1] // newArr: [1, 4, 3, 2, 5] 分析 第一，快速排序是原地排序算法吗 ？ 因为 partition() 函数进行分区时，不需要很多额外的内存空间，所以快排是原地排序算法。 第二，快速排序是稳定的排序算法吗 ？ 和选择排序相似，快速排序每次交换的元素都有可能不是相邻的，因此它有可能打破原来值为相同的元素之间的顺序。因此，快速排序并不稳定。 第三，快速排序的时间复杂度是多少 ？ 极端的例子：如果数组中的数据原来已经是有序的了，比如 1，3，5，6，8。如果我们每次选择最后一个元素作为 pivot，那每次分区得到的两个区间都是不均等的。我们需要进行大约 n 次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约 n / 2 个元素，这种情况下，快排的时间复杂度就从 O(nlogn) 退化成了 O(n2)。 最佳情况：T(n) = O(n log n)。 最差情况：T(n) = O(n2)。 平均情况：T(n) = O(n log n)。 动画 解答开篇问题 快排和归并用的都是分治思想，递推公式和递归代码也非常相似，那它们的区别在哪里呢 ？ 可以发现： 归并排序的处理过程是由下而上的，先处理子问题，然后再合并。 而快排正好相反，它的处理过程是由上而下的，先分区，然后再处理子问题。 归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。 归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。 快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。 3.6 希尔排序（Shell Sort）思想 先将整个待排序的记录序列分割成为若干子序列。 分别进行直接插入排序。 待整个序列中的记录基本有序时，再对全体记录进行依次直接插入排序。 过程 举个易于理解的例子：[35, 33, 42, 10, 14, 19, 27, 44]，我们采取间隔 4。创建一个位于 4 个位置间隔的所有值的虚拟子列表。下面这些值是 { 35, 14 }，{ 33, 19 }，{ 42, 27 } 和 { 10, 44 }。 我们比较每个子列表中的值，并在原始数组中交换它们（如果需要）。完成此步骤后，新数组应如下所示。 然后，我们采用 2 的间隔，这个间隙产生两个子列表：{ 14, 27, 35, 42 }， { 19, 10, 33, 44 }。 我们比较并交换原始数组中的值（如果需要）。完成此步骤后，数组变成：[14, 10, 27, 19, 35, 33, 42, 44]，图如下所示，10 与 19 的位置互换一下。 最后，我们使用值间隔 1 对数组的其余部分进行排序，Shell sort 使用插入排序对数组进行排序。 实现 const shellSort = arr =&gt; &#123; let len = arr.length, temp, gap = 1; console.time(&#39;希尔排序耗时&#39;); while (gap &lt; len / 3) &#123; gap = gap * 3 + 1; &#125; for (gap; gap &gt; 0; gap = Math.floor(gap / 3)) &#123; for (let i = gap; i &lt; len; i++) &#123; temp = arr[i]; let j = i - gap; for (; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= gap) &#123; arr[j + gap] = arr[j]; &#125; arr[j + gap] = temp; console.log(&#39;arr :&#39;, arr); &#125; &#125; console.timeEnd(&#39;希尔排序耗时&#39;); return arr; &#125;; 测试 // 测试 const array = [35, 33, 42, 10, 14, 19, 27, 44]; console.log(&#39;原始array:&#39;, array); const newArr = shellSort(array); console.log(&#39;newArr:&#39;, newArr); // 原始 array: [35, 33, 42, 10, 14, 19, 27, 44] // arr : [14, 33, 42, 10, 35, 19, 27, 44] // arr : [14, 19, 42, 10, 35, 33, 27, 44] // arr : [14, 19, 27, 10, 35, 33, 42, 44] // arr : [14, 19, 27, 10, 35, 33, 42, 44] // arr : [14, 19, 27, 10, 35, 33, 42, 44] // arr : [14, 19, 27, 10, 35, 33, 42, 44] // arr : [10, 14, 19, 27, 35, 33, 42, 44] // arr : [10, 14, 19, 27, 35, 33, 42, 44] // arr : [10, 14, 19, 27, 33, 35, 42, 44] // arr : [10, 14, 19, 27, 33, 35, 42, 44] // arr : [10, 14, 19, 27, 33, 35, 42, 44] // 希尔排序耗时: 3.592041015625ms // newArr: [10, 14, 19, 27, 33, 35, 42, 44] 分析 第一，希尔排序是原地排序算法吗 ？ 希尔排序过程中，只涉及相邻数据的交换操作，只需要常量级的临时空间，空间复杂度为 O(1) 。所以，希尔排序是原地排序算法。 第二，希尔排序是稳定的排序算法吗 ？ 我们知道，单次直接插入排序是稳定的，它不会改变相同元素之间的相对顺序，但在多次不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，可能导致相同元素相对顺序发生变化。 因此，希尔排序不稳定。 第三，希尔排序的时间复杂度是多少 ？ 最佳情况：T(n) = O(n log n)。 最差情况：T(n) = O(n log2 n)。 平均情况：T(n) = O(n log2 n)。 动画 3.7 堆排序（Heap Sort）堆的定义 堆其实是一种特殊的树。只要满足这两点，它就是一个堆。 堆是一个完全二叉树。 完全二叉树：除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。 也可以说：堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值。这两种表述是等价的。 对于每个节点的值都大于等于子树中每个节点值的堆，我们叫作大顶堆。 对于每个节点的值都小于等于子树中每个节点值的堆，我们叫作小顶堆。 其中图 1 和 图 2 是大顶堆，图 3 是小顶堆，图 4 不是堆。除此之外，从图中还可以看出来，对于同一组数据，我们可以构建多种不同形态的堆。 思想 将初始待排序关键字序列 (R1, R2 .... Rn) 构建成大顶堆，此堆为初始的无序区； 将堆顶元素 R[1] 与最后一个元素 R[n] 交换，此时得到新的无序区 (R1, R2, ..... Rn-1) 和新的有序区 (Rn) ，且满足 R[1, 2 ... n-1] &lt;= R[n]。 由于交换后新的堆顶 R[1] 可能违反堆的性质，因此需要对当前无序区 (R1, R2 ...... Rn-1) 调整为新堆，然后再次将 R[1] 与无序区最后一个元素交换，得到新的无序区 (R1, R2 .... Rn-2) 和新的有序区 (Rn-1, Rn)。不断重复此过程，直到有序区的元素个数为 n - 1，则整个排序过程完成。 实现 const heapSort = array =&gt; &#123; console.time(&#39;堆排序耗时&#39;); for (let i = Math.floor(array.length / 2 - 1); i &gt;= 0; i--) &#123; heapify(array, i, array.length); &#125; for (let i = Math.floor(array.length - 1); i &gt; 0; i--) &#123; swap(array, 0, i); heapify(array, 0, i); &#125; console.timeEnd(&#39;堆排序耗时&#39;); return array; &#125;; const swap = (array, i, j) =&gt; &#123; let temp = array[i]; array[i] = array[j]; array[j] = temp; &#125;; const heapify = (array, i, length) =&gt; &#123; let temp = array[i]; for (let j = 2 * i + 1; j &lt; length; j = 2 * j + 1) &#123; temp = array[i]; if (j + 1 &lt; length &amp;&amp; array[j] &lt; array[j + 1]) &#123; j++; &#125; if (temp &lt; array[j]) &#123; swap(array, i, j); i = j; &#125; else &#123; break; &#125; &#125; &#125;; 测试 const array = [4, 6, 8, 5, 9, 1, 2, 5, 3, 2]; console.log(&#39;原始array:&#39;, array); const newArr = heapSort(array); console.log(&#39;newArr:&#39;, newArr); // 原始 array: [4, 6, 8, 5, 9, 1, 2, 5, 3, 2] // 堆排序耗时: 0.15087890625ms // newArr: [1, 2, 2, 3, 4, 5, 5, 6, 8, 9] 分析 第一，堆排序是原地排序算法吗 ？ 整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序是原地排序算法。 第二，堆排序是稳定的排序算法吗 ？ 因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。 所以，堆排序是不稳定的排序算法。 第三，堆排序的时间复杂度是多少 ？ 堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 O(n)，排序过程的时间复杂度是 O(nlogn)，所以，堆排序整体的时间复杂度是 O(nlogn)。 最佳情况：T(n) = O(n log n)。 最差情况：T(n) = O(n log n)。 平均情况：T(n) = O(n log n)。 动画 3.8 桶排序（Bucket Sort）桶排序是计数排序的升级版，也采用了分治思想。 思想 将要排序的数据分到有限数量的几个有序的桶里。 每个桶里的数据再单独进行排序（一般用插入排序或者快速排序）。 桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。 比如： 桶排序利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。 为了使桶排序更加高效，我们需要做到这两点： 在额外空间充足的情况下，尽量增大桶的数量。 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中。 桶排序的核心：就在于怎么把元素平均分配到每个桶里，合理的分配将大大提高排序的效率。 实现 const bucketSort = (array, bucketSize) =&gt; &#123; if (array.length === 0) &#123; return array; &#125; console.time(&#39;桶排序耗时&#39;); let i = 0; let minValue = array[0]; let maxValue = array[0]; for (i = 1; i &lt; array.length; i++) &#123; if (array[i] &lt; minValue) &#123; minValue = array[i]; &#125; else if (array[i] &gt; maxValue) &#123; maxValue = array[i]; &#125; &#125; const DEFAULT_BUCKET_SIZE = 5; bucketSize = bucketSize || DEFAULT_BUCKET_SIZE; const bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1; const buckets = new Array(bucketCount); for (i = 0; i &lt; buckets.length; i++) &#123; buckets[i] = []; &#125; for (i = 0; i &lt; array.length; i++) &#123; buckets[Math.floor((array[i] - minValue) / bucketSize)].push(array[i]); &#125; array.length = 0; for (i = 0; i &lt; buckets.length; i++) &#123; quickSort(buckets[i]); for (var j = 0; j &lt; buckets[i].length; j++) &#123; array.push(buckets[i][j]); &#125; &#125; console.timeEnd(&#39;桶排序耗时&#39;); return array; &#125;; const quickSort = (arr, left, right) =&gt; &#123; let len = arr.length, partitionIndex; left = typeof left != &#39;number&#39; ? 0 : left; right = typeof right != &#39;number&#39; ? len - 1 : right; if (left &lt; right) &#123; partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex - 1); quickSort(arr, partitionIndex + 1, right); &#125; return arr; &#125;; const partition = (arr, left, right) =&gt; &#123; let pivot = left, index = pivot + 1; for (let i = index; i &lt;= right; i++) &#123; if (arr[i] &lt; arr[pivot]) &#123; swap(arr, i, index); index++; &#125; &#125; swap(arr, pivot, index - 1); return index - 1; &#125;; const swap = (arr, i, j) =&gt; &#123; let temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;; 测试 const array = [4, 6, 8, 5, 9, 1, 2, 5, 3, 2]; console.log(&#39;原始array:&#39;, array); const newArr = bucketSort(array); console.log(&#39;newArr:&#39;, newArr); // 原始 array: [4, 6, 8, 5, 9, 1, 2, 5, 3, 2] // 堆排序耗时: 0.133056640625ms // newArr: [1, 2, 2, 3, 4, 5, 5, 6, 8, 9] 分析 第一，桶排序是原地排序算法吗 ？ 因为桶排序的空间复杂度，也即内存消耗为 O(n)，所以不是原地排序算法。 第二，桶排序是稳定的排序算法吗 ？ 取决于每个桶的排序方式，比如：快排就不稳定，归并就稳定。 第三，桶排序的时间复杂度是多少 ？ 因为桶内部的排序可以有多种方法，是会对桶排序的时间复杂度产生很重大的影响。所以，桶排序的时间复杂度可以是多种情况的。 总的来说 最佳情况：当输入的数据可以均匀的分配到每一个桶中。 最差情况：当输入的数据被分配到了同一个桶中。 以下是桶的内部排序为快速排序的情况： 如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k =n / m 个元素。每个桶内部使用快速排序，时间复杂度为 O(k * logk)。 m 个桶排序的时间复杂度就是 O(m * k * logk)，因为 k = n / m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。 当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。 最佳情况：T(n) = O(n)。当输入的数据可以均匀的分配到每一个桶中。 最差情况：T(n) = O(nlogn)。当输入的数据被分配到了同一个桶中。 平均情况：T(n) = O(n)。 桶排序最好情况下使用线性时间 O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为 O(n)。 很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 适用场景 桶排序比较适合用在外部排序中。 外部排序就是数据存储在外部磁盘且数据量大，但内存有限，无法将整个数据全部加载到内存中。 动画 3.9 计数排序（Counting Sort）思想 找出待排序的数组中最大和最小的元素。 统计数组中每个值为 i 的元素出现的次数，存入新数组 countArr 的第 i 项。 对所有的计数累加（从 countArr 中的第一个元素开始，每一项和前一项相加）。 反向填充目标数组：将每个元素 i 放在新数组的第 countArr[i] 项，每放一个元素就将 countArr[i] 减去 1 。 关键在于理解最后反向填充时的操作。 使用条件 只能用在数据范围不大的场景中，若数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序。 计数排序只能给非负整数排序，其他类型需要在不改变相对大小情况下，转换为非负整数。 比如如果考试成绩精确到小数后一位，就需要将所有分数乘以 10，转换为整数。 实现 方法一： const countingSort = array =&gt; &#123; let len = array.length, result = [], countArr = [], min = (max = array[0]); console.time(&#39;计数排序耗时&#39;); for (let i = 0; i &lt; len; i++) &#123; // 获取最小，最大 值 min = min &lt;= array[i] ? min : array[i]; max = max &gt;= array[i] ? max : array[i]; countArr[array[i]] = countArr[array[i]] ? countArr[array[i]] + 1 : 1; &#125; console.log(&#39;countArr :&#39;, countArr); // 从最小值 -&gt; 最大值,将计数逐项相加 for (let j = min; j &lt; max; j++) &#123; countArr[j + 1] = (countArr[j + 1] || 0) + (countArr[j] || 0); &#125; console.log(&#39;countArr 2:&#39;, countArr); // countArr 中,下标为 array 数值，数据为 array 数值出现次数；反向填充数据进入 result 数据 for (let k = len - 1; k &gt;= 0; k--) &#123; // result[位置] = array 数据 result[countArr[array[k]] - 1] = array[k]; // 减少 countArr 数组中保存的计数 countArr[array[k]]--; // console.log(&quot;array[k]:&quot;, array[k], &#39;countArr[array[k]] :&#39;, countArr[array[k]],) console.log(&#39;result:&#39;, result); &#125; console.timeEnd(&#39;计数排序耗时&#39;); return result; &#125;; 测试 const array = [2, 2, 3, 8, 7, 1, 2, 2, 2, 7, 3, 9, 8, 2, 1, 4, 2, 4, 6, 9, 2]; console.log(&#39;原始 array: &#39;, array); const newArr = countingSort(array); console.log(&#39;newArr: &#39;, newArr); 方法二： const countingSort2 = (arr, maxValue) =&gt; &#123; console.time(&#39;计数排序耗时&#39;); maxValue = maxValue || arr.length; let bucket = new Array(maxValue + 1), sortedIndex = 0; (arrLen = arr.length), (bucketLen = maxValue + 1); for (let i = 0; i &lt; arrLen; i++) &#123; if (!bucket[arr[i]]) &#123; bucket[arr[i]] = 0; &#125; bucket[arr[i]]++; &#125; for (let j = 0; j &lt; bucketLen; j++) &#123; while (bucket[j] &gt; 0) &#123; arr[sortedIndex++] = j; bucket[j]--; &#125; &#125; console.timeEnd(&#39;计数排序耗时&#39;); return arr; &#125;; 测试 const array2 = [2, 2, 3, 8, 7, 1, 2, 2, 2, 7, 3, 9, 8, 2, 1, 4, 2, 4, 6, 9, 2]; console.log(&#39;原始 array2: &#39;, array2); const newArr2 = countingSort2(array2, 21); console.log(&#39;newArr2: &#39;, newArr2); 例子 可以认为，计数排序其实是桶排序的一种特殊情况。 当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。 我们都经历过高考，高考查分数系统你还记得吗？我们查分数的时候，系统会显示我们的成绩以及所在省的排名。如果你所在的省有 50 万考生，如何通过成绩快速排序得出名次呢？ 考生的满分是 900 分，最小是 0 分，这个数据的范围很小，所以我们可以分成 901 个桶，对应分数从 0 分到 900 分。 根据考生的成绩，我们将这 50 万考生划分到这 901 个桶里。桶内的数据都是分数相同的考生，所以并不需要再进行排序。 我们只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了 50 万考生的排序。 因为只涉及扫描遍历操作，所以时间复杂度是 O(n)。 分析 第一，计数排序是原地排序算法吗 ？ 因为计数排序的空间复杂度为 O(k)，k 桶的个数，所以不是原地排序算法。 第二，计数排序是稳定的排序算法吗 ？ 计数排序不改变相同元素之间原本相对的顺序，因此它是稳定的排序算法。 第三，计数排序的时间复杂度是多少 ？ 最佳情况：T(n) = O(n + k) 最差情况：T(n) = O(n + k) 平均情况：T(n) = O(n + k) k 是待排序列最大值。 动画 3.10 基数排序（Radix Sort）思想 基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。 例子 假设我们有 10 万个手机号码，希望将这 10 万个手机号码从小到大排序，你有什么比较快速的排序方法呢 ？ 这个问题里有这样的规律：假设要比较两个手机号码 a，b 的大小，如果在前面几位中，a 手机号码已经比 b 手机号码大了，那后面的几位就不用看了。所以是基于位来比较的。 桶排序、计数排序能派上用场吗 ？手机号码有 11 位，范围太大，显然不适合用这两种排序算法。针对这个排序问题，有没有时间复杂度是 O(n) 的算法呢 ？ 有，就是基数排序。 使用条件 要求数据可以分割独立的位来比较； 位之间由递进关系，如果 a 数据的高位比 b 数据大，那么剩下的地位就不用比较了； 每一位的数据范围不能太大，要可以用线性排序，否则基数排序的时间复杂度无法做到 O(n)。 方案 按照优先从高位或低位来排序有两种实现方案: MSD：由高位为基底，先按 k1 排序分组，同一组中记录, 关键码 k1 相等，再对各组按 k2 排序分成子组, 之后，对后面的关键码继续这样的排序分组，直到按最次位关键码 kd 对各子组排序后，再将各组连接起来，便得到一个有序序列。MSD 方式适用于位数多的序列。 LSD：由低位为基底，先从 kd 开始排序，再对 kd - 1 进行排序，依次重复，直到对 k1 排序后便得到一个有序序列。LSD 方式适用于位数少的序列。 实现 const radixSort = (array, max) =&gt; &#123; console.time(&#39;计数排序耗时&#39;); const buckets = []; let unit = 10, base = 1; for (let i = 0; i &lt; max; i++, base *= 10, unit *= 10) &#123; for (let j = 0; j &lt; array.length; j++) &#123; let index = ~~((array[j] % unit) / base); if (buckets[index] == null) &#123; buckets[index] = []; &#125; buckets[index].push(array[j]); &#125; let pos = 0, value; for (let j = 0, length = buckets.length; j &lt; length; j++) &#123; if (buckets[j] != null) &#123; while ((value = buckets[j].shift()) != null) &#123; array[pos++] = value; &#125; &#125; &#125; &#125; console.timeEnd(&#39;计数排序耗时&#39;); return array; &#125;; 测试 const array = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48]; console.log(&#39;原始array:&#39;, array); const newArr = radixSort(array, 2); console.log(&#39;newArr:&#39;, newArr); // 原始 array: [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48] // 堆排序耗时: 0.064208984375ms // newArr: [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 分析 第一，基数排序是原地排序算法吗 ？ 因为计数排序的空间复杂度为 O(n + k)，所以不是原地排序算法。 第二，基数排序是稳定的排序算法吗 ？ 基数排序不改变相同元素之间的相对顺序，因此它是稳定的排序算法。 第三，基数排序的时间复杂度是多少 ？ 最佳情况：T(n) = O(n * k) 最差情况：T(n) = O(n * k) 平均情况：T(n) = O(n * k) 其中，k 是待排序列最大值。 动画 LSD 基数排序动图演示： 4. 复杂度对比十大经典排序算法的 时间复杂度与空间复杂度 比较。 名称 平均 最好 最坏 空间 稳定性 排序方式 冒泡排序 O(n2) O(n) O(n2) O(1) Yes In-place 插入排序 O(n2) O(n) O(n2) O(1) Yes In-place 选择排序 O(n2) O(n2) O(n2) O(1) No In-place 归并排序 O(n log n) O(n log n) O(n log n) O(n) Yes Out-place 快速排序 O(n log n) O(n log n) O(n2) O(logn) No In-place 希尔排序 O(n log n) O(n log2 n) O(n log2 n) O(1) No In-place 堆排序 O(n log n) O(n log n) O(n log n) O(1) No In-place 桶排序 O(n + k) O(n + k) O(n2) O(n + k) Yes Out-place 计数排序 O(n + k) O(n + k) O(n + k) O(k) Yes Out-place 基数排序 O(n * k) O(n * k) O(n * k) O(n + k) Yes Out-place 名词解释： n：数据规模； k：桶的个数； In-place: 占用常数内存，不占用额外内存； Out-place: 占用额外内存。 5. 算法可视化工具 算法可视化工具 algorithm-visualizer 算法可视化工具 algorithm-visualizer 是一个交互式的在线平台，可以从代码中可视化算法，还可以看到代码执行的过程。旨在通过交互式可视化的执行来揭示算法背后的机制。 效果如下图： 算法可视化动画网站 https://visualgo.net/en 效果如下图： 算法可视化动画网站 www.ee.ryerson.ca 效果如下图： illustrated-algorithms 变量和操作的可视化表示增强了控制流和实际源代码。您可以快速前进和后退执行，以密切观察算法的工作方式。 效果如下图： 6. 系列文章JavaScript 数据结构与算法之美 系列文章，暂时写了如下的 11 篇文章，后续还有想写的内容，再补充。 所写的内容只是数据结构与算法内容的冰山一角，如果你还想学更多的内容，推荐学习王争老师的 数据结构与算法之美。 从时间和空间复杂度、基础数据结构到排序算法，文章的内容有一定的关联性，所以阅读时推荐按顺序来阅读，效果更佳。 1. JavaScript 数据结构与算法之美 - 时间和空间复杂度 2. JavaScript 数据结构与算法之美 - 线性表（数组、队列、栈、链表） 3. JavaScript 数据结构与算法之美 - 实现一个前端路由，如何实现浏览器的前进与后退 ？ 4. JavaScript 数据结构与算法之美 - 栈内存与堆内存 、浅拷贝与深拷贝 5. JavaScript 数据结构与算法之美 - 递归 6. JavaScript 数据结构与算法之美 - 非线性表（树、堆） 7. JavaScript 数据结构与算法之美 - 冒泡排序、选择排序、插入排序 8. JavaScript 数据结构与算法之美 - 归并排序、快速排序、希尔排序、堆排序 9. JavaScript 数据结构与算法之美 - 计数排序、桶排序、基数排序 10. JavaScript 数据结构与算法之美 - 十大经典排序算法汇总 11. JavaScript 数据结构与算法之美 - 强烈推荐 GitHub 上值得前端学习的数据结构与算法项目 如果有错误或者不严谨的地方，请务必给予指正，以免误人子弟，十分感谢。 Source","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kobingogo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kobingogo.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"nginx初试","slug":"others-nginx-basic","date":"2019-05-25T18:35:46.000Z","updated":"2022-02-18T02:31:03.811Z","comments":true,"path":"others-nginx-basic/","link":"","permalink":"https://kobingogo.github.io/others-nginx-basic/","excerpt":"&quot;Nginx 是一款轻量级的 HTTP 服务器，采用事件驱动的异步非阻塞处理方式框架，这让其具有极好的 IO 性能，时常用于服务端的反向代理和负载均衡。&quot; 作为前端开发，即使没用过 Nginx，但一定听说过 Nginx。上述这段描述，基本构成了所有人对 Nginx 的第一印象。笔者对于 Nginx 也是慕名已久，直到现在才开始试尝这道大餐，本文是记录笔者学习并使用 Nginx 的过程，通过此文可以简单入门并搭建一套 Nginx 服务。","text":"&quot;Nginx 是一款轻量级的 HTTP 服务器，采用事件驱动的异步非阻塞处理方式框架，这让其具有极好的 IO 性能，时常用于服务端的反向代理和负载均衡。&quot; 作为前端开发，即使没用过 Nginx，但一定听说过 Nginx。上述这段描述，基本构成了所有人对 Nginx 的第一印象。笔者对于 Nginx 也是慕名已久，直到现在才开始试尝这道大餐，本文是记录笔者学习并使用 Nginx 的过程，通过此文可以简单入门并搭建一套 Nginx 服务。 一、初试 Nginx想要成为一个合格的大前端，又怎能不会 Nginx 呢？ Nginx 从 2004 年发展至今，从一开始的完善沉淀，再迅速蹿升为“网红”，再到现在占服务器市场中接近 1/3 份额，成为互联网网站搭建的必选技术之一。发展可谓相当迅速，之所以能取得如此成就，主要还是相对于其他 HTTP 服务器其有着不可替代的优势： 支持海量高并发：采用 IO 多路复用 epoll。官方测试 Nginx 能够支持 5 万并发链接，实际生产环境中可以支撑 2-4 万并发连接数。 内存消耗少：在主流的服务器中 Nginx 目前是内存消耗最小的了，比如我们用 Nginx+PHP，在 3 万并发链接下，开启 10 个 Nginx 进程消耗 150M 内存。 免费使用可以商业化：Nginx 为开源软件，采用的是 2-clause BSD-like 协议，可以免费使用，并且可以用于商业。 配置文件简单：网络和程序配置通俗易懂，即使非专业运维也能看懂。 而对于前端童鞋，在实际工作上，更倾向于用 Nodejs 来搭建服务器，进而实现一些需求，对 Nginx 有天然的疏远感。的确，Nginx 中的绝大部分功能，如果单纯的使用 Node.js 也可以满足和实现。但实际上，Nginx 和 Node.js 并不冲突，都有自己擅长的领域：Nginx 更擅长于底层服务器端资源的处理（静态资源处理转发、反向代理，负载均衡等），Node.js 更擅长于上层具体业务逻辑的处理。如果将两者组合一起，则可以更加助力前端开发。 开始动手之前先交代下具体的系统环境： 系统环境说明：服务器：阿里云 ECS操作系统： CentOS 7.4 64 位Nginx 版本：nginx/1.16.1 二、Nginx 的安装首先可以查看下系统的 yum 源下是否有可用的 Nginx 包 1yum list | grep nginx 如果结果类似如图内容，说明 yum 源是存在的 如果不存在或者没有需要的 Nginx 版本，则可以自己配一个 yum 源。 打开终端，输入 1vim /etc/yum.repos.d/nginx.repo 往里面添加如下脚本： 12345[nginx]name=nginx repobaseurl=http://nginx.org/packages/$&#123;OS&#125;/$&#123;OSRELEASE&#125;/$basearch/gpgcheck=0enabled=1 需要注意：OS: 操作系统名称，如：centosOSRELEASE: 操作系统版本，如： 7对应的 baseurl: baseurl=http://nginx.org/packages/centos/7/$basearch/ 保存修改后，就可以安装 Nginx 了，安装命令： 1yum install nginx 安装完成后查看安装的 Nginx 版本: 1nginx -v 三、Nginx 基本配置安装完 Nginx 后，需要知道系统中多了那些文件，它们都安装到了那里。可以使用下面的命令进行查看： 1rpm -ql nginx rpm 是 linux 的 rpm 包管理工具，-q 代表询问模式，-l 代表返回列表，这样我们就可以找到 nginx 的所有安装位置了。 下面重点罗列下一些重要的文件 nginx.conf nginx.conf 文件是 Nginx 总配置文件，在我们搭建服务器时经常调整的文件。 进入 etc/nginx 目录下，然后用 vim 进行打开 12cd /etc/nginxvim nginx.conf 下面是文件的详细注释: 12345678910111213141516171819202122232425262728293031323334#运行用户，默认即是nginx，可以不进行设置user nginx;#Nginx进程，一般设置为和CPU核数一样worker_processes 1;#错误日志存放目录error_log /var/log/nginx/error.log warn;#进程pid存放位置pid /var/run/nginx.pid;events &#123; worker_connections 1024; # 单个后台进程的最大并发数&#125;http &#123; include /etc/nginx/mime.types; #文件扩展名与类型映射表 default_type application/octet-stream; #默认文件类型 #设置日志模式 log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; access_log /var/log/nginx/access.log main; #nginx访问日志存放位置 sendfile on; #开启高效传输模式 #tcp_nopush on; #减少网络报文段的数量 keepalive_timeout 65; #保持连接的时间，也叫超时时间 #gzip on; #开启gzip压缩 include /etc/nginx/conf.d/*.conf; #包含的子配置项位置和文件&#125; default.conf进入 conf.d 目录，打开 default.conf，内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344server &#123; listen 80; #配置监听端口 server_name localhost; //配置域名 #charset koi8-r; #access_log /var/log/nginx/host.access.log main; location / &#123; root /usr/share/nginx/html; #服务默认启动目录 index index.html index.htm; #默认访问文件 &#125; #error_page 404 /404.html; # 配置404页面 # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; #错误状态码的显示页面，配置后需要重启 location = /50x.html &#123; root /usr/share/nginx/html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&#x27;s document root # concurs with nginx&#x27;s one # #location ~ /\\.ht &#123; # deny all; #&#125;&#125; 四、Nginx 常用操作启动 Nginx 服务 Nginx 直接启动（CentOS7.4 以上版本） 1nginx 使用 systemctl 命令启动 1systemctl start nginx.service 查看服务运行状态 1ps aux | grep nginx 关停 Nginx 服务 立即停止服务 1nginx -s stop 这种方法比较强硬，无论进程是否在工作，都直接停止进程。 从容停止服务 1nginx -s quit 这种方法较 stop 相比就比较温和一些了，需要进程完成当前工作后再停止。 killall 方法杀死进程 1killall nginx 这种方法也是比较野蛮的，直接杀死进程。 systemctl 停止 1systemctl stop nginx.service 重启 Nginx 服务1systemctl restart nginx.service 重新载入配置文件在重新编写或者修改 Nginx 的配置文件后，需要作一下重新载入，这时候可以用这个命令。 1nginx -s reload 查看端口号如果 80 端口被占用，可以使用此命令查看端口占用情况 1netstat -tlnp 80 五、自定义错误页面以及访问控制 多错误指向一个页面 1error_page 500 502 503 504 /50x.html; 单独为错误置顶处理方式 1error_page 404 /404_error.html; 把错误码换成一个地址 1error_page 404 http://blog.kobingo.xyz; 简单实现访问控制 有时候我们的服务器只允许特定主机访问，比如内部 OA 系统，或者应用的管理后台系统，更或者是某些应用接口，这时候我们就需要控制一些 IP 访问，我们可以直接在 location 里进行配置。 可以直接在 default.conf 里进行配置。 1234location / &#123; deny 123.9.51.42; allow 45.76.202.231; &#125; 指令优先级 1234location / &#123; allow 45.76.202.231; deny all; &#125; 上面的配置表示只允许45.76.202.231进行访问，其他的 IP 是禁止访问的。但是如果我们把deny all指令，移动到 allow 45.76.202.231之前，会发生什么那？ 会发现所有的 IP 都不允许访问了。这说明了一个问题：就是在同一个块下的两个权限指令，先出现的设置会覆盖后出现的设置（也就是谁先触发，谁起作用）。 复杂访问控制权限匹配 在工作中，访问权限的控制需求更加复杂，例如，对于网站下的 img（图片目录）是运行所有用户访问，但对于网站下的 admin 目录则只允许公司内部固定 IP 访问。这时候仅靠 deny 和 allow 这两个指令，是无法实现的。我们需要 location 块来完成相关的需求匹配。 上面的需求，配置代码如下： 123456location =/img&#123; allow all;&#125;location =/admin&#123; deny all;&#125; 使用正则表达式设置访问权限 只有精确匹配(=)有时是完不成我们的工作任务的，比如现在我们要禁止访问所有 php 的页面，php 的页面大多是后台的管理或者接口代码，所以为了安全我们经常要禁止所有用户访问，而只开放公司内部访问的。 代码如下： 123location ~\\.php$ &#123; deny all; &#125; 这样我们再访问的时候就不能访问以 php 结尾的文件了。是不是让网站变的安全很多了那？ 六、Nginx 配置虚拟主机虚拟主机是指在一台物理主机服务器上划分出多个磁盘空间，每个磁盘空间都是一个虚拟主机，每台虚拟主机都可以对外提供 Web 服务，并且互不干扰。用户能够利用虚拟主机把多个不同域名的网站部署在同一台服务器上。可以大大节约服务器成本与维护成本。 基于端口号配置虚拟主机 基于端口号来配置虚拟主机，算是 Nginx 中最简单的一种方式了。原理就是 Nginx 监听多个端口，根据不同的端口号，来区分不同的网站 我习惯在 conf.d 里新建一个配置文件来配置新的虚拟主机，但也可以配置在主配置 etc/nginx/nginx.conf里，也可以配置在etc/nginx/conf.d/default.conf里。 12345678server&#123; listen 8088; server_name localhost; location / &#123; root /usr/share/nginx/html/html8001; index index.html; &#125;&#125; 基于 IP 的虚拟主机 基于 IP 和基于端口的配置几乎一样，只是把server_name选项，配置成 IP 就可以了。 12345678server&#123; listen 80; server_name 112.74.164.244; location / &#123; root /usr/share/nginx/html/html8001; index index.html; &#125;&#125; 基于域名的虚拟主机 域名设置虚拟主机也非常简单，主要操作的是配置文件的 server_name 项 12345678910111213141516server&#123; listen 80; server_name nginx.kobin.com; location / &#123; root /usr/share/nginx/html/html; index index.html index.htm; &#125;&#125;server&#123; listen 80; server_name nginx2.kobin.com; location / &#123; root /usr/share/nginx/html/html8001; index index.html index.htm; &#125;&#125; 七、Nginx 反向代理的设置什么是反向代理？ 互联网应用基本都基于 CS 基本结构，即 client 端和 server 端。代理其实就是在 client 端和真正的 server 端之前增加一层提供特定服务的服务器，即代理服务器。 在了解反向代理前先了解什么是正向代理。 正向代理 翻墙工具就是一个典型的正向代理工具。它会把我们不能访问的墙外服务器 server 的网页请求，代理到一个可以访问该网站的代理服务器 proxy，这个代理服务器 proxy 把墙外服务器 server 上的网页内容获取，再转发给客户。具体的流程如下图。 其特点如下： 客户端和代理服务器可以直接互相访问，属于一个 LAN（局域网） 代理对用户是非透明的，即用户需要自己操作或者感知得到自己的请求被发送到代理服务器 代理服务器通过代理用户端的请求来向域外服务器请求响应内容。 一句话总结： 代理的是客户端 反向代理 反向代理正好相反，客户端发送的请求，想要访问 server 服务器上的内容。发送的内容被发送到代理服务器上，这个代理服务器再把请求发送到自己设置好的内部服务器上，而用户真实想获得的内容就在这些设置好的服务器上。 其特点如下： 代理服务器和真正 server 服务器可以直接互相访问，属于一个 LAN（服务器内网） 代理对用户是透明的，即无感知。不论加不加这个反向代理，用户都是通过相同的请求进行的，且不需要任何额外的操作； 代理服务器通过代理内部服务器接受域外客户端的请求，并将请求发送到对应的内部服务器上。 一句话总结： 代理的是服务器 反向代理的好处： 安全及权限使用反向代理后，用户端将无法直接通过请求访问真正的内容服务器，而必须通过 Nginx。可以通过在 Nginx 层上将危险或者没有权限的请求内容过滤掉，从而保证了服务器的安全。 负载均衡一个网站的内容被部署在若干服务器上，可以把这些机子看成一个集群，那 Nginx 可以将接收到的客户端请求“均匀地”分配到这个集群中所有的服务器上，从而实现服务器压力的平均分配 简单实现反向代理 举个例子，我们访问 home.blog.kobingo.xyz 这个网站，然后反向代理到 baidu.com 上。可做如下配置： 1234567server&#123; listen 80; server_name home.blog.kobingo.xyz; location / &#123; proxy_pass https://www.baidu.com; &#125;&#125; 结果如下： 其他常用的反向代理配置： proxy_set_header :在将客户端请求发送给后端服务器之前，更改来自客户端的请求头信息。 proxy_connect_timeout:配置 Nginx 与后端代理服务器尝试建立连接的超时时间。 proxy_read_timeout : 配置 Nginx 向后端服务器组发出 read 请求后，等待相应的超时时间。 proxy_send_timeout：配置 Nginx 向后端服务器组发出 write 请求后，等待相应的超时时间。 proxy_redirect :用于修改后端服务器返回的响应头中的 Location 和 Refresh。 八、Nginx 适配移动端与 PC 端Nginx 通过内置变量$http_user_agent，可以获取到请求客户端的userAgent，就可以用户目前处于移动端还是 PC 端，进而展示不同的页面给用户。 在 conf.d 目录下新建一个 demo.conf 文件，内容如下： 1234567891011server &#123; listen 80; server_name blog.blog.kobingo.xyz; location / &#123; root /yangling/app/pc; # 默认展示PC端页面 if ($http_user_agent ~* &#x27;(Android|webOS|iPhone|iPod|BlackBerry)&#x27;) &#123; # 如果匹配到mobile端的user_agent则展示mobile页面 root /yangling/app/mobile; &#125; index index.html; &#125;&#125; 九、Nginx 实现 Gzip 压缩Gzip 是网页的一种网页压缩技术，经过 gzip 压缩后，页面大小可以变为原来的 30%甚至更小。更小的网页会让用户浏览的体验更好，速度更快。gzip 网页压缩的实现需要浏览器和服务器的支持。 gzip 是需要服务器和浏览器同事支持的。当浏览器支持 gzip 压缩时，会在请求消息中包含 Accept-Encoding:gzip,这样 Nginx 就会向浏览器发送听过 gzip 后的内容，同时在相应信息头中加入 Content-Encoding:gzip，声明这是 gzip 后的内容，告知浏览器要先解压后才能解析输出。 gzip 配置： gzip : 该指令用于开启或 关闭 gzip 模块。 gzip_buffers : 设置系统获取几个单位的缓存用于存储 gzip 的压缩结果数据流。 gzip_comp_level : gzip 压缩比，压缩级别是 1-9，1 的压缩级别最低，9 的压缩级别最高。压缩级别越高压缩率越大，压缩时间越长。 gzip_disable : 可以通过该指令对一些特定的 User-Agent 不使用压缩功能。 gzip_min_length:设置允许压缩的页面最小字节数，页面字节数从相应消息头的 Content-length 中进行获取。 gzip_http_version：识别 HTTP 协议版本，其值可以是 1.1.或 1.0. gzip_proxied : 用于设置启用或禁用从代理服务器上收到相应内容 gzip 压缩。 gzip_vary : 用于在响应消息头中添加 Vary：Accept-Encoding,使代理服务器根据请求头中的 Accept-Encoding 识别是否启用 gzip 压缩。 简单配置： 123456http &#123; ..... gzip on; gzip_types text/plain application/javascript text/css; .....&#125; gzip on是启用 gizp 模块，下面的一行是用于在客户端访问网页时，对文本、JavaScript 和 CSS 文件进行压缩输出。 十、Nginx 与跨域请求举个例子：在 a.com 页面中有请求 b.com 的接口http://b.com/getHomeData, 出现了跨域问题。当然这种跨域问题的处理方式很多，这里主要说下用 Nginx 如何解决。 在 a.com 启个 Nginx 服务，配置如下： 12345678910server &#123; listen 80; server_name a.com; #请求跨域，这里约定代理请求url path是以/apis/开头 location ^~/apis/ &#123; # 这里重写了请求，将正则匹配中的第一个()中$1的path，拼接到真正的请求后面，并用break停止后续匹配 rewrite ^/apis/(.*)$ /$1 break; proxy_pass https://www.b.com/; &#125;&#125; 这时请求接口 URL 换成http://a.com/apis/getHomeData，就可以正常请求到数据了。其本质还是利用了服务端不受跨域限制的原理。 十一、Nginx 与合并请求通过nginx-http-concat插件可以实现将多个资源请求合并为一个请求，达到性能优化目的。 十二、Nginx 与图片处理通过ngx_http_image_filter_module插件实现日常对图片的处理，包括缩放、裁剪、旋转、图片质量等的控制。 十三、使用Let’s Encrypt配置ssl证书安装certbot1yum install -y python3 &amp;&amp; pip3 install certbot 查看certbot使用方法： 1certbot --help certbot 默认使用http方式对域名所有权进行验证，该操作需要绑定vps的80端口。如果80端口已被占用，请先停止占用的进程，例如停止Nginx： 1killall nginx 为指定域名生成证书： 1certbot certonly --standalone -d 域名1 -d 域名2 查看域名证书的路径和国旗时间 1certbot certificates 生成的证文件位置： 1/etc/letsencrypt/live/blog.kobingo.xyz/ 配置Nginx编辑/etc/nginx/conf.d/default.conf: 1234567891011121314151617181920212223242526server &#123; listen 80; server_name blog.kobingo.xyz; rewrite ^(.*) https://$server_name$1 permanent;&#125;server &#123; listen 443 ssl; server_name blog.kobingo.xyz; charset utf-8; ssl_certificate /etc/letsencrypt/live/blog.kobingo.xyz/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/blog.kobingo.xyz/privkey.pem; ssl_protocols TLSv1.2 TLSv1.3; # TLSv1.3需要nginx 1.13.0以上版本 # 如果nginx版本低，建议使用这种加密算法配置 # ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-SHA384; ssl_ecdh_curve secp384r1; ssl_prefer_server_ciphers on; ssl_session_cache shared:SSL:10m; ssl_session_timeout 10m; ssl_session_tickets off; keepalive_timeout 70; # 这里填写其他配置&#125; 查看配置有无错误： 1nginx -t 如果没有错误，则启动Nginx： 1systemctl restart nginx.service 证书自动更新Let’s Encrypt证书的有效期是三个月，超过期限则需要续签。证书续期可以手动完成，例如： 123systemctl stop nginxcertbot renewsystemctl restart nginx 也可以配置crontab任务自动续签，在/etc/crontab文件末添加一行： 10 0 1 */2 0 root systemctl stop nginx; /usr/local/bin/certbot renew; systemctl restart nginx","categories":[{"name":"others","slug":"others","permalink":"https://kobingogo.github.io/categories/others/"}],"tags":[{"name":"全栈","slug":"全栈","permalink":"https://kobingogo.github.io/tags/%E5%85%A8%E6%A0%88/"},{"name":"nginx","slug":"nginx","permalink":"https://kobingogo.github.io/tags/nginx/"}]},{"title":"文章摘录","slug":"collection","date":"2019-05-06T15:35:35.000Z","updated":"2022-02-18T02:31:03.807Z","comments":true,"path":"collection/","link":"","permalink":"https://kobingogo.github.io/collection/","excerpt":"在这里记录一些看到的好文章好博客","text":"在这里记录一些看到的好文章好博客 龙恩 0707 cdn 全栈修炼 前端进阶之道 大前端面试宝典 - 图解前端 未来可期的 TypeScript 别再说虚拟 DOM 快了，要被打脸的 深入理解虚拟 DOM，它真的不快 Deep In React 之详谈 React 16 Diff 策略(二) ReactFiber 在并发模式下的运行机制 前端浏览器输入 URL 后发生什么 大公司如何部署前端代码 Vuex、Flux、Redux、Redux-saga、Dva、MobX累死累活做业务，绩效还不怎么样，我只能帮你到这了……","categories":[{"name":"面试","slug":"面试","permalink":"https://kobingogo.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://kobingogo.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"面试","slug":"面试","permalink":"https://kobingogo.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"基于hexo搭建个人博客并使用GitHub Actions一键发布到GitHub pages & 阿里云ECS","slug":"others-hexo","date":"2019-04-28T15:15:23.000Z","updated":"2022-02-18T02:31:03.811Z","comments":true,"path":"others-hexo/","link":"","permalink":"https://kobingogo.github.io/others-hexo/","excerpt":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。本文记录了使用 Hexo 创建个人博客并使用GitHub Actions一键发布到 GitHub pages 和 阿里云ECS上的全过程。","text":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。本文记录了使用 Hexo 创建个人博客并使用GitHub Actions一键发布到 GitHub pages 和 阿里云ECS上的全过程。 什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装安装前提安装 Hexo 前，请先确保您的电脑上已经安装了下列应用程序： Node.js (Node.js 版本需不低于 8.10，建议使用 Node.js 10.0 及以上版本) Git 注： 如果您的电脑未安装 Node 或者 Git，请先安装后再阅读下面内容 安装 Hexo使用 npm: 1$ npm install -g hexo-cli 使用 yarn: 1$ yarn global add hexo-cli 建站安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml网站的 配置 信息，您可以在此配置大部分的参数。 scaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 source资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去 themes主题 文件夹。Hexo 会根据主题来生成静态页面。 常用命令new新建一篇文章 1$ hexo new [layout] &lt;title&gt; generate生成静态文件。 1$ hexo generate publish发表草稿。 1$ hexo publish [layout] &lt;filename&gt; server启动服务器。默认情况下，访问网址为： http://localhost:4000/。 1$ hexo server deploy部署网站。 1$ hexo deploy clean清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 1$ hexo clean list列出网站资料。 1$ hexo list &lt;type&gt; 注： 更多命令见官网 部署 GitHub pages如果您只是想部署到GitHub Actions上，那么可以直接用这节的方法。如果还想部署到阿里云等私人服务器上，那么可以跳过这步，直接看下一节。 新建 GitHub 项目打开 GitHub 点击右上角的new repository 然后在下图所示中，输入项目名称（后面一定要加.github.io 后缀），勾选 readme 初始化，点击完成创建 安装 hexo-deployer-git。1$ npm install hexo-deployer-git --save 修改_config.yml 配置1234deploy: type: git repo: git@github.com:jiangawait/jiangawait.github.io.git branch: master 执行命令执行 hexo deploy 将生成的文件部署到上一步配置的仓库对应的分支上去。 1hexo clean &amp;&amp; hexo deploy 至此，已经实现了个人博客的搭建并完成了一键发布到GitHub Pages的功能，如果只需要发布到GitHub Pages，那么至此已经可以愉快地写文章了。 但是由于总所周知的原因，GitHub在国内的访问速度总是时好时坏，不够畅快。 那么如果你手里恰好有闲置的云服务器，那么接下去就更进一步吧！🙂 GitHub Actions登场GitHub Actions 是 GitHub 于2018年10月推出的持续集成服务。功能非常强大，具体的基础用法不赘述，可以参阅阮一峰老师的教程。 这里主要介绍如何配置GitHub Actions实现自动部署功能。 创建workflow 文件GitHub Actions 的配置文件叫做 workflow 文件, 存放在代码仓库的.github/workflows目录。 新建.github/workflows/deploy.yml, 具体配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152name: Hexo build and deployon: push: branches: - blog # blog分支是本人的hexo源码分支jobs: build: runs-on: ubuntu-latest steps: # 切换分支 - name: Checkout uses: actions/checkout@v2 # If you&#x27;re using actions/checkout@v2 you must set persist-credentials to false in most cases for the deployment to work correctly. with: persist-credentials: false # checkout到你的hexo代码分支 ref: blog # hexo需要加载内部子模块 submodules: true # 使用 node:10 - name: use Node.js 10 uses: actions/setup-node@v1 with: node-version: 10 # 安装npm包 &amp; 生成静态文件 - name: Install and publish run: | npm install npm run build # 将静态文件部署到阿里云 - name: Deploy to aliyun server uses: easingthemes/ssh-deploy@v2.0.7 env: SSH_PRIVATE_KEY: $&#123;&#123; secrets.ALIYUN_SERVER_ACCESS_TOKEN &#125;&#125; ARGS: &quot;-avz --delete&quot; SOURCE: &quot;public&quot; REMOTE_HOST: $&#123;&#123; secrets.ALIYUN_SERVER_HOST &#125;&#125; REMOTE_USER: &quot;root&quot; TARGET: &quot;/code/hexo-blog&quot; # 静态资源存放目录 # 将静态文件部署到github pages - name: Deploy to Github Pages uses: JamesIves/github-pages-deploy-action@releases/v3 with: ACCESS_TOKEN: $&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125; BASE_BRANCH: blog BRANCH: master FOLDER: public 配置参数说明 ALIYUN_SERVER_HOST： 阿里云服务器公网IP； ALIYUN_SERVER_ACCESS_TOKEN：阿里云.ssh下的私钥(id_rsa); 如果未生成过，可以执行如下命令：1ssh-keygen -m PEM -t rsa -b 4096 把公钥复制一份到authorized_keys中:12cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keyschmod 600 ~/.ssh/authorized_keys ACCESS_TOKEN: GitHub 密钥, 按照官方文档生成一个秘钥。 以上三个参数都保存到自己仓库-&gt;settings-&gt;Secrets里面： 构建结果将整个仓库推送到GitHub，GitHub 发现了 workflow 文件以后，就会自动运行。 至此，我们已经将博客部署到GitHub Actions和阿里云上了。阿里云上我们可以使用Nginx托管静态资源： 12345678server &#123; listen 80; server_name blog.kobingo.xyz; location / &#123; root /code/hexo-blog/public; # 静态资源存放目录 index index.html; &#125;&#125; 一切大功告成！收工😄","categories":[{"name":"others","slug":"others","permalink":"https://kobingogo.github.io/categories/others/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://kobingogo.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"浏览器缓存IntersectionObserver原理分析","slug":"浏览器-浏览器缓存","date":"2018-10-23T17:10:38.000Z","updated":"2022-02-18T02:31:03.811Z","comments":true,"path":"浏览器-浏览器缓存/","link":"","permalink":"https://kobingogo.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/","excerpt":"浏览器缓存作为性能优化的重要一环，对于前端而言，重要性不言而喻。以前总是一知半解的，所以这次好好整理总结了一下。","text":"浏览器缓存作为性能优化的重要一环，对于前端而言，重要性不言而喻。以前总是一知半解的，所以这次好好整理总结了一下。 首先我们来总体感知一下它的匹配流程，如下： 浏览器发送请求前，根据请求头的expires和cache-control判断是否命中（包括是否过期）强缓存策略，如果命中，直接从缓存获取资源，并不会发送请求。如果没有命中，则进入下一步。 没有命中强缓存规则，浏览器会发送请求，根据请求头的last-modified和etag判断是否命中协商缓存，如果命中，直接从缓存获取资源。如果没有命中，则进入下一步。 如果前两步都没有命中，则直接从服务端获取资源。 强缓存：不会向服务器发送请求，直接从缓存中读取资源。 2.1 强缓存原理强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下： 第一次请求，不存在缓存结果和缓存标识，直接向服务器发送请求 存在缓存标识和缓存结果，但是已经失效，强制缓存是啊比，则使用协商缓存（暂不分析） 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果 那么强制缓存的缓存规则是什么？当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。 2.1.1、 Expires缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。 Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。 2.1.2、 Cache-Control在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为： public：所有内容都将被缓存（客户端和代理服务器都可缓存） private：所有内容只有客户端可以缓存，Cache-Control的默认取值 no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定 no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存 max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效 需要注意的是，no-cache这个名字有一点误导。设置了no-cache之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致，也就是协商缓存。而no-store才表示不会被缓存，即不使用强制缓存，也不使用协商缓存 2.1.3、设置强缓存需要服务端设置expires和cache-control。nginx代码参考，设置了一年的缓存时间： location ~ .*\\.(ico|svg|ttf|eot|woff)(.*) &#123; proxy_cache pnc; proxy_cache_valid 200 304 1y; proxy_cache_valid any 1m; proxy_cache_lock on; proxy_cache_lock_timeout 5s; proxy_cache_use_stale updating error timeout invalid_header http_500 http_502; expires 1y; &#125; 浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？这就是下面我们要讲到的from disk cache和from memory cache。 2.2、from disk cache和from memory cache细心地同学在开发的时候应该注意到了Chrome的网络请求的Size会出现三种情况from disk cache(磁盘缓存)、from memory cache(内存缓存)、以及资源大小数值。 状态 类型 说明 200 form memory cache 不请求网络资源，资源在内存当中，一般脚本、字体、图片会存在内存当中 200 form disk ceche 不请求网络资源，在磁盘当中，一般非脚本会存在内存当中，如css等 200 资源大小数值 从服务器下载最新资源 304 报文大小 请求服务端发现资源没有更新，使用本地资源 浏览器读取缓存的顺序为memory –&gt; disk。以访问https://github.com/xiangxingchen/blog为例我们第一次访问时https://github.com/xiangxingchen/blog关闭标签页，再此打开https://github.com/xiangxingchen/blog时F5刷新时 简单的对比一下 协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况： 协商缓存生效，返回304和Not Modified 协商缓存失效，返回200和请求结果 3.1、Last-Modified和If-Modified-Since 浏览器首先发送一个请求，让服务端在response header中返回请求的资源上次更新时间，就是last-modified，浏览器会缓存下这个时间。 然后浏览器再下次请求中，request header中带上if-modified-since:[保存的last-modified的值]。根据浏览器发送的修改时间和服务端的修改时间进行比对，一致的话代表资源没有改变，服务端返回正文为空的响应，让浏览器中缓存中读取资源，这就大大减小了请求的消耗。 由于last-modified依赖的是保存的绝对时间，还是会出现误差的情况： 保存的时间是以秒为单位的，1秒内多次修改是无法捕捉到的； 各机器读取到的时间不一致，就有出现误差的可能性。为了改善这个问题，提出了使用etag。 3.2、ETag和If-None-Matchetag是http协议提供的若干机制中的一种Web缓存验证机制，并且允许客户端进行缓存协商。生成etag常用的方法包括对资源内容使用抗碰撞散列函数，使用最近修改的时间戳的哈希值，甚至只是一个版本号。 和last-modified一样. 浏览器会先发送一个请求得到etag的值，然后再下一次请求在request header中带上if-none-match:[保存的etag的值]。 通过发送的etag的值和服务端重新生成的etag的值进行比对，如果一致代表资源没有改变，服务端返回正文为空的响应，告诉浏览器从缓存中读取资源。 etag能够解决last-modified的一些缺点，但是etag每次服务端生成都需要进行读写操作，而last-modified只需要读取操作，从这方面来看，etag的消耗是更大的。 二者对比 精确度上：Etag要优于Last-Modified。 优先级上：服务器校验优先考虑Etag。 性能上：Etag要逊于Last-Modified 打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。 普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。 强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control:no-cache(为了兼容，还带了 Pragma:no-cache),服务器直接返回 200 和最新内容。 Source","categories":[{"name":"浏览器","slug":"浏览器","permalink":"https://kobingogo.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"缓存","slug":"缓存","permalink":"https://kobingogo.github.io/tags/%E7%BC%93%E5%AD%98/"}]},{"title":"js浮点数陷进与解法","slug":"javascript-js浮点数陷进与解法","date":"2018-10-15T18:48:33.000Z","updated":"2022-02-18T02:31:03.811Z","comments":true,"path":"javascript-js浮点数陷进与解法/","link":"","permalink":"https://kobingogo.github.io/javascript-js%E6%B5%AE%E7%82%B9%E6%95%B0%E9%99%B7%E8%BF%9B%E4%B8%8E%E8%A7%A3%E6%B3%95/","excerpt":"众所周知，JavaScript 浮点数运算时经常遇到会 0.000000001 和 0.999999999 这样奇怪的结果，如 0.1+0.2=0.30000000000000004、1-0.9=0.09999999999999998，很多人知道这是浮点数误差问题，但具体原因就说不清楚了。本文帮你理清这背后的原理以及解决方案，还会向你解释JS中的大数危机和四则运算中会遇到的坑。","text":"众所周知，JavaScript 浮点数运算时经常遇到会 0.000000001 和 0.999999999 这样奇怪的结果，如 0.1+0.2=0.30000000000000004、1-0.9=0.09999999999999998，很多人知道这是浮点数误差问题，但具体原因就说不清楚了。本文帮你理清这背后的原理以及解决方案，还会向你解释JS中的大数危机和四则运算中会遇到的坑。 浮点数的存储首先要搞清楚 JavaScript 如何存储小数。和其它语言如 Java 和 Python 不同，JavaScript 中所有数字包括整数和小数都只有一种类型 — Number。它的实现遵循 IEEE 754 标准，使用 64 位固定长度来表示，也就是标准的 double 双精度浮点数（相关的还有float 32位单精度）。计算机组成原理中有过详细介绍，如果你不记得也没关系。 注：大多数语言中的小数默认都是遵循 IEEE 754 的 float 浮点数，包括 Java、Ruby、Python，本文中的浮点数问题同样存在。 这样的存储结构优点是可以归一化处理整数和小数，节省存储空间。 64位比特又可分为三个部分： 符号位S：第 1 位是正负数符号位（sign），0代表正数，1代表负数 指数位E：中间的 11 位存储指数（exponent），用来表示次方数 尾数位M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零 实际数字就可以用以下公式来计算： 注意以上的公式遵循科学计数法的规范，在十进制中 0&lt;M&lt;10，到二进制就是 0&lt;M&lt;2。也就是说整数部分只能是1，所以可以被舍去，只保留后面的小数部分。如 4.5 转成二进制就是 100.1，科学计数法表示是 1.001*2^2，舍去1后 M = 001。E是一个无符号整数，因为长度是11位，取值范围是 0~2047。但是科学计数法中的指数是可以为负数的，所以约定减去一个中间数 1023，[0,1022] 表示为负，[1024,2047] 表示为正。如 4.5 的指数 E = 1025，尾数 M = 001。 最终的公式变成： 所以 4.5 最终表示为（M=001、E=1025）： (图片由此生成 http://www.binaryconvert.com/convert_double.html) 下面再以 0.1 为例解释浮点误差的原因，0.1 转成二进制表示为 0.0001100110011001100(1100循环)，1.100110011001100x2^-4，所以 E=-4+1023=1019；M 舍去首位的1，得到 100110011...。最终就是： 转化成十进制后为 0.100000000000000005551115123126，因此就出现了浮点误差。 为什么 0.1+0.2=0.30000000000000004？计算步骤为： // 0.1 和 0.2 都转化成二进制后再进行运算 0.00011001100110011001100110011001100110011001100110011010 + 0.0011001100110011001100110011001100110011001100110011010 = 0.0100110011001100110011001100110011001100110011001100111 // 转成十进制正好是 0.30000000000000004 为什么 x=0.1 能得到 0.1？恭喜你到了看山不是山的境界。因为 mantissa 固定长度是 52 位，再加上省略的一位，最多可以表示的数是 2^53=9007199254740992，对应科学计数尾数是 9.007199254740992，这也是 JS 最多能表示的精度。它的长度是 16，所以可以近似使用 toPrecision(16) 来做精度运算，超过的精度会自动做凑整处理。于是就有： 0.10000000000000000555.toPrecision(16) // 返回 0.1000000000000000，去掉末尾的零后正好为 0.1 // 但你看到的 `0.1` 实际上并不是 `0.1`。不信你可用更高的精度试试： 0.1.toPrecision(21) = 0.100000000000000005551 大数危机可能你已经隐约感觉到了，如果整数大于 9007199254740992 会出现什么情况呢？由于 E 最大值是 1023，所以最大可以表示的整数是 2^1024 - 1，这就是能表示的最大整数。但你并不能这样计算这个数字，因为从 2^1024 开始就变成了 Infinity &gt; Math.pow(2, 1023) 8.98846567431158e+307 &gt; Math.pow(2, 1024) Infinity 那么对于 (2^53, 2^63) 之间的数会出现什么情况呢？ (2^53, 2^54) 之间的数会两个选一个，只能精确表示偶数 (2^54, 2^55) 之间的数会四个选一个，只能精确表示4个倍数 ... 依次跳过更多2的倍数 下面这张图能很好的表示 JavaScript 中浮点数和实数（Real Number）之间的对应关系。我们常用的 (-2^53, 2^53) 只是最中间非常小的一部分，越往两边越稀疏越不精确。 在淘宝早期的订单系统中把订单号当作数字处理，后来随意订单号暴增，已经超过了9007199254740992，最终的解法是把订单号改成字符串处理。 要想解决大数的问题你可以引用第三方库 bignumber.js，原理是把所有数字当作字符串，重新实现了计算逻辑，缺点是性能比原生的差很多，所以原生支持大数就很有必要了。TC39 已经有一个 Stage 3 的提案 proposal bigint，大数问题有望彻底解决。在浏览器正式支持前，可以使用 Babel 7.0 来实现，它的内部是自动转换成 big-integer 来计算，这样能保持精度但运算效率会降低。 toPrecision vs toFixed数据处理时，这两个函数很容易混淆。它们的共同点是把数字转成字符串供展示使用。注意在计算的中间过程不要使用，只用于最终结果。 不同点就需要注意一下： toPrecision 是处理精度，精度是从左至右第一个不为0的数开始数起。 toFixed 是小数点后指定位数取整，从小数点开始数起。 两者都能对多余数字做凑整处理，也有些人用 toFixed 来做四舍五入，但一定要知道它是有 Bug 的。 如：1.005.toFixed(2) 返回的是 1.00 而不是 1.01。 原因： 1.005 实际对应的数字是 1.00499999999999989，在四舍五入时全部被舍去！ 解法：使用四舍五入函数 Math.round() 来处理。但 Math.round(1.005 * 100) / 100还是不行，因为 1.005 * 100 = 100.49999999999999。还需要把乘法和除法精度误差都解决后再使用 Math.round。可以使用后面介绍的 number-precision#round 方法来解决。 解决方案回到最关心的问题：如何解决浮点误差。首先，理论上用有限的空间来存储无限的小数是不可能保证精确的，但我们可以处理一下得到我们期望的结果。 数据展示类当你拿到 1.4000000000000001 这样的数据要展示时，建议使用 toPrecision 凑整并 parseFloat 转成数字后再显示，如下： parseFloat(1.4000000000000001.toPrecision(12)) === 1.4 // True 封装成方法就是： function strip(num, precision = 12) &#123; return +parseFloat(num.toPrecision(precision)); &#125; 为什么选择 12 做为默认精度？这是一个经验的选择，一般选12就能解决掉大部分0001和0009问题，而且大部分情况下也够用了，如果你需要更精确可以调高。 数据运算类对于运算类操作，如 +-*/，就不能使用 toPrecision 了。正确的做法是把小数转成整数后再运算。以加法为例： /** * 精确加法 */ function add(num1, num2) &#123; const num1Digits = (num1.toString().split(&#39;.&#39;)[1] || &#39;&#39;).length; const num2Digits = (num2.toString().split(&#39;.&#39;)[1] || &#39;&#39;).length; const baseNum = Math.pow(10, Math.max(num1Digits, num2Digits)); return (num1 * baseNum + num2 * baseNum) / baseNum; &#125; 以上方法能适用于大部分场景。遇到科学计数法如 2.3e+1（当数字精度大于21时，数字会强制转为科学计数法形式显示）时还需要特别处理一下。 能读到这里，说明你非常有耐心，那我就放个福利吧。遇到浮点数误差问题时可以直接使用https://github.com/dt-fe/number-precision 完美支持浮点数的加减乘除、四舍五入等运算。非常小只有1K，远小于绝大多数同类库（如Math.js、BigDecimal.js），100%测试全覆盖，代码可读性强，不妨在你的应用里用起来！ 参考 Double-precision floating-point format What Every Programmer Should Know About Floating-Point Arithmetic Why Computers are Bad at Algebra | Infinite Series Is Your Model Susceptible to Floating-Point Errors? 原文里链接","categories":[{"name":"JavaScript","slug":"javascript","permalink":"https://kobingogo.github.io/categories/javascript/"}],"tags":[{"name":"number","slug":"number","permalink":"https://kobingogo.github.io/tags/number/"},{"name":"bigint","slug":"bigint","permalink":"https://kobingogo.github.io/tags/bigint/"}]},{"title":"Event Loop详解","slug":"javascript-event-loop","date":"2018-03-01T18:55:10.000Z","updated":"2022-02-18T02:31:03.811Z","comments":true,"path":"javascript-event-loop/","link":"","permalink":"https://kobingogo.github.io/javascript-event-loop/","excerpt":"JavaScript从诞生起就是一门单线程的语言,单线程的缺点是任务执行会阻塞，表现到网页里是：发起数据请求 --&gt; http延迟 --&gt; 等待完成，等待的过程中，其他操作无法执行，导致页面长时间无响应。 JavaScript用异步回调（asynchronous callback）去解决这些问题。实现异步回调的特性，其实是基于Event Loop（事件循环）。","text":"JavaScript从诞生起就是一门单线程的语言,单线程的缺点是任务执行会阻塞，表现到网页里是：发起数据请求 --&gt; http延迟 --&gt; 等待完成，等待的过程中，其他操作无法执行，导致页面长时间无响应。 JavaScript用异步回调（asynchronous callback）去解决这些问题。实现异步回调的特性，其实是基于Event Loop（事件循环）。 先了解一点基础知识1. JavaScript的 Engine 和 Runtime简单来说，为了让 JavaScript 运行起来，要完成两部分工作（当然实际比这复杂得多）： 第一部分是Engine（JS引擎）：编译并执行 JavaScript 代码，完成内存分配、垃圾回收等；第二部分是是 Runtime（运行时）：为 JavaScript 提供一些对象或机制，使它能够与外界交互。 举个例子： Chrome浏览器 和 Node.js 都使用了 V8 Engine。V8 实现并提供了 ECMAScript 标准中的所有数据类型、操作符、对象和方法（注意并没有 DOM）。 但它们的 Runtime 并不一样：Chrome 提供了 window、DOM，而 Node.js 则是 require、process 等等。 2. 浏览器的线程现代浏览器的一个 tab ，其中的线程包括但不局限于： GUI 渲染线程 JS引擎线程 事件触发线程 定时器触发线程 异步http请求线程 JavaScript中的异步回调是通过 WebAPIs 去支持的，常见的有 XMLHttpRequest，setTimeout，事件回调（onclik, onscroll等）。而这几个 API 浏览器都提供了单独的线程去运行，所以才会有合适的地方去处理定时器的计时、各种请求的回调。即当代码中出现这几个定义的异步任务，是由浏览器实现了它们与JS引擎的通信，与JS引擎不属与同一个线程。 另外，GUI 渲染和JavaScript执行是互斥的。虽然两者属于不同的线程，但是由于JavaScript执行结果可能会对页面产生影响，所以浏览器对此做了处理，大部分情况下JavaScript线程执行，执行渲染（render）的线程就会暂停，等JavaScript的同步代码执行完再去渲染。 Event loop的定义Event Loop（事件循环） 是让 JavaScript 做到既是单线程，又绝对不会阻塞的核心机制，也是 JavaScript 并发模型（Concurrency Model）的基础，是用来协调各种事件、用户交互、脚本执行、UI 渲染、网络请求等的一种机制。Event Loop的作用很简单： 监控调用栈和任务队列（见 3），如果调用栈是空的，它就会取出队列中的第一个&quot;callback函数&quot;，然后将它压入到调用栈中，然后执行它。 总的来说，Event Loop 是实现异步回调的一种机制而已。 1.分两种Event Loop 分为两种，一种存在于 Browsing Context 中，还有一种在 Worker 中。 Browsing Context 是指一种用来将 Document（文档）展现给用户的环境。例如浏览器中的 tab，window 或 iframe 等，通常都包含 Browsing Context。 Worker 是指一种独立于 UI 脚本，可在后台执行脚本的 API。常用来在后台处理一些计算密集型的任务。 本篇重点介绍的是 Browsing Context 中的 Event Loop，相比 Worker 中的 Event Loop，它也更加复杂一些。 另外，Event Loop 并不是在 ECMAScript 标准中定义的，而是在 HTML 标准中定义的。在 JS引擎中（以V8为例），只是实现了 ECMAScript 标准，而并不关心什么 Event Loop。也就是说 Event Loop 是属于 JavaScript Runtime 的，是由宿主环境（比如浏览器）提供的。所以千万不要理解错了，这也是前面介绍 JavaScript Engine 和 Runtime 的原因。 2.独立每个”线程“都有自己的 Event Loop。所以，每个 web worker 拥有独立的 Event Loop，它们都可以独立运行；同源的 windows 共享一个 Event Loop，它们之间可以互相通信。 内存模型从 JavaScript 内存模型的角度，我们可以将内存划分为调用栈（Call Stack）、堆（Heap）以及任务队列（Queue）等几个部分： 1. 调用栈调用栈会记录所有的函数调用信息，当我们调用某个函数时，会将其参数与局部变量等以栈帧的形式压入栈中（入栈）；在执行完毕后，会弹出栈顶的帧。让我们来看一看下面的例子： 12345678function multiply(x, y) &#123; return x * y;&#125;function printSquare(x) &#123; var s = multiply(x, x); console.log(s);&#125;printSquare(5); 当程序开始执行的时候，调用栈是空的，然后，步骤如下： 2. 堆堆则则存放了大量的非结构化数据，譬如程序分配的变量与对象。 3. 任务队列任务队列包含了一系列待处理的信息与相关联的回调函数。任务队列又分为 MacroTask Queue 和 MicroTask Queue 两种。 MacroTask 和 MicroTask1. MacroTask Queue（宏任务队列）Event Loop 会有一个或多个 MacroTask Queue，这是一个先进先出（FIFO）的有序列表，存放着来自不同 Task Source（任务源）的 Task（也即MacroTask）。 关于 Task，常有人通俗地称它为 MarcoTask，但其实 HTML 标准中并没有这种说法。然而，为了方便理解，本书仍沿用通俗的称谓MacroTask。 在 HTML 标准中，定义了几种常见的 Task Source： DOM manipulation（DOM 操作）； User interaction（用户交互）； Networking（网络请求）； History traversal（History API 操作）。 MacroTask Source 的定义非常的宽泛，常见的鼠标、键盘事件，AJAX，数据库操作（例如 IndexedDB），以及定时器相关的 setTimeout、setInterval 等等都属于 Task Source，所有来自这些 MacroTask Source 的 MacroTask 都会被放到对应的 MacroTask Queue 中等待处理。 对于 MacroTask、MacroTask Queue 和 Task Source，有如下规定： 来自相同 Task Source 的 MacroTask，必须放在同一个 MacroTask Queue 中； 来自不同 Task Source 的 MacroTask，可以放在不同的 MacroTask Queue 中； 同一个 MacroTask Queue 内的 MacroTask 是按顺序执行的； 但对于不同的 MacroTask Queue（Task Source），浏览器会进行调度，允许优先执行来自特定 Task Source 的 MacroTask。 例如，鼠标、键盘事件和网络请求都有各自的 MacroTask Queue，当两者同时存时，浏览器可以优先从用户交互相关的 MacroTask Queue 中挑选 MacroTask 并执行，比如这里的鼠标、键盘事件，从而保证流畅的用户体验。 2. MicroTask Queue（微任务队列）MicroTask Queue 与 MacroTask Queue 类似，也是一个有序列表。不同之处在于，一个 Event Loop 只有一个 MicroTask Queue。 在 HTML 标准中，并没有明确规定 MicroTask Source，通常认为有以下几种： Promise 在 Promises/A+ Note 3.1 中提到了 then、onFulfilled、onRejected 的实现方法，但 Promise 本身属于平台代码，由具体实现来决定是否使用 Microtask，因此在不同浏览器上可能会出现执行顺序不一致的问题。不过好在目前的共识是用 Microtask 来实现事件队列。 MutationObserver Object.observe (已废弃) 这里要特别提一下：网上有很多文章把 Node.js 的 process.nextTick 和 Microtask 混为一谈，事实上虽然两者层级（运行时机）非常接近，但并不是同一个东西。process.nextTick 是 Node.js 自身定义实现的一种机制，有自己的 nextTickQueue，与 HTML 标准中的 MicroTask 不是一回事。在 Node.js 中，process.nextTick 会先于 Microtask Queue 被执行。 3. 二者关系图例Event Loop中，每一次循环称为tick，每一次tick的任务细节如下： 调用栈选择最先进入队列的MacroTask（通常是script整体代码），如果有则执行； 检查是否存在 MicroTask，如果存在则不停的执行，直至清空 MicroTask Queue； 浏览器更新渲染（render），每一次事件循环，浏览器都可能会去更新渲染； 重复以上步骤。 MacroTask Queue和MicroTask Queue二者的关系如下图： 如图所示，二者互相穿插：MacroTask --&gt; MicroTask Queue --&gt; MacroTask。 一个Event Loop会有一个或多个 MacroTask Queue，而 Event Loop 仅有一个 MicroTask Queue。 这句话可能比较令人费解，因为图中似乎有2 个MicroTask Queue！ 其实是这样的，每个 MacroTask Queue 都保证按照回调函数（callback）入队列的顺序依次执行MacroTask，在 MacroTask 或者 MicroTask 中产生的新 MicroTask 会被压入到 MicroTask Queue中并执行。而在 执行两个MacroTask之间，也即在执行下一个MacroTask之前，会优先执行完所有MicroTask，也即会优先清空已有的 MicroTask Queue。 因此，图中第二个MicroTask Queue产生的时候，第一个MicroTask Queue其实已经被清空了。所以Event Loop实际上仅有一个MicroTask Queue。 JavaScript Runtime 的运行机制了解了 Event Loop 和任务队列的基本概念后，就可以从相对宏观的角度先了解一下 JavaScript Runtime 的运行机制了，简化后的步骤如下： 主线程不断循环； 对于同步任务，创建执行上下文（Execution Context），按顺序进入调用栈； 对于异步任务： 与步骤 2 相同，同步执行这段代码； 将相应的 MacroTask（或 Microtask）添加到任务队列； 由其他线程来执行具体的异步操作。 其他线程是指：尽管 JavaScript 是单线程的，但浏览器内核是多线程的，它会将 GUI 渲染、定时器触发、HTTP 请求等工作交给专门的线程来处理。另外，在 Node.js 中，异步操作会优先由 OS 或第三方系统提供的异步接口来执行，然后才由线程池处理。 当主线程执行完当前调用栈中的所有任务，就会去读取 Event Loop 的任务队列，取出并执行任务； 重复以上步骤。 用一张简图来表示一下这种运行机制： 还是拿 setTimeout 举例： 主线程同步执行这个 setTimeout 函数本身。 将负责执行这个 setTimeout 的回调函数的 MacroTask 添加到 MacroTask Queue。 定时器开始工作（实际上是靠 Event Loop 不断循环检查系统时间来判断是否已经到达指定的时间点）。 主线程继续执行其他任务。 当调用栈为空，且定时器触发时，主线程取出 MacroTask 并执行相应的回调函数。 很明显，执行 setTimeout 不会导致阻塞。当然，如果主线程很忙的话（调用栈一直非空），就会出现明明时间已经到了，却也不执行回调的现象，所以类似 setTimeout 这样的回调函数都是没法保证执行时机的。 setTimeout和setInterval取的时间是不准确的，因为当调用栈若不为空，它们的回调函数永远不会别执行。所以，我们会经常碰到setTimeout和setInterval用来做动画的时候，很不流畅或者卡顿。 面试题解析在面试中我们常常会碰到如下类似的代码题，面试官要你写出输出结果，其要目的是考察对JavaScript不同任务的执行先后顺序的理解： 1234567891011// 执行顺序问题，考察频率挺高setTimeout(function() &#123; console.log(1);&#125;);new Promise(function(resolve, reject) &#123; console.log(2); resolve(3);&#125;).then(function(val) &#123; console.log(val);&#125;);console.log(4); 根据本文的解析，我们可以得到： 先执行同步代码 首先，执行new Promise中的console.log(2)，then后面的属于MicroTask所以跳过； 然后，执行console.log(4)。 执行完script这个MacroTask后，执行MicroTask（也即Promise.then） 中的console.log(val)，此时val的值由resolve(3)传递过来，值为3。后面无其他微任务。 执行另一个MacroTask也即定时器setTimeout中的console.log(1)。 根据本文的内容，可以很轻松，且有理有据的猜出写出正确答案：2，4，3，1。","categories":[],"tags":[]},{"title":"javascript的继承实现","slug":"javascript-javascript的继承实现","date":"2018-03-01T17:19:23.000Z","updated":"2022-02-18T02:31:03.811Z","comments":true,"path":"javascript-javascript的继承实现/","link":"","permalink":"https://kobingogo.github.io/javascript-javascript%E7%9A%84%E7%BB%A7%E6%89%BF%E5%AE%9E%E7%8E%B0/","excerpt":"抛开JavaScript自带的class语法糖实现类的继承，如果用原生JavaScript实现类的继承，有以下六种方式，其实现代码与优缺点分析如下","text":"抛开JavaScript自带的class语法糖实现类的继承，如果用原生JavaScript实现类的继承，有以下六种方式，其实现代码与优缺点分析如下 01.类式继承(classical inheritance) 实现本质：重写子类的原型，代之以父类的实例。 1234567891011121314151617181920212223242526272829303132//父类function User(username) &#123; this.username = username ? username : &quot;Unknown&quot;; this.books = [&quot;coffe&quot;, &quot;1891&quot;];&#125;//子类function CoffeUser(username) &#123; if (username) this.username = username;&#125;//关键CoffeUser.prototype = new User();const user1 = new CoffeUser();const user2 = new CoffeUser();//instanceof是检测某个对象是否是某个类的实例console.log(user1 instanceof User);//&gt;&gt; true// 可以直接访问原型链上的属性console.log(user1.username);//&gt;&gt; Unknownconsole.log(user1.books); //&gt;&gt; [&quot;coffe&quot;, &quot;1891&quot;]//修改来自原型上的引用类型的属性，则有副作用：会影响到所有实例user1.books.push(&quot;hello&quot;);console.log(user1.books); //&gt;&gt; [&quot;coffe&quot;, &quot;1891&quot;, &quot;hello&quot;]console.log(user2.books); //&gt;&gt; [&quot;coffe&quot;, &quot;1891&quot;, &quot;hello&quot;]//修改来自原型上的值类型的属性，无副作用user1.username = &#x27;U&#x27;;console.log(user1.username, user2.username); //&gt;&gt; U Unknown 缺陷： 引用类型属性的误修改。原型属性中的引用类型属性会被所有实例共享，若子类实例更改从父类原型继承来的引用类型的共有属性，会影响其他子类。 无法传递参数。在创建子类型的实例时，不能向父类的构造函数中传递参数。这点如过不好理解的话，接着看下面的“构造函数式继承”。 综上，我们在实际开发中很少单独使用类式继承。 02.构造函数式继承通过call/apply调用来实现继承： 123456789101112131415161718function User(username, password) &#123; this.password = password; this.username = username; User.prototype.login = function () &#123; console.log(this.username + &#x27;要登录Github，密码是&#x27; + this.password); &#125;&#125;function CoffeUser(username, password) &#123; User.call(this, username, password);//通过call向父类的构造函数传递参数 this.articles = 3; // 文章数量&#125;const user1 = new CoffeUser(&#x27;coffe1891&#x27;, &#x27;123456&#x27;);console.log(user1 instanceof User);//&gt;&gt; falseconsole.log(user1.username, user1.password); //&gt;&gt; coffe1891 123456console.log(user1.login()); // TypeError: user1.login is not a function 存在明显的缺陷： 无法通过instanceof的测试； 并没有继承父类原型上的方法。 03.组合式继承既然上述两种方法各有缺点，但是又各有所长，那么我们是否可以将其结合起来使用呢？即原型链继承方法，而在构造函数继承属性，这种继承方式就叫做“组合式继承”。 123456789101112131415161718function User(username, password) &#123; this.password = password; this.username = username; User.prototype.login = function () &#123; console.log(this.username + &#x27;要登录Github，密码是&#x27; + this.password); &#125;&#125;function CoffeUser(username, password) &#123; User.call(this, username, password); // 第2次执行 User 的构造函数 this.articles = 3; // 文章数量&#125;CoffeUser.prototype = new User(); // 第1次执行 User 的构造函数const user1 = new CoffeUser(&quot;coffe1891&quot;, &quot;123456&quot;);console.log(user1 instanceof User);//&gt;&gt; trueuser1.login();//&gt;&gt; coffe1891要登录Github，密码是123456 虽然这种方式弥补了上述两种方式的一些缺陷，但有些问题仍然存在： 父类的构造函数被调用了两次，显得多余； 污染：若再添加一个子类型，给其原型单独添加一个方法，那么其他子类型也同时拥有了这个方法。 综上，组合式继承也不是我们最终想要的。 04.原型继承(prototypal inheritance)原型继承实际上是对类式继承的一种封装，只不过其独特之处在于，定义了一个干净的中间类，如下： 123456789function createObject(o) &#123; // 创建临时类 function F() &#123; &#125; // 修改类的原型为o, 于是f的实例都将继承o上的方法 F.prototype = o; return new F();&#125; 这不就是ES5的 Object.create 吗？没错，你可以认为是如此。 既然只是类式继承的一种封装，其使用方式自然如下： 1CoffeUser.prototype = createObject(User) 也就仍然没有解决类式继承的一些问题。从这个角度而言，原型继承和类式继承应该直接归为一种继承。 05.寄生式继承寄生式继承是与原型继承紧密相关的一种思路，它依托于一个内部对象而生成一个新对象，因此称之为寄生。 12345678910111213141516const UserSample = &#123; username: &quot;coffe1891&quot;, password: &quot;123456&quot;&#125;function CoffeUser(obj) &#123; var o = Object.create(obj);//o继承obj的原型 o.__proto__.readArticle = function () &#123;//扩展方法 console.log(&#x27;Read article&#x27;); &#125; return o;&#125;var user = new CoffeUser(UserSample);user.readArticle();//&gt;&gt; Read articleconsole.log(user.username, user.password);//&gt;&gt; coffe1891 123456 06.寄生组合式继承12345678910111213141516171819202122232425262728293031323334353637//寄生组合式继承的核心方法function inherit(child, parent) &#123; // 继承父类的原型 const p = Object.create(parent.prototype); // 重写子类的原型 child.prototype = p; // 重写被污染的子类的constructor p.constructor = child;&#125;//User, 父类function User(username, password) &#123; let _password = password this.username = username&#125;User.prototype.login = function () &#123; console.log(this.username + &#x27;要登录Github，密码是&#x27; + _password); //&gt;&gt; ReferenceError: _password is not defined&#125;//CoffeUser, 子类function CoffeUser(username, password) &#123; User.call(this, username, password) // 继承属性 this.articles = 3 // 文章数量&#125;//继承inherit(CoffeUser, User);//在原型上添加新方法CoffeUser.prototype.readArticle = function () &#123; console.log(&#x27;Read article&#x27;);&#125;const user1 = new CoffeUser(&quot;Coffe1891&quot;, &quot;123456&quot;);console.log(user1); 观察chrome浏览器的输出结果： 简单说明一下： 子类继承了父类的属性和方法，同时，属性没有被创建在原型链上，因此多个子类不会共享同一个属性； 子类可以传递动态参数给父类； 父类的构造函数只执行了一次。 Nice！这才是我们想要的继承方法。然而，仍然存在一个美中不足的问题： 子类想要在原型上添加方法，必须在继承之后添加，否则将覆盖掉原有原型上的方法。这样的话若是已经存在的两个类，就不好办了。 所以，我们可以将其优化一下： 12345678function inherit(child, parent) &#123; // 继承父类的原型 const parentPrototype = Object.create(parent.prototype) // 将父类原型和子类原型合并，并赋值给子类的原型 child.prototype = Object.assign(parentPrototype, child.prototype) // 重写被污染的子类的constructor p.constructor = child&#125; 但实际上，使用Object.assign 来进行 copy 仍然不是最好的方法。因为上述的继承方法只适用于 copy 原型链上可枚举的方法，而ES6中，类的方法默认都是不可枚举的。此外，如果子类本身已经继承自某个类，以上的继承将不能满足要求。 参考文献Inheritance in JavaScript","categories":[{"name":"JavaScript","slug":"javascript","permalink":"https://kobingogo.github.io/categories/javascript/"}],"tags":[{"name":"继承","slug":"继承","permalink":"https://kobingogo.github.io/tags/%E7%BB%A7%E6%89%BF/"},{"name":"JavaScript","slug":"javascript","permalink":"https://kobingogo.github.io/tags/javascript/"}]},{"title":"敲入URL到看到页面的全过程分析","slug":"Chrome源码-敲入URL到看到页面的全过程","date":"2018-02-27T15:18:36.000Z","updated":"2022-02-18T02:31:03.807Z","comments":true,"path":"Chrome源码-敲入URL到看到页面的全过程/","link":"","permalink":"https://kobingogo.github.io/Chrome%E6%BA%90%E7%A0%81-%E6%95%B2%E5%85%A5URL%E5%88%B0%E7%9C%8B%E5%88%B0%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/","excerpt":"这是一个经典的面试题，相信每个人都会说出一些点来，但是要想全面细致的解答这个问题，就必须对网络通信、webkit内核有一定的了解。本文试图从更细微的层面剖析这个问题。","text":"这是一个经典的面试题，相信每个人都会说出一些点来，但是要想全面细致的解答这个问题，就必须对网络通信、webkit内核有一定的了解。本文试图从更细微的层面剖析这个问题。 1. 输入地址浏览器引入了 DNS 预取技术。它是利用现有的 DNS 机制，提前解析网页中可能的网络连接。 当我们开始在浏览器中输入网址的时候，浏览器其实就已经在智能的匹配可能得 url 了。它会从历史记录，书签等地方，找到已经输入的字符串可能对应的 url ，找到同输入的地址很匹配的项，然后给出智能提示，让你可以补全 url 地址。用户还没有按下 enter 键， 浏览器已经开始使用 DNS 预取技术解析该域名了。 对于 chrome 的浏览器，如果有该域名相关的缓存，它会直接从缓存中把网页展示出来，就是说，你还没有按下 enter，页面就出来了。如果没有缓存，就还是会重新请求资源。 2. 查询 DNS 查找对应的请求 IP 地址假设输入 www.baidu.com，大概过程： 浏览器搜索自己的 DNS 缓存。 在浏览器缓存中没找到，就在操作系统缓存中查找，这一步中也会查找本机的 hosts 看看有没有对应的域名映射。 在系统中也没有的话，就到你的路由器来查找，因为路由器一般也会有自己的 DNS 缓存。 若没有，则操作系统将域名发送至 本地域名服务器——递归查询方式，本地域名服务器 查询自己的 DNS 缓存，查找成功则返回结果，否则，采用迭代查询方式。本地域名服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。 本地域名服务器 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来。 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来，以备下次别的用户查询时，可以直接返回结果，加快网络访问。 至此，浏览器已经得到了域名对应的 IP 地址。 3. 建立 TCP 连接TCP 是一种面向有连接的传输层协议。 它可以保证两端（发送端和接收端）通信主机之间的通信可达。 它能够处理在传输过程中丢包、传输顺序乱掉等异常情况；此外它还能有效利用宽带，缓解网络拥堵。 三次握手的步骤：（抽象派） 123客户端：hello，你是server么？服务端：hello，我是server，你是client么客户端：yes，我是client 在 TCP 连接建立完成之后就可以发送 HTTP 请求了。 然后，待到断开连接时，需要进行四次挥手（因为是全双工的，所以需要四次挥手） 四次挥手的步骤：（抽象派） 1234主动方：我已经关闭了向你那边的主动通道了，只能被动接收了被动方：收到通道关闭的信息被动方：那我也告诉你，我这边向你的主动通道也关闭了主动方：最后收到数据，之后双方无法通信 4. 服务器收到请求并响应 HTTP 请求在接收和解释请求消息后，服务器返回一个HTTP响应消息。 HTTP 响应由三个部分组成，分别是：状态行、消息报头、响应正文。 状态代码：由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值： 1xx：指示信息--表示请求已接收，继续处理2xx：成功--表示请求已被成功接收、理解、接受3xx：重定向--要完成请求必须进行更进一步的操作4xx：客户端错误--请求有语法错误或请求无法实现5xx：服务器端错误--服务器未能实现合法的请求常见状态代码、状态描述、说明： 200 OK ：客户端请求成功400 Bad Request ：客户端请求有语法错误，不能被服务器所理解401 Unauthorized ：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用403 Forbidden ：服务器收到请求，但是拒绝提供服务404 Not Found ：请求资源不存在，eg：输入了错误的URL500 Internal Server Error ：服务器发生不可预期的错误503 Server Unavailable ：服务器当前不能处理客户端的请求，一段时间后可能恢复正常HTTP消息报头包括：普通报头、请求报头、响应报头、实体报头。具体不作介绍。 响应正文：就是服务器返回的资源的内容 5.浏览器接收服务器响应结果并处理在浏览器没有完整接受全部HTML文档时，它就已经开始显示这个页面了，不同浏览器可能解析的过程不太一样，这里我们只介绍 WebKit 的渲染过程。 渲染步骤大致可以分为以下几步： 解析HTML，构建 DOM 树 解析 CSS ，生成 CSS 规则树 合并 DOM 树和 CSS 规则，生成 render 树 布局 render 树（ Layout / reflow ），负责各元素尺寸、位置的计算 绘制 render 树（ paint ），绘制页面像素信息 浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（ composite ），显示在屏幕上 其中每个解释的过程中，WebKit 都提供了很多相关的类来一步一步地解释对应的内部模块，这里面不做详细描述。 下面根据上面的大致过程来一步步细解。 5.1 构造 DOM 树浏览器在解析html文件时, 是WebKit 中的 HTML 解释器的将网络或者本地磁盘获取的 HTML 网页和资源从字节流解释成 DOM 树结构。具体过程如下 ： 在 WebKit 中这一过程如下：首先是字节流，经过解码之后是字符流，然后通过词法分析器会被解释成词语（Tokens），之后经过语法分析器构建成节点，最后这些节点被组建成一棵 DOM 树。 浏览器在解析html文件过程中，会 ”自上而下“ 加载，并在加载过程中进行解析渲染。在解析过程中，如果遇到请求外部资源时，如图片、外链的CSS、iconfont等，请求过程是异步的，并不会影响html文档进行加载，且统一交由 Browser 进程来处理，这使得资源在不同网页间的共享变得很容易。 HTML 的解释、布局和渲染等工作基本上就是工作在渲染线程完成的（这不是绝对的）。因为 DOM 树只能在渲染线程上创建和访问，这也就是说构建 DOM 树的过程只能在渲染线程中进行，但是，从字符到词语这个阶段可以交给另外的单独的线程来做。 而且因为有 DNS 预取技术，当用户正在浏览当前网页的时候，Chromium 提取网页中的超链接，将域名抽取出来，利用比较少的 CPU 和网络带宽来解析这些域名或者 IP 地址，这样一来，用户根本感觉不到这一过程。当用户单击这些链接的时候，可以节省不少时间，特别在域名解析比较慢的时候，效果特别明显。 解析过程中，浏览器首先会解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建 Render树，等到 Render 树构建完成后，浏览器开始布局 Render 树并将其绘制到屏幕上。 5.2 解释 CSSCSS 解释过程是指从 CSS 字符串 经过 CSS 解释器 处理后变成渲染引擎内部规则的表示过程。 生成样式规则之后，会进行样式规则匹配，WebKit 会为其中的一些节点（只限于可视节点）选择合适的样式信息，规则的匹配则是由 ElementRuleCollector 类来计算并获得，它根据元素的属性等，并从 DocumentRuleSets 类中获取规则集合，依次按照 ID、类别、标签等选择器信息逐次匹配获得元素的样式。 最后，WebKit 对这些规则进行排序。对于该元素需要的样式属性，WebKit 选择从高优先级规则中选取，并将样式属性值返回。 从整个网页的加载和渲染过程来看，CSS 解释和规则匹配处于 DOM 树建立之后，RenderObject 树建立之前，CSS 解释器解释后的结果会保存起来，然后 RenderObject 树基于该结果来进行规范匹配和布局计算。当网页有用户交互或者动画等动作的时候，通过 CSSDOM 等技术，JavaScript 代码同样可以非常方便地修改 CSS 代码，WebKit 此时需要重新解释样式并重复以上这一过程。 5.3 渲染过程遇到 JavaScript当文档加载过程中遇到 js 文件，html 文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中 js 文件加载完毕，还要等待解析执行完毕，才可以恢复 html 文档的渲染线程。因为 JS 有可能会修改 DOM，最为经典的 document.write，这意味着，在 JS 执行完成前，后续所有资源的下载可能是没有必要的，这是 js 阻塞后续资源下载的根本原因。所以我们平时的代码中，js 是放在 html 文档末尾的。 而且当遇到执行 JavaScript 代码的时候，WebKit 先暂停当前 JavaScript 代码的执行，使用预先扫描器 HTMLPreloadScanner 类来扫描后面的词语。如果 WebKit 发现它们需要使用其他资源，那么使用预资源加载器 HTMLPreloadScanner 类来发送请求，在这之后，才执行 JavaScript 代码。预先扫描器本身并不创建节点对象，也不会构建 DOM 树，所以速度比较快。 当 DOM 树构建完之后，WebKit 触发 “DOMContentLoaded” 事件，注册在该事件上的 JavaScript 函数会被调用。当所在资源都被加载完之后，WebKit 触发 “onload” 事件。 WebKit 将 DOM 树创建过程中需要执行的 JavaScript 代码交由 HTMLScriptRunner 类来负责。工作方式很简单，就是利用 JavaScript 引擎来执行 Node 节点中包含的代码。 JS 的解析是由浏览器中的 JavaScript 引擎完成的。JS是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如 IO 读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。 JS 的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈; 异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。 5.4 渲染合成 Render 树HTML 经过 WebKit 解释之后，生成 DOM 树。在 DOM 树构建完成之后，WebKit 会为 DOM 树节点构建 RenderObject 树，再通过 RenderObject 树构建出 RenderLayer 树。 RenderObject 树是基于 DOM 树建立起来的一棵新树，是为了布局计算和渲染等机制而构建的一种新的内部表示。RenderObject 树节点和 DOM 节点不是一一对应关系，因为有可视节点（常用的 div img 标签等）与不可视节点（如 head、meta 标签），不可视节点是不会构成 RenderObject 树的。 网页是有层次结构的，可以分层的，一是为了方便设置网页的层次，二是为了 WebKit 处理上的便利，为了简化渲染的逻辑。 而且 RenderLayer 节点和 RenderObject 节点不是一一对应关系，而是一对多的关系。 5.5 布局当 WebKit 创建 RenderObject 对象之后，每个对象是不知道自己的位置、大小等信息的，WebKit 根据框模型来计算它们的位置，大小等信息的过程称为布局计算。 布局计算是一个递归的过程，因为一个节点的大小通常需要先计算它的子女节点的位置，大小等信息。 当用户 网页的动画、翻滚网页、JavaScript 代码通过 CSSDOM 等操作时还会有重新布局。 5.6 绘制在 WebKit 中，绘图操作就是绘图上下文，所有绘图的操作都是在该上下文中来进行的。 绘图上下文可以分成两种类型： 一是 2D 图形上下文（GraphicsContext），用来绘制 2D 图形的的上下文； 二是 3D 绘图上下文，是用来绘制 3D 图形的上下文。 2D 绘图上下文具体的作用：提供基本绘图单元的绘制接口以及设置绘图的样式。绘图接口包括画点，画线、画图片、画多边形、画文字等，绘图样式包括颜色、线宽、字号大小、渐变等。 关于 3D 绘图上下文，它的主要用处是支持 CSS3D、WebGL 等。 网页的渲染方式，有三种方式，一是软件渲染，二是硬件加速渲染，三可以说是混合模式。 如果绘图操作使用 CPU 来完成，称之为软件绘图。 如果绘图操作由 GPU 来完成，称之为 GPU 硬件加速绘图。 理想情况下，每个层都有个绘制的存储区域，这个存储区域用来保存绘图的结果。最后，需要将这些层的内容合并到同一个图像之中，可以称之为合成（Compositing），使用了合成技术的渲染称之为合成化渲染。 所以，在完成构建 DOM 树之后，WebKit 会调用绘图操作、软件渲染或者硬件加速渲染或者两者都有，将模型绘制出来，呈现在屏幕上。 至此，浏览器渲染完成。","categories":[{"name":"浏览器","slug":"浏览器","permalink":"https://kobingogo.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://kobingogo.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"原型与原型链","slug":"javascript-原型与原型链","date":"2018-02-05T15:45:38.000Z","updated":"2022-02-18T02:31:03.811Z","comments":true,"path":"javascript-原型与原型链/","link":"","permalink":"https://kobingogo.github.io/javascript-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"在ES6之前，JavaScript 中除了基础类型外的数据类型都是对象（引用类型），没有类（class），为了实现类似继承以便复用代码的能力，JavaScript选择了原型和原型链。甚至在ES6之后，JavaScript也没有真正的类（class）。ES6虽然提供了class关键字让我么可以伪造一个“类”，但其实只是语法糖而已，本质上仍然是一个对象。ES6实现的继承，本质仍是基于原型和原型链。","text":"在ES6之前，JavaScript 中除了基础类型外的数据类型都是对象（引用类型），没有类（class），为了实现类似继承以便复用代码的能力，JavaScript选择了原型和原型链。甚至在ES6之后，JavaScript也没有真正的类（class）。ES6虽然提供了class关键字让我么可以伪造一个“类”，但其实只是语法糖而已，本质上仍然是一个对象。ES6实现的继承，本质仍是基于原型和原型链。 原型、prototype、__proto__ 原型是一个对象。 prototype是函数的一个属性而已，也是一个对象，它和原型没有绝对的关系（很多书、很多网络文章都模糊地将prototype表述为原型，这是严重不对的）。JavaScript里函数也是一种对象，每个对象都有一个原型，但不是所有对象都有prototype属性，实际上只有函数才有这个属性。 12345678var a = function()&#123;&#125;;var b=[1,2,3];//函数才有prototype属性console.log(a.prototype);//&gt;&gt; function()&#123;&#125;//非函数，没有prototype属性console.log(b.prototype);//&gt;&gt; undefined 每个对象(实例)都有一个属性__proto__，指向他的构造函数（constructor）的prototype属性。 一个对象的原型就是它的构造函数的prototype属性的值，因此**__proto__也即原型的代名词**。 对象的__proto__也有自己的__proto__，层层向上，直到__proto__为null。换句话说，原型本身也有自己的原型。这种由原型层层链接起来的数据结构成为 原型链。因为null不再有原型，所以原型链的末端是null。 让我们用更多代码来验证一下以上结论： 123456789101112131415161718var a = function()&#123;&#125;;var b=[1,2,3];//a的构造函数是「Function函数」console.log(a.__proto__ == Function.prototype);//&gt;&gt; true//b的构造函数是「Array函数」console.log(b.__proto__ == Array.prototype);//&gt;&gt; true//因为「Function函数」和「Array函数」又都是对象，其构造函数//是「Object函数」，所以，a和b的原型的原型都是Object.prototypeconsole.log(a.__proto__.__proto__ === Object.prototype);//&gt;&gt; trueconsole.log(b.__proto__.__proto__ === Object.prototype);//&gt;&gt; true//Object作为顶级对象的构造函数，它实例的原型本身就不再有原型了，因此它原型//的__proto__属性为nullconsole.log(new Object().__proto__.__proto__);//&gt;&gt; null//也即Object类型对象，其原型（Object.prototype）的__proto__为nullconsole.log(Object.prototype.__proto__);//&gt;&gt; null 三者关系图如下： 使用__proto__是有争议的，也不鼓励使用它。因为它从来没有被包括在EcmaScript语言规范中，但是现代浏览器都实现了它。__proto__属性已在ECMAScript 6语言规范中标准化，用于确保Web浏览器的兼容性，因此它未来将被支持。但是，它已被不推荐使用，现在更推荐使用Object.getPrototypeOf/Reflect.getPrototypeOf 和Object.setPrototypeOf/Reflect.setPrototypeOf（尽管如此，设置对象的原型是一个缓慢的操作，如果性能要求很高，应该避免设置对象的原型）。 原型继承使用最新的方法Object.setPrototypeOf（类似Reflect.setPrototypeOf）可以很方便地给对象设置原型，这个对象会继承该原型所有属性和方法。 但是，setPrototypeOf的性能很差，我们应该尽量使用 Object.create()来为某个对象设置原型。 1234567891011//obj的原型是Object.prototypevar obj=&#123; methodA()&#123; console.log(&quot;coffe&quot;); &#125;&#125;var newObj = Object.create(obj);//以obj为原型创建一个新的对象//methodA实际上是newObj原型对象obj上的方法。也即newObj继承了它的原型对象obj的属性和方法。newObj.methodA();//&gt;&gt; coffe 类(class）的prototype和__proto__ES6之后，类(class)也有了prototype属性，为什么呢，因为class本质上是构造函数的语法糖. 1234class A &#123;&#125;typeof A;//&gt;&gt; &quot;function&quot; 说明class本质上也是函数，所以它带有prototype属性是十分正常的事。然后，在Chrome浏览器里调试如下代码： 1234class A &#123;&#125;A.prototype; 得到的结果如下图: 上面代码说明类的prototype是一个对象，它包含有constructor属性。这和函数的prototype属性表现具有一致性。 1234class A &#123;&#125;A===A.prototype.constructor;//&gt;&gt; true 上面代码说明一个重要结论：类指向自身构造函数。而且，事实上，类的所有方法都定义在类的prototype属性上面。同样可以通过Chrome调试验证。 1234567891011121314151617181920class A&#123; constructor() &#123; // ... &#125; toString() &#123; // ... &#125; toValue() &#123; // ... &#125;&#125;// 等同于A.prototype = &#123; constructor() &#123;&#125;, toString() &#123;&#125;, toValue() &#123;&#125;,&#125;; 结果如下： 定理class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。 （1）子类的__proto__属性，表示构造函数的继承，总是指向父类。 （2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。 12345678class A &#123;&#125;class B extends A &#123;&#125;B.__proto__ === A //&gt;&gt; trueB.prototype.__proto__ === A.prototype //&gt;&gt; true","categories":[{"name":"JavaScript","slug":"javascript","permalink":"https://kobingogo.github.io/categories/javascript/"}],"tags":[{"name":"原型","slug":"原型","permalink":"https://kobingogo.github.io/tags/%E5%8E%9F%E5%9E%8B/"}]},{"title":"闭包","slug":"javascript-闭包","date":"2018-02-03T15:04:57.000Z","updated":"2022-02-18T02:31:03.811Z","comments":true,"path":"javascript-闭包/","link":"","permalink":"https://kobingogo.github.io/javascript-%E9%97%AD%E5%8C%85/","excerpt":"闭包是JavaScript的强大的特性，很多强大JavaScript库比如jQuery、Vue.js都使用了闭包的特性来实现的，同时，闭包也是js里的理解难点之一。","text":"闭包是JavaScript的强大的特性，很多强大JavaScript库比如jQuery、Vue.js都使用了闭包的特性来实现的，同时，闭包也是js里的理解难点之一。 热身：循环中的闭包12345for (var i = 1; i &lt;= 5; i++) &#123; setTimeout(function test() &#123; console.log(i) //&gt;&gt; 6 6 6 6 6 &#125;, i * 1000);&#125; 本意是想每隔一秒依次输出“1 2 3 4 5”，结果变成输出“6 6 6 6 6 ”。为什么会这样呢，根据作用域链上变量查找机制，setTimeout第一个参数的函数体内的i引用了去全局作用域里面的i，当for循环完毕后，i的值为6，所以输出了“6 6 6 6 6 ”。 如何实现正确的输出呢？ 其实用闭包就能轻松解决这个问题： 1234567for (var i = 1; i &lt;= 5; i++) &#123; (function(j) &#123;//包了一层IIFE形式的函数，这个函数是闭包 setTimeout(function test() &#123;//函数体内的j引用了外层匿名函数的参数j console.log(j); //&gt;&gt; 1 2 3 4 5 &#125;, j * 1000); &#125;)(i);&#125; 什么是闭包1. 闭包的定义关于JavaScript闭包的定义有很多种，每本书、每个作者都有不完全相同的描述，虽然笔者认为函数就是闭包这个定义才是最简单最直白的，但其实笔者看到过不下十种定义，到现在一种都记不住。鉴于此，我们干脆不要记住这些五花八门的定义了，只要记住了产生闭包的时机会更实际一些，面试时，把闭包产生的时机告诉面试官就可以了： 内层的作用域访问它外层函数作用域里的参数/变量/函数时，闭包就产生了。让我们用代码来说事儿吧： 1234567891011function func()&#123;//func1引用了它外层的变量a，因此func成为了闭包 let a=&quot;coffe&quot;; function func1()&#123; console.log(a);//访问了外层函数func体内的变量a debugger;//断点 &#125; func1();&#125;func(); 我们在chrome浏览器的“开发者工具”里面的控制台，运行上面的代码，可以很方便看到闭包。 看上面这个图，Closure出现在Scope一栏里面，所以可以认为闭包也是一种作用域。既然闭包也是一种作用域，闭包能够解决经典的“循环中的闭包”的问题，那是不是利用作用域就能解决问题？这让人想到了关键字let，试试看吧，把本文开头的代码改造一下： 12345678for (var i = 1; i &lt;= 5; i++) &#123; &#123; let j = i; setTimeout(function test() &#123; console.log(j) //&gt;&gt; 1 2 3 4 5 &#125;, j * 1000); &#125;&#125; 果然，用let关键字包上一个作用域，也能和闭包一样解决问题达成目的。因此可以说，闭包是一种作用域，它拷贝了一套外层函数作用域中被访问的参数、变量/函数，这个拷贝都是浅拷贝 2. 写成闭包形式有什么好处呢？当然有好处！还是以之前的代码为例，变量a类似于高级语言的私有属性，无法被func外部作用域访问和修改，只有func内部的作用域（含嵌套作用域）可以访问。这样可以实现软件设计上的封装，设计出很强大的类库、框架，比如我们常用的jQuery、AngularJS、Vue.js。 看一个ES6出现之前最常见的模块化封装的例子: 12345678910111213141516171819202122//定义一个模块function module(n) &#123; //私有属性 let name = n; //私有方法 function getModuleName() &#123; return name; &#125; //私有方法 function someMethod() &#123; console.log(&quot;coffe1891&quot;); &#125; //以一个对象的形式返回 return &#123; getModuleName: getModuleName, getXXX: someMethod &#125;;&#125;let myapp = module(&quot;myModule&quot;);//定义一个模块console.log(myapp.getModuleName()); //&gt;&gt; myModuleconsole.log(myapp.getXXX()); //&gt;&gt; coffe1891 3. 闭包有什么缺点吗？javascript中的垃圾回收（GC）规则是这样的：如果对象不再被引用，或者对象互相引用形成数据孤岛后且没有被孤岛之外的其他对象引用，那么这些对象将会被JS引擎的垃圾回收器回收；反之，这些对象一直会保存在内存中。 由于闭包会引用包含它的外层函数作用域里的变量/函数，因此会比其他非闭包形式的函数占用更多内存。当外层函数执行完毕退出函数调用栈（call stack）的时候，外层函数作用域里变量因为被引用着，可能并不会被JS引擎的垃圾回收器回收，因而会引起内存泄漏。过度使用闭包，会导致内存占用过多，甚至内存泄漏。 123456789101112function A()&#123; var count = 0; function B()&#123; count ++; console.log(count); &#125; return B;//函数B保持了对count的引用&#125;var b = A();b();//&gt;&gt; 1b();//&gt;&gt; 2b();//&gt;&gt; 3 count是函数A中的一个变量，它的值在函数B中被改变，B每执行一次，count的值就在原来的基础上累加1。因此，函数A中的count一直保存在内存中，并没有因为函数A执行完毕退出函数调用栈后被JS引擎的垃圾回收器回收掉。 避免闭包导致内存泄漏的解决方法是，在函数A执行完毕退出函数调用栈之前，将不再使用的局部变量全部删除或者赋值为null。 其他使用场景介绍除了上面介绍过的循环中的闭包、模块化封装之外，闭包还有一些其他写法。 1. 返回一个新函数123456789101112function sayHello2(name) &#123; var text = &quot;Hello &quot; + name; // 局部变量 var sayAlert = function() &#123; console.log(text); &#125;; return sayAlert;&#125;var say2 = sayHello2(&quot;coffe1891&quot;);say2(); //&gt;&gt; Hello coffe1891 调用sayHello2()函数返回了sayAlert，赋值给say2。注意say2是一个引用变量，指向一个函数本身，而不是指向一个变量。 2. 扩展全局对象的方法下面这种利用闭包扩展全局对象，可以有效地保护私有变量，形成一定的封装、持久性。 12345678910111213141516171819202122232425function setupSomeGlobals() &#123; //私有变量 var num = 666; gAlertNumber = function() &#123;//没有用var和let关键字声明，会成为全局对象的方法 console.log(num); &#125;; gIncreaseNumber = function() &#123; num++; &#125;; gSetNumber = function(x) &#123; num = x; &#125;;&#125;setupSomeGlobals();gAlertNumber(); //&gt;&gt; 666gIncreaseNumber();gAlertNumber(); //&gt;&gt; 667gSetNumber(1891);gAlertNumber(); //&gt;&gt; 1891 三个全局函数gAlertNumber，gIncreaseNumber，gSetNumber指向了同一个闭包，因为它们是在同一次setupSomeGlobals()调用中声明的。它们所指向的闭包是与setupSomeGlobals()函数关联一个作用域，该作用域包括了num变量的拷贝。也就是说，这三个函数操作的是同一个num变量。 3. 延长局部变量的生命日常开发时，Image对象经常被用于数据统计的上报，示例代码如下： 12345var report = function(src) &#123; var img = new Image(); img.src = src;&#125;report(&#x27;http://www.xxx.com/getClientInfo&#x27;);//把客户端信息上报数据 这段代码在运行时，发现在一些低版本浏览器上存在bug，会丢失部分数据上报。原因是Image对象是report函数中的局部变量，当report函数调用结束后，Image对象随即被JS引擎垃圾回收器回收，而此时可能还没来得及发出http请求，所以可能导致此次上报数据的请求失败。 怎么办呢？我们可以使用闭包把Image对象封闭起来，就可以解决数据丢失的问题，代码如下： 123456789var report = (function() &#123; var imgs = [];//在内存里持久化 return function(src) &#123; var img = new Image(); imgs.push(img);//引用局部变量imgs img.src = src; &#125;&#125;());report(&#x27;http://www.xxx.com/getClientInfo&#x27;);//把客户端信息上报数据","categories":[{"name":"JavaScript","slug":"javascript","permalink":"https://kobingogo.github.io/categories/javascript/"}],"tags":[{"name":"闭包","slug":"闭包","permalink":"https://kobingogo.github.io/tags/%E9%97%AD%E5%8C%85/"}]},{"title":"完全理解javascript里的this","slug":"javascript-javascript里的this","date":"2018-02-01T14:03:22.000Z","updated":"2022-02-18T02:31:03.811Z","comments":true,"path":"javascript-javascript里的this/","link":"","permalink":"https://kobingogo.github.io/javascript-javascript%E9%87%8C%E7%9A%84this/","excerpt":"","text":"this是JavaScript世界最让人迷惑的关键字之一，很多人对它一知半解，本文希望详细的把this说明白。 为什么要有this？JavaScript 允许在函数体内部，引用当前执行上下文的其他变量。 123function func() &#123; console.log(a);&#125; 如上代码，函数func引用了当前执行上下文的变量a，问题是这个函数func可以在任意其他执行上下文中被调用，因此这个a可能就指向不同了。正因为如此，JS引擎需要有一个机制，可以依靠其 优雅地、准确地指向当前代码运行时所处的上下文环境（context）。 因此便催生了“this”。 何谓”优雅地“？12345678910//假设有个对象名字很长，而且有可能会改名var iAmALongLongLongNameObject=&#123; name:&quot;coffe&quot;, func1()&#123; return iAmALongLongLongNameObject.name; &#125;, func2()&#123; return this.name; &#125;&#125; iAmALongLongLongNameObject的方法func2使用了this关键字，是不是优雅多了？然后即使以后对象名字变化，func2内部的代码也不用改变。func1这种确实也可以实现与func2同样的功能，但是就显得丑陋、不灵活了。 何谓“准确地”？this可以准确地指向（某个对象）而不会产生歧义。 123456789101112131415161718192021//全局变量var iAmALongLongLongNameObject = &#123; name: &quot;1891&quot;&#125;;(function() &#123; //局部变量 var iAmALongLongLongNameObject = &#123; name: &quot;coffe&quot;, func1() &#123; //如果光看代码，是不是容易看成调用了全局变量的name？ return iAmALongLongLongNameObject.name; &#125;, func2() &#123; //这里光看代码就很准确地知道是调用了局部变量的name！ return this.name; &#125; &#125;; console.log(iAmALongLongLongNameObject.func1());//&gt;&gt; coffe&#125;)(); 与“Java等高级语言的this会指向对象的实例本身”不同，JavaScript的this指向函数的调用位置的对象，也即调用该函数的对象。你需要知道，JavaScript中所有的函数都有属性，就如对象有属性一样。函数执行阶段（也即执行上下文的执行阶段）会获取this属性的值，此时this就是一个变量，储存着调用该函数的对象的值。 12345var a = &quot;coffe&quot;;function func() &#123; console.log(this.a);&#125;func();//&gt;&gt; coffe 上面代码中，func的调用者未通过点操作符.指明，那它的调用者就是默认的全局对象window，func函数作为window的一个方法，其体内的this.a就是明确指代window中属性a，这种指向是准确而清晰的，不会有歧义。this的这种灵活性在设计API的时候，会变得很方便和容易被复用。 调用位置调用位置就是函数在代码中被调用的位置，而不是声明的位置。研究调用位置，也即搞清“由谁在哪调用了这个函数”的问题。搞清楚了调用位置，才能准确地找到this的指向。 要找到调用位置，最重要的是要分析是被谁、在哪调用。 1234567891011var module = &#123; x: &quot;1891&quot;, getX: function() &#123; return this.x; &#125;&#125;console.log(module.getX());//&gt;&gt; 1891var getX = module.getX;//注意：getX和module.getX都是指向内存中函数的地址而已，它们并没有被“()”以便执行 //这里实际上是【间接引用】的模式，见文尾【壹.2.3.6】解释console.log(getX()); //&gt;&gt; undefined 如上代码，要找到函数getX的调用位置，需要先看哪儿调用了它，很明显，有函数有两处位置调用了函数getX()，接下来分析是谁调用了它。 作为module对象的getX方法被调用。 这种情况被谁调用？很明显是被对象module调用，this是指向module。module对象里面有一个属性x，它的值是1891，因此console.log(module.getX())输出1891。 作为全局函数getX被调用。 这种情况是被谁调用？我们都知道全局函数可以看作为window对象的方法，那么，很明显现在getX是被当做全局对象window的一个方法被调用。 我们搞清楚了调用位置之后，接下来就会着手判断this的指向。 先看看很多人对this指向的一些误解this 既不指向函数自身也不指向函数的作用域，这之前是很多前端工程师容易误解的地方，现在澄清一下。 this的指向，是在函数被调用的时候确定的，也就是执行上下文被创建时确定的； this 的指向和函数声明的位置没有任何关系，只取决于函数的调用位置（也即由谁、在什么地方调用这个函数）； 正因为在执行上下文的创建阶段this的指向就已经被确定了，在执行阶段this指向不可再被更改。 12345678910var obj = &#123; a: &quot;1891&quot;&#125;function func() &#123; this = obj; //报错，因为在执行阶段试图修改this的指向 console.log(this.a);&#125;func(); this的指向规则1. 默认指向独立函数调用（无法应用后面其他指向规则时），this指向全局对象window。 12345function func() &#123; console.log( this.a ); // this指向全局对象&#125;var a = 2;func(); //&gt;&gt; 2 对于默认指向来说，决定this指向对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式。如果函数体处于严格模式，this会指向undefined，否则this会指向全局对象。 123456789function func() &#123; &quot;use strict&quot;;//函数体处于严格模式下，this指向undefined console.log(this.a);&#125;var a = &quot;1891&quot;;(function() &#123; func(); //&gt;&gt; 报错&#125;)(); 12345678910function func() &#123; console.log(this.a);&#125;var a = &quot;1891&quot;;(function() &#123; &quot;use strict&quot;; func(); //&gt;&gt; 1891 //这里输出 1891 而不是报错，是因为严格模式下，this的指向与func的调用位置无关&#125;)(); 还有一种默认指向，就是在SetTimeout或SetInterval结合使用时。代码示例如下。 1234567891011121314151617181920212223var num = 0;class Obj &#123; constructor(num)&#123; this.num = num; &#125; func()&#123; console.log(this.num); &#125; func1()&#123; setTimeout(function () &#123; console.log(&quot;setTimeout:&quot;+this.num); &#125;, 1000) &#125; func2()&#123; setInterval(function () &#123; console.log(this.num); &#125;, 2000) &#125;&#125;var obj = new Obj(1);obj.func();//&gt;&gt; 1 输出的是obj.numobj.func1()//&gt;&gt; setTimeout:0 输出的是window.numobj.func2()//&gt;&gt; 0 0 0 0 …… 输出的是window.num 可以发现在setInterval和setTimeout中传入函数时，函数中的this会指向window对象。 2. 隐式指向隐式指向是日常开发中最常见的指向。 函数体内this的指向由调用位置的调用者决定。如果调用者调用的函数，为某以个对象的方法，那么该函数在被调用时，其内部的this指向该对象。 1234567891011function func() &#123; console.log(this.a);&#125;var obj = &#123; a: 2, func: func&#125;;obj.func(); //&gt;&gt; 2// 找到调用位置，由 obj 对象来调用函数func，// 此时可以说函数func被调用时，obj 对象“拥有”或者“包含”func函数，// 所以此时的 this 指向调用 func 函数的 obj 对象。 对象属性引用链中只有最顶层或者说最后一层会影响调用位置，也就是说this指向最终调用函数的对象。这句话可能说得比较拗口，其实简单通俗地说，this指向最靠近被调用函数的对象，离得远的不是。举例来说： 12345678910111213141516function func() &#123; console.log(this.a);&#125;var obj2 = &#123; a: &quot;1891&quot;, func: func&#125;;var obj1 = &#123; a: &quot;coffe&quot;, obj2: obj2&#125;;//此时的 this 指向 obj2 对象，因为obj2离得近！obj1.obj2.func(); //&gt;&gt; 1891 再来看看隐式丢失： 1234567891011121314151617function func() &#123; console.log( this.a );&#125;var obj = &#123; a: &quot;coffe1891&quot;, func: func&#125;;var bar = obj.func; // 间接引用,见本文【壹.2.3.6】。此时bar和obj.func其实 // 都指向内存中的函数func本身。var a = &quot;oops, global&quot;; // a 是全局对象window的属性，也是全局变量bar(); //&gt;&gt; oops, global// 虽然 bar 是 obj.func 的一个引用，但是实际上，它引用的是func函数本身，// 因此此时的 bar() 其实是一个不带任何定语的独立函数调用，应用【默认指向】规则,// 因此函数体内的this指向window，this.a指向window的属性a（全局变量a） 3. 显式指向JavaScript内置对象Function的三个原型方法call()、apply()和bind()，它们的第一个参数是一个对象，它们会把这个对象绑定到this，接着在调用函数时让this指向这个对象。 1234567891011var a = &quot;makai&quot;;function func() &#123; console.log( this.a );&#125;var obj = &#123; a:&quot;coffe1891&quot;&#125;;func.call(obj); //&gt;&gt; coffe1891// 在调用 func 时强制把它的 this 绑定到 obj 上 另外，使用bind可以修正SetTimeout和SetInterval的this指向： 1234567891011121314151617181920212223var num = 0;class Obj &#123; constructor(num)&#123; this.num = num; &#125; func()&#123; console.log(this.num); &#125; func1()&#123; setTimeout(function () &#123; console.log(&quot;setTimeout:&quot;+this.num); &#125;.bind(this), 1000);//bind &#125; func2()&#123; setInterval(function () &#123; console.log(this.num); &#125;.bind(this), 2000);//bind &#125;&#125;var obj = new Obj(1);obj.func();//&gt;&gt; 1 输出的是obj.numobj.func1()//&gt;&gt; setTimeout:1 输出的是obj.numobj.func2()//&gt;&gt; 1 1 1 1 …… 输出的是obj.num 4. “new”操作符指向在JavaScript 中，构造函数只是一些使用new操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至都不能算是一种特殊的类型（class），它们只是被new操作符调用的普通函数而已。 使用new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作： 创建（或者说构造）一个全新的对象； 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）； 执行构造函数中的代码（为这个新对象添加属性、方法等）； 如果函数没有返回其他对象，那么返回这个新对象。 123456function func(a) &#123; this.a = a;&#125;var bar = new func(&quot;coffe1891&quot;);console.log(bar.a); //&gt;&gt; coffe1891// 使用new 来调用func(..)时，我们会构造一个新对象并把它绑定到func(..)调用中的this上 可以将函数的返回值分成三种情况： 返回一个对象 没有返回值，即默认返回undefined 返回基本数据类型 1234567891011121314151617181920212223242526272829303132333435363738391、返回一个对象function Foo(name,age) &#123; this.name = name; return &#123; age &#125;&#125;var bar = new Foo(&quot;kobin&quot;,&quot;18&quot;);bar.name; // undefinedbar.age; // 182、没有返回值function Foo(name,age) &#123; this.name = name;&#125;var bar = new Foo(&quot;kobin&quot;,&quot;18&quot;);bar.name; // kobinbar.age; // undefined3、返回基本数据类型function Foo(name,age) &#123; this.name = name; return 123&#125;var bar = new Foo(&quot;kobin&quot;,&quot;18&quot;);bar.name; // kobinbar.age; // undefined 所以使用new绑定时，需要判断函数返回的值是否为一个对象，如果是对象，那么this会绑定到返回的对象上 如何利用规则判断this的指向this的指向判断，可以按照下面的优先级顺序来判断函数在某个调用位置应用的是哪条规则 1. 函数是否在new 中被调用（new 操作符指向）？如果是的话，**this 绑定的是新创建的对象**。 123456789function func(name) &#123; this.name = name; this.getName = function() &#123; return this.name; &#125;;&#125;var obj = new func(&quot;coffe&quot;); //this会指向objconsole.log(obj.getName()); //&gt;&gt; coffe 2. 函数是否通过call、apply、bind显式指向？如果是的话，**this指向的是call、apply、bind三个方法的第一个参数指定的对象**。 12345678var obj1 = &#123; name: &quot;coffe&quot;&#125;;function func() &#123; return this.name; //这里的this本来指向window&#125;var str = func.call(obj1); //改变了func函数里面this的指向，指向obj1console.log(str); //&gt;&gt; coffe 3. 函数是否被当做某个对象的方法而调用（隐式指向）？如果是的话，this指向的是这个对象。 123456789var obj1 = &#123; name: &quot;coffe&quot;, func() &#123; return this.name; //指向obj1 &#125;&#125;;//这里的obj1.func()，表明func函数被obj1调用，因此func中的this指向obj1console.log(obj1.func()); //&gt;&gt; coffe 4. 若以上都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到全局对象。 12345678var a = &quot;coffe&quot;; //为全局对象window添加一个属性afunction func() &#123; &quot;use strict&quot;;//开启严格模式 return this.a;&#125;//严格模式下，this指向undefinedconsole.log(func()); //&gt;&gt; TypeError 几个例外情况1. 被忽略的thisnull 或者undefined作为this指向的对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认指向规则。 1234567function func() &#123; console.log(this.a);&#125;var a = 2;func.call(null); //&gt;&gt; 2 //this指向了window 2. 间接引用间接引用最容易在赋值时发生；间接引用时，调用这个函数会应用默认指向规则。 12345678910function func() &#123; console.log(this.a);&#125;var a = 2;var o = &#123; a: 3, func: func &#125;;var p = &#123; a: 4 &#125;;o.func(); //&gt;&gt; 3(p.func = o.func)(); //&gt;&gt; 2// 赋值表达式 p.func=o.func 的返回值是目标函数的引用，也就是 func 函数的引用// 因此调用位置是 func() 而不是 p.func() 或者 o.func() 3. 箭头函数箭头函数并不是使用function关键字定义的，而是使用被称为“胖箭头”的操作符 =&gt; 定 义的。 箭头函数不遵守this的四种指向规则，而是根据函数定义时的作用域来决定 this 的指向。何谓“定义时的作用域”？就是你定义这个箭头函数的时候，该箭头函数在哪个函数里，那么箭头函数体内的this就是它父函数的this。 看下面代码加深理解： 1234567891011121314151617181920function func() &#123; // 返回一个箭头函数 return a =&gt; &#123; //this 继承自 func() console.log(this.a); &#125;;&#125;var obj1 = &#123; a: 2&#125;;var obj2 = &#123; a: 3&#125;;var bar = func.call(obj1);bar.call(obj2); //&gt;&gt; 2 不是 3 ！// func() 内部创建的箭头函数会捕获调用时 func() 的 this。// 由于 func() 的 this 绑定到 obj1， bar（引用箭头函数）的 this 也会绑定到 obj1，// this一旦被确定，就不可更改，所以箭头函数的绑定无法被修改。（new 也不行！） 这个特性甚至被mozilla的MDN称作“没有this”，这种说法很费解。其实应该这么理解：一般而言，this的指向是在函数运行之后才确定的，而箭头函数的this指向在定义时也即调用之前就定死了，在运行之后无法更改，那相当于当成一个固定值的变量，此时this失去了原来作为“指向当前代码运行时所处的上下文环境（context）”的意义，所以MDN说箭头函数没有了this，我觉得翻译成“把this阉割了”更贴切 🤣 。","categories":[],"tags":[{"name":"JavaScript","slug":"javascript","permalink":"https://kobingogo.github.io/tags/javascript/"}]},{"title":"如何让centOS7下全局安装的npm模块在环境变量中生效","slug":"others-centOS7-npm","date":"2017-09-10T16:12:53.000Z","updated":"2022-02-18T02:31:03.811Z","comments":true,"path":"others-centOS7-npm/","link":"","permalink":"https://kobingogo.github.io/others-centOS7-npm/","excerpt":"记一次在centOS7下npm安装全局模块，依然无法使用相关全局命令的问题的解决方案","text":"记一次在centOS7下npm安装全局模块，依然无法使用相关全局命令的问题的解决方案 问题详述通过npm i -g cnpm安装的cnpm后，依然无法全局使用cnpm命令： 1-bash: cnpm: command not found 解决方案： 需要将node路径关联到环境变量中 具体操作 使用npm root -g获取node目录, 1/usr/sbin/nodejs/lib/node_modules 通过vim编辑/etc/profile文件, 在文件最底下新增: 123# Node所在路径export NODE_HOME=/usr/sbin/nodejsexport PATH=$&#123;NODE_HOME&#125;/bin:$PATH 如果PATH有其他配置，通过export PATH=&lt;path1&gt;:&lt;path2&gt;:&lt;path3&gt;:$PATH方式配置 最后执行命令使环境变量生效 1source /etc/profile 查看环境变量 1echo $PATH 验证效果 以后通过npm全局安装的模块会自动在环境变量中生效","categories":[{"name":"others","slug":"others","permalink":"https://kobingogo.github.io/categories/others/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://kobingogo.github.io/tags/linux/"},{"name":"centOS","slug":"centos","permalink":"https://kobingogo.github.io/tags/centos/"}]},{"title":"git设置代理","slug":"others-git设置代理","date":"2017-09-10T16:12:53.000Z","updated":"2022-02-18T02:31:03.811Z","comments":true,"path":"others-git设置代理/","link":"","permalink":"https://kobingogo.github.io/others-git%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/","excerpt":"本文讲解如何为github设置代理，让 git clone 飞起来","text":"本文讲解如何为github设置代理，让 git clone 飞起来 macOS 给 Git(Github) 设置代理（HTTP/SSH） macOS 给 Git(Github) 设置代理（HTTP/SSH）. GitHub Gist: instantly share code, notes, and snippets. 分辨需要设置的代理 HTTP 形式： git clone https://github.com/owner/git.git SSH 形式： git clone git@github.com:owner/git.git 一、HTTP 形式走 HTTP 代理git config --global http.proxy &quot;http://127.0.0.1:8080&quot;git config --global https.proxy &quot;http://127.0.0.1:8080&quot; 走 socks5 代理（如 Shadowsocks）git config --global http.proxy &quot;socks5://127.0.0.1:1080&quot;git config --global https.proxy &quot;socks5://127.0.0.1:1080&quot; 取消设置git config --global --unset http.proxygit config --global --unset https.proxy 二、SSH 形式修改 ~/.ssh/config 文件（不存在则新建）： # 必须是 github.com Host github.com HostName github.com User git # 走 HTTP 代理 # ProxyCommand socat - PROXY:127.0.0.1:%h:%p,proxyport=8080 # 走 socks5 代理（如 Shadowsocks） # ProxyCommand nc -v -x 127.0.0.1:1080 %h %p 对于Windows用户，要使用socks5代理却没有 nc 的，可以将ProxyCommand nc -v -x 127.0.0.1:1080 %h %p换成ProxyCommand connect -S 127.0.0.1:1080 %h %p 详细配置： 12345678910111213141516171819202122232425262728293031Host * ServerAliveInterval 120 ServerAliveCountMax 5# macOS 给 Git(Github) 设置代理（HTTP/SSH）# https://gist.github.com/chuyik/02d0d37a49edc162546441092efae6a1# 0x00 克隆 repo 的两种方式：https 和 ssh 方式# https 方式：git clone https://github.com/owner/git.git# ssh 方式：git clone git@github.com:owner/git.git# 0x01 https 方式克隆的 repo，走 http 或 sock5 代理，任选一个# 0x0101 http 代理# git config --global http.proxy &quot;http://127.0.0.1:1087&quot;# git config --global https.proxy &quot;http://127.0.0.1:1087&quot;# 0x0102 sock5 代理# git config --global http.proxy &quot;socks5://127.0.0.1:1086&quot;# git config --global https.proxy &quot;socks5://127.0.0.1:1086&quot;# 0x0103 取消使用代理# git config --global --unset http.proxy# git config --global --unset https.proxy# 0x02 ssh 克隆方式的代理设置，直接在全局设置文件配置，即 ~/.ssh/config 文件Host github.com HostName github.com User git # 走 HTTP 代理，需要 brew install socat # ProxyCommand socat - PROXY:127.0.0.1:%h:%p,proxyport=1087 # 走 socks5 代理（如 Shadowsocks） ProxyCommand nc -v -x 127.0.0.1:1086 %h %p # 走 socks5 代理（如 Shadowsocks），Windows 平台没有 nc 命令 # ProxyCommand connect -S 127.0.0.1:1086 %h %p Source","categories":[{"name":"others","slug":"others","permalink":"https://kobingogo.github.io/categories/others/"}],"tags":[{"name":"git","slug":"git","permalink":"https://kobingogo.github.io/tags/git/"},{"name":"github","slug":"github","permalink":"https://kobingogo.github.io/tags/github/"}]},{"title":"word-wrap,word-break,white-space强制换行和不换行总结","slug":"css-强制换行与不换行","date":"2017-05-15T17:30:05.000Z","updated":"2022-02-18T02:31:03.811Z","comments":true,"path":"css-强制换行与不换行/","link":"","permalink":"https://kobingogo.github.io/css-%E5%BC%BA%E5%88%B6%E6%8D%A2%E8%A1%8C%E4%B8%8E%E4%B8%8D%E6%8D%A2%E8%A1%8C/","excerpt":"我们一般控制换行所用到的 CSS 属性一共有三个：word-wrap; word-break; white-space。这三个属性可以说是专为了文字断行而创造出来的","text":"我们一般控制换行所用到的 CSS 属性一共有三个：word-wrap; word-break; white-space。这三个属性可以说是专为了文字断行而创造出来的 word-wrap 语法： word-wrap: normal(默认) | break-word normal: 允许内容顶开指定的容器边界 break-word: 内容将在边界内换行。必要时会触发 word-break 说明word-wrap 是控制是否“为词断行”的，设置或检索当前行超过指定容器的边界时是否断开转行。中文没有任何问题，英文语句也没问题。但是对于长串的英文，就不起作用。 范例congratulation 这个单词属于长串英文，word-wrap:break-word 整个单词看成一个整体，如果该行末端宽度不够显示整个单词，它会自动把整个单词放到下一行，而不会把单词截断，这就是对于长串文字不起作用的解释。word-wrap:normal 是默认情况，英文单词不被拆开。 结论作用范围仅为 div 这类标准块级元素，th,td 这类 table 元素虽然识别但是没有效果（如果为 td,th 加上宽度 word-wrap 在 IE 下是能够发挥效果的，但根据完全兼容性方便记忆角度上来说还是以前面的结论为准）。 word-break word-break: normal(默认) | break-all | keep-all normal: 依照亚洲语言和非亚洲语言的文本规则，允许在字内换行。 break-all: 该行为与亚洲语言的 normal 相同。也允许非亚洲语言文本行的任意字内断开。该值适合包含一些非亚洲文本的亚洲文本。 keep-all: 与所有非亚洲语言的 normal 相同。对于中文，韩文，日文，不允许字断开。适合包含少量亚洲文本的非亚洲文本。 说明word-break:break-all，是断开单词。在单词到边界时，下个字母自动到下一行。主要解决了长串英文的问题（恰恰弥补了上面 word-wrap:break-word 对于长串文字不起作用的缺陷） 范例继续以上面 congratulation 这个单词属于长串英文，word-break:break-all 它会把单词截断，该行末端就会变成类似 conra(congratulation 的前端部分)，下一行为 tulation（conguatulation）的后端部分了。word-break:keep-all，是指 Chinese, Japanese, and Korean 不断词。即只用此时，不用 word-wrap，中文就不会换行了。（英文语句正常。） 结论作用范围仅为 div 这类标准块级元素，th,td 这类 table 元素虽然识别但是没有效果（经测试 Chrome 下 word-break:break-all 是有效果的，但根据完全兼容性方便记忆角度上来说还是以前面的结论为准）。Firefox,Opera 是无法识别 word-break 的，更不用提 Firefox 下的 th,td 中使用 word-break 的效果了。 white-space white-space: normal(默认) | pre | nowrap normal: 默认。空白会被浏览器忽略。 pre: 空白会被浏览器保留。其行为方式类似 HTML 中的 pre 标签 nowrap: 文本不会换行，文本会在在同一行上继续，直到遇到 br 标签为止。 说明 对于 pre 属性，其实就是 HTML 中连续的多个空白符会被合并，然后为了不让他合并（最常用的场合就是表示代码文字缩进）让其中的空白符继续保留而不需要我们增加额外的样式和标签来控制它的缩进和换行。pre 标签的原理也是一样的内部默认有了个 white-space:pre。 对于 nowrap 属性，这个是强制不换行核心，一般强制不换行就是利用这个属性。Firefox 的 div 和 td 中，以及 IE 的 div 中，均没有问题。唯一的瑕疵就是在 IE 的 td 中会有一个问题，如果 td 没有指定宽度，则 nowrap 仍然有效，如果 td 有宽度，并且文字中无标点、无空格（例如中文长串文字），nowrap 则不再有效。解决方式就是可以加 word-break:keep-all;可以解决此问题。 总结强制换行 div（块级元素） word-wrap:break-word; word-break:break-all; td,th 这类 table 元素 先为 table 设定 table-layout:fixed，基本上设定完这个属性后基本的换行问题都能够解决而不会出现 table 中 td,th 因为里面各个内容的多寡发生抢夺其他 td,th 宽度的情形发生。这时如果你依旧有强制换行问题，那么在此 td 中内部加一层 div，那么情况就会像上面讨论的方式来解决。 总结强制不换行 white-space:nowrap 在文字与 td 之间再套一层 div，然后使用 nowrap overflow:hidden 防止文字溢出","categories":[{"name":"css","slug":"css","permalink":"https://kobingogo.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://kobingogo.github.io/tags/css/"}]}],"categories":[{"name":"tool","slug":"tool","permalink":"https://kobingogo.github.io/categories/tool/"},{"name":"理财","slug":"理财","permalink":"https://kobingogo.github.io/categories/%E7%90%86%E8%B4%A2/"},{"name":"css","slug":"css","permalink":"https://kobingogo.github.io/categories/css/"},{"name":"JavaScript","slug":"javascript","permalink":"https://kobingogo.github.io/categories/javascript/"},{"name":"浏览器","slug":"浏览器","permalink":"https://kobingogo.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"npm","slug":"npm","permalink":"https://kobingogo.github.io/categories/npm/"},{"name":"react","slug":"react","permalink":"https://kobingogo.github.io/categories/react/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kobingogo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Chrome源码","slug":"chrome源码","permalink":"https://kobingogo.github.io/categories/chrome%E6%BA%90%E7%A0%81/"},{"name":"others","slug":"others","permalink":"https://kobingogo.github.io/categories/others/"},{"name":"node","slug":"node","permalink":"https://kobingogo.github.io/categories/node/"},{"name":"面试","slug":"面试","permalink":"https://kobingogo.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"工程化","slug":"工程化","permalink":"https://kobingogo.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"理财","slug":"理财","permalink":"https://kobingogo.github.io/tags/%E7%90%86%E8%B4%A2/"},{"name":"css","slug":"css","permalink":"https://kobingogo.github.io/tags/css/"},{"name":"ES6","slug":"es6","permalink":"https://kobingogo.github.io/tags/es6/"},{"name":"IntersectionObserver","slug":"intersectionobserver","permalink":"https://kobingogo.github.io/tags/intersectionobserver/"},{"name":"生活","slug":"生活","permalink":"https://kobingogo.github.io/tags/%E7%94%9F%E6%B4%BB/"},{"name":"npm","slug":"npm","permalink":"https://kobingogo.github.io/tags/npm/"},{"name":"react","slug":"react","permalink":"https://kobingogo.github.io/tags/react/"},{"name":"keep alice","slug":"keep-alice","permalink":"https://kobingogo.github.io/tags/keep-alice/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kobingogo.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"leetcode","permalink":"https://kobingogo.github.io/tags/leetcode/"},{"name":"array","slug":"array","permalink":"https://kobingogo.github.io/tags/array/"},{"name":"命令","slug":"命令","permalink":"https://kobingogo.github.io/tags/%E5%91%BD%E4%BB%A4/"},{"name":"梯子","slug":"梯子","permalink":"https://kobingogo.github.io/tags/%E6%A2%AF%E5%AD%90/"},{"name":"Mac终端","slug":"mac终端","permalink":"https://kobingogo.github.io/tags/mac%E7%BB%88%E7%AB%AF/"},{"name":"software","slug":"software","permalink":"https://kobingogo.github.io/tags/software/"},{"name":"软件","slug":"软件","permalink":"https://kobingogo.github.io/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"Linux","slug":"linux","permalink":"https://kobingogo.github.io/tags/linux/"},{"name":"centOS","slug":"centos","permalink":"https://kobingogo.github.io/tags/centos/"},{"name":"java","slug":"java","permalink":"https://kobingogo.github.io/tags/java/"},{"name":"JavaScript","slug":"javascript","permalink":"https://kobingogo.github.io/tags/javascript/"},{"name":"堆","slug":"堆","permalink":"https://kobingogo.github.io/tags/%E5%A0%86/"},{"name":"栈","slug":"栈","permalink":"https://kobingogo.github.io/tags/%E6%A0%88/"},{"name":"node","slug":"node","permalink":"https://kobingogo.github.io/tags/node/"},{"name":"stdin","slug":"stdin","permalink":"https://kobingogo.github.io/tags/stdin/"},{"name":"promise","slug":"promise","permalink":"https://kobingogo.github.io/tags/promise/"},{"name":"iframe","slug":"iframe","permalink":"https://kobingogo.github.io/tags/iframe/"},{"name":"download","slug":"download","permalink":"https://kobingogo.github.io/tags/download/"},{"name":"全栈","slug":"全栈","permalink":"https://kobingogo.github.io/tags/%E5%85%A8%E6%A0%88/"},{"name":"nginx","slug":"nginx","permalink":"https://kobingogo.github.io/tags/nginx/"},{"name":"前端","slug":"前端","permalink":"https://kobingogo.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"面试","slug":"面试","permalink":"https://kobingogo.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://kobingogo.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"缓存","slug":"缓存","permalink":"https://kobingogo.github.io/tags/%E7%BC%93%E5%AD%98/"},{"name":"number","slug":"number","permalink":"https://kobingogo.github.io/tags/number/"},{"name":"bigint","slug":"bigint","permalink":"https://kobingogo.github.io/tags/bigint/"},{"name":"继承","slug":"继承","permalink":"https://kobingogo.github.io/tags/%E7%BB%A7%E6%89%BF/"},{"name":"浏览器","slug":"浏览器","permalink":"https://kobingogo.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"原型","slug":"原型","permalink":"https://kobingogo.github.io/tags/%E5%8E%9F%E5%9E%8B/"},{"name":"闭包","slug":"闭包","permalink":"https://kobingogo.github.io/tags/%E9%97%AD%E5%8C%85/"},{"name":"git","slug":"git","permalink":"https://kobingogo.github.io/tags/git/"},{"name":"github","slug":"github","permalink":"https://kobingogo.github.io/tags/github/"}]}