<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2021前端发展展望</title>
      <link href="/2021%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E5%B1%95%E6%9C%9B/"/>
      <url>/2021%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E5%B1%95%E6%9C%9B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>又到了年底，想简单谈谈这一年前端的发展，以及21年可能会出现的一些趋势。毋庸置疑，2020年确实是不平凡的一年，对前端来说，私以为可以用“大前端持续深耕，泛前端兼容并包”这十四个字来形容。这里需要明确一下我对“大前端”以及“泛前端”这两个概念的理解：首先大前端可以分为广义的“大前端”和狭义的“大前端”，市面上常…</p></blockquote><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><div class="story post-story"><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20210114180804.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20210114180804.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20210114180804"></p><p>又到了年底，想简单谈谈这一年前端的发展，以及21年可能会出现的一些趋势。毋庸置疑，2020年确实是不平凡的一年，对前端来说，私以为可以用“大前端持续深耕，泛前端兼容并包”这十四个字来形容。这里需要明确一下我对“大前端”以及“泛前端”这两个概念的理解：首先大前端可以分为广义的“大前端”和狭义的“大前端”，市面上常说的大前端主要分为这两类，所谓广义的“大前端”是指以前端技术解决所有本属于其他领域问题的前端技术，这里其实是包含了后边所说的泛前端的概念，也就是说只要是使用前端技术去解决的都可以定义为“大前端”；而狭义的“大前端”是仅指垂直到后端领域的前端技术，其代表是以node.js为主的扩展的去解决后端领域的技术，如出现了诸如express、koa、egg、nest等等配套的后端技术框架，甚至出现了node的微服务框架，我这里不做说明仅指狭义的“大前端”概念。对于“泛前端”，这个概念没有歧义，通常指的都是跨端技术，比如客户端、桌面端，甚至HUB等等，上图中所示的仅仅指一部分框架，并未收录完全，毕竟js/ts的社区实在太太太太活跃了，下面简单分说一下“大前端”和“泛前端”个人的一些见解，是以前端三大框架Vue、React、Angular为核心进行横向和纵向的框架探讨</p><h3 id="泛前端技术框架探讨"><a href="#泛前端技术框架探讨" class="headerlink" title="泛前端技术框架探讨"></a>泛前端技术框架探讨</h3><table><thead><tr><th></th><th>Vue</th><th>React</th><th>Angular</th></tr></thead><tbody><tr><td>web端</td><td>Vue全家桶</td><td>React全家桶</td><td>Angular全家桶</td></tr><tr><td>桌面端</td><td>Electron/Nw</td><td>Electron/Nw</td><td>Electron/Nw/Cordova/Ionic</td></tr><tr><td>原生移动端</td><td>Weex</td><td>React Native</td><td>Cordova/Ionic</td></tr><tr><td>小程序端</td><td>uniapp/mpvue/mapx</td><td>taro/Rax</td><td>无</td></tr></tbody></table><h3 id="大前端技术框架探讨"><a href="#大前端技术框架探讨" class="headerlink" title="大前端技术框架探讨"></a>大前端技术框架探讨</h3><table><thead><tr><th></th><th>Vue</th><th>React</th><th>Angular</th></tr></thead><tbody><tr><td>web端</td><td>Vue全家桶</td><td>React全家桶</td><td>Angular全家桶</td></tr><tr><td>SSR</td><td>Nuxt</td><td>Next</td><td>Universal</td></tr><tr><td>服务端</td><td>无特定</td><td>无特定</td><td>可配合Nest</td></tr></tbody></table><p>今年<a href="https://mp.weixin.qq.com/s/Nm1G3jgS-fafEeNywTCtDA" target="_blank" rel="noopener">阿里前端练习生计划</a>将前端领域划分了七大方向，分别是工程化方向、前端中后台方向、Node.js方向、跨端技术方向、互动技术方向、可视化技术方向、前端智能化方向，个人认为Node.js是一个整体的前端基础，并不能单算做一个方向，因而我将其替换为音视频方向，私以为可将前端方向划分为以下几种，下面我将在这几个不同的方向维度进行个人的一些阐述和拙见：</p><ul><li>中后台方向：微前端</li><li>可视化方向：antv</li><li>智能化方向：imgcook</li><li>互动方向：Eva</li><li>音视频方向：wasm</li><li>工程化方向：severless、全链路工程</li><li>跨端方向：kbone、rax</li></ul></div><h2 id="中后台方向"><a href="#中后台方向" class="headerlink" title="中后台方向"></a>中后台方向</h2><div class="story post-story"><ol><li>对于中后台方向，这是传统web方向，对于前端来说，2020年对于微前端的落地应用已有很多实践。因此，私以为微前端会作为未来前端大型应用的一种趋势，对于不同团队的不同技术栈的汇总整合是一个比较好的方案，虽然不同于服务端的那种微服务可以微的很彻底，但是前端加持着ts等的特性也是可以实现微化的效果，从而优化工时，提升效率，避免重复劳作；</li><li>既然第一点提到了ts，那这里我想说一说关于ts的问题，在19年我对ts的态度尚存观望，但在今年，我认为ts可以作为一种必备技能来考察和实践，并不是因为大家都在用，而是因为随着时间的发展，现在前端要承载的能力越来越重，项目也越来越大，ts可以很好的约定，对于后期的维护以及修改都可以很好的限制，对于大型团队、大型项目来说，ts是不二之选；另外，如果有团队真的要去开发服务端，那我真的建议你去用ts，如果你用过nest.js，你会发现和写java真的没什么区别，而且服务端的很多理念也可以通过ts的各种特性来使用，比如泛型、抽象类等。当然，如果是小团队，而且需要快速开发，对于小而美的应用，个人认为还是js适合，毕竟js是一门灵活的语言，哈哈哈</li></ol></div><h2 id="可视化方向"><a href="#可视化方向" class="headerlink" title="可视化方向"></a>可视化方向</h2><div class="story post-story"><ol><li>可视化这里，今年其实没有做多少实践，但是个人认为，这七个大方向而言，最容易出成果，或者说最能出大佬的，可能还真是可视化领域，如果能在可视化领域做到了前5%，那么我相信各大厂肯定会花钱养着你，毕竟我拥有你不一定重要，但是对手不拥有你对我很重要，你的技术壁垒就呈现了出来，也就在这个内卷的江湖获得了一些领先和优势，最起码裁员的优先级也不会那么靠前，哈哈哈</li><li>第一点说的有点儿远，说说实在的，个人觉得可以将阿里的antv作为可视化领域的一个标杆，针对各种特定领域进行展开，比如gis等，当然，其实可视化领域研究的深的话还是挺冷门的，这其实也会有一些机会，webGL/webAR/webVR等等都可以作为切入点，配合着下面的音视频领域，这两个的相互结合，确实还是能做出些东西的</li></ol></div><h2 id="智能化方向"><a href="#智能化方向" class="headerlink" title="智能化方向"></a>智能化方向</h2><div class="story post-story"><ol><li>智能化领域，个人认为其实核心不在于前端，而在于人工智能，而人工智能领域就不仅仅前端那么些东西了，对于封装好的如TensorFlow.js，我们是直接拿来用的，但是对于领面的模型建立其实才是关键，如果有同学想在智能化领域有所发展，个人建议还是要深钻一下，最好可以深造一下，毕竟这个东西是真的需要学术研究+产业实践的</li><li>在产业实践的前端领域，阿里还是比较领先的，比如imgcook，其核心目的是将图片转成前端代码，利用的机器视觉去识别图片中的不同的位置信息等，将其转成前端的代码，也就是所谓的D2C，即：Design to Code，今年的D2大会上又提出了P2C，即：Product to Code，但并不是真的将人类语言直接转换成code，而是对D2C的一个业务扩展，对于D2C某些业务代码利用一些特定的schema进行约定，让机器学习过程中多一些参数约束，从而提升代码实现度。虽然转化的代码还很冗余，但是对于一些初级的项目或页面，确实可以交给机器去实现，个人认为人工智能对低端重复的工作确实会进行替代，也算是对前端内卷做了一定的贡献，摊手…</li></ol></div><h2 id="互动方向"><a href="#互动方向" class="headerlink" title="互动方向"></a>互动方向</h2><div class="story post-story"><ol><li>互动方向，目前大头还是在游戏方向，但是我还是认为页游或前端实现游戏主要还是做一些开胃菜的功能，并不能真正的将用户带进沉浸式的体验，对于小游戏引擎，今年阿里好像出了一个eva的引擎，感兴趣的同学可以看看</li><li>对于新体验方面，AR/VR/MR等可能在明年5g深化的时候会有一些落地实践，但可能还是不温不火，互动方向配合设计的新理念可能会是一个新的突破点</li></ol></div><h2 id="音视频方向"><a href="#音视频方向" class="headerlink" title="音视频方向"></a>音视频方向</h2><div class="story post-story"><ol><li>这里想说一说WebAssembly，虽然都说wasm是会替代掉js，但目前看应该还不太现实，wasm目前主要还是配合音视频领域多一些，另外就是一些额外的优化措施，配合rust进行优化等，如果有志于音视频领域有所建树的同学，wasm确实可以储备起来</li><li>webrtc是音视频领域一个绕不开的技术，另外就是播放器的实现，video.js、flv.js等，对于一些视频播放的协议也要了解，如rtmp/rtsp等，今年疫情的关系，带动着直播领域的火热，前端音视频方向说不定会是一个风口</li></ol></div><h2 id="工程化方向"><a href="#工程化方向" class="headerlink" title="工程化方向"></a>工程化方向</h2><div class="story post-story"><ol><li>工程化方向就不得不提serverless，这是今年前端最火热的一个话题了，私以为serverless不仅仅是前端领域的变化，它可能改变目前的开发模式，以后没有前后端之分（ps：目前确实是有合的趋势），只有云工程师和端工程师之分，那么对于目前的前端来说，我们就不能仅仅只关注前端领域的一些内容了，docker、k8s等属于传统后端或运维的部分，我们也需要掌握，对于一些后端的思维及名词也需要熟悉，如限流、削峰、服务降级等。当然serverless的前提其实是云原生，如果没有云化，那实现serverless的效果应该不如目前这样，当然个人认为这是一个必然的趋势，从今年的云栖大会以及运营商5g云化来看，云网融合、云边协同应该会是主流</li><li>前端工程化另外一个方向就是全链路的工程化，从脚手架、low code、插件市场等全链路的提供，简化前端开发门槛，这里可以参考淘系的飞冰，对low code以及ide的插件提供都有涉及，以及ui组件库的提供等等，形成一个全链路的前端生态。这里可以说说low code和no code，no code是一个无需任何编码的现成的工具，就是完全没有编程的入口；low code是一个需要部分编码的工具，为了是给一些非专业人士但又有编程需要的人员使用，强调开发出来给别人用，常见的比如给运营人员用的h5编辑器，如易企秀、maka、ih5等</li></ol></div><h2 id="跨端方向"><a href="#跨端方向" class="headerlink" title="跨端方向"></a>跨端方向</h2><div class="story post-story"><ol><li>跨端方向是一个老生常谈的问题，主流还是要write once，run anywhere，常见的无非就是利用各种框架将各个DSL进行来回转换，但其实这是一个伪命题，本质是不可能达到大一统的局面的，抽象就很难具象，这两者需要有一个平衡，需要对具体常见具体分析</li><li>私以为小程序领域是端方向下一个各家大佬追逐的市场，因为app领域的跑马圈地都已基本形成，现在再去开发出一个现象级的app几乎很难很难了，但是将app作为操作系统，以小程序去带动用户，形成用户闭环，还是有很大市场的，类小程序应用，如pwa、快应用等都是这种承载方式的不同展现，对跨端来说，这个不失为一种发展选择。对于小程序的框架也出现了kbone、rax等，可能也会有一个类似w3c这样的一个小程序标准，但是像微信这种巨无霸应用，是否真的会遵守就是另一回事了，总之，其实也不失为一个选择</li></ol></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="story post-story"><p>回望2020，展望2021，总结如下：</p><ol><li>大前端持续深耕，泛前端兼容并包</li><li>中后台微服务化，可视化行业细化</li><li>智能侧算法深化，互娱侧形态变化</li><li>音视频结构优化，工程侧全面转化</li><li>跨端侧具体改化，前端更加内卷化</li></ol><p>好了，2021到了，愿大家在这个内卷的时代，都有自己的一技之长，形成自己的核心竞争力，升职加薪，再创辉煌，共勉！！！</p><p>转载自<a href="https://segmentfault.com/a/1190000038768154" target="_blank" rel="noopener">Source</a></p></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>css实现两个圆重叠</title>
      <link href="/css-css%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E5%9C%86%E9%87%8D%E5%8F%A0/"/>
      <url>/css-css%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E5%9C%86%E9%87%8D%E5%8F%A0/</url>
      
        <content type="html"><![CDATA[<p>工作中有一个需求，实现两个椭圆相交，并且相交区域颜色不同，类似于一个简单的<code>韦恩图</code>，如何用css实现这个效果？ 经过一番探索，找到了答案。</p><a id="more"></a><p>要实现这个效果，需要用到的神技：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/mix-blend-mode#%E4%B8%8D%E5%90%8Cmix-blend-mode%E5%80%BC%E7%9A%84%E6%95%88%E6%9E%9C" target="_blank" rel="noopener"><code>css-blend-mode</code></a>, 它是一个css属性，描述了元素的内容应该与元素的直系父元素的内容和元素的背景如何混合。</p><p>有了这个，就可以愉快的直接上代码了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"isolate"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"circle circle-1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"circle circle-2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.circle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">110px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">70px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span> / <span class="number">35px</span>;</span><br><span class="line">  <span class="attribute">mix-blend-mode</span>: color-dodge;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.circle-1</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#39518A</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.circle-2</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#0091FF</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.isolate</span> &#123;</span><br><span class="line">  <span class="attribute">isolation</span>: isolate; <span class="comment">/* Without isolation, the background color will be taken into account */</span></span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体效果参见：<a href="https://codepen.io/jiangawait/pen/zYKaRZx" target="_blank" rel="noopener">例子</a></p><p>当然css-blend-mode不仅仅只有这点作用，它还能用作背景混合，纹理叠加，视频混合等场景，具体可参考：</p><p><a href="https://www.zhangxinxu.com/wordpress/2019/05/css-mix-blend-mode-screen/" target="_blank" rel="noopener">大神的文章</a></p><p>打完收工😊</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6全部特性汇总</title>
      <link href="/javascript-ES6%E5%85%A8%E9%83%A8%E7%89%B9%E6%80%A7%E6%B1%87%E6%80%BB/"/>
      <url>/javascript-ES6%E5%85%A8%E9%83%A8%E7%89%B9%E6%80%A7%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>本文的知识点完全是参考或摘录<a href="https://es6.ruanyifeng.com/" target="_blank" rel="noopener">《ES6》</a>里的语句，有部分语句为了方便理解和记忆，进行了相同意思的转义，同时对知识点进行归类划分。为了让大家能集中精力来记住这些特性，全文一句废话和题外话都没有，全部模块以笔记的形式进行书写，如果看得不是很惯建议对照<a href="https://es6.ruanyifeng.com/" target="_blank" rel="noopener">《ES6》</a>的内容来学习。</p><p>本文整理出来的笔记都是书中的精华内容，囊括了整个<code>ES6体系</code>的所有特性，非常方便大家重新认识<code>全部ES6特性</code>。半小时的阅读就可对<code>ES6</code>有一个全面的了解，可认为是一本<code>ES6特性小字典</code>，收藏后可随时查阅。即使看不完也要拉到本文末尾喔，有个大彩蛋，嘻嘻！</p><a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201023110159.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201023110159.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20201023110159"></p><h3 id="修正"><a href="#修正" class="headerlink" title="修正"></a>修正</h3><p><strong>ES6</strong>是<code>ECMA</code>为<code>JavaScript</code>制定的第6个标准版本，相关历史可查看此章节<a href="https://es6.ruanyifeng.com/#docs/intro" target="_blank" rel="noopener">《ES6-ECMAScript6简介》</a>。</p><p>标准委员会最终决定，标准在每年6月正式发布并作为当年的正式版本，接下来的时间里就在此版本的基础上进行改动，直到下一年6月草案就自然变成新一年的版本，这样一来就无需以前的版本号，只要用年份标记即可。<code>ECMAscript 2015</code>是在<code>2015年6月</code>发布ES6的第一个版本。以此类推，<code>ECMAscript 2016</code>是ES6的第二个版本、 <code>ECMAscript 2017</code>是ES6的第三个版本。<strong>ES6</strong>既是一个历史名词也是一个泛指，含义是<code>5.1版本</code>以后的<code>JavaScript下一代标准</code>，目前涵盖了<code>ES2015</code>、<code>ES2016</code>、<code>ES2017</code>、<code>ES2018</code>、<code>ES2019</code>、<code>ES2020</code>。</p><p>所以有些文章上提到的<code>ES7</code>(实质上是<code>ES2016</code>)、<code>ES8</code>(实质上是<code>ES2017</code>)、<code>ES9</code>(实质上是<code>ES2018</code>)、<code>ES10</code>(实质上是<code>ES2019</code>)、<code>ES11</code>(实质上是<code>ES2020</code>)，实质上都是一些不规范的概念。从ES1到ES6，每个标准都是花了好几年甚至十多年才制定下来，你一个ES6到ES7，ES7到ES8，才用了一年，按照这样的定义下去，那不是很快就ES20了。用正确的概念来说ES6目前涵盖了<strong>ES2015</strong>、<strong>ES2016</strong>、<strong>ES2017</strong>、<strong>ES2018</strong>、<strong>ES2019</strong>、<strong>ES2020</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201023110231.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201023110231.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20201023110231"></p><p>另外，ES6更新的内容主要分为以下几点</p><ul><li><strong>表达式</strong>：声明、解构赋值</li><li><strong>内置对象</strong>：字符串扩展、数值扩展、对象扩展、数组扩展、函数扩展、正则扩展、Symbol、Set、Map、Proxy、Reflect</li><li><strong>语句与运算</strong>：Class、Module、Iterator</li><li><strong>异步编程</strong>：Promise、Generator、Async</li></ul><h2 id="ES2015"><a href="#ES2015" class="headerlink" title="ES2015"></a>ES2015</h2><div class="story post-story"><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201023110314.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201023110314.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20201023110314"></p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><ul><li><strong>const命令</strong>：声明常量</li><li><strong>let命令</strong>：声明变量</li></ul><blockquote><p>作用</p></blockquote><ul><li>作用域<ul><li><strong>全局作用域</strong></li><li><strong>函数作用域</strong>：<code>function() {}</code></li><li><strong>块级作用域</strong>：<code>{}</code></li></ul></li><li>作用范围<ul><li><code>var命令</code>在全局代码中执行</li><li><code>const命令</code>和<code>let命令</code>只能在代码块中执行</li></ul></li><li>赋值使用<ul><li><code>const命令</code>声明常量后必须立马赋值</li><li><code>let命令</code>声明变量后可立马赋值或使用时赋值</li></ul></li><li>声明方法：<code>var</code>、<code>const</code>、<code>let</code>、<code>function</code>、<code>class</code>、<code>import</code></li></ul><blockquote><p>重点难点</p></blockquote><ul><li>不允许重复声明</li><li>未定义就使用会报错：<code>const命令</code>和<code>let命令</code>不存在变量提升</li><li>暂时性死区：在代码块内使用<code>const命令</code>和<code>let命令</code>声明变量之前，该变量都不可用</li></ul><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><ul><li><strong>字符串解构</strong>：<code>const [a, b, c, d, e] = &quot;hello&quot;</code></li><li><strong>数值解构</strong>：<code>const { toString: s } = 123</code></li><li><strong>布尔解构</strong>：<code>const { toString: b } = true</code></li><li><strong>对象解构</strong><ul><li>形式：<code>const { x, y } = { x: 1, y: 2 }</code></li><li>默认：<code>const { x, y = 2 } = { x: 1 }</code></li><li>改名：<code>const { x, y: z } = { x: 1, y: 2 }</code></li></ul></li><li><strong>数组解构</strong><ul><li>规则：数据结构具有<code>Iterator接口</code>可采用数组形式的解构赋值</li><li>形式：<code>const [x, y] = [1, 2]</code></li><li>默认：<code>const [x, y = 2] = [1]</code></li></ul></li><li><strong>函数参数解构</strong><ul><li>数组解构：<code>function Func([x = 0, y = 1]) {}</code></li><li>对象解构：<code>function Func({ x = 0, y = 1 } = {}) {}</code></li></ul></li></ul><blockquote><p>应用场景</p></blockquote><ul><li>交换变量值：<code>[x, y] = [y, x]</code></li><li>返回函数多个值：<code>const [x, y, z] = Func()</code></li><li>定义函数参数：<code>Func([1, 2])</code></li><li>提取JSON数据：<code>const { name, version } = packageJson</code></li><li>定义函数参数默认值：<code>function Func({ x = 1, y = 2 } = {}) {}</code></li><li>遍历Map结构：<code>for (let [k, v] of Map) {}</code></li><li>输入模块指定属性和方法：<code>const { readFile, writeFile } = require(&quot;fs&quot;)</code></li></ul><blockquote><p>重点难点</p></blockquote><ul><li>匹配模式：只要等号两边的模式相同，左边的变量就会被赋予对应的值</li><li>解构赋值规则：只要等号右边的值不是对象或数组，就先将其转为对象</li><li>解构默认值生效条件：属性值严格等于<code>undefined</code></li><li>解构遵循匹配模式</li><li>解构不成功时变量的值等于<code>undefined</code></li><li><code>undefined</code>和<code>null</code>无法转为对象，因此无法进行解构</li></ul><h3 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h3><ul><li><strong>Unicode表示法</strong>：<code>大括号包含</code>表示Unicode字符(<code>\u{0xXX}</code>或<code>\u{0XXX}</code>)</li><li><strong>字符串遍历</strong>：可通过<code>for-of</code>遍历字符串</li><li><strong>字符串模板</strong>：可单行可多行可插入变量的增强版字符串</li><li><strong>标签模板</strong>：函数参数的特殊调用</li><li><strong>String.raw()</strong>：返回把字符串所有变量替换且对斜杠进行转义的结果</li><li><strong>String.fromCodePoint()</strong>：返回码点对应字符</li><li><strong>codePointAt()</strong>：返回字符对应码点(<code>String.fromCodePoint()</code>的逆操作)</li><li><strong>normalize()</strong>：把字符的不同表示方法统一为同样形式，返回<code>新字符串</code>(Unicode正规化)</li><li><strong>repeat()</strong>：把字符串重复n次，返回<code>新字符串</code></li><li><strong>matchAll()</strong>：返回正则表达式在字符串的所有匹配</li><li><strong>includes()</strong>：是否存在指定字符串</li><li><strong>startsWith()</strong>：是否存在字符串头部指定字符串</li><li><strong>endsWith()</strong>：是否存在字符串尾部指定字符串</li></ul><blockquote><p>重点难点</p></blockquote><ul><li>以上扩展方法均可作用于由<code>4个字节储存</code>的<code>Unicode字符</code>上</li></ul><h3 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h3><ul><li><strong>二进制表示法</strong>：<code>0b或0B开头</code>表示二进制(<code>0bXX</code>或<code>0BXX</code>)</li><li><strong>八进制表示法</strong>：<code>0o或0O开头</code>表示二进制(<code>0oXX</code>或<code>0OXX</code>)</li><li><strong>Number.EPSILON</strong>：数值最小精度</li><li><strong>Number.MIN_SAFE_INTEGER</strong>：最小安全数值(<code>-2^53</code>)</li><li><strong>Number.MAX_SAFE_INTEGER</strong>：最大安全数值(<code>2^53</code>)</li><li><strong>Number.parseInt()</strong>：返回转换值的整数部分</li><li><strong>Number.parseFloat()</strong>：返回转换值的浮点数部分</li><li><strong>Number.isFinite()</strong>：是否为有限数值</li><li><strong>Number.isNaN()</strong>：是否为NaN</li><li><strong>Number.isInteger()</strong>：是否为整数</li><li><strong>Number.isSafeInteger()</strong>：是否在数值安全范围内</li><li><strong>Math.trunc()</strong>：返回数值整数部分</li><li><strong>Math.sign()</strong>：返回数值类型(<code>正数1</code>、<code>负数-1</code>、<code>零0</code>)</li><li><strong>Math.cbrt()</strong>：返回数值立方根</li><li><strong>Math.clz32()</strong>：返回数值的32位无符号整数形式</li><li><strong>Math.imul()</strong>：返回两个数值相乘</li><li><strong>Math.fround()</strong>：返回数值的32位单精度浮点数形式</li><li><strong>Math.hypot()</strong>：返回所有数值平方和的平方根</li><li><strong>Math.expm1()</strong>：返回<code>e^n - 1</code></li><li><strong>Math.log1p()</strong>：返回<code>1 + n</code>的自然对数(<code>Math.log(1 + n)</code>)</li><li><strong>Math.log10()</strong>：返回以10为底的n的对数</li><li><strong>Math.log2()</strong>：返回以2为底的n的对数</li><li><strong>Math.sinh()</strong>：返回n的双曲正弦</li><li><strong>Math.cosh()</strong>：返回n的双曲余弦</li><li><strong>Math.tanh()</strong>：返回n的双曲正切</li><li><strong>Math.asinh()</strong>：返回n的反双曲正弦</li><li><strong>Math.acosh()</strong>：返回n的反双曲余弦</li><li><strong>Math.atanh()</strong>：返回n的反双曲正切</li></ul><h3 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h3><ul><li><strong>简洁表示法</strong>：直接写入变量和函数作为对象的属性和方法(<code>{ prop, method() {} }</code>)</li><li><strong>属性名表达式</strong>：字面量定义对象时使用<code>[]</code>定义键(<code>[prop]</code>，不能与上同时使用)</li><li><strong>方法的name属性</strong>：返回方法函数名<ul><li>取值函数(getter)和存值函数(setter)：<code>get/set 函数名</code>(属性的描述对象在<code>get</code>和<code>set</code>上)</li><li>bind返回的函数：<code>bound 函数名</code></li><li>Function构造函数返回的函数实例：<code>anonymous</code></li></ul></li><li><strong>属性的可枚举性和遍历</strong>：描述对象的<code>enumerable</code></li><li><strong>super关键字</strong>：指向当前对象的原型对象(只能用在对象的简写方法中<code>method() {}</code>)</li><li><strong>Object.is()</strong>：对比两值是否相等</li><li><strong>Object.assign()</strong>：合并对象(浅拷贝)，返回原对象</li><li><strong>Object.getPrototypeOf()</strong>：返回对象的原型对象</li><li><strong>Object.setPrototypeOf()</strong>：设置对象的原型对象</li><li><strong>__proto__</strong>：返回或设置对象的原型对象</li></ul><blockquote><p>属性遍历</p></blockquote><ul><li>描述：<code>自身</code>、<code>可继承</code>、<code>可枚举</code>、<code>非枚举</code>、<code>Symbol</code></li><li>遍历<ul><li><code>for-in</code>：遍历对象<code>自身可继承可枚举</code>属性</li><li><code>Object.keys()</code>：返回对象<code>自身可枚举</code>属性键组成的数组</li><li><code>Object.getOwnPropertyNames()</code>：返回对象<code>自身非Symbol</code>属性键组成的数组</li><li><code>Object.getOwnPropertySymbols()</code>：返回对象<code>自身Symbol</code>属性键组成的数组</li><li><code>Reflect.ownKeys()</code>：返回对象<code>自身全部</code>属性键组成的数组</li></ul></li><li>规则<ul><li>首先遍历所有数值键，按照数值升序排列</li><li>其次遍历所有字符串键，按照加入时间升序排列</li><li>最后遍历所有Symbol键，按照加入时间升序排列</li></ul></li></ul><h3 id="数组扩展"><a href="#数组扩展" class="headerlink" title="数组扩展"></a>数组扩展</h3><ul><li><strong>扩展运算符(…)</strong>：转换数组为用逗号分隔的参数序列(<code>[...arr]</code>，相当于<code>rest/spread参数</code>的逆运算)</li><li><strong>Array.from()</strong>：转换具有<code>Iterator接口</code>的数据结构为真正数组，返回新数组<ul><li>类数组对象：<code>包含length的对象</code>、<code>Arguments对象</code>、<code>NodeList对象</code></li><li>可遍历对象：<code>String</code>、<code>Set结构</code>、<code>Map结构</code>、<code>Generator函数</code></li></ul></li><li><strong>Array.of()</strong>：转换一组值为真正数组，返回新数组</li><li><strong>copyWithin()</strong>：把指定位置的成员复制到其他位置，返回原数组</li><li><strong>find()</strong>：返回第一个符合条件的成员</li><li><strong>findIndex()</strong>：返回第一个符合条件的成员索引值</li><li><strong>fill()</strong>：根据指定值填充整个数组，返回原数组</li><li><strong>keys()</strong>：返回以索引值为遍历器的对象</li><li><strong>values()</strong>：返回以属性值为遍历器的对象</li><li><strong>entries()</strong>：返回以索引值和属性值为遍历器的对象</li><li><strong>数组空位</strong>：ES6明确将数组空位转为<code>undefined</code>(空位处理规不一，建议避免出现)</li></ul><blockquote><p>扩展应用</p></blockquote><ul><li>克隆数组：<code>const arr = [...arr1]</code></li><li>合并数组：<code>const arr = [...arr1, ...arr2]</code></li><li>拼接数组：<code>arr.push(...arr1)</code></li><li>代替apply：<code>Math.max.apply(null, [x, y])</code> =&gt; <code>Math.max(...[x, y])</code></li><li>转换字符串为数组：<code>[...&quot;hello&quot;]</code></li><li>转换类数组对象为数组：<code>[...Arguments, ...NodeList]</code></li><li>转换可遍历对象为数组：<code>[...String, ...Set, ...Map, ...Generator]</code></li><li>与数组解构赋值结合：<code>const [x, ...rest/spread] = [1, 2, 3]</code></li><li>计算Unicode字符长度：<code>Array.from(&quot;hello&quot;).length</code> =&gt; <code>[...&quot;hello&quot;].length</code></li></ul><blockquote><p>重点难点</p></blockquote><ul><li>使用<code>keys()</code>、<code>values()</code>、<code>entries()</code>返回的遍历器对象，可用<code>for-of</code>自动遍历或<code>next()</code>手动遍历</li></ul><h3 id="函数扩展"><a href="#函数扩展" class="headerlink" title="函数扩展"></a>函数扩展</h3><ul><li><strong>参数默认值</strong>：为函数参数指定默认值<ul><li>形式：<code>function Func(x = 1, y = 2) {}</code></li><li>参数赋值：惰性求值(函数调用后才求值)</li><li>参数位置：尾参数</li><li>参数作用域：函数作用域</li><li>声明方式：默认声明，不能用<code>const</code>或<code>let</code>再次声明</li><li>length：返回没有指定默认值的参数个数</li><li>与解构赋值默认值结合：<code>function Func({ x = 1, y = 2 } = {}) {}</code></li><li>应用<ul><li>指定某个参数不得省略，省略即抛出错误：<code>function Func(x = throwMissing()) {}</code></li><li>将参数默认值设为<code>undefined</code>，表明此参数可省略：<code>Func(undefined, 1)</code></li></ul></li></ul></li><li><strong>rest/spread参数(…)</strong>：返回函数多余参数<ul><li>形式：以数组的形式存在，之后不能再有其他参数</li><li>作用：代替<code>Arguments对象</code></li><li>length：返回没有指定默认值的参数个数但不包括<code>rest/spread参数</code></li></ul></li><li><strong>严格模式</strong>：在严格条件下运行JS<ul><li>应用：只要函数参数使用默认值、解构赋值、扩展运算符，那么函数内部就不能显式设定为严格模式</li></ul></li><li><strong>name属性</strong>：返回函数的函数名<ul><li>将匿名函数赋值给变量：<code>空字符串</code>(<strong>ES5</strong>)、<code>变量名</code>(<strong>ES6</strong>)</li><li>将具名函数赋值给变量：<code>函数名</code>(<strong>ES5和ES6</strong>)</li><li>bind返回的函数：<code>bound 函数名</code>(<strong>ES5和ES6</strong>)</li><li>Function构造函数返回的函数实例：<code>anonymous</code>(<strong>ES5和ES6</strong>)</li></ul></li><li><strong>箭头函数(=&gt;)</strong>：函数简写<ul><li>无参数：<code>() =&gt; {}</code></li><li>单个参数：<code>x =&gt; {}</code></li><li>多个参数：<code>(x, y) =&gt; {}</code></li><li>解构参数：<code>({x, y}) =&gt; {}</code></li><li>嵌套使用：部署管道机制</li><li>this指向固定化<ul><li>并非因为内部有绑定<code>this</code>的机制，而是根本没有自己的<code>this</code>，导致内部的<code>this</code>就是外层代码块的<code>this</code></li><li>因为没有<code>this</code>，因此不能用作构造函数</li></ul></li></ul></li><li><strong>尾调用优化</strong>：只保留内层函数的调用帧<ul><li>尾调用<ul><li>定义：某个函数的最后一步是调用另一个函数</li><li>形式：<code>function f(x) { return g(x); }</code></li></ul></li><li>尾递归<ul><li>定义：函数尾调用自身</li><li>作用：只要使用尾递归就不会发生栈溢出，相对节省内存</li><li>实现：把所有用到的内部变量改写成函数的参数并使用参数默认值</li></ul></li></ul></li></ul><blockquote><p>箭头函数误区</p></blockquote><ul><li>函数体内的<code>this</code>是<code>定义时所在的对象</code>而不是<code>使用时所在的对象</code></li><li>可让<code>this</code>指向固定化，这种特性很有利于封装回调函数</li><li>不可当作<code>构造函数</code>，因此箭头函数不可使用<code>new命令</code></li><li>不可使用<code>yield命令</code>，因此箭头函数不能用作<code>Generator函数</code></li><li>不可使用<code>Arguments对象</code>，此对象在函数体内不存在(可用<code>rest/spread参数</code>代替)</li><li>返回对象时必须在对象外面加上括号</li></ul><h3 id="正则扩展"><a href="#正则扩展" class="headerlink" title="正则扩展"></a>正则扩展</h3><ul><li><strong>变更RegExp构造函数入参</strong>：允许首参数为<code>正则对象</code>，尾参数为<code>正则修饰符</code>(返回的正则表达式会忽略原正则表达式的修饰符)</li><li><strong>正则方法调用变更</strong>：字符串对象的<code>match()</code>、<code>replace()</code>、<code>search()</code>、<code>split()</code>内部调用转为调用<code>RegExp</code>实例对应的<code>RegExp.prototype[Symbol.方法]</code></li><li><strong>u修饰符</strong>：Unicode模式修饰符，正确处理大于<code>\uFFFF</code>的<code>Unicode字符</code><ul><li><code>点字符</code>(.)</li><li><code>Unicode表示法</code></li><li><code>量词</code></li><li><code>预定义模式</code></li><li><code>i修饰符</code></li><li><code>转义</code></li></ul></li><li><strong>y修饰符</strong>：粘连修饰符，确保匹配必须从剩余的第一个位置开始全局匹配(与<code>g修饰符</code>作用类似)</li><li><strong>unicode</strong>：是否设置<code>u修饰符</code></li><li><strong>sticky</strong>：是否设置<code>y修饰符</code></li><li><strong>flags</strong>：返回正则表达式的修饰符</li></ul><blockquote><p>重点难点</p></blockquote><ul><li><code>y修饰符</code>隐含头部匹配标志<code>^</code></li><li>单单一个<code>y修饰符</code>对<code>match()</code>只能返回第一个匹配，必须与<code>g修饰符</code>联用才能返回所有匹配</li></ul><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><ul><li>定义：独一无二的值</li><li>声明：<code>const set = Symbol(str)</code></li><li>入参：字符串(可选)</li><li>方法<ul><li><strong>Symbol()</strong>：创建以参数作为描述的<code>Symbol值</code>(不登记在全局环境)</li><li><strong>Symbol.for()</strong>：创建以参数作为描述的<code>Symbol值</code>，如存在此参数则返回原有的<code>Symbol值</code>(先搜索后创建，登记在全局环境)</li><li><strong>Symbol.keyFor()</strong>：返回已登记的<code>Symbol值</code>的描述(只能返回<code>Symbol.for()</code>的<code>key</code>)</li><li><strong>Object.getOwnPropertySymbols()</strong>：返回对象中所有用作属性名的<code>Symbol值</code>的数组</li></ul></li><li>内置<ul><li><strong>Symbol.hasInstance</strong>：指向一个内部方法，当其他对象使用<code>instanceof运算符</code>判断是否为此对象的实例时会调用此方法</li><li><strong>Symbol.isConcatSpreadable</strong>：指向一个布尔，定义对象用于<code>Array.prototype.concat()</code>时是否可展开</li><li><strong>Symbol.species</strong>：指向一个构造函数，当实例对象使用自身构造函数时会调用指定的构造函数</li><li><strong>Symbol.match</strong>：指向一个函数，当实例对象被<code>String.prototype.match()</code>调用时会重新定义<code>match()</code>的行为</li><li><strong>Symbol.replace</strong>：指向一个函数，当实例对象被<code>String.prototype.replace()</code>调用时会重新定义<code>replace()</code>的行为</li><li><strong>Symbol.search</strong>：指向一个函数，当实例对象被<code>String.prototype.search()</code>调用时会重新定义<code>search()</code>的行为</li><li><strong>Symbol.split</strong>：指向一个函数，当实例对象被<code>String.prototype.split()</code>调用时会重新定义<code>split()</code>的行为</li><li><strong>Symbol.iterator</strong>：指向一个默认遍历器方法，当实例对象执行<code>for-of</code>时会调用指定的默认遍历器</li><li><strong>Symbol.toPrimitive</strong>：指向一个函数，当实例对象被转为原始类型的值时会返回此对象对应的原始类型值</li><li><strong>Symbol.toStringTag</strong>：指向一个函数，当实例对象被<code>Object.prototype.toString()</code>调用时其返回值会出现在<code>toString()</code>返回的字符串之中表示对象的类型</li><li><strong>Symbol.unscopables</strong>：指向一个对象，指定使用<code>with</code>时哪些属性会被<code>with环境</code>排除</li></ul></li></ul><blockquote><p>数据类型</p></blockquote><ul><li><strong>Undefined</strong></li><li><strong>Null</strong></li><li><strong>String</strong></li><li><strong>Number</strong></li><li><strong>Boolean</strong></li><li><strong>Object</strong>(包含<code>Array</code>、<code>Function</code>、<code>Date</code>、<code>RegExp</code>、<code>Error</code>)</li><li><strong>Symbol</strong></li></ul><blockquote><p>应用场景</p></blockquote><ul><li>唯一化对象属性名：属性名属于Symbol类型，就都是独一无二的，可保证不会与其他属性名产生冲突</li><li>消除魔术字符串：在代码中多次出现且与代码形成强耦合的某一个具体的字符串或数值</li><li>遍历属性名：无法通过<code>for-in</code>、<code>for-of</code>、<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回，只能通过<code>Object.getOwnPropertySymbols</code>返回</li><li>启用模块的Singleton模式：调用一个类在任何时候返回同一个实例(<code>window</code>和<code>global</code>)，使用<code>Symbol.for()</code>来模拟全局的<code>Singleton模式</code></li></ul><blockquote><p>重点难点</p></blockquote><ul><li><code>Symbol()</code>生成一个原始类型的值不是对象，因此<code>Symbol()</code>前不能使用<code>new命令</code></li><li><code>Symbol()</code>参数表示对当前<code>Symbol值</code>的描述，相同参数的<code>Symbol()</code>返回值不相等</li><li><code>Symbol值</code>不能与其他类型的值进行运算</li><li><code>Symbol值</code>可通过<code>String()</code>或<code>toString()</code>显式转为字符串</li><li><code>Symbol值</code>作为对象属性名时，此属性是公开属性，但不是私有属性</li><li><code>Symbol值</code>作为对象属性名时，只能用方括号运算符(<code>[]</code>)读取，不能用点运算符(<code>.</code>)读取</li><li><code>Symbol值</code>作为对象属性名时，不会被常规方法遍历得到，可利用此特性为对象定义<code>非私有但又只用于内部的方法</code></li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h5 id="Set-1"><a href="#Set-1" class="headerlink" title="Set"></a>Set</h5><ul><li>定义：类似于数组的数据结构，成员值都是唯一且没有重复的值</li><li>声明：<code>const set = new Set(arr)</code></li><li>入参：具有<code>Iterator接口</code>的数据结构</li><li>属性<ul><li><strong>constructor</strong>：构造函数，返回Set</li><li><strong>size</strong>：返回实例成员总数</li></ul></li><li>方法<ul><li><strong>add()</strong>：添加值，返回实例</li><li><strong>delete()</strong>：删除值，返回布尔</li><li><strong>has()</strong>：检查值，返回布尔</li><li><strong>clear()</strong>：清除所有成员</li><li><strong>keys()</strong>：返回以属性值为遍历器的对象</li><li><strong>values()</strong>：返回以属性值为遍历器的对象</li><li><strong>entries()</strong>：返回以属性值和属性值为遍历器的对象</li><li><strong>forEach()</strong>：使用回调函数遍历每个成员</li></ul></li></ul><blockquote><p>应用场景</p></blockquote><ul><li>去重字符串：<code>[...new Set(str)].join(&quot;&quot;)</code></li><li>去重数组：<code>[...new Set(arr)]</code>或<code>Array.from(new Set(arr))</code></li><li>集合数组<ul><li>声明：<code>const a = new Set(arr1)</code>、<code>const b = new Set(arr2)</code></li><li>并集：<code>new Set([...a, ...b])</code></li><li>交集：<code>new Set([...a].filter(v =&gt; b.has(v)))</code></li><li>差集：<code>new Set([...a].filter(v =&gt; !b.has(v)))</code></li></ul></li><li>映射集合<ul><li>声明：<code>let set = new Set(arr)</code></li><li>映射：<code>set = new Set([...set].map(v =&gt; v * 2))</code>或<code>set = new Set(Array.from(set, v =&gt; v * 2))</code></li></ul></li></ul><blockquote><p>重点难点</p></blockquote><ul><li>遍历顺序：插入顺序</li><li>没有键只有值，可认为键和值两值相等</li><li>添加多个<code>NaN</code>时，只会存在一个<code>NaN</code></li><li>添加相同的对象时，会认为是不同的对象</li><li>添加值时不会发生类型转换(<code>5 !== &quot;5&quot;</code>)</li><li><code>keys()</code>和<code>values()</code>的行为完全一致，<code>entries()</code>返回的遍历器同时包括键和值且两值相等</li></ul><h5 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h5><ul><li>定义：和Set结构类似，成员值只能是对象</li><li>声明：<code>const set = new WeakSet(arr)</code></li><li>入参：具有<code>Iterator接口</code>的数据结构</li><li>属性<ul><li><strong>constructor</strong>：构造函数，返回WeakSet</li></ul></li><li>方法<ul><li><strong>add()</strong>：添加值，返回实例</li><li><strong>delete()</strong>：删除值，返回布尔</li><li><strong>has()</strong>：检查值，返回布尔</li></ul></li></ul><blockquote><p>应用场景</p></blockquote><ul><li>储存DOM节点：DOM节点被移除时自动释放此成员，不用担心这些节点从文档移除时会引发内存泄漏</li><li>临时存放一组对象或存放跟对象绑定的信息：只要这些对象在外部消失，它在<code>WeakSet结构</code>中的引用就会自动消</li></ul><blockquote><p>重点难点</p></blockquote><ul><li>成员都是<code>弱引用</code>，垃圾回收机制不考虑<code>WeakSet结构</code>对此成员的引用</li><li>成员不适合引用，它会随时消失，因此ES6规定<code>WeakSet结构不可遍历</code></li><li>其他对象不再引用成员时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于<code>WeakSet结构</code>中</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h5 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h5><ul><li>定义：类似于对象的数据结构，成员键是任何类型的值</li><li>声明：<code>const set = new Map(arr)</code></li><li>入参：具有<code>Iterator接口</code>且每个成员都是一个双元素数组的数据结构</li><li>属性<ul><li><strong>constructor</strong>：构造函数，返回Map</li><li><strong>size</strong>：返回实例成员总数</li></ul></li><li>方法<ul><li><strong>get()</strong>：返回键值对</li><li><strong>set()</strong>：添加键值对，返回实例</li><li><strong>delete()</strong>：删除键值对，返回布尔</li><li><strong>has()</strong>：检查键值对，返回布尔</li><li><strong>clear()</strong>：清除所有成员</li><li><strong>keys()</strong>：返回以键为遍历器的对象</li><li><strong>values()</strong>：返回以值为遍历器的对象</li><li><strong>entries()</strong>：返回以键和值为遍历器的对象</li><li><strong>forEach()</strong>：使用回调函数遍历每个成员</li></ul></li></ul><blockquote><p>重点难点</p></blockquote><ul><li>遍历顺序：插入顺序</li><li>对同一个键多次赋值，后面的值将覆盖前面的值</li><li>对同一个对象的引用，被视为一个键</li><li>对同样值的两个实例，被视为两个键</li><li>键跟内存地址绑定，只要内存地址不一样就视为两个键</li><li>添加多个以<code>NaN</code>作为键时，只会存在一个以<code>NaN</code>作为键的值</li><li><code>Object结构</code>提供<code>字符串—值</code>的对应，<code>Map结构</code>提供<code>值—值</code>的对应</li></ul><h5 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h5><ul><li>定义：和Map结构类似，成员键只能是对象</li><li>声明：<code>const set = new WeakMap(arr)</code></li><li>入参：具有<code>Iterator接口</code>且每个成员都是一个双元素数组的数据结构</li><li>属性<ul><li><strong>constructor</strong>：构造函数，返回WeakMap</li></ul></li><li>方法<ul><li><strong>get()</strong>：返回键值对</li><li><strong>set()</strong>：添加键值对，返回实例</li><li><strong>delete()</strong>：删除键值对，返回布尔</li><li><strong>has()</strong>：检查键值对，返回布尔</li></ul></li></ul><blockquote><p>应用场景</p></blockquote><ul><li>储存DOM节点：DOM节点被移除时自动释放此成员键，不用担心这些节点从文档移除时会引发内存泄漏</li><li>部署私有属性：内部属性是实例的弱引用，删除实例时它们也随之消失，不会造成内存泄漏</li></ul><blockquote><p>重点难点</p></blockquote><ul><li>成员键都是<code>弱引用</code>，垃圾回收机制不考虑<code>WeakMap结构</code>对此成员键的引用</li><li>成员键不适合引用，它会随时消失，因此ES6规定<code>WeakMap结构不可遍历</code></li><li>其他对象不再引用成员键时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于<code>WeakMap结构</code>中</li><li>一旦不再需要，成员会自动消失，不用手动删除引用</li><li>弱引用的<code>只是键而不是值</code>，值依然是正常引用</li><li>即使在外部消除了成员键的引用，内部的成员值依然存在</li></ul><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><ul><li>定义：修改某些操作的默认行为</li><li>声明：<code>const proxy = new Proxy(target, handler)</code></li><li>入参<ul><li><strong>target</strong>：拦截的目标对象</li><li><strong>handler</strong>：定制拦截行为</li></ul></li><li>方法<ul><li><strong>Proxy.revocable()</strong>：返回可取消的Proxy实例(返回<code>{ proxy, revoke }</code>，通过revoke()取消代理)</li></ul></li><li>拦截方式<ul><li><strong>get()</strong>：拦截对象属性读取</li><li><strong>set()</strong>：拦截对象属性设置，返回布尔</li><li><strong>has()</strong>：拦截对象属性检查<code>k in obj</code>，返回布尔</li><li><strong>deleteProperty()</strong>：拦截对象属性删除<code>delete obj[k]</code>，返回布尔</li><li><strong>defineProperty()</strong>：拦截对象属性定义<code>Object.defineProperty()</code>、<code>Object.defineProperties()</code>，返回布尔</li><li><strong>ownKeys()</strong>：拦截对象属性遍历<code>for-in</code>、<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>Object.getOwnPropertySymbols()</code>，返回数组</li><li><strong>getOwnPropertyDescriptor()</strong>：拦截对象属性描述读取<code>Object.getOwnPropertyDescriptor()</code>，返回对象</li><li><strong>getPrototypeOf()</strong>：拦截对象原型读取<code>instanceof</code>、<code>Object.getPrototypeOf()</code>、<code>Object.prototype.__proto__</code>、<code>Object.prototype.isPrototypeOf()</code>、<code>Reflect.getPrototypeOf()</code>，返回对象</li><li><strong>setPrototypeOf()</strong>：拦截对象原型设置<code>Object.setPrototypeOf()</code>，返回布尔</li><li><strong>isExtensible()</strong>：拦截对象是否可扩展读取<code>Object.isExtensible()</code>，返回布尔</li><li><strong>preventExtensions()</strong>：拦截对象不可扩展设置<code>Object.preventExtensions()</code>，返回布尔</li><li><strong>apply()</strong>：拦截Proxy实例作为函数调用<code>proxy()</code>、<code>proxy.apply()</code>、<code>proxy.call()</code></li><li><strong>construct()</strong>：拦截Proxy实例作为构造函数调用<code>new proxy()</code></li></ul></li></ul><blockquote><p>应用场景</p></blockquote><ul><li><code>Proxy.revocable()</code>：不允许直接访问对象，必须通过代理访问，一旦访问结束就收回代理权不允许再次访问</li><li><code>get()</code>：读取未知属性报错、读取数组负数索引的值、封装链式操作、生成DOM嵌套节点</li><li><code>set()</code>：数据绑定(Vue数据绑定实现原理)、确保属性值设置符合要求、防止内部属性被外部读写</li><li><code>has()</code>：隐藏内部属性不被发现、排除不符合属性条件的对象</li><li><code>deleteProperty()</code>：保护内部属性不被删除</li><li><code>defineProperty()</code>：阻止属性被外部定义</li><li><code>ownKeys()</code>：保护内部属性不被遍历</li></ul><blockquote><p>重点难点</p></blockquote><ul><li>要使<code>Proxy</code>起作用，必须针对<code>实例</code>进行操作，而不是针对<code>目标对象</code>进行操作</li><li>没有设置任何拦截时，等同于<code>直接通向原对象</code></li><li>属性被定义为<code>不可读写/扩展/配置/枚举</code>时，使用拦截方法会报错</li><li>代理下的目标对象，内部<code>this</code>指向<code>Proxy代理</code></li></ul><h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><ul><li>定义：保持<code>Object方法</code>的默认行为</li><li>方法<ul><li><strong>get()</strong>：返回对象属性</li><li><strong>set()</strong>：设置对象属性，返回布尔</li><li><strong>has()</strong>：检查对象属性，返回布尔</li><li><strong>deleteProperty()</strong>：删除对象属性，返回布尔</li><li><strong>defineProperty()</strong>：定义对象属性，返回布尔</li><li><strong>ownKeys()</strong>：遍历对象属性，返回数组(<code>Object.getOwnPropertyNames()</code>+<code>Object.getOwnPropertySymbols()</code>)</li><li><strong>getOwnPropertyDescriptor()</strong>：返回对象属性描述，返回对象</li><li><strong>getPrototypeOf()</strong>：返回对象原型，返回对象</li><li><strong>setPrototypeOf()</strong>：设置对象原型，返回布尔</li><li><strong>isExtensible()</strong>：返回对象是否可扩展，返回布尔</li><li><strong>preventExtensions()</strong>：设置对象不可扩展，返回布尔</li><li><strong>apply()</strong>：绑定this后执行指定函数</li><li><strong>construct()</strong>：调用构造函数创建实例</li></ul></li></ul><blockquote><p>设计目的</p></blockquote><ul><li>将<code>Object</code>属于<code>语言内部的方法</code>放到<code>Reflect</code>上</li><li>将某些Object方法报错情况改成返回<code>false</code></li><li>让<code>Object操作</code>变成<code>函数行为</code></li><li><code>Proxy</code>与<code>Reflect</code>相辅相成</li></ul><blockquote><p>废弃方法</p></blockquote><ul><li><code>Object.defineProperty()</code> =&gt; <code>Reflect.defineProperty()</code></li><li><code>Object.getOwnPropertyDescriptor()</code> =&gt; <code>Reflect.getOwnPropertyDescriptor()</code></li></ul><blockquote><p>重点难点</p></blockquote><ul><li><code>Proxy方法</code>和<code>Reflect方法</code>一一对应</li><li><code>Proxy</code>和<code>Reflect</code>联合使用，前者负责<code>拦截赋值操作</code>，后者负责<code>完成赋值操作</code></li></ul><blockquote><p>数据绑定：观察者模式</p></blockquote><pre><code>const observerQueue = new Set();const observe = fn =&gt; observerQueue.add(fn);const observable = obj =&gt; new Proxy(obj, {    set(tgt, key, val, receiver) {        const result = Reflect.set(tgt, key, val, receiver);        observerQueue.forEach(v =&gt; v());        return result;    }});const person = observable({ age: 25, name: &quot;Yajun&quot; });const print = () =&gt; console.log(`${person.name} is ${person.age} years old`);observe(print);person.name = &quot;Joway&quot;;复制代码</code></pre><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><ul><li>定义：对一类具有共同特征的事物的抽象(构造函数语法糖)</li><li>原理：类本身指向构造函数，所有方法定义在<code>prototype</code>上，可看作构造函数的另一种写法(<code>Class === Class.prototype.constructor</code>)</li><li>方法和关键字<ul><li><strong>constructor()</strong>：构造函数，<code>new命令</code>生成实例时自动调用</li><li><strong>extends</strong>：继承父类</li><li><strong>super</strong>：新建父类的<code>this</code></li><li><strong>static</strong>：定义静态属性方法</li><li><strong>get</strong>：取值函数，拦截属性的取值行为</li><li><strong>set</strong>：存值函数，拦截属性的存值行为</li></ul></li><li>属性<ul><li><strong>__proto__</strong>：<code>构造函数的继承</code>(总是指向<code>父类</code>)</li><li><strong>__proto__.__proto__</strong>：子类的原型的原型，即父类的原型(总是指向父类的<code>__proto__</code>)</li><li><strong>prototype.__proto__</strong>：<code>属性方法的继承</code>(总是指向父类的<code>prototype</code>)</li></ul></li><li>静态属性：定义类完成后赋值属性，该属性<code>不会被实例继承</code>，只能通过类来调用</li><li>静态方法：使用<code>static</code>定义方法，该方法<code>不会被实例继承</code>，只能通过类来调用(方法中的<code>this</code>指向类，而不是实例)</li><li>继承<ul><li>实质<ul><li>ES5实质：先创造子类实例的<code>this</code>，再将父类的属性方法添加到<code>this</code>上(<code>Parent.apply(this)</code>)</li><li>ES6实质：先将父类实例的属性方法加到<code>this</code>上(调用<code>super()</code>)，再用子类构造函数修改<code>this</code></li></ul></li><li>super<ul><li>作为函数调用：只能在构造函数中调用<code>super()</code>，内部<code>this</code>指向继承的<code>当前子类</code>(<code>super()</code>调用后才可在构造函数中使用<code>this</code>)</li><li>作为对象调用：在<code>普通方法</code>中指向<code>父类的原型对象</code>，在<code>静态方法</code>中指向<code>父类</code></li></ul></li><li>显示定义：使用<code>constructor() { super(); }</code>定义继承父类，没有书写则<code>显示定义</code></li><li>子类继承父类：子类使用父类的属性方法时，必须在构造函数中调用<code>super()</code>，否则得不到父类的<code>this</code><ul><li>父类静态属性方法可被子类继承</li><li>子类继承父类后，可从<code>super</code>上调用父类静态属性方法</li></ul></li></ul></li><li>实例：类相当于<code>实例的原型</code>，所有在类中定义的属性方法都会被实例继承<ul><li>显式指定属性方法：使用<code>this</code>指定到自身上(使用<code>Class.hasOwnProperty()</code>可检测到)</li><li>隐式指定属性方法：直接声明定义在对象原型上(使用<code>Class.__proto__.hasOwnProperty()</code>可检测到)</li></ul></li><li>表达式<ul><li>类表达式：<code>const Class = class {}</code></li><li>name属性：返回紧跟<code>class</code>后的类名</li><li>属性表达式：<code>[prop]</code></li><li>Generator方法：<code>* mothod() {}</code></li><li>Async方法：<code>async mothod() {}</code></li></ul></li><li>this指向：解构实例属性或方法时会报错<ul><li>绑定this：<code>this.mothod = this.mothod.bind(this)</code></li><li>箭头函数：<code>this.mothod = () =&gt; this.mothod()</code></li></ul></li><li>属性定义位置<ul><li>定义在构造函数中并使用<code>this</code>指向</li><li>定义在<code>类最顶层</code></li></ul></li><li><strong>new.target</strong>：确定构造函数是如何调用</li></ul><blockquote><p>原生构造函数</p></blockquote><ul><li><strong>String()</strong></li><li><strong>Number()</strong></li><li><strong>Boolean()</strong></li><li><strong>Array()</strong></li><li><strong>Object()</strong></li><li><strong>Function()</strong></li><li><strong>Date()</strong></li><li><strong>RegExp()</strong></li><li><strong>Error()</strong></li></ul><blockquote><p>重点难点</p></blockquote><ul><li>在实例上调用方法，实质是调用原型上的方法</li><li><code>Object.assign()</code>可方便地一次向类添加多个方法(<code>Object.assign(Class.prototype, { ... })</code>)</li><li>类内部所有定义的方法是不可枚举的(<code>non-enumerable</code>)</li><li>构造函数默认返回实例对象(<code>this</code>)，可指定返回另一个对象</li><li>取值函数和存值函数设置在属性的<code>Descriptor对象</code>上</li><li>类不存在变量提升</li><li>利用<code>new.target === Class</code>写出不能独立使用必须继承后才能使用的类</li><li>子类继承父类后，<code>this</code>指向子类实例，通过<code>super</code>对某个属性赋值，赋值的属性会变成子类实例的属性</li><li>使用<code>super</code>时，必须显式指定是作为函数还是作为对象使用</li><li><code>extends</code>不仅可继承类还可继承原生的构造函数</li></ul><blockquote><p>私有属性方法</p></blockquote><pre><code>const name = Symbol(&quot;name&quot;);const print = Symbol(&quot;print&quot;);class Person {    constructor(age) {        this[name] = &quot;Bruce&quot;;        this.age = age;    }    [print]() {        console.log(`${this[name]} is ${this.age} years old`);    }}复制代码</code></pre><blockquote><p>继承混合类</p></blockquote><pre><code>function CopyProperties(target, source) {    for (const key of Reflect.ownKeys(source)) {        if (key !== &quot;constructor&quot; &amp;&amp; key !== &quot;prototype&quot; &amp;&amp; key !== &quot;name&quot;) {            const desc = Object.getOwnPropertyDescriptor(source, key);            Object.defineProperty(target, key, desc);        }    }}function MixClass(...mixins) {    class Mix {        constructor() {            for (const mixin of mixins) {                CopyProperties(this, new mixin());            }        }    }    for (const mixin of mixins) {        CopyProperties(Mix, mixin);        CopyProperties(Mix.prototype, mixin.prototype);    }    return Mix;}class Student extends MixClass(Person, Kid) {}复制代码</code></pre><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><ul><li>命令<ul><li><strong>export</strong>：规定模块对外接口<ul><li><strong>默认导出</strong>：<code>export default Person</code>(导入时可指定模块任意名称，无需知晓内部真实名称)</li><li><strong>单独导出</strong>：<code>export const name = &quot;Bruce&quot;</code></li><li><strong>按需导出</strong>：<code>export { age, name, sex }</code>(推荐)</li><li><strong>改名导出</strong>：<code>export { name as newName }</code></li></ul></li><li><strong>import</strong>：导入模块内部功能<ul><li><strong>默认导入</strong>：<code>import Person from &quot;person&quot;</code></li><li><strong>整体导入</strong>：<code>import * as Person from &quot;person&quot;</code></li><li><strong>按需导入</strong>：<code>import { age, name, sex } from &quot;person&quot;</code></li><li><strong>改名导入</strong>：<code>import { name as newName } from &quot;person&quot;</code></li><li><strong>自执导入</strong>：<code>import &quot;person&quot;</code></li><li><strong>复合导入</strong>：<code>import Person, { name } from &quot;person&quot;</code></li></ul></li><li><strong>复合模式</strong>：<code>export命令</code>和<code>import命令</code>结合在一起写成一行，变量实质没有被导入当前模块，相当于对外转发接口，导致当前模块无法直接使用其导入变量<ul><li><strong>默认导入导出</strong>：<code>export { default } from &quot;person&quot;</code></li><li><strong>整体导入导出</strong>：<code>export * from &quot;person&quot;</code></li><li><strong>按需导入导出</strong>：<code>export { age, name, sex } from &quot;person&quot;</code></li><li><strong>改名导入导出</strong>：<code>export { name as newName } from &quot;person&quot;</code></li><li><strong>具名改默认导入导出</strong>：<code>export { name as default } from &quot;person&quot;</code></li><li><strong>默认改具名导入导出</strong>：<code>export { default as name } from &quot;person&quot;</code></li></ul></li></ul></li><li>继承：<code>默认导出</code>和<code>改名导出</code>结合使用可使模块具备继承性</li><li>设计思想：尽量地静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量</li><li>严格模式：ES6模块自动采用严格模式(不管模块头部是否添加<code>use strict</code>)</li></ul><blockquote><p>模块方案</p></blockquote><ul><li><strong>CommonJS</strong>：用于服务器(动态化依赖)</li><li><strong>AMD</strong>：用于浏览器(动态化依赖)</li><li><strong>CMD</strong>：用于浏览器(动态化依赖)</li><li><strong>UMD</strong>：用于浏览器和服务器(动态化依赖)</li><li><strong>ESM</strong>：用于浏览器和服务器(静态化依赖)</li></ul><blockquote><p>加载方式</p></blockquote><ul><li><strong>运行时加载</strong><ul><li>定义：整体加载模块生成一个对象，再从对象上获取需要的属性和方法进行加载(全部加载)</li><li>影响：只有运行时才能得到这个对象，导致无法在编译时做静态优化</li></ul></li><li><strong>编译时加载</strong><ul><li>定义：直接从模块中获取需要的属性和方法进行加载(按需加载)</li><li>影响：在编译时就完成模块加载，效率比其他方案高，但无法引用模块本身(<strong>本身不是对象</strong>)，可拓展JS高级语法(<strong>宏和类型校验</strong>)</li></ul></li></ul><blockquote><p>加载实现</p></blockquote><ul><li><strong>传统加载</strong>：通过<code>&lt;script&gt;</code>进行同步或异步加载脚本<ul><li>同步加载：<code>&lt;script src=&quot;&quot;&gt;&lt;/script&gt;</code></li><li>Defer异步加载：<code>&lt;script src=&quot;&quot; defer&gt;&lt;/script&gt;</code>(顺序加载，渲染完再执行)</li><li>Async异步加载：<code>&lt;script src=&quot;&quot; async&gt;&lt;/script&gt;</code>(乱序加载，下载完就执行)</li></ul></li><li><strong>模块加载</strong>：<code>&lt;script type=&quot;module&quot; src=&quot;&quot;&gt;&lt;/script&gt;</code>(默认是Defer异步加载)</li></ul><blockquote><p>CommonJS和ESM的区别</p></blockquote><ul><li><code>CommonJS</code>输出<code>值的拷贝</code>，<code>ESM</code>输出<code>值的引用</code><ul><li><code>CommonJS</code>一旦输出一个值，模块内部的变化就影响不到这个值</li><li><code>ESM</code>是动态引用且不会缓存值，模块里的变量绑定其所在的模块，等到脚本真正执行时，再根据这个只读引用到被加载的那个模块里去取值</li></ul></li><li><code>CommonJS</code>是运行时加载，<code>ESM</code>是编译时加载<ul><li><code>CommonJS</code>加载模块是对象(即<code>module.exports</code>)，该对象只有在脚本运行完才会生成</li><li><code>ESM</code>加载模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成</li></ul></li></ul><blockquote><p>Node加载</p></blockquote><ul><li>背景：<code>CommonJS</code>和<code>ESM</code>互不兼容，目前解决方案是将两者分开，采用各自的加载方案</li><li>区分：要求<code>ESM</code>采用<code>.mjs</code>后缀文件名<ul><li><code>require()</code>不能加载<code>.mjs文件</code>，只有<code>import命令</code>才可加载<code>.mjs文件</code></li><li><code>.mjs文件</code>里不能使用<code>require()</code>，必须使用<code>import命令</code>加载文件</li></ul></li><li>驱动：<code>node --experimental-modules file.mjs</code></li><li>限制：Node的<code>import命令</code>目前只支持加载本地模块(<code>file:协议</code>)，不支持加载远程模块</li><li>加载优先级<ul><li>脚本文件省略后缀名：依次尝试加载四个后缀名文件(<code>.mjs</code>、<code>.js</code>、<code>.json</code>、<code>node</code>)</li><li>以上不存在：尝试加载<code>package.json</code>的<code>main字段</code>指定的脚本</li><li>以上不存在：依次尝试加载名称为<code>index</code>四个后缀名文件(<code>.mjs</code>、<code>.js</code>、<code>.json</code>、<code>node</code>)</li><li>以上不存在：报错</li></ul></li><li>不存在的内部变量：<code>arguments</code>、<code>exports</code>、<code>module</code>、<code>require</code>、<code>this</code>、<code>__dirname</code>、<code>__filename</code></li><li>CommonJS加载ESM<ul><li>不能使用<code>require()</code>，只能使用<code>import()</code></li></ul></li><li>ESM加载CommonJS<ul><li>自动将<code>module.exports</code>转化成<code>export default</code></li><li><code>CommonJS</code>输出缓存机制在<code>ESM</code>加载方式下依然有效</li><li>采用<code>import命令</code>加载<code>CommonJS模块</code>时，不允许采用<code>按需导入</code>，应使用<code>默认导入</code>或<code>整体导入</code></li></ul></li></ul><blockquote><p>循环加载</p></blockquote><ul><li>定义：<code>脚本A</code>的执行依赖<code>脚本B</code>，而<code>脚本A</code>的执行又依赖<code>脚本B</code></li><li>加载原理<ul><li>CommonJS：<code>require()</code>首次加载脚本就会执行整个脚本，在内存里生成一个对象缓存下来，二次加载脚本时直接从缓存中获取</li><li>ESM：<code>import命令</code>加载变量不会被缓存，而是成为一个指向被加载模块的引用</li></ul></li><li>循环加载<ul><li>CommonJS：只输出已经执行的部分，还未执行的部分不会输出</li><li>ESM：需开发者自己保证真正取值时能够取到值(可把变量写成函数形式，函数具有提升作用)</li></ul></li></ul><blockquote><p>重点难点</p></blockquote><ul><li>ES6模块中，顶层<code>this</code>指向<code>undefined</code>，不应该在顶层代码使用<code>this</code></li><li>一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取</li><li><code>export命令</code>输出的接口与其对应的值是<code>动态绑定关系</code>，即通过该接口可获取模块内部实时的值</li><li><code>import命令</code>大括号里的变量名必须与被导入模块对外接口的名称相同</li><li><code>import命令</code>输入的变量只读(本质是输入接口)，不允许在加载模块的脚本里改写接口</li><li><code>import命令</code>命令具有提升效果，会提升到整个模块的头部，首先执行</li><li>重复执行同一句<code>import语句</code>，只会执行一次</li><li><code>export default</code>命令只能使用一次</li><li><code>export default命令</code>导出的整体模块，在执行<code>import命令</code>时其后不能跟<code>大括号</code></li><li><code>export default命令</code>本质是输出一个名为<code>default</code>的变量，后面不能跟<code>变量声明语句</code></li><li><code>export default命令</code>本质是将后面的值赋给名为<code>default</code>的变量，可直接将值写在其后</li><li><code>export default命令</code>和<code>export {}命令</code>可同时存在，对应<code>复合导入</code></li><li><code>export命令</code>和<code>import命令</code>可出现在模块任何位置，只要处于模块顶层即可，不能处于块级作用域</li><li><code>import()</code>加载模块成功后，此模块会作为一个对象，当作<code>then()</code>的参数，可使用<code>对象解构赋值</code>来获取输出接口</li><li>同时动态加载多个模块时，可使用<code>Promise.all()</code>和<code>import()</code>相结合来实现</li><li><code>import()</code>和结合<code>async/await</code>来书写同步操作的代码</li></ul><blockquote><p>单例模式：跨模块常量</p></blockquote><pre><code>const NAME = &quot;Bruce&quot;;const AGE = 25;const SEX = &quot;male&quot;;export { AGE, NAME, SEX };复制代码import { AGE } from &quot;person&quot;;console.log(AGE);复制代码import { AGE, NAME, SEX } from &quot;person&quot;;console.log(AGE, NAME, SEX);复制代码</code></pre><blockquote><p>默认导入互换整体导入</p></blockquote><pre><code>import Person from &quot;person&quot;;console.log(Person.AGE);复制代码import * as Person from &quot;person&quot;;console.log(Person.default.AGE);复制代码</code></pre><h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><ul><li>定义：为各种不同的数据结构提供统一的访问机制</li><li>原理：创建一个指针指向首个成员，按照次序使用<code>next()</code>指向下一个成员，直接到结束位置(数据结构只要部署<code>Iterator接口</code>就可完成遍历操作)</li><li>作用<ul><li>为各种数据结构提供一个统一的简便的访问接口</li><li>使得数据结构成员能够按某种次序排列</li><li>ES6创造了新的遍历命令<code>for-of</code>，<code>Iterator接口</code>主要供<code>for-of</code>消费</li></ul></li><li>形式：<code>for-of</code>(自动去寻找Iterator接口)</li><li>数据结构<ul><li>集合：<code>Array</code>、<code>Object</code>、<code>Set</code>、<code>Map</code></li><li>原生具备接口的数据结构：<code>String</code>、<code>Array</code>、<code>Set</code>、<code>Map</code>、<code>TypedArray</code>、<code>Arguments</code>、<code>NodeList</code></li></ul></li><li>部署：默认部署在<code>Symbol.iterator</code>(具备此属性被认为<code>可遍历的iterable</code>)</li><li>遍历器对象<ul><li><strong>next()</strong>：下一步操作，返回<code>{ done, value }</code>(必须部署)</li><li><strong>return()</strong>：<code>for-of</code>提前退出调用，返回<code>{ done: true }</code></li><li><strong>throw()</strong>：不使用，配合<code>Generator函数</code>使用</li></ul></li></ul><blockquote><p>ForOf循环</p></blockquote><ul><li>定义：调用<code>Iterator接口</code>产生遍历器对象(<code>for-of</code>内部调用数据结构的<code>Symbol.iterator()</code>)</li><li>遍历字符串：<code>for-in</code>获取<code>索引</code>，<code>for-of</code>获取<code>值</code>(可识别32位UTF-16字符)</li><li>遍历数组：<code>for-in</code>获取<code>索引</code>，<code>for-of</code>获取<code>值</code></li><li>遍历对象：<code>for-in</code>获取<code>键</code>，<code>for-of</code>需自行部署</li><li>遍历Set：<code>for-of</code>获取<code>值</code> =&gt; <code>for (const v of set)</code></li><li>遍历Map：<code>for-of</code>获取<code>键值对</code> =&gt; <code>for (const [k, v] of map)</code></li><li>遍历类数组：<code>包含length的对象</code>、<code>Arguments对象</code>、<code>NodeList对象</code>(无<code>Iterator接口的类数组</code>可用<code>Array.from()</code>转换)</li><li>计算生成数据结构：<code>Array</code>、<code>Set</code>、<code>Map</code><ul><li><strong>keys()</strong>：返回遍历器对象，遍历所有的键</li><li><strong>values()</strong>：返回遍历器对象，遍历所有的值</li><li><strong>entries()</strong>：返回遍历器对象，遍历所有的键值对</li></ul></li><li>与<code>for-in</code>区别<ul><li>有着同<code>for-in</code>一样的简洁语法，但没有<code>for-in</code>那些缺点、</li><li>不同于<code>forEach()</code>，它可与<code>break</code>、<code>continue</code>和<code>return</code>配合使用</li><li>提供遍历所有数据结构的统一操作接口</li></ul></li></ul><blockquote><p>应用场景</p></blockquote><ul><li>改写具有<code>Iterator接口</code>的数据结构的<code>Symbol.iterator</code></li><li>解构赋值：对Set进行结构</li><li>扩展运算符：将部署<code>Iterator接口</code>的数据结构转为数组</li><li>yield*：<code>yield*</code>后跟一个可遍历的数据结构，会调用其遍历器接口</li><li>接受数组作为参数的函数：<code>for-of</code>、<code>Array.from()</code>、<code>new Set()</code>、<code>new WeakSet()</code>、<code>new Map()</code>、<code>new WeakMap()</code>、<code>Promise.all()</code>、<code>Promise.race()</code></li></ul><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><ul><li>定义：包含异步操作结果的对象</li><li>状态<ul><li><strong>进行中</strong>：<code>pending</code></li><li><strong>已成功</strong>：<code>resolved</code></li><li><strong>已失败</strong>：<code>rejected</code></li></ul></li><li>特点<ul><li>对象的状态不受外界影响</li><li>一旦状态改变就不会再变，任何时候都可得到这个结果</li></ul></li><li>声明：<code>new Promise((resolve, reject) =&gt; {})</code></li><li>出参<ul><li><strong>resolve</strong>：将状态从<code>未完成</code>变为<code>成功</code>，在异步操作成功时调用，并将异步操作的结果作为参数传递出去</li><li><strong>reject</strong>：将状态从<code>未完成</code>变为<code>失败</code>，在异步操作失败时调用，并将异步操作的错误作为参数传递出去</li></ul></li><li>方法<ul><li><strong>then()</strong>：分别指定<code>resolved状态</code>和<code>rejected状态</code>的回调函数<ul><li><strong>第一参数</strong>：状态变为<code>resolved</code>时调用</li><li><strong>第二参数</strong>：状态变为<code>rejected</code>时调用(可选)</li></ul></li><li><strong>catch()</strong>：指定发生错误时的回调函数</li><li><strong>Promise.all()</strong>：将多个实例包装成一个新实例，返回全部实例状态变更后的结果数组(齐变更再返回)<ul><li>入参：具有<code>Iterator接口</code>的数据结构</li><li>成功：只有全部实例状态变成<code>fulfilled</code>，最终状态才会变成<code>fulfilled</code></li><li>失败：其中一个实例状态变成<code>rejected</code>，最终状态就会变成<code>rejected</code></li></ul></li><li><strong>Promise.race()</strong>：将多个实例包装成一个新实例，返回全部实例状态优先变更后的结果(先变更先返回)<ul><li>入参：具有<code>Iterator接口</code>的数据结构</li><li>成功失败：哪个实例率先改变状态就返回哪个实例的状态</li></ul></li><li><strong>Promise.resolve()</strong>：将对象转为Promise对象(等价于<code>new Promise(resolve =&gt; resolve())</code>)<ul><li><strong>Promise实例</strong>：原封不动地返回入参</li><li><strong>Thenable对象</strong>：将此对象转为Promise对象并返回(Thenable为包含<code>then()</code>的对象，执行<code>then()</code>相当于执行此对象的<code>then()</code>)</li><li><strong>不具有then()的对象</strong>：将此对象转为Promise对象并返回，状态为<code>resolved</code></li><li><strong>不带参数</strong>：返回Promise对象，状态为<code>resolved</code></li></ul></li><li><strong>Promise.reject()</strong>：将对象转为状态为<code>rejected</code>的Promise对象(等价于<code>new Promise((resolve, reject) =&gt; reject())</code>)</li></ul></li></ul><blockquote><p>应用场景</p></blockquote><ul><li>加载图片</li><li>AJAX转Promise对象</li></ul><blockquote><p>重点难点</p></blockquote><ul><li>只有异步操作的结果可决定当前状态是哪一种，其他操作都无法改变这个状态</li><li>状态改变只有两种可能：从<code>pending</code>变为<code>resolved</code>、从<code>pending</code>变为<code>rejected</code></li><li>一旦新建<code>Promise对象</code>就会立即执行，无法中途取消</li><li>不设置回调函数，内部抛错不会反应到外部</li><li>当处于<code>pending</code>时，无法得知目前进展到哪一个阶段</li><li>实例状态变为<code>resolved</code>或<code>rejected</code>时，会触发<code>then()</code>绑定的回调函数</li><li><code>resolve()</code>和<code>reject()</code>的执行总是晚于本轮循环的同步任务</li><li><code>then()</code>返回新实例，其后可再调用另一个<code>then()</code></li><li><code>then()</code>运行中抛出错误会被<code>catch()</code>捕获</li><li><code>reject()</code>的作用等同于抛出错误</li><li>实例状态已变成<code>resolved</code>时，再抛出错误是无效的，不会被捕获，等于没有抛出</li><li>实例状态的错误具有<code>冒泡</code>性质，会一直向后传递直到被捕获为止，错误总是会被下一个<code>catch()</code>捕获</li><li>不要在<code>then()</code>里定义<code>rejected</code>状态的回调函数(不使用其第二参数)</li><li>建议使用<code>catch()</code>捕获错误，不要使用<code>then()</code>第二个参数捕获</li><li>没有使用<code>catch()</code>捕获错误，实例抛错不会传递到外层代码，即<code>不会有任何反应</code></li><li>作为参数的实例定义了<code>catch()</code>，一旦被<code>rejected</code>并不会触发<code>Promise.all()</code>的<code>catch()</code></li><li><code>Promise.reject()</code>的参数会原封不动地作为<code>rejected</code>的理由，变成后续方法的参数</li></ul><h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><ul><li>定义：封装多个内部状态的异步编程解决方案</li><li>形式：调用<code>Generator函数</code>(该函数不执行)返回指向内部状态的指针对象(不是运行结果)</li><li>声明：<code>function* Func() {}</code></li><li>方法<ul><li><strong>next()</strong>：使指针移向下一个状态，返回<code>{ done, value }</code>(入参会被当作上一个<code>yield命令表达式</code>的返回值)</li><li><strong>return()</strong>：返回指定值且终结遍历<code>Generator函数</code>，返回<code>{ done: true, value: 入参 }</code></li><li><strong>throw()</strong>：在<code>Generator函数</code>体外抛出错误，在<code>Generator函数</code>体内捕获错误，返回自定义的<code>new Errow()</code></li></ul></li><li>yield命令：声明内部状态的值(<code>return</code>声明结束返回的值)<ul><li>遇到<code>yield命令</code>就暂停执行后面的操作，并将其后表达式的值作为返回对象的<code>value</code></li><li>下次调用<code>next()</code>时，再继续往下执行直到遇到下一个<code>yield命令</code></li><li>没有再遇到<code>yield命令</code>就一直运行到<code>Generator函数</code>结束，直到遇到<code>return语句</code>为止并将其后表达式的值作为返回对象的<code>value</code></li><li><code>Generator函数</code>没有<code>return语句</code>则返回对象的<code>value</code>为<code>undefined</code></li></ul></li><li>yield*命令：在一个<code>Generator函数</code>里执行另一个<code>Generator函数</code>(后随具有<code>Iterator接口</code>的数据结构)</li><li>遍历：通过<code>for-of</code>自动调用<code>next()</code></li><li>作为对象属性<ul><li>全写：<code>const obj = { method: function*() {} }</code></li><li>简写：<code>const obj = { * method() {} }</code></li></ul></li><li>上下文：执行产生的<code>上下文环境</code>一旦遇到<code>yield命令</code>就会暂时退出堆栈(但并不消失)，所有变量和对象会冻结在<code>当前状态</code>，等到对它执行<code>next()</code>时，这个<code>上下文环境</code>又会重新加入调用栈，冻结的变量和对象恢复执行</li></ul><blockquote><p>方法异同</p></blockquote><ul><li>相同点：<code>next()</code>、<code>throw()</code>、<code>return()</code>本质上是同一件事，作用都是让函数恢复执行且使用不同的语句替换<code>yield命令</code></li><li>不同点<ul><li><strong>next()</strong>：将<code>yield命令</code>替换成一个<code>值</code></li><li><strong>return()</strong>：将<code>yield命令</code>替换成一个<code>return语句</code></li><li><strong>throw()</strong>：将<code>yield命令</code>替换成一个<code>throw语句</code></li></ul></li></ul><blockquote><p>应用场景</p></blockquote><ul><li>异步操作同步化表达</li><li>控制流管理</li><li>为对象部署Iterator接口：把<code>Generator函数</code>赋值给对象的<code>Symbol.iterator</code>，从而使该对象具有<code>Iterator接口</code></li><li>作为具有Iterator接口的数据结构</li></ul><blockquote><p>重点难点</p></blockquote><ul><li>每次调用<code>next()</code>，指针就从<code>函数头部</code>或<code>上次停下的位置</code>开始执行，直到遇到下一个<code>yield命令</code>或<code>return语句</code>为止</li><li>函数内部可不用<code>yield命令</code>，但会变成单纯的<code>暂缓执行函数</code>(还是需要<code>next()</code>触发)</li><li><code>yield命令</code>是暂停执行的标记，<code>next()</code>是恢复执行的操作</li><li><code>yield命令</code>用在另一个表达式中必须放在<code>圆括号</code>里</li><li><code>yield命令</code>用作函数参数或放在赋值表达式的右边，可不加<code>圆括号</code></li><li><code>yield命令</code>本身没有返回值，可认为是返回<code>undefined</code></li><li><code>yield命令表达式</code>为惰性求值，等<code>next()</code>执行到此才求值</li><li>函数调用后生成遍历器对象，此对象的<code>Symbol.iterator</code>是此对象本身</li><li>在函数运行的不同阶段，通过<code>next()</code>从外部向内部注入不同的值，从而调整函数行为</li><li>首个<code>next()</code>用来启动遍历器对象，后续才可传递参数</li><li>想首次调用<code>next()</code>时就能输入值，可在函数外面再包一层</li><li>一旦<code>next()</code>返回对象的<code>done</code>为<code>true</code>，<code>for-of</code>遍历会中止且不包含该返回对象</li><li>函数内部部署<code>try-finally</code>且正在执行<code>try</code>，那么<code>return()</code>会导致立刻进入<code>finally</code>，执行完<code>finally</code>以后整个函数才会结束</li><li>函数内部没有部署<code>try-catch</code>，<code>throw()</code>抛错将被外部<code>try-catch</code>捕获</li><li><code>throw()</code>抛错要被内部捕获，前提是必须<code>至少执行过一次next()</code></li><li><code>throw()</code>被捕获以后，会附带执行下一条<code>yield命令</code></li><li>函数还未开始执行，这时<code>throw()</code>抛错只可能抛出在函数外部</li></ul><blockquote><p>首次next()可传值</p></blockquote><pre><code>function Wrapper(func) {    return function(...args) {        const generator = func(...args);        generator.next();        return generator;    }}const print = Wrapper(function*() {    console.log(`First Input: ${yield}`);    return &quot;done&quot;;});print().next(&quot;hello&quot;);复制代码</code></pre></div><h2 id="ES2016"><a href="#ES2016" class="headerlink" title="ES2016"></a>ES2016</h2><div class="story post-story"><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201023110400.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201023110400.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20201023110400"></p><h3 id="数值扩展-1"><a href="#数值扩展-1" class="headerlink" title="数值扩展"></a>数值扩展</h3><ul><li><strong>指数运算符(**)</strong>：数值求幂(相当于<code>Math.pow()</code>)</li></ul><h3 id="数组扩展-1"><a href="#数组扩展-1" class="headerlink" title="数组扩展"></a>数组扩展</h3><ul><li><strong>includes()</strong>：是否存在指定成员</li></ul></div><h2 id="ES2017"><a href="#ES2017" class="headerlink" title="ES2017"></a>ES2017</h2><div class="story post-story"><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201023110427.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201023110427.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20201023110427"></p><h3 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h3><ul><li><strong>共享内存和原子操作</strong>：由全局对象<code>SharedArrayBuffer</code>和<code>Atomics</code>实现，将数据存储在一块共享内存空间中，这些数据可在<code>JS主线程</code>和<code>web-worker线程</code>之间共享</li></ul><h3 id="字符串扩展-1"><a href="#字符串扩展-1" class="headerlink" title="字符串扩展"></a>字符串扩展</h3><ul><li><strong>padStart()</strong>：把指定字符串填充到字符串头部，返回新字符串</li><li><strong>padEnd()</strong>：把指定字符串填充到字符串尾部，返回新字符串</li></ul><h3 id="对象扩展-1"><a href="#对象扩展-1" class="headerlink" title="对象扩展"></a>对象扩展</h3><ul><li><strong>Object.getOwnPropertyDescriptors()</strong>：返回对象所有自身属性(非继承属性)的描述对象</li><li><strong>Object.values()</strong>：返回以值组成的数组</li><li><strong>Object.entries()</strong>：返回以键和值组成的数组</li></ul><h3 id="函数扩展-1"><a href="#函数扩展-1" class="headerlink" title="函数扩展"></a>函数扩展</h3><ul><li><strong>函数参数尾逗号</strong>：允许函数最后一个参数有尾逗号</li></ul><h3 id="Async"><a href="#Async" class="headerlink" title="Async"></a>Async</h3><ul><li>定义：使异步函数以同步函数的形式书写(Generator函数语法糖)</li><li>原理：将<code>Generator函数</code>和自动执行器<code>spawn</code>包装在一个函数里</li><li>形式：将<code>Generator函数</code>的<code>*</code>替换成<code>async</code>，将<code>yield</code>替换成<code>await</code></li><li>声明<ul><li>具名函数：<code>async function Func() {}</code></li><li>函数表达式：<code>const func = async function() {}</code></li><li>箭头函数：<code>const func = async() =&gt; {}</code></li><li>对象方法：<code>const obj = { async func() {} }</code></li><li>类方法：<code>class Cla { async Func() {} }</code></li></ul></li><li>await命令：等待当前Promise对象状态变更完毕<ul><li>正常情况：后面是Promise对象则返回其结果，否则返回对应的值</li><li>后随<code>Thenable对象</code>：将其等同于Promise对象返回其结果</li></ul></li><li>错误处理：将<code>await命令Promise对象</code>放到<code>try-catch</code>中(可放多个)</li></ul><blockquote><p>Async对Generator改进</p></blockquote><ul><li>内置执行器</li><li>更好的语义</li><li>更广的适用性</li><li>返回值是Promise对象</li></ul><blockquote><p>应用场景</p></blockquote><ul><li>按顺序完成异步操作</li></ul><blockquote><p>重点难点</p></blockquote><ul><li><code>Async函数</code>返回<code>Promise对象</code>，可使用<code>then()</code>添加回调函数</li><li>内部<code>return返回值</code>会成为后续<code>then()</code>的出参</li><li>内部抛出错误会导致返回的Promise对象变为<code>rejected状态</code>，被<code>catch()</code>接收到</li><li>返回的Promise对象必须等到内部所有<code>await命令Promise对象</code>执行完才会发生状态改变，除非遇到<code>return语句</code>或<code>抛出错误</code></li><li>任何一个<code>await命令Promise对象</code>变为<code>rejected状态</code>，整个<code>Async函数</code>都会中断执行</li><li>希望即使前一个异步操作失败也不要中断后面的异步操作<ul><li>将<code>await命令Promise对象</code>放到<code>try-catch</code>中</li><li><code>await命令Promise对象</code>跟一个<code>catch()</code></li></ul></li><li><code>await命令Promise对象</code>可能变为<code>rejected状态</code>，最好把其放到<code>try-catch</code>中</li><li>多个<code>await命令Promise对象</code>若不存在继发关系，最好让它们同时触发</li><li><code>await命令</code>只能用在<code>Async函数</code>之中，否则会报错</li><li>数组使用<code>forEach()</code>执行<code>async/await</code>会失效，可使用<code>for-of</code>和<code>Promise.all()</code>代替</li><li>可保留运行堆栈，函数上下文随着<code>Async函数</code>的执行而存在，执行完成就消失</li></ul></div><h2 id="ES2018"><a href="#ES2018" class="headerlink" title="ES2018"></a>ES2018</h2><div class="story post-story"><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201023110442.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201023110442.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20201023110442"></p><h3 id="字符串扩展-2"><a href="#字符串扩展-2" class="headerlink" title="字符串扩展"></a>字符串扩展</h3><ul><li><strong>放松对标签模板里字符串转义的限制</strong>：遇到不合法的字符串转义返回<code>undefined</code>，并且从<code>raw</code>上可获取原字符串</li></ul><h3 id="对象扩展-2"><a href="#对象扩展-2" class="headerlink" title="对象扩展"></a>对象扩展</h3><ul><li><strong>扩展运算符(…)</strong>：转换对象为用逗号分隔的参数序列(<code>{ ...obj }</code>，相当于<code>rest/spread参数</code>的逆运算)</li></ul><blockquote><p>扩展应用</p></blockquote><ul><li>克隆对象：<code>const obj = { __proto__: Object.getPrototypeOf(obj1), ...obj1 }</code></li><li>合并对象：<code>const obj = { ...obj1, ...obj2 }</code></li><li>转换字符串为对象：<code>{ ...&quot;hello&quot; }</code></li><li>转换数组为对象：<code>{ ...[1, 2] }</code></li><li>与对象解构赋值结合：<code>const { x, ...rest/spread } = { x: 1, y: 2, z: 3 }</code>(不能复制继承自原型对象的属性)</li><li>修改现有对象部分属性：<code>const obj = { x: 1, ...{ x: 2 } }</code></li></ul><h3 id="正则扩展-1"><a href="#正则扩展-1" class="headerlink" title="正则扩展"></a>正则扩展</h3><ul><li><strong>s修饰符</strong>：dotAll模式修饰符，使<code>.</code>匹配任意单个字符(<code>dotAll模式</code>)</li><li><strong>dotAll</strong>：是否设置<code>s修饰符</code></li><li><strong>后行断言</strong>：<code>x</code>只有在<code>y</code>后才匹配</li><li><strong>后行否定断言</strong>：<code>x</code>只有不在<code>y</code>后才匹配</li><li><strong>Unicode属性转义</strong>：匹配符合<code>Unicode某种属性</code>的所有字符<ul><li>正向匹配：<code>\p{PropRule}</code></li><li>反向匹配：<code>\P{PropRule}</code></li><li>限制：<code>\p{...}</code>和<code>\P{...}</code>只对<code>Unicode字符</code>有效，使用时需加上<code>u修饰符</code></li></ul></li><li><strong>具名组匹配</strong>：为每组匹配指定名字(<code>?&lt;GroupName&gt;</code>)<ul><li>形式：<code>str.exec().groups.GroupName</code></li><li>解构赋值替换<ul><li>声明：<code>const time = &quot;2017-09-11&quot;</code>、<code>const regexp = /(?&lt;year&gt;\d{4})-(?&lt;month&gt;\d{2})-(?&lt;day&gt;\d{2})/u</code></li><li>匹配：<code>time.replace(regexp, &quot;$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;&quot;)</code></li></ul></li></ul></li></ul><h3 id="Promise-1"><a href="#Promise-1" class="headerlink" title="Promise"></a>Promise</h3><ul><li><strong>finally()</strong>：指定不管最后状态如何都会执行的回调函数</li></ul><h3 id="Async-1"><a href="#Async-1" class="headerlink" title="Async"></a>Async</h3><ul><li><strong>异步迭代器(for-await-of)</strong>：循环等待每个<code>Promise对象</code>变为<code>resolved状态</code>才进入下一步</li></ul></div><h2 id="ES2019"><a href="#ES2019" class="headerlink" title="ES2019"></a>ES2019</h2><div class="story post-story"><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201023110456.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201023110456.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20201023110456"></p><h3 id="字符串扩展-3"><a href="#字符串扩展-3" class="headerlink" title="字符串扩展"></a>字符串扩展</h3><ul><li><strong>直接输入U+2028和U+2029</strong>：字符串可直接输入<code>行分隔符</code>和<code>段分隔符</code></li><li><strong>JSON.stringify()改造</strong>：可返回不符合UTF-8标准的字符串</li><li><strong>trimStart()</strong>：消除字符串头部空格，返回新字符串</li><li><strong>trimEnd()</strong>：消除字符串尾部空格，返回新字符串</li></ul><h3 id="对象扩展-3"><a href="#对象扩展-3" class="headerlink" title="对象扩展"></a>对象扩展</h3><ul><li><strong>Object.fromEntries()</strong>：返回以键和值组成的对象(<code>Object.entries()</code>的逆操作)</li></ul><h3 id="数组扩展-2"><a href="#数组扩展-2" class="headerlink" title="数组扩展"></a>数组扩展</h3><ul><li><strong>sort()稳定性</strong>：排序关键字相同的项目其排序前后的顺序不变，默认为<code>稳定</code></li><li><strong>flat()</strong>：扁平化数组，返回新数组</li><li><strong>flatMap()</strong>：映射且扁平化数组，返回新数组(只能展开一层数组)</li></ul><h3 id="函数扩展-2"><a href="#函数扩展-2" class="headerlink" title="函数扩展"></a>函数扩展</h3><ul><li><strong>toString()改造</strong>：返回函数原始代码(与编码一致)</li><li><strong>catch()参数可省略</strong>：<code>catch()</code>中的参数可省略</li></ul><h3 id="Symbol-1"><a href="#Symbol-1" class="headerlink" title="Symbol"></a>Symbol</h3><ul><li><strong>description</strong>：返回<code>Symbol值</code>的描述</li></ul></div><h2 id="ES2020"><a href="#ES2020" class="headerlink" title="ES2020"></a>ES2020</h2><div class="story post-story"><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201023110521.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201023110521.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20201023110521"></p><h3 id="声明-2"><a href="#声明-2" class="headerlink" title="声明"></a>声明</h3><ul><li><strong>globalThis</strong>：作为顶层对象，指向全局环境下的<code>this</code><ul><li>Browser：顶层对象是<code>window</code></li><li>Node：顶层对象是<code>global</code></li><li>WebWorker：顶层对象是<code>self</code></li><li>以上三者：通用顶层对象是<code>globalThis</code></li></ul></li></ul><h3 id="数值扩展-2"><a href="#数值扩展-2" class="headerlink" title="数值扩展"></a>数值扩展</h3><ul><li><strong>BigInt</strong>：任何位数的整数(新增的数据类型，使用<code>n</code>结尾)<ul><li><strong>BigInt()</strong>：转换普通数值为BigInt类型</li><li><strong>BigInt.asUintN()</strong>：转换BigInt为0到2n-1之间对应的值</li><li><strong>BigInt.asIntN()</strong>：转换BigInt为-2n-1 到2n-1-1</li><li><strong>BigInt.parseInt()</strong>：近似于<code>Number.parseInt()</code>，将一个字符串转换成指定进制的BigInt类型</li></ul></li></ul><blockquote><p>重点难点</p></blockquote><ul><li>BigInt同样可使用各种进制表示，都要加上后缀</li><li>BigInt与普通整数是两种值，它们之间并不相等</li><li>typeof运算符对于BigInt类型的数据返回<code>bigint</code></li></ul><h3 id="对象扩展-4"><a href="#对象扩展-4" class="headerlink" title="对象扩展"></a>对象扩展</h3><ul><li><strong>链判断操作符(?.)</strong>：是否存在对象属性(不存在返回<code>undefined</code>且不再往下执行)<ul><li>对象属性：<code>obj?.prop</code>、<code>obj?.[expr]</code></li><li>函数调用：<code>func?.(...args)</code></li></ul></li><li><strong>空判断操作符(??)</strong>：是否值为<code>undefined</code>或<code>null</code>，是则使用默认值</li></ul><h3 id="正则扩展-2"><a href="#正则扩展-2" class="headerlink" title="正则扩展"></a>正则扩展</h3><ul><li><strong>matchAll()</strong>：返回所有匹配的遍历器</li></ul><h3 id="Module-1"><a href="#Module-1" class="headerlink" title="Module"></a>Module</h3><ul><li><strong>import()</strong>：动态导入(返回<code>Promise</code>)<ul><li>背景：<code>import命令</code>被JS引擎静态分析，先于模块内的其他语句执行，无法取代<code>require()</code>的动态加载功能，提案建议引入<code>import()</code>来代替<code>require()</code></li><li>位置：可在任何地方使用</li><li>区别：<code>require()</code>是<strong>同步加载</strong>，<code>import()</code>是<strong>异步加载</strong></li><li>场景：按需加载、条件加载、模块路径动态化</li></ul></li></ul><h3 id="Iterator-1"><a href="#Iterator-1" class="headerlink" title="Iterator"></a>Iterator</h3><ul><li><strong>for-in遍历顺序</strong>：不同的引擎已就如何迭代属性达成一致，从而使行为标准化</li></ul><h3 id="Promise-2"><a href="#Promise-2" class="headerlink" title="Promise"></a>Promise</h3><ul><li><strong>Promise.allSettled()</strong>：将多个实例包装成一个新实例，返回全部实例状态变更后的状态数组(齐变更再返回)<ul><li>入参：具有<code>Iterator接口</code>的数据结构</li><li>成功：成员包含<code>status</code>和<code>value</code>，<code>status</code>为<code>fulfilled</code>，<code>value</code>为返回值</li><li>失败：成员包含<code>status</code>和<code>reason</code>，<code>status</code>为<code>rejected</code>，<code>value</code>为错误原因</li></ul></li></ul></div><h2 id="ES提案"><a href="#ES提案" class="headerlink" title="ES提案"></a>ES提案</h2><div class="story post-story"><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201023110554.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201023110554.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20201023110554"></p><h3 id="声明-3"><a href="#声明-3" class="headerlink" title="声明"></a>声明</h3><ul><li><strong>do表达式</strong>：封装块级作用域的操作，返回内部最后执行表达式的值(<code>do{}</code>)</li><li><strong>throw表达式</strong>：直接使用<code>throw new Error()</code>，无需<code>()</code>或<code>{}</code>包括</li><li><strong>!#命令</strong>：指定脚本执行器(写在文件首行)</li></ul><h3 id="数值扩展-3"><a href="#数值扩展-3" class="headerlink" title="数值扩展"></a>数值扩展</h3><ul><li><strong>数值分隔符(_)</strong>：使用<code>_</code>作为千分位分隔符(增加数值的可读性)</li><li><strong>Math.signbit()</strong>：返回数值符号是否设置</li></ul><h3 id="函数扩展-3"><a href="#函数扩展-3" class="headerlink" title="函数扩展"></a>函数扩展</h3><ul><li><strong>函数部分执行</strong>：复用函数功能(<code>?</code>表示单个参数占位符，<code>...</code>表示多个参数占位符)</li><li><strong>管道操作符(|&gt;)</strong>：把左边表达式的值传入右边的函数进行求值(<code>f(x)</code> =&gt; <code>x |&gt; f</code>)</li><li><strong>绑定运算符(::)</strong>：函数绑定(左边是对象右边是函数，取代<code>bind</code>、<code>apply</code>、<code>call</code>调用)<ul><li>bind：<code>bar.bind(foo)</code> =&gt; <code>foo::bar</code></li><li>apply：<code>bar.apply(foo, arguments)</code> =&gt; <code>foo::bar(...arguments)</code></li></ul></li></ul><h3 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h3><ul><li>定义：提供<code>沙箱功能</code>，允许隔离代码，防止被隔离的代码拿到全局对象</li><li>声明：<code>new Realm().global</code></li></ul><h3 id="Class-1"><a href="#Class-1" class="headerlink" title="Class"></a>Class</h3><ul><li><strong>静态属性</strong>：使用<code>static</code>定义属性，该属性<code>不会被实例继承</code>，只能通过类来调用</li><li><strong>私有属性</strong>：使用<code>#</code>定义属性，该属性只能在类内部访问</li><li><strong>私有方法</strong>：使用<code>#</code>定义方法，该方法只能在类内部访问</li><li><strong>装饰器</strong>：使用<code>@</code>注释或修改类和类方法</li></ul><h3 id="Module-2"><a href="#Module-2" class="headerlink" title="Module"></a>Module</h3><ul><li><strong>import.meta</strong>：返回脚本元信息</li></ul><h3 id="Promise-3"><a href="#Promise-3" class="headerlink" title="Promise"></a>Promise</h3><ul><li><strong>Promise.any()</strong>：将多个实例包装成一个新实例，返回全部实例状态变更后的结果数组(齐变更再返回)<ul><li>入参：具有<code>Iterator接口</code>的数据结构</li><li>成功：其中一个实例状态变成<code>fulfilled</code>，最终状态就会变成<code>fulfilled</code></li><li>失败：只有全部实例状态变成<code>rejected</code>，最终状态才会变成<code>rejected</code></li></ul></li><li><strong>Promise.try()</strong>：不想区分是否同步异步函数，包装函数为实例，使用<code>then()</code>指定下一步流程，使用<code>catch()</code>捕获错误</li></ul><h3 id="Async-2"><a href="#Async-2" class="headerlink" title="Async"></a>Async</h3><ul><li><strong>顶层Await</strong>：允许在模块的顶层独立使用<code>await命令</code>(借用<code>await</code>解决模块异步加载的问题)</li></ul><p><a href="https://juejin.im/post/6844903959283367950" target="_blank" rel="noopener">原文链接</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IntersectionObserver原理分析</title>
      <link href="/Chrome%E6%BA%90%E7%A0%81-IntersectionObserver/"/>
      <url>/Chrome%E6%BA%90%E7%A0%81-IntersectionObserver/</url>
      
        <content type="html"><![CDATA[<p>在介绍<code>IntersectionObserver</code>的时候曾提到过这个接口目前使用的最大问题就是浏览器的兼容性问题。所以，我们平时在使用的时候切记不要忘记判断这个API在我们的宿主环境中是否存在。如果不存在，我们可以通过引入其<code>polyfill</code>来作部分功能的兼容。</p><p><code>IntersectionObserver-polyfill</code>是<code>w3c</code>官方创建的<a href="https://github.com/w3c/IntersectionObserver" target="_blank" rel="noopener">https://github.com/w3c/IntersectionObserver</a>。我们可以在浏览器不支持<code>IntersectionObserver</code>的情况下引入它。当然，你也可以直接引入它，其内部也只会在浏览器不支持其的情况下进行<code>polyfill</code>。</p><a id="more"></a><p><code>IntersectionObserver</code>的使用前面做了简单的叙述</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="built_in">document</span>.getElementById(<span class="string">'target'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> IntersectionObserver(<span class="function">(<span class="params">entries</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [entry] = entries</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (entry.isIntersecting) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'元素曝光了'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">observer.observe(target)</span><br></pre></td></tr></table></figure><p>下面我们就从其<code>polyfill</code>的源码中来了解其基本原理</p><h2 id="IntersectionObserver"><a href="#IntersectionObserver" class="headerlink" title="IntersectionObserver"></a>IntersectionObserver</h2><div class="story post-story"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IntersectionObserver</span>(<span class="params">callback, opt_options</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> options = opt_options || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> callback != <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'callback must be a function'</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (options.root &amp;&amp; options.root.nodeType != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'root must be an Element'</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Binds and throttles `this._checkForIntersections`.</span></span><br><span class="line">      <span class="keyword">this</span>._checkForIntersections = throttle(</span><br><span class="line">          <span class="keyword">this</span>._checkForIntersections.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.THROTTLE_TIMEOUT);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Private properties.</span></span><br><span class="line">      <span class="keyword">this</span>._callback = callback;</span><br><span class="line">      <span class="keyword">this</span>._observationTargets = [];</span><br><span class="line">      <span class="keyword">this</span>._queuedEntries = [];</span><br><span class="line">      <span class="keyword">this</span>._rootMarginValues = <span class="keyword">this</span>._parseRootMargin(options.rootMargin);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Public properties.</span></span><br><span class="line">      <span class="keyword">this</span>.thresholds = <span class="keyword">this</span>._initThresholds(options.threshold);</span><br><span class="line">      <span class="keyword">this</span>.root = options.root || <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">this</span>.rootMargin = <span class="keyword">this</span>._rootMarginValues.map(<span class="function"><span class="keyword">function</span>(<span class="params">margin</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> margin.value + margin.unit;</span><br><span class="line">      &#125;).join(<span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>IntersectionObserver</code>是一个构造函数。当我们创建其实例的时候，可以传递两个参数。第一个参数必须是一个函数，否则会抛出一个错误。第二个参数是一个可选的对象，唯一的要求就是我们指定的<code>root</code>属性的值必须是一个<code>Element</code>。构造函数会在创建实例的时候添加很多私有属性。有些属性后面用到的时候会讲解，这里我们先看几个用来保存我们传递的选项的属性。</p><p>在创建<code>IntersectionObserver</code>实例的时候，我们可以在第二个参数对象中传入以下几个属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  root: Element,</span><br><span class="line">  rootMargin: string,</span><br><span class="line">  threshold: number | number[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造函数中首先会调用私有方法解析我们传入的<code>rootMargin</code>属性，下面是这个方法的基本实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">IntersectionObserver.prototype._parseRootMargin = <span class="function"><span class="keyword">function</span>(<span class="params">opt_rootMargin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> marginString = opt_rootMargin || <span class="string">'0px'</span>;</span><br><span class="line">  <span class="keyword">var</span> margins = marginString.split(<span class="regexp">/\s+/</span>).map(<span class="function"><span class="keyword">function</span>(<span class="params">margin</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> parts = <span class="regexp">/^(-?\d*\.?\d+)(px|%)$/</span>.exec(margin);</span><br><span class="line">    <span class="keyword">if</span> (!parts) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'rootMargin must be specified in pixels or percent'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">value</span>: <span class="built_in">parseFloat</span>(parts[<span class="number">1</span>]), <span class="attr">unit</span>: parts[<span class="number">2</span>]&#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Handles shorthand.</span></span><br><span class="line">  margins[<span class="number">1</span>] = margins[<span class="number">1</span>] || margins[<span class="number">0</span>];</span><br><span class="line">  margins[<span class="number">2</span>] = margins[<span class="number">2</span>] || margins[<span class="number">0</span>];</span><br><span class="line">  margins[<span class="number">3</span>] = margins[<span class="number">3</span>] || margins[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> margins;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法就是将我们传入的<code>rootMargin</code>解析成数组，这个数组包含四个元素代表的分别是<code>上，右，下，左</code>边距的值和单位。<code>rootMargin</code>设置的时候和<code>css margin</code>设置的方式一样，可以传入<code>1,2,3,4</code>个值。比如</p><pre><code>rootMargin: &apos;10px&apos; --&gt; _parseRootMargin(rootMargin) --&gt; [{value: 10, unit: &apos;px&apos;},{value: 10, unit: &apos;px&apos;},{value: 10, unit: &apos;px&apos;},{value: 10, unit: &apos;px&apos;}]// 传入2，3，4个值的解析规则和css margin的解析规则其实是一样的</code></pre><p>解析完<code>rootMargin</code>后，私有属性<code>this._rootMarginValues</code>就是如下形式</p><pre><code>[  {value: 10, unit: &apos;px&apos;},  {value: 10, unit: &apos;px&apos;},  {value: 10, unit: &apos;px&apos;},  {value: 10, unit: &apos;px&apos;}]</code></pre><p>后面又将其转化为<code>this.rootMargin</code>的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.rootMargin = <span class="keyword">this</span>._rootMarginValues.map(<span class="function"><span class="keyword">function</span>(<span class="params">margin</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> margin.value + margin.unit;</span><br><span class="line">  &#125;).join(<span class="string">' '</span>);</span><br></pre></td></tr></table></figure><p>所以，无论我们传入的<code>rootMargin</code>是什么样的形式，构造函数执行结束后都会变成<code>10px 10px 10px 10px</code>的形式。</p><p>在构造函数中还有一个步骤是初始化我们传入的<code>threshold</code>。我们知道，<code>threshold</code>可以是一个数字，也可以是由数字组成的数组。构造函数执行的时候，会统一将其转换成数组的形式并保存在<code>this.thresholds</code>属性中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.thresholds = <span class="keyword">this</span>._initThresholds(options.threshold);</span><br></pre></td></tr></table></figure><p>下面是解析<code>threshold</code>的<code>_initThreshold</code>方法的实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IntersectionObserver.prototype._initThresholds = <span class="function"><span class="keyword">function</span>(<span class="params">opt_threshold</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> threshold = opt_threshold || [<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(threshold)) threshold = [threshold];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> threshold.sort().filter(<span class="function"><span class="keyword">function</span>(<span class="params">t, i, a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> t != <span class="string">'number'</span> || <span class="built_in">isNaN</span>(t) || t &lt; <span class="number">0</span> || t &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'threshold must be a number between 0 and 1 inclusively'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t !== a[i - <span class="number">1</span>];</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法接收我们传入的<code>options.threshold</code>选项的值作为参数，如果我们没有传入这个值，则默认为0。如果我们传入的不是一个数组，就将其转化为数组。下面的<code>filter</code>是对一个数组进行去重的方法，即如果我们对<code>threshold</code>传入了重复的值，只会取一个。而且<code>threshold</code>中的每一个值都必须是数字，并且在<code>[0, 1]</code>之间。所以，<code>this.threshold</code>最终保存的值是如下形式</p><pre><code>this.threshold = [0]this.threshold = [0.25, 0.5, 1]</code></pre><p>上面就是<code>IntersectionObserver</code>构造函数大致的执行过程，实例创建好后，我们会调用<code>observe</code>方法监测元素。下面我们看一下<code>observe</code>方法的具体实现</p><h3 id="observe"><a href="#observe" class="headerlink" title="observe"></a>observe</h3><p><code>observe</code>方法定义在<code>IntersectionObserver.prototype</code>上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">IntersectionObserver.prototype.observe = <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> isTargetAlreadyObserved = <span class="keyword">this</span>._observationTargets.some(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item.element == target;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isTargetAlreadyObserved) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(target &amp;&amp; target.nodeType == <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'target must be an Element'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>._registerInstance();</span><br><span class="line">  <span class="keyword">this</span>._observationTargets.push(&#123;<span class="attr">element</span>: target, <span class="attr">entry</span>: <span class="literal">null</span>&#125;);</span><br><span class="line">  <span class="keyword">this</span>._monitorIntersections();</span><br><span class="line">  <span class="keyword">this</span>._checkForIntersections();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收的参数就是我们需要监测的dom元素。首先会遍历<code>this._observationTargets</code>，这个属性是一个数组，它也是在初始化<code>IntersectionObserver</code>的时候创建的</p><pre><code>this._observationTargets = [];</code></pre><p>对这个属性的遍历，其实就是为了判断当前的<code>observer</code>是否已经通过<code>observe</code>方法监测过<code>target</code>元素。如果已经监测过，就直接<code>return</code>，防止同一个<code>observer</code>实例对同一个<code>target</code>元素进行多次监测。</p><p>如果没有监测过<code>target</code>元素，这里同样会对<code>target</code>的类型进行判断。如果不是一个dom结点，同样会抛出一个错误。</p><p>接着，会调用<code>this._registerInstance</code>方法。这个方法的主要作用就是将当前的<code>observer</code>实例添加到全局数组<code>registry</code>中，主要是为了防止我们的<code>observer</code>实例被垃圾回收进行清除</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IntersectionObserver.prototype._registerInstance = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (registry.indexOf(<span class="keyword">this</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    registry.push(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，将我们<code>target</code>元素保存在<code>this._observationTargets</code>中。从上面代码中可以看到，<code>this._observationTargets</code>并不只是保存<code>target</code>元素。它会将<code>target</code>元素作为一个对象的<code>element</code>属性的值进行保存，同时这个对象还有一个<code>entry</code>属性。这个属性初始的时候是一个<code>null</code>，后续是<code>IntersectionObserverEntry</code>的一个实例对象。</p><p>之后调用<code>this._monitorIntersections</code>方法，这个方法后面我们会说。它的作用主要就是采用什么样的方式来检测<code>target</code>的状态。</p><p>最后调用<code>this._checkForIntersections</code>方法，这个方法同样会在后面讲解。这里它主要就是对<code>target</code>元素的状态进行一次初始的判断。如果<code>target</code>元素在初始的时候已经满足了和<code>root</code>元素的交集的状态，在调用这个方法的时候就会触发我们的回调函数。</p><h3 id="monitorIntersections"><a href="#monitorIntersections" class="headerlink" title="_monitorIntersections"></a>_monitorIntersections</h3><p>调用<code>observe</code>方法之后，我们就能够监测<code>target</code>元素的状态了。对<code>target</code>元素状态的监测，就是通过调用上面我们所提到的<code>this._monitorIntersections</code>方法。这里我们来看一下这个方法是怎么实现对元素的监测的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">IntersectionObserver.prototype._monitorIntersections = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>._monitoringIntersections) &#123;</span><br><span class="line">    <span class="keyword">this</span>._monitoringIntersections = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If a poll interval is set, use polling instead of listening to</span></span><br><span class="line">    <span class="comment">// resize and scroll events or DOM mutations.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.POLL_INTERVAL) &#123;</span><br><span class="line">      <span class="keyword">this</span>._monitoringInterval = setInterval(</span><br><span class="line">          <span class="keyword">this</span>._checkForIntersections, <span class="keyword">this</span>.POLL_INTERVAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      addEvent(<span class="built_in">window</span>, <span class="string">'resize'</span>, <span class="keyword">this</span>._checkForIntersections, <span class="literal">true</span>);</span><br><span class="line">      addEvent(<span class="built_in">document</span>, <span class="string">'scroll'</span>, <span class="keyword">this</span>._checkForIntersections, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.USE_MUTATION_OBSERVER &amp;&amp; <span class="string">'MutationObserver'</span> <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>._domObserver = <span class="keyword">new</span> MutationObserver(<span class="keyword">this</span>._checkForIntersections);</span><br><span class="line">        <span class="keyword">this</span>._domObserver.observe(<span class="built_in">document</span>, &#123;</span><br><span class="line">          attributes: <span class="literal">true</span>,</span><br><span class="line">          childList: <span class="literal">true</span>,</span><br><span class="line">          characterData: <span class="literal">true</span>,</span><br><span class="line">          subtree: <span class="literal">true</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法提供了两种方式用来监测元素状态的变化。第一种很简单，也很粗暴 – <code>polling</code>。这种方式默认是关闭的</p><pre><code>IntersectionObserver.prototype.POLL_INTERVAL = null;</code></pre><p>如果你想使用<code>polling</code>的方式监测元素的状态，则需要在创建<code>IntersectionObserver</code>实例之后，调用<code>observe</code>方法之前设置<code>observer.POLL_INTERVAL</code>属性，比如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> IntersectionObserver(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line">observer.POLL_INTERVAL = <span class="number">300</span></span><br><span class="line"></span><br><span class="line">observer.observe(target)</span><br></pre></td></tr></table></figure><p>如果按照上面代码的设置，浏览器就会开启一个定时器，每300毫秒判断一下元素的状态</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>._monitoringInterval = setInterval(</span><br><span class="line">          <span class="keyword">this</span>._checkForIntersections, <span class="keyword">this</span>.POLL_INTERVAL);</span><br></pre></td></tr></table></figure><p>但是，这种方式不推荐；所以在<code>polyfill</code>的源码中默认将这种方式关闭，采用更高效的事件监听的方式来监测元素状态的变化。首先需要监听<code>window</code>的<code>resize</code>和<code>document</code>的<code>scroll</code>事件。监听这两种事件能够满足大多数对元素状态判断的情况。如果一个元素自身的属性没有变化，当窗口滚动或者大小改变的时候都会影响元素和”视窗”的交集。但是，在某些业务场景下这两种事件是无法监测到元素状态的变化的。比如选项卡切换，元素自身的显示和隐藏等。对于这种情况，<code>polyfill</code>中同样采用一种粗暴的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.USE_MUTATION_OBSERVER &amp;&amp; <span class="string">'MutationObserver'</span> <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">  <span class="keyword">this</span>._domObserver = <span class="keyword">new</span> MutationObserver(<span class="keyword">this</span>._checkForIntersections);</span><br><span class="line">  <span class="keyword">this</span>._domObserver.observe(<span class="built_in">document</span>, &#123;</span><br><span class="line">    attributes: <span class="literal">true</span>,</span><br><span class="line">    childList: <span class="literal">true</span>,</span><br><span class="line">    characterData: <span class="literal">true</span>,</span><br><span class="line">    subtree: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>MutationObserver</code>接口监测<code>document</code>元素下所有节点的<code>attributes</code>，<code>childList</code>和<code>characterData</code>的变化。每当有子节点状态变化的时候都会去检测<code>target</code>元素和<code>root</code>元素的交集状态。这种方式很粗暴，但是某些业务场景下我们也不得不这样做。</p><p>上面监测元素所有的方式中，其回调函数都是<code>this._checkForIntersections</code>方法。这个方法在上面也提到过，在调用<code>observe</code>方法的时候同样也会调用这个方法。这个方法到底做了什么，下面就详细的看一下。</p><h3 id="checkForIntersections"><a href="#checkForIntersections" class="headerlink" title="_checkForIntersections"></a>_checkForIntersections</h3><p>在详细讲解这个方法之前，先来简单的总结一下这个方法会在什么样的条件下被调用</p><ul><li>调用<code>observer.observe(target)</code>方法的时候</li><li>采用轮询的方式监测元素，作为<code>setInterval</code>回调函数</li><li>采用事件的方式监测元素，作为<code>document</code>的<code>scroll</code>事件的回调函数</li><li>采用事件的方式监测元素，作为<code>window</code>的<code>resize</code>事件的回调函数</li><li>采用事件的方式监测元素，作为<code>MutationObserver</code>的回调函数</li></ul><p>总之，在<code>this._checkForIntersections</code>方法被调用的时候，主要就是为了判断<code>target</code>元素和<code>root</code>元素的交集状态有没有发生变化，如果交集状态发生了变化，就会触发我们的回调函数。下面就详细的看一下这个方法到底做了哪些事情</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">IntersectionObserver.prototype._checkForIntersections = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> rootIsInDom = <span class="keyword">this</span>._rootIsInDom();</span><br><span class="line">  <span class="keyword">var</span> rootRect = rootIsInDom ? <span class="keyword">this</span>._getRootRect() : getEmptyRect();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>._observationTargets.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> target = item.element;</span><br><span class="line">    <span class="keyword">var</span> targetRect = getBoundingClientRect(target);</span><br><span class="line">    <span class="keyword">var</span> rootContainsTarget = <span class="keyword">this</span>._rootContainsTarget(target);</span><br><span class="line">    <span class="keyword">var</span> oldEntry = item.entry;</span><br><span class="line">    <span class="keyword">var</span> intersectionRect = rootIsInDom &amp;&amp; rootContainsTarget &amp;&amp;</span><br><span class="line">        <span class="keyword">this</span>._computeTargetAndRootIntersection(target, rootRect);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> newEntry = item.entry = <span class="keyword">new</span> IntersectionObserverEntry(&#123;</span><br><span class="line">      time: now(),</span><br><span class="line">      target: target,</span><br><span class="line">      boundingClientRect: targetRect,</span><br><span class="line">      rootBounds: rootRect,</span><br><span class="line">      intersectionRect: intersectionRect</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!oldEntry) &#123;</span><br><span class="line">      <span class="keyword">this</span>._queuedEntries.push(newEntry);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rootIsInDom &amp;&amp; rootContainsTarget) &#123;</span><br><span class="line">      <span class="comment">// If the new entry intersection ratio has crossed any of the</span></span><br><span class="line">      <span class="comment">// thresholds, add a new entry.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._hasCrossedThreshold(oldEntry, newEntry)) &#123;</span><br><span class="line">        <span class="keyword">this</span>._queuedEntries.push(newEntry);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// If the root is not in the DOM or target is not contained within</span></span><br><span class="line">      <span class="comment">// root but the previous entry for this target had an intersection,</span></span><br><span class="line">      <span class="comment">// add a new record indicating removal.</span></span><br><span class="line">      <span class="keyword">if</span> (oldEntry &amp;&amp; oldEntry.isIntersecting) &#123;</span><br><span class="line">        <span class="keyword">this</span>._queuedEntries.push(newEntry);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._queuedEntries.length) &#123;</span><br><span class="line">    <span class="keyword">this</span>._callback(<span class="keyword">this</span>.takeRecords(), <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会判断<code>root</code>元素是不是在<code>dom</code>结构中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">IntersectionObserver.prototype._rootIsInDom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !<span class="keyword">this</span>.root || containsDeep(<span class="built_in">document</span>, <span class="keyword">this</span>.root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">containsDeep</span>(<span class="params">parent, child</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> node = child;</span><br><span class="line">  <span class="keyword">while</span> (node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == parent) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    node = getParentNode(node);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getParentNode</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> parent = node.parentNode;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (parent &amp;&amp; parent.nodeType == <span class="number">11</span> &amp;&amp; parent.host) &#123;</span><br><span class="line">    <span class="comment">// If the parent is a shadow root, return the host element.</span></span><br><span class="line">    <span class="keyword">return</span> parent.host;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (parent &amp;&amp; parent.assignedSlot) &#123;</span><br><span class="line">    <span class="comment">// If the parent is distributed in a &lt;slot&gt;, return the parent of a slot.</span></span><br><span class="line">    <span class="keyword">return</span> parent.assignedSlot.parentNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码主要就是用来判断<code>root</code>元素是不是在<code>dom</code>结构中。所以这就要求我们传入的<code>options.root</code>选项一定要是<code>target</code>的祖先元素。</p><p>接着会获取<code>root</code>元素的区域数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">IntersectionObserver.prototype._getRootRect = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> rootRect;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.root) &#123;</span><br><span class="line">    rootRect = getBoundingClientRect(<span class="keyword">this</span>.root);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Use &lt;html&gt;/&lt;body&gt; instead of window since scroll bars affect size.</span></span><br><span class="line">    <span class="keyword">var</span> html = <span class="built_in">document</span>.documentElement;</span><br><span class="line">    <span class="keyword">var</span> body = <span class="built_in">document</span>.body;</span><br><span class="line">    rootRect = &#123;</span><br><span class="line">      top: <span class="number">0</span>,</span><br><span class="line">      left: <span class="number">0</span>,</span><br><span class="line">      right: html.clientWidth || body.clientWidth,</span><br><span class="line">      width: html.clientWidth || body.clientWidth,</span><br><span class="line">      bottom: html.clientHeight || body.clientHeight,</span><br><span class="line">      height: html.clientHeight || body.clientHeight</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._expandRectByRootMargin(rootRect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们自己传递了<code>root</code>元素，就会通过<code>root.getBoundingClientRect</code>方法获取到<code>root</code>的区域数据。如果采用默认的<code>document</code>元素，则会使用视窗的区域数据。后面又调用了<code>_expandRectByRootMargin</code>方法，这个方法主要是用来将我们传入的<code>rootMargin</code>和<code>rootRect</code>数据结合得出新的<code>newRootRect</code>数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">IntersectionObserver.prototype._expandRectByRootMargin = <span class="function"><span class="keyword">function</span>(<span class="params">rect</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> margins = <span class="keyword">this</span>._rootMarginValues.map(<span class="function"><span class="keyword">function</span>(<span class="params">margin, i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> margin.unit == <span class="string">'px'</span> ? margin.value :</span><br><span class="line">        margin.value * (i % <span class="number">2</span> ? rect.width : rect.height) / <span class="number">100</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> newRect = &#123;</span><br><span class="line">    top: rect.top - margins[<span class="number">0</span>],</span><br><span class="line">    right: rect.right + margins[<span class="number">1</span>],</span><br><span class="line">    bottom: rect.bottom + margins[<span class="number">2</span>],</span><br><span class="line">    left: rect.left - margins[<span class="number">3</span>]</span><br><span class="line">  &#125;;</span><br><span class="line">  newRect.width = newRect.right - newRect.left;</span><br><span class="line">  newRect.height = newRect.bottom - newRect.top;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newRect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_expandRectByRootMargin</code>方法很好理解，就是将<code>rootRect</code>和<code>rootMargin</code>结合计算出新的<code>rootRect</code>区域的大小。</p><p>在<code>root</code>的区域确定后，会遍历<code>this._observationTargets</code>属性。这个属性上面我们也提过，它用来保存被<code>observer</code>所监测的所有的<code>target</code>元素。遍历的过程先不看，后面还有一小段代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>._queuedEntries.length) &#123;</span><br><span class="line">  <span class="keyword">this</span>._callback(<span class="keyword">this</span>.takeRecords(), <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>this._queuedEntries</code>这个属性一个数组，其中每一个元素都是<code>IntersectionObserverEntry</code>实例对象。只有当这个属性的长度大于0的时候，才会触发回调函数。在讲解<code>IntersectionObserver</code>方法的基本使用的时候我们曾经说过，<code>callback</code>的第一个参数是由<code>IntersectionObserverEntry</code>实例组成的数组，那这里是通过<code>this.takeRecords()</code>方法获取的，这个方法做了什么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IntersectionObserver.prototype.takeRecords = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> records = <span class="keyword">this</span>._queuedEntries.slice();</span><br><span class="line">  <span class="keyword">this</span>._queuedEntries = [];</span><br><span class="line">  <span class="keyword">return</span> records;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法很简单，就是通过<code>slice</code>方法对<code>this._queuedEntries</code>数据做个备份，然后清空<code>this._queuedEntries</code>。这表示在这个时间段内和<code>root</code>发生交集变化的<code>target</code>会在调用<code>this._checkForIntersections</code>后交给我们的<code>callback</code>统一处理。也就是说，每个时间段都是重新收集发生变化的<code>target</code>的。</p><p>下面我们来看一下对<code>this._observationTargets</code>的遍历会做哪些事情？估计大家也能想到，它主要就是用来收集在这个阶段中和<code>root</code>元素发生交集变化的<code>target</code>元素，并将新的交集状态(<code>IntersectionObserverEntry</code>实例对象) 保存在<code>this._queuedEntries</code>队列中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>._observationTargets.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> target = item.element;</span><br><span class="line">  <span class="keyword">var</span> targetRect = getBoundingClientRect(target);</span><br><span class="line">  <span class="keyword">var</span> rootContainsTarget = <span class="keyword">this</span>._rootContainsTarget(target);</span><br><span class="line">  <span class="keyword">var</span> oldEntry = item.entry;</span><br><span class="line">  <span class="keyword">var</span> intersectionRect = rootIsInDom &amp;&amp; rootContainsTarget &amp;&amp;</span><br><span class="line">      <span class="keyword">this</span>._computeTargetAndRootIntersection(target, rootRect);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> newEntry = item.entry = <span class="keyword">new</span> IntersectionObserverEntry(&#123;</span><br><span class="line">    time: now(),</span><br><span class="line">    target: target,</span><br><span class="line">    boundingClientRect: targetRect,</span><br><span class="line">    rootBounds: rootRect,</span><br><span class="line">    intersectionRect: intersectionRect</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!oldEntry) &#123;</span><br><span class="line">    <span class="keyword">this</span>._queuedEntries.push(newEntry);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rootIsInDom &amp;&amp; rootContainsTarget) &#123;</span><br><span class="line">    <span class="comment">// If the new entry intersection ratio has crossed any of the</span></span><br><span class="line">    <span class="comment">// thresholds, add a new entry.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._hasCrossedThreshold(oldEntry, newEntry)) &#123;</span><br><span class="line">      <span class="keyword">this</span>._queuedEntries.push(newEntry);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// If the root is not in the DOM or target is not contained within</span></span><br><span class="line">    <span class="comment">// root but the previous entry for this target had an intersection,</span></span><br><span class="line">    <span class="comment">// add a new record indicating removal.</span></span><br><span class="line">    <span class="keyword">if</span> (oldEntry &amp;&amp; oldEntry.isIntersecting) &#123;</span><br><span class="line">      <span class="keyword">this</span>._queuedEntries.push(newEntry);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>在遍历的过程中，首先获取每个<code>target</code>元素的区域数据，然后调用<code>this._rootContainsTarget</code>方法，这个方法就是用来判断<code>root</code>元素是不是<code>target</code>元素的祖先元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntersectionObserver.prototype._rootContainsTarget = <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> containsDeep(<span class="keyword">this</span>.root || <span class="built_in">document</span>, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，我们先看一下这段代码做了啥，后面再看看<code>item.entry</code>是什么</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intersectionRect = rootIsInDom &amp;&amp; rootContainsTarget &amp;&amp;</span><br><span class="line">      <span class="keyword">this</span>._computeTargetAndRootIntersection(target, rootRect);</span><br></pre></td></tr></table></figure><p>如果<code>rootIsInDom</code>为真（表示root元素在dom结构中）且<code>rootContainsTarget</code>为真（表示<code>root</code>是<code>target</code>元素的祖先元素），就调用<code>this._computeTargetAndRootIntersection</code>方法。这个方法从名称上应该都能理解它的作用：计算<code>target</code>元素和<code>root</code>元素的相交区域。其实就是用来计算相交面积<code>intersectionRect</code>的大小。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">IntersectionObserver.prototype._computeTargetAndRootIntersection =</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">target, rootRect</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the element isn't displayed, an intersection can't happen.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.getComputedStyle(target).display == <span class="string">'none'</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> targetRect = getBoundingClientRect(target);</span><br><span class="line">  <span class="keyword">var</span> intersectionRect = targetRect;</span><br><span class="line">  <span class="keyword">var</span> parent = getParentNode(target);</span><br><span class="line">  <span class="keyword">var</span> atRoot = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!atRoot) &#123;</span><br><span class="line">    <span class="keyword">var</span> parentRect = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">var</span> parentComputedStyle = parent.nodeType == <span class="number">1</span> ?</span><br><span class="line">        <span class="built_in">window</span>.getComputedStyle(parent) : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the parent isn't displayed, an intersection can't happen.</span></span><br><span class="line">    <span class="keyword">if</span> (parentComputedStyle.display == <span class="string">'none'</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="keyword">this</span>.root || parent == <span class="built_in">document</span>) &#123;</span><br><span class="line">      atRoot = <span class="literal">true</span>;</span><br><span class="line">      parentRect = rootRect;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// If the element has a non-visible overflow, and it's not the &lt;body&gt;</span></span><br><span class="line">      <span class="comment">// or &lt;html&gt; element, update the intersection rect.</span></span><br><span class="line">      <span class="comment">// Note: &lt;body&gt; and &lt;html&gt; cannot be clipped to a rect that's not also</span></span><br><span class="line">      <span class="comment">// the document rect, so no need to compute a new intersection.</span></span><br><span class="line">      <span class="keyword">if</span> (parent != <span class="built_in">document</span>.body &amp;&amp;</span><br><span class="line">          parent != <span class="built_in">document</span>.documentElement &amp;&amp;</span><br><span class="line">          parentComputedStyle.overflow != <span class="string">'visible'</span>) &#123;</span><br><span class="line">        parentRect = getBoundingClientRect(parent);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If either of the above conditionals set a new parentRect,</span></span><br><span class="line">    <span class="comment">// calculate new intersection data.</span></span><br><span class="line">    <span class="keyword">if</span> (parentRect) &#123;</span><br><span class="line">      intersectionRect = computeRectIntersection(parentRect, intersectionRect);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!intersectionRect) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    parent = getParentNode(parent);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> intersectionRect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法接收的两个参数分别是<code>target</code>元素和<code>root</code>元素区域的大小。如果元素是隐藏的，是不可能存在相交的，所以直接返回就行了。接着会获取<code>target</code>区域数据和其parentNode元素，并设置一个标志位用来表示下面的while循环是否循环到了<code>this.root</code>或者是<code>document</code>。在while循环中先会判断<code>target.parentNode</code>是否显示，如果其隐藏的话，<code>target</code>和<code>root</code>元素同样是不可能存在交集的。这里我们先假设我们采用默认的<code>root</code>即<code>document</code>，而且<code>parentNode</code>就是<code>document</code>，那么循环将会进入<code>if</code>分支，并将<code>parentRect</code>设置<code>rootRect</code>的大小，atRoot设置为<code>true</code>。接着会执行如下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (parentRect) &#123;</span><br><span class="line">  intersectionRect = computeRectIntersection(parentRect, intersectionRect);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!intersectionRect) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">parent = getParentNode(parent);</span><br></pre></td></tr></table></figure><p>在这个分支中会执行<code>computeRectIntersection</code>函数，这个函数才是真正的计算<code>target</code>和<code>root</code>相交区域的大小</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">computeRectIntersection</span>(<span class="params">rect1, rect2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> top = <span class="built_in">Math</span>.max(rect1.top, rect2.top);</span><br><span class="line">  <span class="keyword">var</span> bottom = <span class="built_in">Math</span>.min(rect1.bottom, rect2.bottom);</span><br><span class="line">  <span class="keyword">var</span> left = <span class="built_in">Math</span>.max(rect1.left, rect2.left);</span><br><span class="line">  <span class="keyword">var</span> right = <span class="built_in">Math</span>.min(rect1.right, rect2.right);</span><br><span class="line">  <span class="keyword">var</span> width = right - left;</span><br><span class="line">  <span class="keyword">var</span> height = bottom - top;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (width &gt;= <span class="number">0</span> &amp;&amp; height &gt;= <span class="number">0</span>) &amp;&amp; &#123;</span><br><span class="line">    top: top,</span><br><span class="line">    bottom: bottom,</span><br><span class="line">    left: left,</span><br><span class="line">    right: right,</span><br><span class="line">    width: width,</span><br><span class="line">    height: height</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将这段代码用下面的图片来表示，就能看出它到底在做啥</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201014163228.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201014163228.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><p>上图中红色的线段就是相交区域的<code>上，下，左，右</code>的长度。所以，相交区域的大小就是图中橙色实心部分的大小。如果<code>target</code>位于<code>root</code>的区域外，则表示<code>width</code>或者<code>height</code>至少有一个<code>&lt;=0</code>。那么计算出来的相交区域的大小也就为<code>0</code>。</p><p>假设<code>target.parentNode</code>不是<code>document</code>，那么while循环会执行<code>else</code>分支。其中执行<code>else</code>分支有一个条件<code>parentComputedStyle.overflow != &#39;visible&#39;</code>。如果<code>parentComputedStyle.overflow</code>的值为<code>visible</code>，那么<code>target</code>和<code>root</code>最大的交叉面积就是<code>target</code>的大小，如果<code>parentComputedStyle.overflow</code>的值不为<code>visible</code>，那么<code>target</code>和<code>root</code>最大的交叉面积是多少呢？最大的交叉面积就是<code>target</code>最大能显示出来的面积的大小。</p><p>交叉面积计算出来后，我们接着分析下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oldEntry = item.entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newEntry = item.entry = <span class="keyword">new</span> IntersectionObserverEntry(&#123;</span><br><span class="line">  time: now(),</span><br><span class="line">  target: target,</span><br><span class="line">  boundingClientRect: targetRect,</span><br><span class="line">  rootBounds: rootRect,</span><br><span class="line">  intersectionRect: intersectionRect</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>先看对<code>newEntry</code>的赋值。我们上面说过<code>this._observationTargets</code>保存的数据的结构为<code>{element: target, entry: null}</code>这种类型。从这里就能看到<code>entry</code>就是通过<code>new IntersectionObserverEntry</code>就是创建的实例对象。那<code>oldEntry</code>是什么呢？<code>oldEntry</code>就是上一次调用<code>this._checkForIntersections</code>方法的时候所创建的<code>entry</code>对象。这里为什么取新老两次<code>entry</code>对象，后面我们会分析。这里我们先看一下<code>IntersectionObserverEntry</code>构造函数的执行流程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IntersectionObserverEntry</span>(<span class="params">entry</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.time = entry.time;</span><br><span class="line">  <span class="keyword">this</span>.target = entry.target;</span><br><span class="line">  <span class="keyword">this</span>.rootBounds = entry.rootBounds;</span><br><span class="line">  <span class="keyword">this</span>.boundingClientRect = entry.boundingClientRect;</span><br><span class="line">  <span class="keyword">this</span>.intersectionRect = entry.intersectionRect || getEmptyRect();</span><br><span class="line">  <span class="keyword">this</span>.isIntersecting = !!entry.intersectionRect;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Calculates the intersection ratio.</span></span><br><span class="line">  <span class="keyword">var</span> targetRect = <span class="keyword">this</span>.boundingClientRect;</span><br><span class="line">  <span class="keyword">var</span> targetArea = targetRect.width * targetRect.height;</span><br><span class="line">  <span class="keyword">var</span> intersectionRect = <span class="keyword">this</span>.intersectionRect;</span><br><span class="line">  <span class="keyword">var</span> intersectionArea = intersectionRect.width * intersectionRect.height;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sets intersection ratio.</span></span><br><span class="line">  <span class="keyword">if</span> (targetArea) &#123;</span><br><span class="line">    <span class="comment">// Round the intersection ratio to avoid floating point math issues:</span></span><br><span class="line">    <span class="comment">// https://github.com/w3c/IntersectionObserver/issues/324</span></span><br><span class="line">    <span class="keyword">this</span>.intersectionRatio = <span class="built_in">Number</span>((intersectionArea / targetArea).toFixed(<span class="number">4</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// If area is zero and is intersecting, sets to 1, otherwise to 0</span></span><br><span class="line">    <span class="keyword">this</span>.intersectionRatio = <span class="keyword">this</span>.isIntersecting ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>IntersectionObserverEntry</code>函数的执行流程十分简单，就是计算出其各个属性的值。其它的属性我们就不多说了，这里我们主要看以下三个属性值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.intersectionRect = entry.intersectionRect || getEmptyRect();</span><br><span class="line"><span class="keyword">this</span>.isIntersecting = !!entry.intersectionRect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (targetArea) &#123;</span><br><span class="line">    <span class="comment">// Round the intersection ratio to avoid floating point math issues:</span></span><br><span class="line">    <span class="comment">// https://github.com/w3c/IntersectionObserver/issues/324</span></span><br><span class="line">    <span class="keyword">this</span>.intersectionRatio = <span class="built_in">Number</span>((intersectionArea / targetArea).toFixed(<span class="number">4</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// If area is zero and is intersecting, sets to 1, otherwise to 0</span></span><br><span class="line">    <span class="keyword">this</span>.intersectionRatio = <span class="keyword">this</span>.isIntersecting ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>其中<code>this.intersectionRect</code>就是上面通过<code>this._computeTargetAndRootIntersection</code>方法计算出来的。<code>this.isIntersecting</code>的判定也十分简单，如果存在相交面积，就表示相交。不存在相交面积，就表示不想交。最后是相交比<code>this.intersectionRatio</code>的计算，正常情况下(target的width和height都不为0)就是<code>intersectionArea</code>和<code>target</code>区域面积的比值。</p><p>然后就会判断<code>oldEntry</code>是否存在，<code>oldEntry</code>在什么状态下不会存在？在初始调用，也就是调用<code>observer.observe</code>方法监测<code>target</code>元素的时候<code>item.entry</code>是不存在的。然后就会将<code>newEntry</code>添加到<code>this._queuedEntries</code>队列中，当执行到</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>._queuedEntries.length) &#123;</span><br><span class="line">  <span class="keyword">this</span>._callback(<span class="keyword">this</span>.takeRecords(), <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>的时候，就会调用我们传入的回调函数。</p><p>如果不是在初始状态下，在<code>rootIsInDom &amp;&amp; rootContainsTarget</code>为真的时候，会调用<code>this._hasCrossedThreshold</code>方法，那这个方法是干啥的？我们在介绍<code>IntersectionObserver</code>的时候曾经提到在创建<code>IntersectionObserver</code>实例的时候，我们传入一个选项，可以通过这个选项的<code>threshold</code>属性指定相交比达到什么样的条件才需要触发我们的回调函数。<code>this._hasCrossedThreshold</code>就是用来判断这种情况的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">IntersectionObserver.prototype._hasCrossedThreshold =</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">oldEntry, newEntry</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// To make comparing easier, an entry that has a ratio of 0</span></span><br><span class="line">  <span class="comment">// but does not actually intersect is given a value of -1</span></span><br><span class="line">  <span class="keyword">var</span> oldRatio = oldEntry &amp;&amp; oldEntry.isIntersecting ?</span><br><span class="line">      oldEntry.intersectionRatio || <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">var</span> newRatio = newEntry.isIntersecting ?</span><br><span class="line">      newEntry.intersectionRatio || <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ignore unchanged ratios</span></span><br><span class="line">  <span class="keyword">if</span> (oldRatio === newRatio) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.thresholds.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> threshold = <span class="keyword">this</span>.thresholds[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return true if an entry matches a threshold or if the new ratio</span></span><br><span class="line">    <span class="comment">// and the old ratio are on the opposite sides of a threshold.</span></span><br><span class="line">    <span class="keyword">if</span> (threshold == oldRatio || threshold == newRatio ||</span><br><span class="line">        threshold &lt; oldRatio !== threshold &lt; newRatio) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>_hasCrossedThreshold</code>代码中我们可以看到。如果<code>target</code>完全没有显示<code>oldRatio === newRatio === -1</code>，直接<code>return</code>。这种情况下是不会执行我们的回调函数的。如果<code>target</code>完全显示<code>oldRatio === newRatio === newEntry.intersectionRatio</code>，这种情况下也不会执行我们的回调函数。那什么时候才会执行我们的回调函数呢，从这段代码的<code>for</code>循环中我们可以总结出<strong>只有当threshold设置的值在oldRatio和newRatio之间的时候才会执行我们的回调</strong>。这里大家可以画图分析一下。</p><p>上面就是关于怎么监测<code>target</code>和执行回调函数时机的分析，下面我们看一下<code>unobserve</code>的过程</p><h3 id="unobserve"><a href="#unobserve" class="headerlink" title="unobserve"></a>unobserve</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IntersectionObserver.prototype.unobserve = <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._observationTargets =</span><br><span class="line">      <span class="keyword">this</span>._observationTargets.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> item.element != target;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>._observationTargets.length) &#123;</span><br><span class="line">    <span class="keyword">this</span>._unmonitorIntersections();</span><br><span class="line">    <span class="keyword">this</span>._unregisterInstance();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>unobserve</code>的执行流程十分简单，首先是从<code>this._observationTargets</code>将<code>target</code>删除。如果<code>this._observationTargets</code>队列长度为0，表示当前的<code>observer</code>没有监听任何<code>target</code>，那么就可以将当前<code>observer</code>从全局的<code>registry</code>数组中删除。如果<code>registry</code>也为空，那么就可以卸载相关事件。这个过程主要是通过<code>this._unmonitorIntersections</code>和<code>this._unregisterInstance</code>方法来实现的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">IntersectionObserver.prototype._unmonitorIntersections = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._monitoringIntersections) &#123;</span><br><span class="line">    <span class="keyword">this</span>._monitoringIntersections = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    clearInterval(<span class="keyword">this</span>._monitoringInterval);</span><br><span class="line">    <span class="keyword">this</span>._monitoringInterval = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    removeEvent(<span class="built_in">window</span>, <span class="string">'resize'</span>, <span class="keyword">this</span>._checkForIntersections, <span class="literal">true</span>);</span><br><span class="line">    removeEvent(<span class="built_in">document</span>, <span class="string">'scroll'</span>, <span class="keyword">this</span>._checkForIntersections, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._domObserver) &#123;</span><br><span class="line">      <span class="keyword">this</span>._domObserver.disconnect();</span><br><span class="line">      <span class="keyword">this</span>._domObserver = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IntersectionObserver.prototype._unregisterInstance = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = registry.indexOf(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">if</span> (index != <span class="number">-1</span>) registry.splice(index, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="disconnect"><a href="#disconnect" class="headerlink" title="disconnect"></a>disconnect</h3><p><code>disconnect</code>可以一次性取消<code>observer</code>对所有<code>target</code>的监测，这个方法的实现同样很简单</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IntersectionObserver.prototype.disconnect = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._observationTargets = [];</span><br><span class="line">  <span class="keyword">this</span>._unmonitorIntersections();</span><br><span class="line">  <span class="keyword">this</span>._unregisterInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是对<code>IntersectionObserver polyfill</code>源码的大致分析。如有错误，欢迎指正。</p><h3 id="使用IntersectionObserver实现一个简单的无限滚动"><a href="#使用IntersectionObserver实现一个简单的无限滚动" class="headerlink" title="使用IntersectionObserver实现一个简单的无限滚动"></a>使用IntersectionObserver实现一个简单的无限滚动</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.img-area</span> &#123;</span></span><br><span class="line">      width: 500px;</span><br><span class="line">      height: 320px;</span><br><span class="line">      margin: 0 auto;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.my-photo</span> &#123;</span></span><br><span class="line">      width: 500px;</span><br><span class="line">      height: 300px;</span><br><span class="line">      opacity: 0;</span><br><span class="line"><span class="css">      <span class="selector-tag">-webkit-transition</span>: <span class="selector-tag">opacity</span> 0<span class="selector-class">.25s</span> <span class="selector-tag">ease-in-out</span>;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">-moz-transition</span>: <span class="selector-tag">opacity</span> 0<span class="selector-class">.25s</span> <span class="selector-tag">ease-in-out</span>;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">-o-transition</span>: <span class="selector-tag">opacity</span> 0<span class="selector-class">.25s</span> <span class="selector-tag">ease-in-out</span>;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">transition</span>: <span class="selector-tag">opacity</span> 0<span class="selector-class">.25s</span> <span class="selector-tag">ease-in-out</span>;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">class</span>=<span class="string">"body"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img-area"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"my-photo"</span> <span class="attr">alt</span>=<span class="string">"loading"</span> <span class="attr">data-src</span>=<span class="string">"./img/1.png"</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img-area"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"my-photo"</span> <span class="attr">alt</span>=<span class="string">"loading"</span> <span class="attr">data-src</span>=<span class="string">"./img/1.png"</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img-area"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"my-photo"</span> <span class="attr">alt</span>=<span class="string">"loading"</span> <span class="attr">data-src</span>=<span class="string">"./img/1.png"</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img-area"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"my-photo"</span> <span class="attr">alt</span>=<span class="string">"loading"</span> <span class="attr">data-src</span>=<span class="string">"./img/1.png"</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img-area"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"my-photo"</span> <span class="attr">alt</span>=<span class="string">"loading"</span> <span class="attr">data-src</span>=<span class="string">"./img/1.png"</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img-area"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"my-photo"</span> <span class="attr">alt</span>=<span class="string">"loading"</span> <span class="attr">data-src</span>=<span class="string">"./img/1.png"</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img-area"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"my-photo"</span> <span class="attr">alt</span>=<span class="string">"loading"</span> <span class="attr">data-src</span>=<span class="string">"./img/1.png"</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img-area"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"my-photo"</span> <span class="attr">alt</span>=<span class="string">"loading"</span> <span class="attr">data-src</span>=<span class="string">"./img/1.png"</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img-area"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"my-photo"</span> <span class="attr">alt</span>=<span class="string">"loading"</span> <span class="attr">data-src</span>=<span class="string">"./img/1.png"</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img-area"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"my-photo"</span> <span class="attr">alt</span>=<span class="string">"loading"</span> <span class="attr">data-src</span>=<span class="string">"./img/1.png"</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="comment">&lt;!-- 页尾标志，判断是否需要新添加节点到文档流中 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">loadItems</span><span class="params">(io, count = 10)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> container = <span class="built_in">document</span>.querySelector(<span class="string">'.container'</span>)</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span></span><br><span class="line"><span class="javascript">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> li = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span></span><br><span class="line"><span class="actionscript">        li.className = <span class="string">'img-area'</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>)</span></span><br><span class="line"><span class="actionscript">        img.className = <span class="string">'my-photo'</span></span></span><br><span class="line"><span class="actionscript">        img.alt = <span class="string">'loading'</span></span></span><br><span class="line"><span class="actionscript">        img.dataset.src = <span class="string">'./img/1.png'</span></span></span><br><span class="line">        li.appendChild(img);</span><br><span class="line">        fragment.appendChild(li);</span><br><span class="line">        io.observe(img)</span><br><span class="line">      &#125;</span><br><span class="line">      container.appendChild(fragment)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">lazyLoad</span><span class="params">(imgClassName)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> imgList = <span class="built_in">Array</span>.from(<span class="built_in">document</span>.querySelectorAll(imgClassName));</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> opts = &#123;</span></span><br><span class="line"><span class="javascript">        root: <span class="built_in">document</span>,</span></span><br><span class="line"><span class="actionscript">        rootMargin: <span class="string">"500px 0px"</span></span></span><br><span class="line">      &#125;;</span><br><span class="line"><span class="actionscript">      <span class="keyword">const</span> io = <span class="keyword">new</span> IntersectionObserver(<span class="function"><span class="keyword">function</span> <span class="params">(ioes)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        ioes.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(ioe)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">const</span> el = ioe.target;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">const</span> cn = el.className;</span></span><br><span class="line"><span class="actionscript">          <span class="comment">// const intersectionRatio = ioe.intersectionRatio;</span></span></span><br><span class="line"><span class="actionscript">          <span class="keyword">if</span> (cn === <span class="string">'footer'</span>) &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (!ioe.isIntersecting) <span class="keyword">return</span>;</span></span><br><span class="line">            loadItems(io);</span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'loaded new items'</span>);</span></span><br><span class="line"><span class="actionscript">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ioe.isIntersecting) &#123; <span class="comment">//对于图片节点，当其进入范围内，则load其src</span></span></span><br><span class="line">            if (!el.src) &#123;</span><br><span class="line">              el.src = el.dataset.src;</span><br><span class="line"><span class="actionscript">              el.onload = <span class="function"><span class="keyword">function</span> <span class="params">(e)</span> </span>&#123;</span></span><br><span class="line">                el.style.opacity = 1</span><br><span class="line">              &#125;</span><br><span class="line"><span class="actionscript">              io.unobserve(el); <span class="comment">//加载图片后停止观察该节点</span></span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;, opts);</span><br><span class="line"><span class="actionscript">      imgList.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(item)</span> </span>&#123;</span></span><br><span class="line">        io.observe(item)</span><br><span class="line">      &#125;);</span><br><span class="line"><span class="javascript">      io.observe(<span class="built_in">document</span>.querySelector(<span class="string">".footer"</span>)) <span class="comment">//观察footer节点，判断添加新节点的时机</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    lazyLoad(<span class="string">'.my-photo'</span>);</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果图：<br><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/Jietu20201014-172126.gif" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/Jietu20201014-172126.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Jietu20201014-172126"></p><!-- 转发自[赵赛赛个人博客](https://zhaosaisai.com/blog/2019/IntersectionObserver-polyfill%E8%A7%A3%E6%9E%90.html) --></div>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IntersectionObserver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>男士洗面奶</title>
      <link href="/%E7%94%9F%E6%B4%BB-%E7%94%B7%E5%A3%AB%E6%B4%97%E9%9D%A2%E5%A5%B6%E6%8E%A8%E8%8D%90/"/>
      <url>/%E7%94%9F%E6%B4%BB-%E7%94%B7%E5%A3%AB%E6%B4%97%E9%9D%A2%E5%A5%B6%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<p>作为全虎扑拥有洗面奶最多的男人，我评价一款洗面奶永远不是嘴上说好用不好用那么简单。好用要有好用的理由，不好用也要说出不好用的地方。</p><a id="more"></a><p>今天就虎扑权威男性洗面奶排行榜，来说一说到底哪些洗面奶值得买。我会从成分分析、酸碱测试、使用体验和适用肤质4个方面来具体盘一盘。</p><p>不懂选择的，对比虎扑洗面奶排行榜，参考文章，对应肤质和预算，直接入就完事了！</p><p>OK，上菜单：<br><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200930172848.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200930172848.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20200930172848"></p><hr><p> 个人建议，选择购入产品，直接选择天猫官方店，价格透明，买的放心，其他平台容易出假，仿货！</p><h4 id="◎NO-1芙丽芳丝-（150元-100g）"><a href="#◎NO-1芙丽芳丝-（150元-100g）" class="headerlink" title="◎NO.1芙丽芳丝 （150元/100g）"></a><a href="https://s.click.taobao.com/cIUdzvu" target="_blank" rel="noopener">◎NO.1芙丽芳丝</a> （150元/100g）</h4><p>1【成分分析】</p><p>成分分析这块儿讲的会有点小枯燥，不喜欢看的直接跳到下一趴！</p><p>这几年芙丽芳丝应该没少在广告上砸钱，洁面界第一网红的称号不是白来的。</p><p>宣传适合敏感肌的洁面，没有刺激性香精防腐剂，靠柠檬酸+丁二醇来防腐，还算靠谱。</p><p>清洁方面主要靠的是氨基酸表活-椰油酰甘氨酸钾，中等偏上清洁力。甘油排位第一为了保湿。添加有两种致痘风险的乳化剂，从消费者反馈来说，有一定致痘风险，我自己用着期间，还没长嘿嘿。</p><p>从烟酰胺开始的各种活性成分，添加量很低很低，而且不在脸上停留，不说也罢！</p><p>2【酸碱测试】</p><p>PH值介于6-7之间，还算过关！比较温和，对肌肤基本没什么刺激。我换季过敏用都毫无压力。</p><p>3【使用体验】</p><p>乳膏质地，洗出来的泡泡跟棉花一样，细密温和。味道有点像宝宝身上的奶香味儿，个人能接受，但是看淘宝评价有人说像塑料……让人有点方。</p><p>洗的干净，洗完不绷，是一款过敏或日常用都可的安全洗面奶。</p><p>4【适用肤质】</p><p>除了塔克拉玛干和大庆油田，基本所有肤质都适用。但是含有烟酰胺，重敏皮要避雷。</p><hr><h4 id="◎NO-2-简男六角瓶-（39-9元）"><a href="#◎NO-2-简男六角瓶-（39-9元）" class="headerlink" title="◎NO.2 简男六角瓶 （39.9元）"></a><a href="https://detail.tmall.com/item.htm?id=624915003970&spm=a1z10.5-b-s.w4023-23052492309.17.27651c92T8yG5B&skuId=4418147024711" target="_blank" rel="noopener">◎NO.2 简男六角瓶</a> （39.9元）</h4><p> 这是我多次回购的，油性肌肤用它没错了！</p><p>1【成分分析】</p><p>作为新型氨基酸粉末洁面，有着比传统乳状洗面奶更明显的优势，溶解速度快，上脸不黏腻，不担心像乳状一样可能会残留，用着舒心方便</p><p>备案没有任何乱七八糟的防腐剂香精成分，巨巨巨温和！甘露糖醇复配聚乙二醇负责保湿，氨基酸表活负责清洁，用之后才知道什么叫真正嫩滑不拔干，学术派护肤党我爱了。</p><p>2【酸碱测试】</p><p>跟皮肤贴合的完美酸碱值，接近于6，上脸一点刺激也没有。</p><p>3【使用体验】</p><p>相比于膏状和乳状以及泡泡洁面，粉状洁面使用感上升了好几个档次，用过的人都懂。</p><p>每次洗脸用一小盒，携带方便，干净卫生，出差日常都可。清洁效果的确挺神奇，每次都能感到颗粒感的粉质能够搓出来一些死皮和附着在毛孔表面的小白头，太加分了！</p><p>没有用过洁颜粉的，墙裂建议试试。</p><p>4【适用肤质】</p><p>尤其适合油皮男士！</p><hr><h4 id="◎NO3-旁氏米粹洗面奶（29-9-59元之间）"><a href="#◎NO3-旁氏米粹洗面奶（29-9-59元之间）" class="headerlink" title="◎NO3. 旁氏米粹洗面奶（29.9-59元之间）"></a><a href="https://s.click.taobao.com/yY8dzvu" target="_blank" rel="noopener">◎NO3. 旁氏米粹洗面奶</a>（29.9-59元之间）</h4><p>上榜的那位，虽然便宜量足。但是含有二氧化钛，洗完假白。相对来说旁氏米粹洁面泡泡这个亲兄弟更值得入。</p><p>不吹说，也就旁氏泡泡能摊得上便宜大碗，30块钱这么大一管，其他牌子就别来凑热闹了行么？</p><p>因为便宜，表活用的也是最便宜的椰油酰甘氨酸钾，氨基酸类，温和。</p><p>插一句，氨基酸洗面奶真的是很普通的一种洗面奶类型，工作关系总是看到各种洗面奶用氨基酸给自己抬身价，没啥稀罕的呀。</p><p>2【酸碱测试】</p><p>作为一款老实本分的温和型洁面，pH在6～7之间，接近皮肤本身的pH值，无论油皮干皮敏感肌都可以放心pick。</p><p>3【使用体验】</p><p>按压出来就是泡泡，不像珂润，旁氏的泡泡挤出来啥样上脸还啥样，不会变虚变薄。洗的时候有淡淡的淘米水味，搞得我每次洗脸都感到有点饿怎么肥四。洗完不干不紧绷，价格也很学生党，是我大学时期回购次数最多的洗面奶，谁让我穷呢～～</p><p>4【适用肤质】</p><p>只要不是两极分化的大庆油田或撒哈拉沙漠，大部分肤质都可。有香精，重敏的人不要用。</p><p>篇幅有限，其他洗面奶就来简单说一说。</p><hr><h4 id="◎NO4-日本UNO洗面奶-（55元）"><a href="#◎NO4-日本UNO洗面奶-（55元）" class="headerlink" title="◎NO4. 日本UNO洗面奶 （55元）"></a><a href="https://s.click.taobao.com/BM3f1wu" target="_blank" rel="noopener">◎NO4. 日本UNO洗面奶 （55元）</a></h4><p>NUO？我傻了。</p><p>UNO吾诺男士洗面奶有黑管、蓝管、绿管三种颜色，这76个泡泡值估计都是投给黑管的。</p><p>成分分析：皂基表活，清洁力强大。添加辣薄荷，洗感清凉。</p><p>使用体验：一个字爽，两个字凉爽。夏天用还好，秋冬真的有种抹风油精的感觉。洗完略紧绷，需要及时补水。</p><p>适用肤质：油性耐受肌。</p><hr><h4 id="◎NO5-碧欧泉洗面奶"><a href="#◎NO5-碧欧泉洗面奶" class="headerlink" title="◎NO5.  碧欧泉洗面奶"></a><a href="https://s.click.taobao.com/YKeczvu" target="_blank" rel="noopener">◎NO5.  碧欧泉洗面奶</a></h4><p>说实话，碧欧泉排行第五有点亏，可能价格有点小贵，用的人不多。所以给他投票的人也不多。</p><p>成分分析：同为皂基表活，但是整体比UNO要温和得多，添加了很多活性成分，贵有贵的理由。</p><p>使用体验：调香高级，淡淡的茶香，清洁力、温和性也平衡得很好，洗完完全不会感到拔干。</p><p>适用肤质：中性-油性耐受肌。</p><hr><h4 id="◎NO-6-Elta-MD（80-188元）"><a href="#◎NO-6-Elta-MD（80-188元）" class="headerlink" title="◎NO.6 Elta MD（80-188元）"></a><a href="https://s.click.taobao.com/ZFje1wu" target="_blank" rel="noopener">◎NO.6 Elta MD（80-188元）</a></h4><p>这款洗面奶JR用得不多，但在小红书上可是火的一塌糊涂。是美国各大皮肤科医生也会推荐的温和型洁面。</p><p>成分分析：典型的氨基酸洁面，加入了沸点很低的醚类，上脸30秒后可自动起泡。</p><p>使用体验：成也萧何，败也萧何。虽然这款洗面奶的亮点是可以自动发泡。但麻烦的是每次用完都要旋转泵头锁住洗面奶，不然它会吐泡泡到你怀疑人生。</p><p>适用肤质：全肤质适用。</p><hr><h4 id="◎NO-7理肤泉洗面奶"><a href="#◎NO-7理肤泉洗面奶" class="headerlink" title="◎NO.7理肤泉洗面奶"></a><a href="https://s.click.taobao.com/OuEe1wu" target="_blank" rel="noopener">◎NO.7理肤泉洗面奶</a></h4><p>相信很多人都是从理肤泉雅漾这类外国牌子开始接触药妆的。这款理肤泉特安洁面，从名字就能看出来非常适合敏感肌。</p><p>成分分析：宣传适合敏感肌的洁面却含有5种皂基表活成分，我有点方。感觉这个洁面更适合油皮才对。</p><p>适用体验：清洁力好，无香精防腐剂，虽然是皂基表活，但还算温和。</p><p>适用肤质：油皮、油皮敏感肌</p><hr><h4 id="◎NO-8欧莱雅"><a href="#◎NO-8欧莱雅" class="headerlink" title="◎NO.8欧莱雅"></a><a href="https://s.click.taobao.com/bcZe1wu" target="_blank" rel="noopener">◎NO.8欧莱雅</a></h4><p>火山泥在JR心中是永远的神和永远的shi。</p><p>成分分析：典型的皂基表活，含有水杨酸，红色质地来自于高岭土。</p><p>使用体验：所谓男性去油系列，就是挂掉你脸上的油，刮油效果不是盖的，用完绷的感觉自己像干尸。油皮瞬间变干皮。对付直男就是要狠。但是这种刮油的方式只会加重痘痘，刺激痘痘，搞不好就会引起外油内干的情况出现。</p><p>适用肤质：油皮，不推荐。</p><hr><h4 id="◎NO-9雅诗兰黛白金洗面奶"><a href="#◎NO-9雅诗兰黛白金洗面奶" class="headerlink" title="◎NO.9雅诗兰黛白金洗面奶"></a>◎NO.9雅诗兰黛白金洗面奶</h4><p>雅诗兰黛白金洗面奶号称可以温和卸妆。这款分为有泡板和无泡板。看包装，有泡foam，无泡creme.</p><p>成分分析：氨基酸系贵妇洗面奶。大牌们可能是商量好的，只要出氨基酸洗面奶就要可着劲儿的添加活性成分，不管这些活性成分有没有用，加上去就能宣传卖高价。</p><p>适用体验：贵妇洗面奶使用感就是好呀，质地、泡沫、调香没得说。但是这些活性成分没卵用，要知道洗面奶只在脸上停留几十秒钟，这么短的时间内，活性成分是不可能被吸收的。</p><p>适用肤质：全肤质适用</p><hr><h4 id="◎NO-10丝塔芙洗面奶"><a href="#◎NO-10丝塔芙洗面奶" class="headerlink" title="◎NO.10丝塔芙洗面奶"></a><a href="https://s.click.taobao.com/8eJczvu" target="_blank" rel="noopener">◎NO.10丝塔芙洗面奶</a></h4><p>没有想到丝塔芙这种毫无清洁力的洗面奶，还能在JR心中占有一席之地。</p><p>成分分析：备案成分一共8种。清洁剂一种，防腐剂三种，神了。清洁剂虽然是我们常说的刺激性较大的SLS，但是添加量较低，对皮肤造不成什么伤害。</p><p>使用体验：个人油性皮肤，对这种几乎无泡无清洁力的洗面奶不感冒，洗完感觉滑滑的，一点都没洗干净。可能干皮会比较喜欢它的温和吧。</p><p>适用肤质：干皮</p><hr><p><a href="https://bbs.hupu.com/38273427.html" target="_blank" rel="noopener">Source</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm依赖管理中容易被忽略细节</title>
      <link href="/node-2020-09-15-npm%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E4%B8%AD%E5%AE%B9%E6%98%93%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%BB%86%E8%8A%82/"/>
      <url>/node-2020-09-15-npm%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E4%B8%AD%E5%AE%B9%E6%98%93%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%BB%86%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<p>提起 npm，大家第一个想到的应该就是 npm install 了，但是 npm install 之后生成的 node_modules 大家有观察过吗？package-lock.json 文件的作用大家知道吗？除了 dependencies 和 devDependencies，其他的依赖有什么作用呢？接下来，本文将针对 npm 中的你可能忽略的细节和大家分享一些经验 。</p><a id="more"></a><h3 id="npm-安装机制"><a href="#npm-安装机制" class="headerlink" title="npm 安装机制"></a>npm 安装机制</h3><p>A 和 B 同时依赖 C，C 这个包会被安装在哪里呢？C 的版本相同和版本不同时安装会有什么差异呢？package.json 中包的前后顺序对于安装时有什么影响吗？这些问题平时大家可能没有注意过，今天我们就来一起研究一下吧。</p><h3 id="A-和-B-同时依赖-C，这个包会被安装在哪里呢？"><a href="#A-和-B-同时依赖-C，这个包会被安装在哪里呢？" class="headerlink" title="A 和 B 同时依赖 C，这个包会被安装在哪里呢？"></a>A 和 B 同时依赖 C，这个包会被安装在哪里呢？</h3><p>假如有 A 和 B 两个包，两个包都依赖 C 这个包，npm 2 会依次递归安装 A 和 B 两个包及其子依赖包到 node_modules 中。执行完毕后，我们会看到 <code>./node_modules</code>这层目录只含有这两个子目录：</p><p>node_modules/<br>├─┬ A<br>│ ├── C<br>├─┬ B<br>│ └── C</p><p>如果使用 npm 3 来进行安装的话，<code>./node_modules</code> 下的目录将会包含三个子目录：</p><p>node_modules/<br>├─┬ A<br>├─┬ B<br>├─┬ C</p><p>为什么会出现这样的区别呢？这就要从 npm 的工作方式说起了：</p><h3 id="npm-2-和-npm-3-模块安装机制的差异"><a href="#npm-2-和-npm-3-模块安装机制的差异" class="headerlink" title="npm 2 和 npm 3 模块安装机制的差异"></a>npm 2 和 npm 3 模块安装机制的差异</h3><p>虽然目前最新的 npm 版本是 npm 6，但 npm 2 到 npm 3 的版本变更中实现了目录打平，与其他版本相比差别较大。因此，让我们具体看下这两个版本的差异​。</p><p>npm 2 在安装依赖包时，采用简单的递归安装方法。执行 npm install 后，npm 根据 dependencies 和 devDependencies 属性中指定的包来确定第一层依赖，npm 2 会根据第一层依赖的子依赖，递归安装各个包到子依赖的 node_modules 中，直到子依赖不再依赖其他模块。执行完毕后，我们会看到 ./node_modules 这层目录中包含有我们 package.json 文件中所有的依赖包，而这些依赖包的子依赖包都安装在了自己的 node_modules 中 ，形成类似于下面的依赖树：<br><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200915234216.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200915234216.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20200915234216"></p><p>这样的目录有较为明显的好处：</p><ol><li>层级结构非常明显，可以清楚的在第一层的 node_modules 中看到我们安装的所有包的子目录；</li><li>在已知自己所需包的名字以及版本号时，可以复制粘贴相应的文件到 node_modules 中，然后手动更改 package.json 中的配置；</li><li>如果想要删除某个包，只需要简单的删除 package.json 文件中相应的某一行，然后删除 node_modules 中该包的目录；</li></ol><p>但是这样的层级结构也有较为明显的缺陷，当我的 A，B，C 三个包中有相同的依赖 D 时，执行 <code>npm install</code> 后，D 会被重复下载三次，而随着我们的项目越来越复杂，node_modules 中的依赖树也会越来越复杂，像 D 这样的包也会越来越多，造成了大量的冗余；在 windows 系统中，甚至会因为目录的层级太深导致文件的路径过长，触发文件路径不能超过 280 个字符的错误；</p><p>​ 为了解决以上问题，npm 3 的 node_modules 目录改成了更为扁平状的层级结构，尽量把依赖以及依赖的依赖平铺在 node_modules 文件夹下共享使用。</p><h3 id="npm-3-对于同一依赖的不同版本会怎么处理呢？"><a href="#npm-3-对于同一依赖的不同版本会怎么处理呢？" class="headerlink" title="npm 3 对于同一依赖的不同版本会怎么处理呢？"></a>npm 3 对于同一依赖的不同版本会怎么处理呢？</h3><p>npm 3 会遍历所有的节点，逐个将模块放在 node_modules 的第一层，当发现有重复模块时，则丢弃， 如果遇到某些依赖版本不兼容的问题，则继续采用 npm 2 的处理方式，前面的放在 node_modules 目录中，后面的放在依赖树中。举个例子： A，B，依赖 D(v 0.0.1)，C 依赖 D(v 0.0.2):</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200915234325.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200915234325.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20200915234325"></p><p>但是 npm 3 会带来一个新的问题：由于在执行 <code>npm install</code> 的时候，按照 <code>package.json</code>里依赖的顺序依次解析，上图如果 C 的顺序在 A，B 的前边，node_modules 树则会改变，会出现下边的情况：</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200915234354.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200915234354.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20200915234354"></p><p>由此可见，npm 3 并未完全解决冗余的问题，甚至还会带来新的问题。</p><h3 id="为什么会出现-package-lock-json-呢？"><a href="#为什么会出现-package-lock-json-呢？" class="headerlink" title="为什么会出现 package-lock.json 呢？"></a>为什么会出现 package-lock.json 呢？</h3><p>为什么会有 package-lock.json 文件呢？这个我们就要先从 package.json 文件说起了。</p><h3 id="package-json-的不足之处"><a href="#package-json-的不足之处" class="headerlink" title="package.json 的不足之处"></a>package.json 的不足之处</h3><p>npm install 执行后，会生成一个 node_modules 树，在理想情况下， 希望对于同一个 package.json 总是生成完全相同 node_modules 树。在某些情况下，确实如此。但在多数情况下，npm 无法做到这一点。有以下两个原因：</p><p>1）某些依赖项自上次安装以来，可能已发布了新版本 。比如：A 包在团队中第一个人安装的时候是 1.0.5 版本，package.json 中的配置项为 A: ‘^1.0.5’ ；团队中第二个人把代码拉下来的时候，A 包的版本已经升级成了 1.0.8，根据 package.json 中的 semver-range version 规范，此时第二个人 npm install 后 A 的版本为 1.0.8； 可能会造成因为依赖版本不同而导致的 bug；</p><p>2）针对 1）中的问题，可能有的小伙伴会想，把 A 的版本号固定为 A: ‘1.0.5’ 不就可以了吗？但是这样的做法其实并没有解决问题， 比如 A 的某个依赖在第一个人下载的时候是 2.1.3 版本，但是第二个人下载的时候已经升级到了 2.2.5 版本，此时生成的 node_modules 树依旧不完全相同 ，固定版本只是固定来自身的版本，依赖的版本无法固定。</p><h3 id="针对-package-json-不足的解决方法"><a href="#针对-package-json-不足的解决方法" class="headerlink" title="针对 package.json 不足的解决方法"></a>针对 package.json 不足的解决方法</h3><p>为了解决上述问题以及 npm 3 的问题，在 npm 5.0 版本后，npm install 后都会自动生成一个 package-lock.json 文件 ，当包中有 package-lock.json 文件时，npm install 执行时，如果 package.json 和 package-lock.json 中的版本兼容，会根据 package-lock.json 中的版本下载；如果不兼容，将会根据 package.json 的版本，更新 package-lock.json 中的版本，已保证 package-lock.json 中的版本兼容 package.json。</p><h3 id="package-lock-json-文件的结构"><a href="#package-lock-json-文件的结构" class="headerlink" title="package-lock.json 文件的结构"></a>package-lock.json 文件的结构</h3><p>package-lock.json 文件中的 name、version 与 package.json 中的 name、version 一样，描述了当前包的名字和版本，dependencies 是一个对象，该对象和 node_modules 中的包结构一一对应，对象的 key 为包的名称，值为包的一些描述信息， 根据 <a href="https://docs.npmjs.com/configuring-npm/package-lock-json.html#requires" target="_blank" rel="noopener">package-lock-json</a>官方文档，主要的结构如下：</p><ul><li>version ：包版本，即这个包当前安装在 node_modules 中的版本</li><li>resolved ：包具体的安装来源</li><li>integrity ：包 hash 值，验证已安装的软件包是否被改动过、是否已失效</li><li>requires ：对应子依赖的依赖，与子依赖的 package.json 中 dependencies 的依赖项相同</li><li>dependencies ：结构和外层的 dependencies 结构相同，存储安装在子依赖 node_modules 中的依赖包</li></ul><p>需要注意的是，并不是所有的子依赖都有 <code>dependencies</code> 属性，只有子依赖的依赖和当前已安装在根目录的 <code>node_modules</code> 中的依赖冲突之后，才会有这个属性。</p><h3 id="package-lock-json-文件的作用"><a href="#package-lock-json-文件的作用" class="headerlink" title="package-lock.json 文件的作用"></a>package-lock.json 文件的作用</h3><ul><li>在团队开发中，确保每个团队成员安装的依赖版本是一致的，确定一棵唯一的 node_modules 树；</li><li>node_modules 目录本身是不会被提交到代码库的，但是 package-lock.json 可以提交到代码库，如果开发人员想要回溯到某一天的目录状态，只需要把 package.json 和 package-lock.json 这两个文件回退到那一天即可 。</li><li>由于 package-lock.json 和 node_modules 中的依赖嵌套完全一致，可以更加清楚的了解树的结构及其变化。</li><li>在安装时，npm 会比较 node_modules 已有的包，和 package-lock.json 进行比较，如果重复的话，就跳过安装 ，从而优化了安装的过程。</li></ul><h3 id="依赖的区别与使用场景"><a href="#依赖的区别与使用场景" class="headerlink" title="依赖的区别与使用场景"></a>依赖的区别与使用场景</h3><p>npm 目前支持以下几类依赖包管理包括</p><ul><li>dependencies</li><li>devDependencies</li><li>optionalDependencies 可选择的依赖包</li><li>peerDependencies 同等依赖</li><li>bundledDependencies 捆绑依赖包</li></ul><p>下面我们来看一下这几种依赖的区别以及各自的应用场景：</p><h4 id="dependencies"><a href="#dependencies" class="headerlink" title="dependencies"></a>dependencies</h4><p>dependencies 是无论在开发环境还是在生产环境都必须使用的依赖，是我们最常用的依赖包管理对象，例如 React，Loadsh，Axios 等，通过 npm install XXX 下载的包都会默认安装在 dependencies 对象中，也可以使用 npm install XXX –save 下载 dependencies 中的包；</p><h4 id="devDependencies"><a href="#devDependencies" class="headerlink" title="devDependencies"></a>devDependencies</h4><p>devDependencies 是指可以在开发环境使用的依赖，例如 eslint，debug 等，通过 npm install packageName –save-dev 下载的包都会在 devDependencies 对象中；</p><p>dependencies 和 devDependencies 最大的区别是在打包运行时，执行 npm install 时默认会把所有依赖全部安装，但是如果使用 <code>npm install --production</code> 时就只会安装 dependencies 中的依赖，如果是 node 服务项目，就可以采用这样的方式用于服务运行时安装和打包，减少包大小。</p><h4 id="optionalDependencies"><a href="#optionalDependencies" class="headerlink" title="optionalDependencies"></a>optionalDependencies</h4><p>optionalDependencies 指的是可以选择的依赖，当你希望某些依赖即使下载失败或者没有找到时，项目依然可以正常运行或者 npm 继续运行的时，就可以把这些依赖放在 optionalDependencies 对象中，但是 optionalDependencies 会覆盖 dependencies 中的同名依赖包，所以不要把一个包同时写进两个对象中。</p><p>optionalDependencies 就像是我们的代码的一种保护机制一样，如果包存在的话就走存在的逻辑，不存在的就走不存在的逻辑。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> axios = <span class="built_in">require</span>(<span class="string">'axios'</span>)</span><br><span class="line">  <span class="keyword">var</span> fooVersion = <span class="built_in">require</span>(<span class="string">'axios/package.json'</span>).version</span><br><span class="line">&#125; <span class="keyword">catch</span> (er) &#123;</span><br><span class="line">  foo = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// .. then later in your program ..</span></span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">  foo.doFooThings()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="peerDependencies"><a href="#peerDependencies" class="headerlink" title="peerDependencies"></a>peerDependencies</h4><p>peerDependencies 用于指定你当前的插件兼容的宿主必须要安装的包的版本，这个是什么意思呢？举个例子🌰：我们常用的 react 组件库 <a href="mailto:ant-design@3.x">ant-design@3.x</a> 的 package.json 中的配置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"peerDependencies"</span>: &#123;</span><br><span class="line">  <span class="string">"react"</span>: <span class="string">"&gt;=16.9.0"</span>,</span><br><span class="line">  <span class="string">"react-dom"</span>: <span class="string">"&gt;=16.9.0"</span></span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p> 假设我们创建了一个名为 project 的项目，在此项目中我们要使用 <a href="mailto:ant-design@3.x">ant-design@3.x</a> 这个插件，此时我们的项目就必须先安装 React &gt;= 16.9.0 和 React-dom &gt;= 16.9.0 的版本。​</p><p>在 npm 2 中，当我们下载 <a href="mailto:ant-design@3.x">ant-design@3.x</a> 时，peerDependencies 中指定的依赖会随着 <a href="mailto:ant-design@3.x">ant-design@3.x</a> 一起被强制安装，所以我们不需要在宿主项目的 package.json 文件中指定 peerDependencies 中的依赖，但是在 npm 3 中，不会再强制安装 peerDependencies 中所指定的包，而是通过警告的方式来提示我们，此时就需要手动在 package.json 文件中手动添加依赖；</p><h4 id="bundledDependencies"><a href="#bundledDependencies" class="headerlink" title="bundledDependencies"></a>bundledDependencies</h4><p>这个依赖项也可以记为 bundleDependencies，与其他几种依赖项不同，他不是一个键值对的对象，而是一个数组，数组里是包名的字符串，例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"project"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"bundleDependencies"</span>: [</span><br><span class="line">    <span class="string">"axios"</span>,</span><br><span class="line">    <span class="string">"lodash"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用 npm pack 的方式来打包时，上述的例子会生成一个 project-1.0.0.tgz 的文件，在使用了 bundledDependencies 后，打包时会把 Axios 和 Lodash 这两个依赖一起放入包中，之后有人使用 npm install project-1.0.0.tgz 下载包时，Axios 和 Lodash 这两个依赖也会被安装。需要注意的是安装之后 Axios 和 Lodash 这两个包的信息在 dependencies 中，并且不包括版本信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"bundleDependencies"</span>: [</span><br><span class="line">  <span class="string">"axios"</span>,</span><br><span class="line">  <span class="string">"lodash"</span></span><br><span class="line">],</span><br><span class="line"><span class="string">"dependencies"</span>: &#123;</span><br><span class="line">  <span class="string">"axios"</span>: <span class="string">"*"</span>,</span><br><span class="line">  <span class="string">"lodash"</span>: <span class="string">"*"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们使用常规的 npm publish 来发布的话，这个属性是不会生效的，所以日常情况中使用的较少。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文介绍的是 npm 2，npm 3，package-lock.json 以及几种依赖的区别和使用场景，希望能够让大家对 npm 的了解更加多一点，有什么不清楚的地方或者不足之处欢迎大家在评论区留言。</p><p>原文转载自：<a href="https://www.zoo.team/article/npm-details" target="_blank" rel="noopener">https://www.zoo.team/article/npm-details</a></p>]]></content>
      
      
      <categories>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 React 中实现 keep alive</title>
      <link href="/framework-react-keep-alive/"/>
      <url>/framework-react-keep-alive/</url>
      
        <content type="html"><![CDATA[<p>本文介绍一种在react中实现Vue的keep alive功能的方案。</p><a id="more"></a><h3 id="什么是-keep-alive"><a href="#什么是-keep-alive" class="headerlink" title="什么是 keep alive"></a>什么是 keep alive</h3><p>在 Vue 中，我们可以使用 keep-alive 包裹一个动态组件，从而缓存不活跃的实例，而不是直接销毁他们：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"view"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这对于某些路由切换等场景非常好用，例如，如果我们需要实现一个列表页和详情页，但在用户从详情页返回列表的时候，我们不希望重新请求接口获取，也不希望重置列表的过滤、排序等条件，那这时就可以对列表页的组件用 keep-alive 包裹一下，这样，当路由切换时，Vue 会将这个组件“失活”并缓存起来，而不是直接卸载掉。</p><h3 id="最简单的方案"><a href="#最简单的方案" class="headerlink" title="最简单的方案"></a>最简单的方案</h3><p>而在 React 中，其实一直以来都没有官方的 keep alive 解决方案，大部分开发者可能都会直接使用 display: none 来将 DOM 隐藏：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&#123;shouldHide ? &#123;<span class="attr">display</span>: <span class="string">'none'</span>&#125; : &#123;&#125;&#125;&gt;</span><br><span class="line">  &lt;Foo/&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p>但这种方案其实只是在“视觉上”将元素隐藏起来了，并没有真正的移除，那有没有可能把 DOM 树真的移除掉，同时又让组件不被销毁呢？</p><h3 id="Portal实现"><a href="#Portal实现" class="headerlink" title="Portal实现"></a>Portal实现</h3><blockquote><p>Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。</p></blockquote><p>这是 React <a href="https://zh-hans.reactjs.org/docs/portals.html" target="_blank" rel="noopener">官方文档</a>上对 Portal 特性的介绍，值得注意的是，这里只是说“父组件以外的 DOM 节点”，但没有要求这个 DOM 节点是真的在页面上，还是只是存在于内存中。 因此，我们可以先通过 document.createElement 在内存中创建一个元素，然后再通过 React.createPoral 把 React 子节点渲染到这个元素上，这样就实现了“空渲染”。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetElement = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">ReactDOM.createPortal(child, targetElement)</span><br></pre></td></tr></table></figure><p>基于这种方案，我们可以进一步封装出一个 Conditional 组件，从而实现通用性的条件渲染逻辑：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Conditional = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [targetElement] = useState(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">document</span>.createElement(<span class="string">'div'</span>))</span><br><span class="line">  <span class="keyword">const</span> containerRef = useRef()</span><br><span class="line">  useLayoutEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (props.active) &#123;</span><br><span class="line">      containerRef.current.appendChild(targetElement)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        containerRef.current.removeChild(targetElement)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [props.active])</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;div ref=&#123;containerRef&#125; /&gt;</span><br><span class="line">      &#123;ReactDOM.createPortal(props.children, targetElement)&#125;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>首先，我们创建了一个 targetElement ，并且通过 createPortal 将 children 渲染到 targetElement 。 然后，我们会创建一个容器 div 元素，并且通过 containerRef 拿到它的引用。 最后，当 active 为 true 时，我们会把 targetElement 手动添加到 containerRef.current 的内部，反之，则会从其内部移除掉 targetElement 。 实际使用的方式如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Conditional active=&#123;!shouldHide&#125;&gt;</span><br><span class="line">  &lt;Foo/&gt;</span><br><span class="line">&lt;<span class="regexp">/Conditional&gt;</span></span><br></pre></td></tr></table></figure><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>细心的读者可能会发现，目前我们的 Conditional 组件还有一点小小的瑕疵：当组件初次渲染时，不论当前的 active 是 true 还是 false ， Conditional 组件都会将 props.children 渲染。这对大型应用可能会带来非常明显的性能问题，所以，我们可以为其增加“懒加载”的特性：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Conditional = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [targetElement] = useState(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">document</span>.createElement(<span class="string">'div'</span>))</span><br><span class="line">  <span class="keyword">const</span> containerRef = useRef()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 增加一个 ref 记录组件是否“被激活过”</span></span><br><span class="line">  <span class="keyword">const</span> activatedRef = useRef(<span class="literal">false</span>)</span><br><span class="line">  activatedRef.current = activatedRef.current || props.active</span><br><span class="line"></span><br><span class="line">  useLayoutEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (props.active) &#123;</span><br><span class="line">      containerRef.current.appendChild(targetElement)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        containerRef.current.removeChild(targetElement)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [props.active])</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;div ref=&#123;containerRef&#125; /&gt;</span><br><span class="line">      &#123;activatedRef.current &amp;&amp; ( <span class="comment">// 如果“被激活过”，才渲染 children</span></span><br><span class="line">        ReactDOM.createPortal(props.children, targetElement)</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="一些遗憾"><a href="#一些遗憾" class="headerlink" title="一些遗憾"></a>一些遗憾</h3><p>不得不承认的是，基于 Portal 方案的 Conditional 组件并不能包治百病，和 Vue 的 keep-alive 相比，也存在不少缺憾：</p><ol><li>需要手动控制 active ，不能直接基于子组件销毁/创建的生命周期事件</li><li>缺少失活/激活的生命周期时间，子组件无法感知自己是不是被缓存起来了</li><li>依赖了 ReactDOM ，对 SSR 不够友好</li></ol><p>原文转载自知乎：<a href="https://zhuanlan.zhihu.com/p/214166951" target="_blank" rel="noopener">在 React 中实现 keep alive</a></p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> keep alice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法知识点汇总</title>
      <link href="/algorithms-%E5%BC%80%E7%AF%87/"/>
      <url>/algorithms-%E5%BC%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200622182516.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200622182516.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解记录</title>
      <link href="/algorithms-leetcode/"/>
      <url>/algorithms-leetcode/</url>
      
        <content type="html"><![CDATA[<h1 id="leetCode题解记录"><a href="#leetCode题解记录" class="headerlink" title="leetCode题解记录"></a>leetCode题解记录</h1><ul><li><a href="#leetcode题解记录">leetCode题解记录</a><ul><li><a href="#数组类">数组类</a><ul><li><a href="#常用方法总结">常用方法总结：</a></li><li><a href="#两数之和">两数之和</a></li><li><a href="#15-三数之和">15. 三数之和</a></li><li><a href="#16-最接近的三数之和">16. 最接近的三数之和</a></li><li><a href="#最大子序和">最大子序和</a></li><li><a href="#239-滑动窗口最大值">239. 滑动窗口最大值</a></li><li><a href="#合并两个有序数组">合并两个有序数组</a></li><li><a href="#14-最长公共前缀">14. 最长公共前缀</a></li></ul></li><li><a href="#链表类">链表类</a><ul><li><a href="#常用方法总结-1">常用方法总结：</a></li><li><a href="#合并两个有序链表">合并两个有序链表</a></li><li><a href="#141-环形链表">141. 环形链表</a></li><li><a href="#142-环形链表-ii">142. 环形链表 II</a></li><li><a href="#反转链表">反转链表</a></li><li><a href="#19-删除链表的倒数第n个节点">19. 删除链表的倒数第N个节点</a></li><li><a href="#876-链表的中间结点">876. 链表的中间结点</a></li></ul></li><li><a href="#动态规划类">动态规划类</a><ul><li><a href="#309-最佳买卖股票时机含冷冻期">309. 最佳买卖股票时机含冷冻期</a></li><li><a href="#面试题-1713-恢复空格">面试题 17.13. 恢复空格</a></li><li><a href="#96-不同的二叉搜索树">96. 不同的二叉搜索树</a></li></ul></li></ul></li></ul><h2 id="数组类"><a href="#数组类" class="headerlink" title="数组类"></a>数组类</h2><div class="story post-story"><h3 id="常用方法总结："><a href="#常用方法总结：" class="headerlink" title="常用方法总结："></a>常用方法总结：</h3><ul><li>结合Object(Map/set)等数据结构来解题；</li><li>滑动窗口方法（最小（大）子集等问题适用）</li><li>Trie 树</li></ul><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">两数之和</a></h3><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p>示例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span></span><br><span class="line">所以返回 [<span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>方法一：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, length = nums.length; i &lt; length; i++)&#123;</span><br><span class="line">        <span class="keyword">const</span> left = target - nums[i];</span><br><span class="line">        <span class="keyword">const</span> leftIndex = nums.lastIndexOf(left);</span><br><span class="line">        <span class="keyword">if</span>(leftIndex &gt; i)&#123;</span><br><span class="line">            result = [i ,leftIndex];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n<sup>2</sup>)</li><li>空间复杂度：o(1)</li></ul><p>方法二：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> k = target-nums[i]</span><br><span class="line">        <span class="keyword">if</span>(map.has(k)) &#123;</span><br><span class="line">            <span class="keyword">return</span> [map.get(k), i]</span><br><span class="line">        &#125;</span><br><span class="line">        map.set(nums[i], i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：o(n)</li></ul><h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum" target="_blank" rel="noopener">15. 三数之和</a></h3><p><strong>解题思路：</strong></p><ol><li>首先对数组从大到小进行排序；</li><li>遍历数组，设置左右俩指针初始位置在数组左右边界（first = i + 1,last = length -1）;</li><li>如果i, first, last 三个数值大于0，则last左移，如果小于0，则first右移；</li><li>使得最终三数之和等于0，则成功找出一组。重复步骤2。</li></ol><p><strong>实现代码:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> threeSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> length = nums.length;</span><br><span class="line">  nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); <span class="comment">// 先排个队，最左边是最弱（小）的，最右边是最强(大)的</span></span><br><span class="line">  <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt; <span class="number">0</span> || nums[length - <span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length - <span class="number">2</span>; i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">let</span> first = i + <span class="number">1</span>, last = length - <span class="number">1</span>, sum;</span><br><span class="line">    <span class="keyword">while</span> (first &lt; last) &#123;</span><br><span class="line">      sum = nums[i] + nums[first] + nums[last];</span><br><span class="line">      <span class="keyword">if</span> (sum === <span class="number">0</span>) &#123;</span><br><span class="line">        res.push([nums[i], nums[first], nums[last]]);</span><br><span class="line">        <span class="keyword">while</span> (first &lt; last &amp;&amp; nums[first] === nums[++first]) &#123; &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (first &lt; last &amp;&amp; nums[first] === nums[++first]) &#123; &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (first &lt; last &amp;&amp; nums[last] === nums[--last]) &#123; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (nums[i] === nums[++i]) &#123; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度： O(n<sup>2</sup>)</li></ul><h3 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a><a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">16. 最接近的三数之和</a></h3><p><strong>解题思路</strong></p><p>思路同上一题类似，不同点在于此题是求最接近给定值的解。</p><p><strong>实现代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> threeSumClosest = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">let</span> length = nums.length;</span><br><span class="line">  <span class="keyword">let</span> result = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[length - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> first = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> last = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> sum;</span><br><span class="line">    <span class="keyword">while</span> (first &lt; last) &#123;</span><br><span class="line">      sum = nums[i] + nums[first] + nums[last];</span><br><span class="line">      sum &gt; target ? last-- : first++;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(target - result) &gt; <span class="built_in">Math</span>.abs(target - sum)) &#123;</span><br><span class="line">        result = sum;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度： O(n<sup>2</sup>)</li></ul><h3 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h3><p>算法：</p><p>在整个数组或在固定大小的滑动窗口中找到总和或最大值或最小值的问题可以通过动态规划（DP）在线性时间内解决。<br>有两种标准 DP 方法适用于数组：</p><ol><li>常数空间，沿数组移动并在原数组修改。</li><li>线性空间，首先沿 left-&gt;right 方向移动，然后再沿 right-&gt;left 方向移动。 合并结果。</li></ol><p>我们在这里使用第一种方法，因为可以修改数组跟踪当前位置的最大和。<br>下一步是在知道当前位置的最大和后更新全局最大和。</p><p><img src="https://s1.ax1x.com/2020/04/16/Jk1psf.png" class="lazyload" data-srcset="https://s1.ax1x.com/2020/04/16/Jk1psf.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Jk1psf.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">var</span> maxSubArray = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>, length = nums.length; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i - <span class="number">1</span>] &gt; <span class="number">0</span>) nums[i] += nums[i - <span class="number">1</span>]; <span class="comment">// index位上的值变为到这位为止的最大值</span></span><br><span class="line">    maxSum = <span class="built_in">Math</span>.max(nums[i], maxSum); <span class="comment">// 取当前位与历史位的最大值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析:</strong></p><ul><li><p>时间复杂度：O(N)。只遍历了一次数组。</p></li><li><p>空间复杂度：O(1)，使用了常数的空间。</p></li></ul><h3 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">239. 滑动窗口最大值</a></h3><p><strong>解题思路</strong></p><ul><li>使用 队列 方式维护一个滑动窗口内的数值索引，并确保队列队首值是当前滑动窗口的最大值索引</li><li>对应索引i来说，在i前面并且比i的值小的数值是没有价值的，可以剔除掉</li></ul><p><strong>实现代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSlidingWindow = <span class="function"><span class="keyword">function</span> (<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//queue保存 SlidingWindow 数据，其中首位是最大值的索引</span></span><br><span class="line">  <span class="keyword">const</span> queue = [], result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="comment">//剔除SlidingWindow外的数据</span></span><br><span class="line">    <span class="keyword">if</span> (i - queue[<span class="number">0</span>] &gt;= k) &#123;</span><br><span class="line">      queue.shift();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 剔除queue元素，确保queue首位保存的是最大值的索引</span></span><br><span class="line">    <span class="keyword">while</span> (nums[i] &gt; nums[queue[queue.length - <span class="number">1</span>]]) &#123;</span><br><span class="line">      queue.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    queue.push(i)</span><br><span class="line">    <span class="comment">//从k-1开始输出结果</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">      result.push(nums[queue[<span class="number">0</span>]])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">合并两个有序数组</a></h3><p>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</p><p>说明:</p><p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。<br>示例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], m = <span class="number">3</span></span><br><span class="line">nums2 = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>],       n = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong>：<br>nums1 、 nums2 有序，若把 nums2 全部合并到 nums1 ，则合并后的 nums1 长度为 m+n<br>我们可以从下标 m+n-1 的位置填充 nums1，循环比较 nums1[len1] 与 nums2[len2] 的大小，将最大值写入 nums1[len]。<br>边界条件：</p><ul><li>若 len1 &lt; 0， len2 &gt;= 0 ，此时 nums1 已重写入， nums2 还未合并完，只需将 nums2 的剩余元素写入 nums1 即可，写入后，合并完成；</li><li>若 len2 &lt; 0，此时 nums2 已全部合并到 nums1 ，合并完成。</li></ul><p><strong>实现代码：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">m</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span> (<span class="params">nums1, m, nums2, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len1 = m - <span class="number">1</span>,</span><br><span class="line">    len2 = n - <span class="number">1</span>,</span><br><span class="line">    len = m + n - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//若len2 &lt; 0,说明 nums2 已全部合并到 nums1 ，合并完成</span></span><br><span class="line">  <span class="keyword">while</span> (len2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (len1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 此时 nums1 已重写入， nums2 还未合并完，仅仅需要将 nums2 的剩余元素写入 nums1 即可</span></span><br><span class="line">      nums1[len--] = nums2[len2--];</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nums1[len--] = nums1[len1] &gt;= nums2[len2] ? nums1[len1--] : nums2[len2--]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度为 O(m+n)</li><li>空间复杂度为 O(1）</li></ul><h3 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a><a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">14. 最长公共前缀</a></h3><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 “”。<br>示例 1:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="string">"flower"</span>,<span class="string">"flow"</span>,<span class="string">"flight"</span>]</span><br><span class="line">输出: <span class="string">"fl"</span></span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="string">"dog"</span>,<span class="string">"racecar"</span>,<span class="string">"car"</span>]</span><br><span class="line">输出: <span class="string">""</span></span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong>：</p><p>本题的解题方法很多，比如：</p><ol><li>直接逐个比较;</li><li>寻找最大字符串与最小字符串，将问题化解为比较这两个字符串的大小（ace &gt; acd &gt; abc =&gt; 这三个字符串的最长公共前缀一定是ace与abc两者的最长公共前缀）</li><li>分治/归并策略： 将问题分解为每两个字符串的最长公共前缀，再归并为一，求得最后值。如下图：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200622161032.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200622161032.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><ol start="4"><li>利用Trie 树（字典树）<br>Trie 树，也称为字典树或前缀树，顾名思义，它是用来处理字符串匹配问题的数据结构，以及用来解决集合中查找固定前缀字符串的数据结构。</li></ol><p>下面以Trie树方式为例来实现，思路如下：<br>构建一个 Trie 树，字符串数组的最长公共序列就为从根节点开始遍历树，直到：</p><ul><li><p>遍历节点存在超过一个子节点的节点</p></li><li><p>或遍历节点为一个字符串的结束字符</p></li></ul><p>为止，走过的字符为字符串数组的最长公共前缀。</p><p>如图，以[“flower”,”flow”,”flight”]为例，最终结果为<code>&quot;fl&quot;</code><br><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200622162347.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200622162347.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20200622162347"></p><p><strong>实现代码</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longestCommonPrefix = <span class="function"><span class="keyword">function</span> (<span class="params">strs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (strs === <span class="literal">null</span> || strs.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">  <span class="comment">// 初始化 Trie 树</span></span><br><span class="line">  <span class="keyword">let</span> trie = <span class="keyword">new</span> Trie()</span><br><span class="line">  <span class="comment">// 构建 Trie 树</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!trie.insert(strs[i])) <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回最长公共前缀</span></span><br><span class="line">  <span class="keyword">return</span> trie.searchLongestPrefix()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> TrieNode = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// next 放入当前节点的子节点</span></span><br><span class="line">  <span class="keyword">this</span>.next = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 当前是否是结束节点</span></span><br><span class="line">  <span class="keyword">this</span>.isEnd = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trie 树</span></span><br><span class="line"><span class="keyword">var</span> Trie = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.root = <span class="keyword">new</span> TrieNode()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Trie.prototype.insert = <span class="function"><span class="keyword">function</span> (<span class="params">word</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!word) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> node = <span class="keyword">this</span>.root</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; word.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node.next[word[i]]) &#123;</span><br><span class="line">      node.next[word[i]] = <span class="keyword">new</span> TrieNode()</span><br><span class="line">    &#125;</span><br><span class="line">    node = node.next[word[i]]</span><br><span class="line">  &#125;</span><br><span class="line">  node.isEnd = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line">Trie.prototype.searchLongestPrefix = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> node = <span class="keyword">this</span>.root</span><br><span class="line">  <span class="keyword">let</span> prevs = <span class="string">''</span></span><br><span class="line">  <span class="keyword">while</span> (node.next) &#123;</span><br><span class="line">    <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(node.next)</span><br><span class="line">    <span class="keyword">if</span> (keys.length !== <span class="number">1</span>) <span class="keyword">break</span>; <span class="comment">//超过一个子节点的节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.next[keys[<span class="number">0</span>]].isEnd) &#123; <span class="comment">//节点为一个字符串的结束字符</span></span><br><span class="line">      prevs += keys[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    prevs += keys[<span class="number">0</span>]</span><br><span class="line">    node = node.next[keys[<span class="number">0</span>]]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> prevs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res = longestCommonPrefix([<span class="string">"flower"</span>, <span class="string">"flow"</span>, <span class="string">"flight"</span>])</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure></div><h2 id="链表类"><a href="#链表类" class="headerlink" title="链表类"></a>链表类</h2><div class="story post-story"><h3 id="常用方法总结：-1"><a href="#常用方法总结：-1" class="headerlink" title="常用方法总结："></a>常用方法总结：</h3><ul><li>快慢指针</li><li>标记位法</li></ul><h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">合并两个有序链表</a></h3><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line">输出：<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong><br>从链表头开始比较，l1 与 l2 是有序递增的，所以比较 l1.val 与 l2.val 的较小值就是合并后链表的最小值，次小值就是小节点的 next.val 与大节点的 val 比较的较小值，依次递归，直到递归到 l1 l2 均为 null</p><p>确定边界条件： 当递归到任意链表为 null ，直接将 next 指向另外的链表即可，不需要继续递归了</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeTwoLists</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l1 === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l2 === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l1.val &lt;= l2.val) &#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2)</span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = mergeTwoLists(l2.next, l1)</span><br><span class="line">        <span class="keyword">return</span> l2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141. 环形链表</a></h3><p>给定一个链表，判断链表中是否有环。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p>示例 1：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">-4</span>], pos = <span class="number">1</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200622140709.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200622140709.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20200622140709"></p><p>示例 2：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>], pos = <span class="number">0</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200622140800.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200622140800.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><p>示例 3：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>], pos = <span class="number">-1</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200622140841.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200622140841.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><p>方法一：标志法<br>给每个已遍历过的节点加标志位，遍历链表，当出现下一个节点已被标志时，则证明单链表有环</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hasCycle = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.flag)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head.flag = <span class="number">1</span>;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法二： 快慢指针法<br>设置快慢两个指针，遍历单链表，快指针一次走两步，慢指针一次走一步，如果单链表中存在环，则快慢指针终会指向同一个节点，否则直到快指针指向 null 时，快慢指针都不可能相遇。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasCycle = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head.next) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> fast = head.next.next, slow = head.next;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast.next)&#123; <span class="comment">// fast.next为null说明fast是链表终点，无环</span></span><br><span class="line">        <span class="keyword">if</span>(fast === slow )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法三： 利用 JSON.stringify() 不能序列化含有循环引用的结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasCycle = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">JSON</span>.stringify(head);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. 环形链表 II</a></h3><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p>说明：不允许修改给定的链表。</p><p><strong>解题思路：</strong></p><p>本题与上一题类似，增加的难度在于需要返回入环点。所以无法基于<code>JSON.stringify()</code>来实现了。<br>方法一： 标志法<br>此方法实现代码与上一题基本一样，只是返回值有所区别。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> detectCycle = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.flag)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        head.flag = <span class="number">1</span>;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法二： 快慢指针法</p><p>上一题中快慢指针相遇点（即<code>fast === slow</code>）肯定是环内某一点（注意不一定是入环点，所以本题不能直接返回这个节点）。</p><p>所以接下去主要工作是如何判断入环点？</p><p>基于上一题，我们设置fast指针速度是2，slow指针速度是1, fast速度是slow速度的2倍，所以最终相遇（<code>fast === slow</code>）时，fast走的距离也是slow走的距离的2倍。<br>具体分析如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A - 起点</span><br><span class="line">B - 第一次相遇点</span><br><span class="line">X - 入环点</span><br><span class="line">d1 - A-X距离</span><br><span class="line">d2 - X-B距离</span><br><span class="line">d3 - B-X距离</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200622145207.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200622145207.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20200622145207"></p><p>最后得出<code>d1 = d3</code>。那么就可以在上题基础上进行寻找入环点：</p><p>当fast和slow在B点相遇后，将fast重回A点。将两个指针均以速度1向前走，最终会在X点相遇（距离一样，速度一样，所以到X点的时间也一样），相遇时返回节点即可。</p><p>实现代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> detectCycle = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head.next) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> fast = head.next.next, slow = head.next;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast.next)&#123;<span class="comment">//fast.next为null说明fast是链表终点，无环</span></span><br><span class="line">        <span class="keyword">if</span>(fast === slow )&#123;</span><br><span class="line">            fast = head;</span><br><span class="line">            <span class="keyword">while</span>(fast !== slow)&#123;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/" target="_blank" rel="noopener">反转链表</a></h3><p><strong>解题思路</strong>：</p><p>定义一个反转链表prev, 循环head指针，将当前head指向prev，实现反转效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        <span class="comment">//临时存放下一个指针</span></span><br><span class="line">        <span class="keyword">let</span> next = head.next;</span><br><span class="line">        <span class="comment">//将当前节点指向prev，实现反转效果</span></span><br><span class="line">        head.next = prev;</span><br><span class="line">        <span class="comment">// 变更prev、head</span></span><br><span class="line">        prev = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">19. 删除链表的倒数第N个节点</a></h3><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。<br>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>, 和 n = <span class="number">2.</span></span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5.</span></span><br></pre></td></tr></table></figure><p><strong>解题思路</strong>：<br>需要删除链表中的倒数第 n 个节点，我们需要知道的就是倒数第 n+1 个节点，然后删除删除倒数第 n+1 节点的后继节点即可.</p><p>使用快慢指针思想来解决此问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeNthFromEnd = <span class="function"><span class="keyword">function</span>(<span class="params">head, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fast = head, slow = head</span><br><span class="line">    <span class="comment">// 快先走 n - 1 步</span></span><br><span class="line">    <span class="keyword">while</span>(--n) &#123;</span><br><span class="line">        fast = fast.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!fast.next) <span class="keyword">return</span> head.next;<span class="comment">//说明列表长度为n,删除头结点</span></span><br><span class="line">    fast = fast.next</span><br><span class="line">    <span class="comment">// fast、slow 一起前进</span></span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast.next) &#123;</span><br><span class="line">        fast = fast.next</span><br><span class="line">        slow = slow.next</span><br><span class="line">    &#125;</span><br><span class="line">    slow.next = slow.next.next</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">876. 链表的中间结点</a></h3><p><strong>解题思路</strong>：<br>使用快慢指针方法： 快指针速度2，慢指针速度1，当快指针到达终点时，慢指针刚好在中间节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> middleNode = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fast = head, slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast.next)&#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul></div><h2 id="动态规划类"><a href="#动态规划类" class="headerlink" title="动态规划类"></a>动态规划类</h2><div class="story post-story"><h3 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">309. 最佳买卖股票时机含冷冻期</a></h3><p>分析：</p><p>  第i天主要有三种情况，当天收益取三者最大值：</p><ol><li><p>当天持有此股票，那么股票可能是：<br>a. 前一天就持有的, 取值(dp[i - 1][0])，<br>b. 或者当天刚买的,取值(dp[i - 1][2] - prices[i]))，<br>这种情况的最大收益为： Math.max(dp[i - 1][0], dp[i - 1][2] - prices[i]);</p></li><li><p>当天卖出股票，则收益为前一天的持有收益 + 当天的股票价格收益， 即： dp[i - 1][0] + prices[i];</p></li><li><p>当天未持有，并且当天未卖出过，则有两种情况：<br>a. 前一天卖出过，dp[i-1][1]<br>b. 前一天未卖出， dp[i-1][2]。<br>这种情况的最大收益为： Math.max(dp[i - 1][1], dp[i - 1][2]);</p><p>第一天的初始值：dp[0] = [-prices[0], 0, 0];</p><p>代码实现：</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 最终的收益是当天的三种情况取最大</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; prices</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span> (<span class="params">prices</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = prices.length;</span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> dp = [];</span><br><span class="line">  dp.push([-prices[<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">let</span> t0, t1, t2;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    t0 = <span class="built_in">Math</span>.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]); <span class="comment">// 当天持有此股票</span></span><br><span class="line">    t1 = dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]; <span class="comment">// 当天未持有，并且当天卖出</span></span><br><span class="line">    t2 = <span class="built_in">Math</span>.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]); <span class="comment">//当天未持有，并且不是当天卖出</span></span><br><span class="line">    dp.push([t0, t1, t2]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(...dp.pop())</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="面试题-17-13-恢复空格"><a href="#面试题-17-13-恢复空格" class="headerlink" title="面试题 17.13. 恢复空格"></a><a href="https://leetcode-cn.com/problems/re-space-lcci/" target="_blank" rel="noopener">面试题 17.13. 恢复空格</a></h3><p>分析：<br>  遍历 sentence，如果i-1结尾的子字符串 等于 dictionary的某个word, 说明dp[i] 可以等于 dp[i - word.length]；</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">dictionary</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> <span class="variable">sentence</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> respace = <span class="function">(<span class="params">dictionary, sentence</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> len = sentence.length;</span><br><span class="line">  <span class="keyword">if</span> (len === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(len + <span class="number">1</span>);</span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123; <span class="comment">//i代表 Length(sentence)</span></span><br><span class="line">    dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> word <span class="keyword">of</span> dictionary) &#123;</span><br><span class="line">      <span class="keyword">if</span> (word === sentence.substring(i - word.length, i)) &#123;</span><br><span class="line">        dp[i] = <span class="built_in">Math</span>.min(dp[i], dp[i - word.length])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dp[len]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">96. 不同的二叉搜索树</a></h3><ul><li>思路:<br>标签：动态规划<br>假设n个节点存在二叉排序树的个数是dp(n)，令f(i)为以i为根的二叉搜索树的个数，则<br>dp(n) = f(1) + f(2) + f(3) + f(4) + … + f(n)</li></ul><p>当i为根节点时，其左子树节点个数为i-1个，右子树节点为n-i，则<br>f(i) = dp(i-1)*dp(n-i)</p><p>综合两个公式可以得到 <a href="https://segmentfault.com/a/1190000021666634" target="_blank" rel="noopener">卡特兰数</a> 公式<br>dp(n) = dp(0)<em>dp(n-1)+dp(1)</em>(n-2)+…+dp(n-1)*dp(0)</p><ul><li>代码实现：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numTrees = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).fill(<span class="number">0</span>);</span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123; <span class="comment">//以j为顶点的个数计算</span></span><br><span class="line">      dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从Chrome源码看JS Array的底层实现</title>
      <link href="/Chrome%E6%BA%90%E7%A0%81-array-knowledge/"/>
      <url>/Chrome%E6%BA%90%E7%A0%81-array-knowledge/</url>
      
        <content type="html"><![CDATA[<p>作为前端er，我们都知道，JS 的数组可以存放不同类型的元素、并且数组长度是可变的。不像其他的语言，比如C，创建的时候要决定数组的大小，如果数组满了，就要重新申请内存空间。</p><p>知道归知道，但是要想弄清楚其中原因，就得从Chrome源码去探究了。</p><a id="more"></a><h3 id="JS-Array为什么可以保存不同类型"><a href="#JS-Array为什么可以保存不同类型" class="headerlink" title="JS Array为什么可以保存不同类型"></a>JS Array为什么可以保存不同类型</h3><p>先看下Chrome V8对JSArray的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The JSArray describes JavaScript Arrays</span></span><br><span class="line"><span class="comment">//  Such an array can be in one of two modes:</span></span><br><span class="line"><span class="comment">//    - fast, backing storage is a FixedArray and length &lt;= elements.length();</span></span><br><span class="line"><span class="comment">//       Please note: push and pop can be used to grow and shrink the array.</span></span><br><span class="line"><span class="comment">//    - slow, backing storage is a HashTable with numbers as keys.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JSArray</span>:</span> <span class="keyword">public</span> JSObject &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// [length]: The length property.</span></span><br><span class="line">  DECL_ACCESSORS(length, Object)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Number of element slots to pre-allocate for an empty array.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kPreallocatedArrayElements = <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以看到 JSArray 是继承自 JSObject 的，所以在 JavaScript 中，数组可以是一个特殊的对象，内部是以 key-value 形式存储数据，所以 JavaScript 中的数组可以存放不同类型的值。</p><h3 id="JS-Array如何存储"><a href="#JS-Array如何存储" class="headerlink" title="JS Array如何存储"></a>JS Array如何存储</h3><p>从上述 V8 源码注释中可以看出，JSArray有两种存储方式：</p><ul><li>fast：存储结构是 FixedArray ，并且数组长度 &lt;= elements.length() ，push 或 pop 时可能会伴随着动态扩容或减容，源码里叫 <code>FastElements</code>;</li><li>slow：存储结构是 HashTable，并且数组下标作为 key,源码里叫 <code>SlowElements</code>;</li></ul><ol><li><p>快数组（FastElements）<br>FixedArray 是 V8 实现的一个类似于数组的类，它表示一段连续的内存，可以使用索引直接定位。新创建的空数组默认就是快数组。当数组满（数组的长度达到数组在内存中申请的内存容量最大值）的时候，继续 push 时， JSArray 会进行动态的扩容，以存储更多的元素。</p></li><li><p>慢数组（SlowElements）<br>慢数组以哈希表的形式存储在内存空间里，它不需要开辟连续的存储空间,节省了内存，但需要额外维护一个哈希表，性能相对较差。</p></li><li><p>什么时候会从 fast 转变为 slow</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/objects/js-objects.h</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint32_t</span> kMaxGap = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/objects/dictionary.h</span></span><br><span class="line"><span class="comment">// JSObjects prefer dictionary elements if the dictionary saves this much</span></span><br><span class="line"><span class="comment">// memory compared to a fast elements backing store.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint32_t</span> kPreferFastElementsSizeFactor = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/objects/js-objects-inl.h</span></span><br><span class="line"><span class="comment">// If the fast-case backing storage takes up much more memory than a dictionary</span></span><br><span class="line"><span class="comment">// backing storage would, the object should have slow elements.</span></span><br><span class="line"><span class="comment">// static</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ShouldConvertToSlowElements</span><span class="params">(<span class="keyword">uint32_t</span> used_elements,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="keyword">uint32_t</span> new_capacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> size_threshold = NumberDictionary::kPreferFastElementsSizeFactor *</span><br><span class="line">                            NumberDictionary::ComputeCapacity(used_elements) *</span><br><span class="line">                            NumberDictionary::kEntrySize;</span><br><span class="line">  <span class="comment">// 快数组新容量是扩容后的容量3倍之多时，也会被转成慢数组</span></span><br><span class="line">  <span class="keyword">return</span> size_threshold &lt;= new_capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ShouldConvertToSlowElements</span><span class="params">(JSObject object,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="keyword">uint32_t</span> capacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="keyword">uint32_t</span> index,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="keyword">uint32_t</span>* new_capacity)</span> </span>&#123;</span><br><span class="line">  STATIC_ASSERT(JSObject::kMaxUncheckedOldFastElementsLength &lt;=</span><br><span class="line">                JSObject::kMaxUncheckedFastElementsLength);</span><br><span class="line">  <span class="keyword">if</span> (index &lt; capacity) &#123;</span><br><span class="line">    *new_capacity = capacity;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当加入的索引值（例如例3中的2000）比当前容量capacity 大于等于 1024时，</span></span><br><span class="line">  <span class="comment">// 返回true，转为慢数组</span></span><br><span class="line">  <span class="keyword">if</span> (index - capacity &gt;= JSObject::kMaxGap) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  *new_capacity = JSObject::NewElementsCapacity(index + <span class="number">1</span>);</span><br><span class="line">  DCHECK_LT(index, *new_capacity);</span><br><span class="line">  <span class="comment">// TODO(ulan): Check if it works with young large objects.</span></span><br><span class="line">  <span class="keyword">if</span> (*new_capacity &lt;= JSObject::kMaxUncheckedOldFastElementsLength ||</span><br><span class="line">      (*new_capacity &lt;= JSObject::kMaxUncheckedFastElementsLength &amp;&amp;</span><br><span class="line">       ObjectInYoungGeneration(object))) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ShouldConvertToSlowElements(object.GetFastElementsUsage(),</span><br><span class="line">                                     *new_capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述源码看出，当处于以下情况时，快数组会被转变为慢数组：</p><ul><li>当加入的索引值 index 比当前容量 capacity 差值大于等于 1024 时（index - capacity &gt;= 1024）</li><li>快数组新容量是扩容后的容量 3 倍之多时</li></ul><p>增加一个2000的索引时，array就会被转成慢数组:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">array[<span class="number">2000</span>] = <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><ol start="4"><li>什么时候会从 slow 转变为 fast</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">ShouldConvertToFastElements</span><span class="params">(JSObject object,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        NumberDictionary dictionary,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">uint32_t</span> index,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">uint32_t</span>* new_capacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// If properties with non-standard attributes or accessors were added, we</span></span><br><span class="line">  <span class="comment">// cannot go back to fast elements.</span></span><br><span class="line">  <span class="keyword">if</span> (dictionary.requires_slow_elements()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// Adding a property with this index will require slow elements.</span></span><br><span class="line">  <span class="keyword">if</span> (index &gt;= <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(Smi::kMaxValue)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (object.IsJSArray()) &#123;</span><br><span class="line">    Object length = JSArray::cast(object).length();</span><br><span class="line">    <span class="keyword">if</span> (!length.IsSmi()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    *new_capacity = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(Smi::ToInt(length));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object.IsJSArgumentsObject()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    *new_capacity = dictionary.max_number_key() + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *new_capacity = Max(index + <span class="number">1</span>, *new_capacity);</span><br><span class="line">  <span class="keyword">uint32_t</span> dictionary_size = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(dictionary.Capacity()) *</span><br><span class="line">                             NumberDictionary::kEntrySize;</span><br><span class="line">  <span class="comment">// Turn fast if the dictionary only saves 50% space.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * dictionary_size &gt;= *new_capacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当慢数组的元素可存放在快数组中且长度在 <code>smi</code> 之间且仅节省了50%的空间(用慢数组节省的空间不大于50%),则会转变为快数组</p><blockquote><p>smi在64位平台为-2<sup>31</sup> 到 2<sup>31</sup> -1，在32位平台为-2<sup>30</sup> 到 2<sup>30</sup> -1</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line">a[<span class="number">1030</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">200</span>; i &lt; <span class="number">1030</span>; i++) &#123;</span><br><span class="line">    a[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 1030 的位置上面添加一个值，会造成多于 1024 个空洞，数组变成慢数组；<br>然后往这个数组中 200-1029 这些位置上赋值，使慢数组不再比快数组节省 50% 的空间，则数组变成快数组。</p><ol start="5"><li>总结</li></ol><p>快数组就是以空间换时间的方式，申请了大块连续内存，提高效率。 慢数组以时间换空间，不必申请连续的空间，节省了内存，但需要付出效率变差的代价。</p><h3 id="数组的动态扩容与减容"><a href="#数组的动态扩容与减容" class="headerlink" title="数组的动态扩容与减容"></a>数组的动态扩容与减容</h3><p>默认空数组初始化大小为 4 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Number of element slots to pre-allocate for an empty array.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kPreallocatedArrayElements = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>在 Chrome 源码中， push 的操作是用汇编实现的，在 c++ 里嵌入的汇编，以提高执行效率，并且在汇编的基础上用 c++ 封装了一层，在编译执行的时候，会将这些 c++ 代码转成汇编代码。</p><p>计算新容量的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// js-objects.h</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint32_t</span> kMinAddedElementsCapacity = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// code-stub-assembler.cc</span></span><br><span class="line"><span class="function">Node* <span class="title">CodeStubAssembler::CalculateNewElementsCapacity</span><span class="params">(Node* old_capacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      ParameterMode mode)</span> </span>&#123;</span><br><span class="line">  CSA_SLOW_ASSERT(<span class="keyword">this</span>, MatchesParameterMode(old_capacity, mode));</span><br><span class="line">  Node* half_old_capacity = WordOrSmiShr(old_capacity, <span class="number">1</span>, mode);</span><br><span class="line">  Node* new_capacity = IntPtrOrSmiAdd(half_old_capacity, old_capacity, mode);</span><br><span class="line">  Node* padding =</span><br><span class="line">      IntPtrOrSmiConstant(JSObject::kMinAddedElementsCapacity, mode);</span><br><span class="line">  <span class="keyword">return</span> IntPtrOrSmiAdd(new_capacity, padding, mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以扩容后新容量计公式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_capacity = old_capacity /<span class="number">2</span> + old_capacity + <span class="number">16</span></span><br></pre></td></tr></table></figure><p>即老的容量的 1.5 倍加上 16 。初始化为 4 个，当 push 第 5 个的时候，容量将会变成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_capacity = <span class="number">4</span> / <span class="number">2</span> + <span class="number">4</span> + <span class="number">16</span> = <span class="number">22</span></span><br></pre></td></tr></table></figure><p>接着申请一块这么大的内存，把老的数据拷过去，把新元素放在当前 length 位置，然后将数组的 length + 1，并返回 length。</p><p>整个过程，用户是无感知的，不像 C，需用用户手动申请内存空间。</p><p>当数组执行 pop 操作时，会判断 pop 后数组的容量，是否需要进行减容。</p><p>不同于数组的 push 使用汇编实现的， pop 使用 c++ 实现的。</p><p>判断是否进行减容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">2</span> * length &lt;= capacity) &#123;</span><br><span class="line">  <span class="comment">// If more than half the elements won't be used, trim the array.</span></span><br><span class="line">  isolate-&gt;heap()-&gt;RightTrimFixedArray(*backing_store, capacity - length);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Otherwise, fill the unused tail with holes.</span></span><br><span class="line">  BackingStore::cast(*backing_store)-&gt;FillWithHoles(length, old_length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，当数组 pop 后，如果数组容量大于等于 length 的 2 倍，则进行容量调整，使用 RightTrimFixedArray 函数，计算出需要释放的空间大小，做好标记，等待 GC 回收；如果数组容量小于 length 的 2 倍，则用 holes 对象填充。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>JavaScript 中， JSArray 继承自 JSObject ，是一个特殊的对象，内部是以 key-value 形式存储数据，所以 JavaScript 中的数组可以存放不同类型的值。</p><p>JSArray有两种存储方式，快数组与慢数组，初始化空数组时，使用快数组，快数组使用连续的内存空间，当快数组长度达到最大时，JSArray 会进行动态的扩容，以存储更多的元素，相对慢数组，性能要好得多。</p><p>当数组中 hole 太多时，会转变成慢数组，即以哈希表的方式（ key-value 的形式）存储数据，以节省内存空间。</p><h3 id="一道面试题-数组扁平化"><a href="#一道面试题-数组扁平化" class="headerlink" title="一道面试题 - 数组扁平化"></a>一道面试题 - 数组扁平化</h3><p>假如有个数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">5</span>]], <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>如何将其扁平化为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>核心思想： 遍历数组arr，若arr[i]为数组则递归遍历，直至arr[i]不为数组然后与之前的结果concat。</p><ol><li>ES6 flat</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.flat(<span class="literal">Infinity</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li>reduce</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">result, item</span>)=&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> result.concat(<span class="built_in">Array</span>.isArray(item) ? flatten(item) : item);</span><br><span class="line">    &#125;, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>toString / join</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.toString().split(<span class="string">','</span>).map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Number</span>(item);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>递归</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = [];</span><br><span class="line">    arr.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(item)) &#123;</span><br><span class="line">            res = res.concat(flatten(item));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>扩展运算符</li></ol><p>es6的扩展运算符能将二维数组变为一维</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(arr.some(<span class="function"><span class="params">item</span>=&gt;</span><span class="built_in">Array</span>.isArray(item))) &#123;</span><br><span class="line">        arr = [].concat(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考链接：<br><a href="https://github.com/sisterAn/JavaScript-Algorithms/issues/2" target="_blank" rel="noopener">前端进阶算法2：从Chrome V8源码看JavaScript数组</a></p>]]></content>
      
      
      <categories>
          
          <category> Chrome源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用系统命令汇总</title>
      <link href="/others-%E5%B8%B8%E7%94%A8%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/"/>
      <url>/others-%E5%B8%B8%E7%94%A8%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="端口检查"><a href="#端口检查" class="headerlink" title="端口检查"></a>端口检查</h3><ul><li>linux</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 192.168.1.102 3306</span><br></pre></td></tr></table></figure><ul><li>mac</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -vz -w 2 192.168.1.104 3306</span><br></pre></td></tr></table></figure><h3 id="查看端口占用"><a href="#查看端口占用" class="headerlink" title="查看端口占用"></a>查看端口占用</h3><ul><li>Centos7+</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lsof -i tcp:80  <span class="comment"># 查看80端口占用情况</span></span><br><span class="line"></span><br><span class="line">netstat -ntlp  <span class="comment"># 列出所有端口</span></span><br><span class="line"></span><br><span class="line">firewall-cmd --query-port=3306/tcp <span class="comment"># 查询是否开启3306端口</span></span><br><span class="line"></span><br><span class="line">firewall-cmd --zone=public --add-port=3306/tcp --permanent <span class="comment"># 开启端口</span></span><br><span class="line"></span><br><span class="line">firewall-cmd --zone=public --remove-port=3306/tcp --permanent <span class="comment"># 关闭端口</span></span><br><span class="line"></span><br><span class="line">firewall-cmd --reload <span class="comment">#重启防火墙</span></span><br></pre></td></tr></table></figure><h3 id="杀掉进程"><a href="#杀掉进程" class="headerlink" title="杀掉进程"></a>杀掉进程</h3><ul><li>Centos</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -tpnul <span class="comment"># 查看当前所有正在运行的进程</span></span><br><span class="line">ps aux |grep httpd <span class="comment"># 查看 httpd 进程</span></span><br><span class="line"><span class="built_in">kill</span> -9 6732 <span class="comment"># 6732为httpd进程对应的进程ID</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vulter + v2ray / Trojan 使用教程</title>
      <link href="/others-v2ray-manual/"/>
      <url>/others-v2ray-manual/</url>
      
        <content type="html"><![CDATA[<p>最近一直在使用的梯子服务临近到期，想要续费发现价格又涨了一波，再加上平时使用中并不是很稳定。就萌生了自建一个梯子的想法。</p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>要想自建梯子有两个前提：</p><ul><li>境外VPS服务器(虚拟专用服务器)</li><li>科学上网工具</li></ul><h4 id="VPS服务器"><a href="#VPS服务器" class="headerlink" title="VPS服务器"></a>VPS服务器</h4><p>对比了阿里云国际版、谷歌云、AWS等巨头产品，以及VULTR、搬瓦工等服务商，最终选择了<code>VULTR</code>，主要原因在于：</p><ol><li>价格便宜： 最便宜的有$2.5/月的服务，价格是王道；</li><li>机房众多：拥有日本、美国、欧洲等 17 个机房；</li><li>架构优秀：全部采用 KVM 架构、SSD 固态硬盘、500G/月流量起步；</li><li>后台强大 ：拥有系统快照、一键装机部署脚本、备份、防火墙等强大功能，从 VPS 这点丝毫不输给阿里云。</li><li>计费灵活 : 采用小时计费模式，可以任意的添加和删除机器 , 并且是单向流量收费 , 也就是只计算下载的的流量;</li><li>支持支付宝/微信支付，国内用户购买方便；</li></ol><p>注册购买请进入官网自行操作：<a href="https://www.vultr.com/" target="_blank" rel="noopener">vultr官网</a></p><h4 id="科学上网工具"><a href="#科学上网工具" class="headerlink" title="科学上网工具"></a>科学上网工具</h4><p>本文主要实现v2ray 和 Trojan 两个工具的搭建</p><h3 id="SSH免密登录vultr服务器"><a href="#SSH免密登录vultr服务器" class="headerlink" title="SSH免密登录vultr服务器"></a>SSH免密登录vultr服务器</h3><ol><li>在本机生成密钥（如果已经有了不用重复生成）：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><ol start="2"><li>将本地公钥拷贝到服务器的<code>~/.ssh/authorized_keys</code>目录中：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一</span></span><br><span class="line">ssh-copy-id user@ip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 法二</span></span><br><span class="line"><span class="comment"># 将 本机 ~/.ssh目录中的 id_rsa.pub 这个文件拷贝到服务器 的~/.ssh目录中</span></span><br><span class="line">scp ~/.ssh/id_rsa.pub user@ip:~/.ssh/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在服务器运行以下命令来将公钥导入到~/.ssh/authorized_keys这个文件中</span></span><br><span class="line">cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># authorized_keys的权限要是600。</span></span><br><span class="line">chmod 600 .ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>user: 服务器用户名，默认为root<br>ip: 服务器公网IP</p><p>至此，就可以用下面命令免密登录了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user@ip</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfopr1r33xj30pk0gpaar.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfopr1r33xj30pk0gpaar.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><h3 id="v2ray安装与配置"><a href="#v2ray安装与配置" class="headerlink" title="v2ray安装与配置"></a>v2ray安装与配置</h3><p>登录了云服务后，就可以开始下载安装v2ray了，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://install.direct/go.sh</span><br><span class="line"></span><br><span class="line">chmod +x go.sh</span><br><span class="line"></span><br><span class="line">./go.sh</span><br></pre></td></tr></table></figure><p>执行成功后，会输出 V2Ray v4.24.2 is installed. 等字样。</p><p>安装V2Ray后， 会在<code>/etc/v2ray/config.json</code>默认生成配置文件，我们需要编辑这个文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/v2ray/config.json</span><br></pre></td></tr></table></figure><p>然后连续按 d 键，将原本的文件内容清空，然后按 i 键开启编辑模式，复制以下配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"log"</span>: &#123;</span><br><span class="line">    <span class="attr">"access"</span>: <span class="string">"/var/log/v2ray/access.log"</span>,</span><br><span class="line">    <span class="attr">"error"</span>: <span class="string">"/var/log/v2ray/error.log"</span>,</span><br><span class="line">    <span class="attr">"loglevel"</span>: <span class="string">"warning"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"inbound"</span>: &#123;</span><br><span class="line">    <span class="attr">"port"</span>: <span class="number">9751</span>,</span><br><span class="line">    <span class="attr">"protocol"</span>: <span class="string">"vmess"</span>,</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">      <span class="attr">"clients"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"id"</span>: <span class="string">"392029fa-a9e0-42e3-93cb-97a9288795ed"</span>,</span><br><span class="line">          <span class="attr">"level"</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="attr">"alterId"</span>: <span class="number">100</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"streamSettings"</span>: &#123;</span><br><span class="line">      <span class="attr">"network"</span>: <span class="string">"tcp"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"detour"</span>: &#123;</span><br><span class="line">      <span class="attr">"to"</span>: <span class="string">"vmess-detour-118345"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"outbound"</span>: &#123;</span><br><span class="line">    <span class="attr">"protocol"</span>: <span class="string">"freedom"</span>,</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"inboundDetour"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"protocol"</span>: <span class="string">"vmess"</span>,</span><br><span class="line">      <span class="attr">"port"</span>: <span class="string">"10000-10010"</span>,</span><br><span class="line">      <span class="attr">"tag"</span>: <span class="string">"vmess-detour-118345"</span>,</span><br><span class="line">      <span class="attr">"settings"</span>: &#123;&#125;,</span><br><span class="line">      <span class="attr">"allocate"</span>: &#123;</span><br><span class="line">        <span class="attr">"strategy"</span>: <span class="string">"random"</span>,</span><br><span class="line">        <span class="attr">"concurrency"</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">"refresh"</span>: <span class="number">5</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"streamSettings"</span>: &#123;</span><br><span class="line">        <span class="attr">"network"</span>: <span class="string">"kcp"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"outboundDetour"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"protocol"</span>: <span class="string">"blackhole"</span>,</span><br><span class="line">      <span class="attr">"settings"</span>: &#123;&#125;,</span><br><span class="line">      <span class="attr">"tag"</span>: <span class="string">"blocked"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"routing"</span>: &#123;</span><br><span class="line">    <span class="attr">"strategy"</span>: <span class="string">"rules"</span>,</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">      <span class="attr">"rules"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"field"</span>,</span><br><span class="line">          <span class="attr">"ip"</span>: [</span><br><span class="line">            <span class="string">"0.0.0.0/8"</span>,</span><br><span class="line">            <span class="string">"10.0.0.0/8"</span>,</span><br><span class="line">            <span class="string">"100.64.0.0/10"</span>,</span><br><span class="line">            <span class="string">"127.0.0.0/8"</span>,</span><br><span class="line">            <span class="string">"169.254.0.0/16"</span>,</span><br><span class="line">            <span class="string">"172.16.0.0/12"</span>,</span><br><span class="line">            <span class="string">"192.0.0.0/24"</span>,</span><br><span class="line">            <span class="string">"192.0.2.0/24"</span>,</span><br><span class="line">            <span class="string">"192.168.0.0/16"</span>,</span><br><span class="line">            <span class="string">"198.18.0.0/15"</span>,</span><br><span class="line">            <span class="string">"198.51.100.0/24"</span>,</span><br><span class="line">            <span class="string">"203.0.113.0/24"</span>,</span><br><span class="line">            <span class="string">"::1/128"</span>,</span><br><span class="line">            <span class="string">"fc00::/7"</span>,</span><br><span class="line">            <span class="string">"fe80::/10"</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">"outboundTag"</span>: <span class="string">"blocked"</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述配置中可根据自己的喜好进行相应修改，也可直接使用不做修改。</p><p>保存并退出编辑模式，再启动v2ray服务，服务端的配置就完成了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start v2ray</span><br></pre></td></tr></table></figure><p>v2ray进程管理命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 v2ray 进程状态</span></span><br><span class="line">systemctl status v2ray</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start v2ray</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart v2ray</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">systemctl stop v2ray</span><br></pre></td></tr></table></figure><h3 id="配置防火墙"><a href="#配置防火墙" class="headerlink" title="配置防火墙"></a>配置防火墙</h3><p>CentOS 7 系统默认会开启防火墙，需要开放上面配置的端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --add-service=https</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">firewall-cmd --zone=public --add-port=9751/tcp --permanent</span><br></pre></td></tr></table></figure><p>– zone #作用域</p><p>– add-port=80/tcp #添加端口，格式为：端口/通讯协议</p><p>– permanent #永久生效，没有此参数重启后失效</p><p>防火墙其他相关命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld <span class="comment"># 查看防火墙状态</span></span><br><span class="line">firewall-cmd --reload <span class="comment">#重启firewall</span></span><br><span class="line">systemctl restart firewalld <span class="comment"># 重启2</span></span><br><span class="line">systemctl stop firewalld.service <span class="comment">#停止firewall</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service <span class="comment">#禁止firewall开机启动</span></span><br><span class="line">firewall-cmd --state <span class="comment">#查看默认防火墙状态（关闭后显示notrunning，开启后显示running）</span></span><br><span class="line"></span><br><span class="line">firewall-cmd --list-ports  <span class="comment"># 查看已经开放的端口</span></span><br></pre></td></tr></table></figure><p>至此，服务端部分就算完成了。下面开始客户端配置。</p><h3 id="V2Ray-客户端"><a href="#V2Ray-客户端" class="headerlink" title="V2Ray 客户端"></a>V2Ray 客户端</h3><ul><li>Mac端</li></ul><p>Mac端使用的是<a href="https://github.com/yichengchen/clashX/releases" target="_blank" rel="noopener">ClashX</a>客户端。安装下载后打开配置文件夹：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfoqnszotfj30ad0c0mya.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfoqnszotfj30ad0c0mya.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><p>新建一个<code>.yaml</code>配置文件，具体配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">port:</span> <span class="number">7890</span></span><br><span class="line"><span class="attr">socks-port:</span> <span class="number">7891</span></span><br><span class="line"><span class="attr">redir-port:</span> <span class="number">7892</span></span><br><span class="line"><span class="attr">allow-lan:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">mode:</span> <span class="string">Rule</span></span><br><span class="line"><span class="attr">log-level:</span> <span class="string">info</span></span><br><span class="line"><span class="attr">external-controller:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9090</span></span><br><span class="line"><span class="attr">secret:</span> <span class="string">""</span></span><br><span class="line"><span class="attr">cfw-bypass:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">localhost</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">127</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.16</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.17</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.18</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.19</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.20</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.21</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.22</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.23</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.24</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.25</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.26</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.27</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.28</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.29</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.30</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.31</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">192.168</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&lt;local&gt;</span></span><br><span class="line"><span class="attr">cfw-latency-timeout:</span> <span class="number">3000</span></span><br><span class="line"><span class="attr">Proxy:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">V2-NewJersey</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">vmess</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">208.167</span><span class="number">.222</span><span class="number">.200</span> <span class="comment"># 服务器公网IP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">"9751"</span> <span class="comment"># v2ray配置的端口</span></span><br><span class="line">    <span class="attr">uuid:</span> <span class="string">392029fa-a9e0-42e3-93cb-97a9288795ed</span> <span class="comment"># v2ray的uuid</span></span><br><span class="line">    <span class="attr">alterId:</span> <span class="string">"100"</span> <span class="comment"># v2ray的额外ID</span></span><br><span class="line">    <span class="attr">cipher:</span> <span class="string">auto</span></span><br><span class="line">    <span class="attr">network:</span> <span class="string">tcp</span> <span class="comment"># 传输协议</span></span><br><span class="line"><span class="attr">Proxy Group:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CroLAX</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">select</span></span><br><span class="line">    <span class="attr">proxies:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">V2-NewJersey</span></span><br><span class="line"><span class="attr">Rule:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN,hls.itunes.apple.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN,itunes.apple.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN,itunes.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,icloud.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,icloud-content.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,me.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,mzstatic.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,akadns.net,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,aaplimg.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,cdn-apple.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,apple.com,DIRECT</span></span><br><span class="line">  <span class="comment">## 国内网站</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,cn,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,-cn,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,126.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,126.net,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,127.net,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,163.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,360buyimg.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,36kr.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,acfun.tv,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,air-matters.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,aixifan.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,akamaized.net,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,alicdn,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,alipay,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,taobao,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,amap.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,autonavi.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,baidu,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,bdimg.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,bdstatic.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,bilibili.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,caiyunapp.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,clouddn.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,cnbeta.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,cnbetacdn.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,cootekservice.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,csdn.net,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ctrip.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,dgtle.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,dianping.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,douban.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,doubanio.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,duokan.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,easou.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ele.me,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,feng.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,fir.im,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,frdic.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,g-cores.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,godic.net,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,gtimg.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,hongxiu.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,hxcdn.net,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,iciba.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ifeng.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ifengimg.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ipip.net,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,iqiyi.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,jd.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,jianshu.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,knewone.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,le.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,lecloud.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,lemicp.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,licdn.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,linkedin.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,luoo.net,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,meituan.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,meituan.net,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,mi.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,miaopai.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,microsoft.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,microsoftonline.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,miui.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,miwifi.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,mob.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,netease.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,office.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,officecdn,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,office365.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,oschina.net,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ppsimg.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,pstatp.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,qcloud.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,qdaily.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,qdmm.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,qhimg.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,qhres.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,qidian.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,qihucdn.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,qiniu.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,qiniucdn.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,qiyipic.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,qq.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,qqurl.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,rarbg.to,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ruguoapp.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,segmentfault.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,sinaapp.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,smzdm.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,sogou.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,sogoucdn.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,sohu.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,soku.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,speedtest.net,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,sspai.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,suning.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,taobao.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,tencent.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,tenpay.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,tianyancha.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,tmall.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,tudou.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,umetrip.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,upaiyun.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,upyun.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,v2ex.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,veryzhun.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,weather.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,weibo.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,xiami.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,xiami.net,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,xiaomicp.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ximalaya.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,xmcdn.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,xunlei.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,yhd.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,yihaodianimg.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,yinxiang.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ykimg.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,youdao.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,youku.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,zealer.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,zhihu.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,zhimg.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,zimuzu.tv,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,netflix,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,nflx,CroLAX</span></span><br><span class="line">  <span class="comment">## 抗 DNS 污染</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,amazon,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,google,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,gmail,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,youtube,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,facebook,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,fb.me,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,fbcdn.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,twitter,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,instagram,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,dropbox,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,twimg.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,blogspot,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,youtu.be,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,whatsapp,CroLAX</span></span><br><span class="line">  <span class="comment">## 国外网站</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,9to5mac.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,abpchina.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,adblockplus.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,adobe.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,alfredapp.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,amplitude.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ampproject.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,android.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,angularjs.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,aolcdn.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,apkpure.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,appledaily.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,appshopper.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,appspot.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,arcgis.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,archive.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,armorgames.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,aspnetcdn.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,att.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,awsstatic.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,azureedge.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,azurewebsites.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,bing.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,bintray.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,bit.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,bit.ly,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,bitbucket.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,bjango.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,bkrtx.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,blog.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,blogcdn.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,blogger.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,blogsmithmedia.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,blogspot.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,blogspot.hk,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,bloomberg.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,box.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,box.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,cachefly.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,chromium.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,cl.ly,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,cloudflare.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,cloudfront.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,cloudmagic.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,cmail19.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,cnet.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,cocoapods.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,comodoca.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,crashlytics.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,culturedcode.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,d.pr,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,danilo.to,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,dayone.me,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,db.tt,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,deskconnect.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,disq.us,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,disqus.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,disquscdn.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,dnsimple.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,docker.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,dribbble.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,droplr.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,duckduckgo.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,dueapp.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,dytt8.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,edgecastcdn.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,edgekey.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,edgesuite.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,engadget.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,entrust.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,eurekavpt.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,evernote.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,fabric.io,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,fast.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,fastly.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,fc2.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,feedburner.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,feedly.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,feedsportal.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,fiftythree.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,firebaseio.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,flexibits.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,flickr.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,flipboard.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,g.co,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,gabia.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,geni.us,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,gfx.ms,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ggpht.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ghostnoteapp.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,git.io,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,github,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,globalsign.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,gmodules.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,godaddy.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,golang.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,gongm.in,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,goo.gl,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,goodreaders.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,goodreads.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,gravatar.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,gstatic.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,gvt0.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,hockeyapp.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,hotmail.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,icons8.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ift.tt,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ifttt.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,iherb.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,imageshack.us,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,img.ly,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,imgur.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,imore.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,instapaper.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ipn.li,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,is.gd,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,issuu.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,itgonglun.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,itun.es,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ixquick.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,j.mp,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,js.revsci.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,jshint.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,jtvnw.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,justgetflux.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,kat.cr,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,klip.me,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,libsyn.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,linode.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,lithium.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,littlehj.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,live.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,live.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,livefilestore.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,llnwd.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,macid.co,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,macromedia.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,macrumors.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,mashable.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,mathjax.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,medium.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,mega.co.nz,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,mega.nz,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,megaupload.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,microsofttranslator.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,mindnode.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,mobile01.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,modmyi.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,msedge.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,myfontastic.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,name.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,nextmedia.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,nsstatic.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,nssurge.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,nyt.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,nytimes.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,omnigroup.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,onedrive.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,onenote.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ooyala.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,openvpn.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,openwrt.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,orkut.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,osxdaily.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,outlook.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ow.ly,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,paddleapi.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,parallels.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,parse.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,pdfexpert.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,periscope.tv,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,pinboard.in,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,pinterest.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,pixelmator.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,pixiv.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,playpcesor.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,playstation.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,playstation.com.hk,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,playstation.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,playstationnetwork.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,pushwoosh.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,rime.im,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,servebom.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,sfx.ms,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,shadowsocks.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,sharethis.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,shazam.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,skype.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,smartdnsProxy.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,smartmailcloud.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,sndcdn.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,sony.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,soundcloud.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,sourceforge.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,spotify.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,squarespace.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,sstatic.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,st.luluku.pw,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,stackoverflow.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,startpage.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,staticflickr.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,steamcommunity.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,symauth.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,symcb.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,symcd.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,tapbots.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,tapbots.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,tdesktop.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,techcrunch.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,techsmith.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,thepiratebay.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,theverge.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,time.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,timeinc.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,tiny.cc,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,tinypic.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,tmblr.co,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,todoist.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,trello.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,trustasiassl.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,tumblr.co,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,tumblr.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,tweetdeck.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,tweetmarker.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,twitch.tv,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,txmblr.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,typekit.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ubertags.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ublock.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ubnt.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ulyssesapp.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,urchin.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,usertrust.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,v.gd,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,vimeo.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,vimeocdn.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,vine.co,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,vivaldi.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,vox-cdn.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,vsco.co,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,vultr.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,w.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,w3schools.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,webtype.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,wikiwand.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,wikileaks.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,wikimedia.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,wikipedia.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,wikipedia.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,windows.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,windows.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,wire.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,wordpress.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,workflowy.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,wp.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,wsj.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,wsj.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,xda-developers.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,xeeno.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,xiti.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,yahoo.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,yimg.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ying.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,yoyo.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ytimg.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,telegram.me,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IP-CIDR,91.108.4.0/22,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IP-CIDR,91.108.8.0/22,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IP-CIDR,91.108.56.0/22,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IP-CIDR,109.239.140.0/24,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IP-CIDR,149.154.160.0/20,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IP-CIDR,127.0.0.0/8,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IP-CIDR,172.16.0.0/12,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IP-CIDR,192.168.0.0/16,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IP-CIDR,10.0.0.0/8,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IP-CIDR,17.0.0.0/8,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IP-CIDR,100.64.0.0/10,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">GEOIP,CN,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">MATCH,,CroLAX</span></span><br></pre></td></tr></table></figure><p>主要关注注释代码部分，更加详细的ClashX配置说明请参加 <a href="https://www.v2rayssr.com/clashxx.html" target="_blank" rel="noopener">此文</a>。</p><ul><li>windows端</li></ul><p>windows端使用<a href="https://github.com/2dust/v2rayN/releases" target="_blank" rel="noopener">v2rayN</a>软件，安装后点击服务器 -&gt; 添加[VMess]服务器, 具体配置如下：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gformgphhaj30kh0gqq3b.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gformgphhaj30kh0gqq3b.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><h3 id="配置-BBR-加速"><a href="#配置-BBR-加速" class="headerlink" title="配置 BBR 加速"></a>配置 BBR 加速</h3><p>TCP BBR 是谷歌在 2016 年 9 月开源的一个优化 TCP 拥塞的算法，并且 Linux 内核从 4.9 版本开始集成该算法，据多方网友反馈，网速甚至可以提升好几个数量级，</p><p>一般新版的Linux操作系统以及自带了BBR，不需要手动安装，如果是老系统，可以执行下面命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载脚本</span></span><br><span class="line">wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可执行权限</span></span><br><span class="line">chmod +x bbr.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行bbr脚本</span></span><br><span class="line">./bbr.sh</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://raw.githubusercontent.com/cx9208/Linux-NetSpeed/master/tcp.sh</span><br><span class="line"></span><br><span class="line">chmod +x tcp.sh</span><br><span class="line"></span><br><span class="line">./tcp.sh</span><br></pre></td></tr></table></figure><p>我这边系统以及自带，运行bbr脚本后提示已经安装了，结果如下：<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfortv177sj30k109vq3t.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfortv177sj30k109vq3t.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><p>可以验证一下是否成功安装最新内核并开启 TCP BBR，输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">uname -r  <span class="comment"># &gt;&gt; 4.18.0-147.8.1.el8_1.x86_64</span></span><br><span class="line"></span><br><span class="line">sysctl net.ipv4.tcp_available_congestion_control  <span class="comment"># &gt;&gt; net.ipv4.tcp_available_congestion_control = reno cubic bbr</span></span><br><span class="line"></span><br><span class="line">sysctl net.ipv4.tcp_congestion_control <span class="comment"># &gt;&gt; net.ipv4.tcp_congestion_control = bbr</span></span><br><span class="line"></span><br><span class="line">sysctl net.core.default_qdisc <span class="comment"># &gt;&gt; net.core.default_qdisc = fq</span></span><br><span class="line"></span><br><span class="line">lsmod | grep bbr <span class="comment"># &gt;&gt; tcp_bbr                20480  9</span></span><br></pre></td></tr></table></figure><p>返回值有 tcp_bbr 模块即说明bbr已启动。</p><h3 id="Trojan安装教程"><a href="#Trojan安装教程" class="headerlink" title="Trojan安装教程"></a>Trojan安装教程</h3><p>Trojan是一个近两年兴起的网络工具，项目官网（<a href="https://github.com/trojan-gfw" target="_blank" rel="noopener">https://github.com/trojan-gfw</a>）。与强调加密和混淆的SS/SSR等工具不同，trojan将通信流量伪装成互联网上最常见的https流量，从而有效防止流量被检测和干扰。</p><p>使用Trojan需要一个指向服务器IP的<a href="https://www.hijk.pw/namesilo-buy-domain-tutorial/" target="_blank" rel="noopener">域名</a>以及域名证书。</p><h4 id="使用Let’s-Encrypt获取免费证书"><a href="#使用Let’s-Encrypt获取免费证书" class="headerlink" title="使用Let’s Encrypt获取免费证书"></a>使用Let’s Encrypt获取免费证书</h4><ul><li>开发端口</li></ul><p>certbot 默认使用http方式对域名所有权进行验证，该操作需要绑定vps的80端口。需要开发防火墙端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=443/tcp --permanent</span><br></pre></td></tr></table></figure><p>如果80端口已被占用，请先停止占用的进程，例如停止Nginx：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall nginx</span><br></pre></td></tr></table></figure><ul><li>安装certbot</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y python3 &amp;&amp; pip3 install certbot</span><br></pre></td></tr></table></figure><p>查看certbot使用方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p>为指定域名生成证书：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot certonly --standalone -d 域名1 -d 域名2</span><br></pre></td></tr></table></figure><p>查看域名证书的路径和国旗时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot certificates</span><br></pre></td></tr></table></figure><h4 id="安装trojan服务端"><a href="#安装trojan服务端" class="headerlink" title="安装trojan服务端"></a>安装trojan服务端</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bash -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/trojan-gfw/trojan-quickstart/master/trojan-quickstart.sh)</span>"</span></span><br></pre></td></tr></table></figure><p>该命令会下载最新版的trojan并安装。安装完毕后，trojan配置文件路径是 /usr/local/etc/trojan/config.json，其初始内容为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"run_type"</span>: <span class="string">"server"</span>,</span><br><span class="line">    <span class="attr">"local_addr"</span>: <span class="string">"0.0.0.0"</span>,</span><br><span class="line">    <span class="attr">"local_port"</span>: <span class="number">443</span>,</span><br><span class="line">    <span class="attr">"remote_addr"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="attr">"remote_port"</span>: <span class="number">80</span>,</span><br><span class="line">    <span class="attr">"password"</span>: [</span><br><span class="line">        <span class="string">"password1"</span>,</span><br><span class="line">        <span class="string">"password2"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"log_level"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"ssl"</span>: &#123;</span><br><span class="line">        <span class="attr">"cert"</span>: <span class="string">"/path/to/certificate.crt"</span>,</span><br><span class="line">        <span class="attr">"key"</span>: <span class="string">"/path/to/private.key"</span>,</span><br><span class="line">        <span class="attr">"key_password"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"cipher"</span>: <span class="string">"ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384"</span>,</span><br><span class="line">        <span class="attr">"cipher_tls13"</span>: <span class="string">"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384"</span>,</span><br><span class="line">        <span class="attr">"prefer_server_cipher"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"alpn"</span>: [</span><br><span class="line">            <span class="string">"http/1.1"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"reuse_session"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"session_ticket"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"session_timeout"</span>: <span class="number">600</span>,</span><br><span class="line">        <span class="attr">"plain_http_response"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"curves"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"dhparam"</span>: <span class="string">""</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"tcp"</span>: &#123;</span><br><span class="line">        <span class="attr">"prefer_ipv4"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"no_delay"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"keep_alive"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"reuse_port"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"fast_open"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"fast_open_qlen"</span>: <span class="number">20</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"mysql"</span>: &#123;</span><br><span class="line">        <span class="attr">"enabled"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"server_addr"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">        <span class="attr">"server_port"</span>: <span class="number">3306</span>,</span><br><span class="line">        <span class="attr">"database"</span>: <span class="string">"trojan"</span>,</span><br><span class="line">        <span class="attr">"username"</span>: <span class="string">"trojan"</span>,</span><br><span class="line">        <span class="attr">"password"</span>: <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>local_port：监听的端口，默认是443，除非端口被墙，不建议改成其他端口；</li><li>remote_addr和remote_port：非trojan协议时，将请求转发处理的地址和端口。可以是任意有效的ip/域名和端口号，默认是本机和80端口；</li><li>password：密码。需要几个密码就填几行，最后一行结尾不能有逗号；</li><li>cert和key：域名的证书和密钥，Let’s Encrypt申请的证书可用 certbot certificates 查看证书路径；</li><li>key_password：默认没有密码（如果证书文件有密码就要填上）；</li><li>alpn：建议填两行：http/1.1和h2，保持默认也没有问题。</li></ul><p>根据自己的情况修改配置，保存，然后设置开机启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> trojan</span><br></pre></td></tr></table></figure><p>启动Trojan：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start trojan</span><br></pre></td></tr></table></figure><p>检查是否运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -lp | grep trojan</span><br></pre></td></tr></table></figure><h4 id="证书自动更新"><a href="#证书自动更新" class="headerlink" title="证书自动更新"></a>证书自动更新</h4><p>Let’s Encrypt证书的有效期是三个月，超过期限则需要续签。证书续期可以手动完成，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop trojan</span><br><span class="line">certbot renew</span><br><span class="line">systemctl restart trojan</span><br></pre></td></tr></table></figure><p>也可以配置crontab任务自动续签，在/etc/crontab文件末添加一行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 1 */2 0 root systemctl stop trojan; /usr/<span class="built_in">local</span>/bin/certbot renew; systemctl restart trojan</span><br></pre></td></tr></table></figure><h3 id="Trojan客户端"><a href="#Trojan客户端" class="headerlink" title="Trojan客户端"></a>Trojan客户端</h3><p>以Mac端使用ClashX客户端为例，配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Proxy:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">trojan_NJ5</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">trojan</span></span><br><span class="line">    <span class="attr">server:</span> <span class="string">nj5.kobingo.xyz</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">OF54OAJN3WZ66882</span></span><br><span class="line">    <span class="comment"># udp: true</span></span><br><span class="line">    <span class="comment"># sni: example.com # aka server name</span></span><br><span class="line">    <span class="attr">alpn:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">h2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">http/1.1</span></span><br><span class="line">    <span class="comment"># skip-cert-verify: true</span></span><br></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://trojan-gfw.github.io/trojan/" target="_blank" rel="noopener">Trojan官网</a></li><li><a href="https://tlanyan.me/trojan-tutorial/" target="_blank" rel="noopener">trojan教程</a></li><li><a href="https://github.com/hijkpw/scripts" target="_blank" rel="noopener">https://github.com/hijkpw/scripts</a></li><li><a href="https://www.hijk.pw/trojan-one-click-scrip/" target="_blank" rel="noopener">trojan一键脚本</a></li><li><a href="https://www.hijk.pw/namesilo-buy-domain-tutorial/" target="_blank" rel="noopener">Namesilo购买域名详细教程</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 梯子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打造赏心悦目的Mac终端</title>
      <link href="/others-zsh/"/>
      <url>/others-zsh/</url>
      
        <content type="html"><![CDATA[<p>本文主要讲解如何基于iTerm2 + Oh My Zsh 打造赏心悦目的Mac终端，以及如何配置终端代理等。</p><a id="more"></a><h3 id="下载iTerm2"><a href="#下载iTerm2" class="headerlink" title="下载iTerm2"></a>下载iTerm2</h3><p>可以直接去官网下载：<a href="https://www.iterm2.com/" target="_blank" rel="noopener">https://www.iterm2.com/</a></p><p>安装完成后，在/bin目录下会多出一个zsh的文件。</p><p>Mac系统自带很多Shell，可以通过命令查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/shells</span><br></pre></td></tr></table></figure><p>结果如下：<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfnavctvytj30ep05wdg2.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfnavctvytj30ep05wdg2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><p>由于Mac默认使用dash作为终端，所以首先修改为默认使用zsh：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure><p>这就是iTerm2初始的样子，下面我们来美化它，让它变得好用又好看！</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfn91wrixhj30vo0p40u7.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfn91wrixhj30vo0p40u7.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><h3 id="安装Oh-my-zsh"><a href="#安装Oh-my-zsh" class="headerlink" title="安装Oh my zsh"></a>安装Oh my zsh</h3><p>oh-my-zsh开源地址：<a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh</a></p><p>主要有<code>curl</code>和<code>wget</code>两种安装方式，可任选一种进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># curl 安装方式</span></span><br><span class="line">sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wget 安装方式</span></span><br><span class="line">sh -c <span class="string">"<span class="variable">$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)</span>"</span></span><br></pre></td></tr></table></figure><p>安装命令和安装完成后的截图：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfn92cdy3oj312a0q27a7.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfn92cdy3oj312a0q27a7.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><h3 id="安装PowerLine"><a href="#安装PowerLine" class="headerlink" title="安装PowerLine"></a>安装PowerLine</h3><p><a href="http://powerline.readthedocs.io/en/latest/installation.html" target="_blank" rel="noopener">Powerline</a>是agnoster主题的依赖。具体可以在repo里查询到：<br><a href="https://github.com/agnoster/agnoster-zsh-theme" target="_blank" rel="noopener">https://github.com/agnoster/agnoster-zsh-theme</a></p><p>安装powerline的方式依然简单，也只需要一条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install powerline-status --user</span><br></pre></td></tr></table></figure><p>没有安装pip的同学可能会碰到zsh: command not found: pip。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfn92zc4clj30dg024dg6.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfn92zc4clj30dg024dg6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><p>使用命令安装pip即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo easy_install pip</span><br></pre></td></tr></table></figure><p>安装后再次执行安装powerline的命令即可。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfn93bjfetj31mg08u77d.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfn93bjfetj31mg08u77d.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><h3 id="安装PowerFonts"><a href="#安装PowerFonts" class="headerlink" title="安装PowerFonts"></a>安装PowerFonts</h3><p>安装字体库需要首先将项目git clone至本地，然后执行源码中的install.sh。</p><p>在你习惯的位置新建一个文件夹，如：~/Desktop/OpenSource/</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfn93sc6fgj30di038aah.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfn93sc6fgj30di038aah.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><p>在此文件夹下执行git clone命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git clone</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/powerline/fonts.git --depth=1</span><br><span class="line"><span class="comment"># cd to folder</span></span><br><span class="line"><span class="built_in">cd</span> fonts</span><br><span class="line"><span class="comment"># run install shell</span></span><br><span class="line">./install.sh</span><br></pre></td></tr></table></figure><p>执行结果如下：<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfn93zramcj31z60fyago.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfn93zramcj31z60fyago.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><p>安装好字体库之后，我们来设置iTerm2的字体，具体的操作是iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Text，在Font区域选中Change Font，然后找到Meslo LG字体。有L、M、S可选，看个人喜好：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfn94aieloj310f0u011l.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfn94aieloj310f0u011l.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><h3 id="安装配色方案"><a href="#安装配色方案" class="headerlink" title="安装配色方案"></a>安装配色方案</h3><p>配色方案在使用VIM或Colorful Log时会变得非常有用，同时界面也不会一片黑绿一样死板。</p><p>同样使用git clone的方式下载源码进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/Desktop/OpenSource</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/altercation/solarized</span><br><span class="line"><span class="built_in">cd</span> solarized/iterm2-colors-solarized/</span><br><span class="line">open .</span><br></pre></td></tr></table></figure><p>在打开的finder窗口中，双击Solarized Dark.itermcolors和Solarized Light.itermcolors即可安装明暗两种配色：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfn94su0j7j31570u07f1.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfn94su0j7j31570u07f1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><p>再次进入iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Colors -&gt; Color Presets中根据个人喜好选择这两种配色中的一种即可：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfn950gf0ej30zx0u04db.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfn950gf0ej30zx0u04db.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><p>下载agnoster主题，执行脚本安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/Desktop/OpenSource</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/fcamblor/oh-my-zsh-agnoster-fcamblor.git</span><br><span class="line"><span class="built_in">cd</span> oh-my-zsh-agnoster-fcamblor/</span><br><span class="line">./install</span><br></pre></td></tr></table></figure><p>执行上面的命令会将主题拷贝到oh my zsh的themes中：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfn95ek4pfj30vo0ra7a0.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfn95ek4pfj30vo0ra7a0.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><p>拷贝完成后，执行命令打开zshrc配置文件，将ZSH_THEME后面的字段改为agnoster。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.zshrc</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/sirius1024/pubimgs/master/blogs/iterm2/11.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/sirius1024/pubimgs/master/blogs/iterm2/11.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="ImageInitIterm"></p><p>修改完成后按一下esc调出vi命令，输入:wq保存并退出vi模式。</p><p>此时command+Q或source配置文件后，iTerm2变了模样：</p><p><img src="https://raw.githubusercontent.com/sirius1024/pubimgs/master/blogs/iterm2/12.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/sirius1024/pubimgs/master/blogs/iterm2/12.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="ImageInitIterm"></p><h3 id="安装高亮插件"><a href="#安装高亮插件" class="headerlink" title="安装高亮插件"></a>安装高亮插件</h3><p>这是oh my zsh的一个插件，安装方式与theme大同小异：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.oh-my-zsh/custom/plugins/</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git</span><br><span class="line">vi ~/.zshrc</span><br></pre></td></tr></table></figure><p>这时我们再次打开zshrc文件进行编辑。找到plugins，此时plugins中应该已经有了git，我们需要把高亮插件也加上：</p><p><img src="https://raw.githubusercontent.com/sirius1024/pubimgs/master/blogs/iterm2/13.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/sirius1024/pubimgs/master/blogs/iterm2/13.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="ImageInitIterm"></p><p>请务必保证插件顺序，zsh-syntax-highlighting必须在最后一个。</p><p>然后在文件的最后一行添加：source ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</p><p>按一下esc调出vi命令，输入:wq保存并退出vi模式。</p><p>执行命令使刚才的修改生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure><p>至此大功告成，请看最终效果图：</p><p><img src="https://raw.githubusercontent.com/sirius1024/pubimgs/master/blogs/iterm2/14.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/sirius1024/pubimgs/master/blogs/iterm2/14.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="ImageInitIterm"></p><p>背景图片取自微软Surface Studio的4K壁纸(将近12MB大小)，非常漂亮，需要的可以自取：</p><p><a href="https://pan.baidu.com/s/1LKd4ghGyyNI6UwHhOHvfaA" target="_blank" rel="noopener">https://pan.baidu.com/s/1LKd4ghGyyNI6UwHhOHvfaA</a><br>提取码: snrd</p><p>更换背景图片方式：iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Window -&gt; BackGround Image勾选图片即可。</p><h3 id="可选择、命令补全"><a href="#可选择、命令补全" class="headerlink" title="可选择、命令补全"></a>可选择、命令补全</h3><p>跟代码高亮的安装方式一样，这也是一个zsh的插件，叫做zsh-autosuggestion，用于命令建议和补全。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.oh-my-zsh/custom/plugins/</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions</span><br><span class="line">vi ~/.zshrc</span><br></pre></td></tr></table></figure><p>找到plugins，加上这个插件即可：</p><p><img src="https://raw.githubusercontent.com/sirius1024/pubimgs/master/blogs/iterm2/15.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/sirius1024/pubimgs/master/blogs/iterm2/15.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="ImageInitIterm"></p><p>插件效果：</p><p><img src="https://raw.githubusercontent.com/sirius1024/pubimgs/master/blogs/iterm2/16.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/sirius1024/pubimgs/master/blogs/iterm2/16.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="ImageInitIterm"></p><p>有同学说补全命令的字体不太清晰，与背景颜色太过相近，其实可以自己调整一下字体颜色。</p><p>Preferences -&gt; Profiles -&gt; Colors 中有Foreground是标准字体颜色，ANSI Colors中Bright的第一个是补全的字体颜色。</p><h3 id="VScode显示异常问题"><a href="#VScode显示异常问题" class="headerlink" title="VScode显示异常问题"></a>VScode显示异常问题</h3><p>在经过上面配置后，发现VScode上的终端显示异常，主要原因是前面配置的agnoster主题需要PowerFonts字体的支持。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfna0fzj8zj30jc06bt8v.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfna0fzj8zj30jc06bt8v.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><p>所以需要在VScode里设置字体（比如：<code>Meslo LG L for Powerline</code>）：<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfna2gfm6lj30kh0cg75k.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfna2gfm6lj30kh0cg75k.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><p>完成后，显示正常：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfna3j770hj30ll05rdg1.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfna3j770hj30ll05rdg1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><h3 id="使用代理"><a href="#使用代理" class="headerlink" title="使用代理"></a>使用代理</h3><p>由于GFW的存在，平时用终端安装npm包，或者clone GitHub上的仓库等操作时，经常速度是可怜的10K/s甚至不到的速度，即便开了 SS / V2Ray 等代理服务，貌似在终端上没什么卵用😭（其实主要原因是这些代理服务走的是会话层，而item的命令走在网络层，层级更低，所以流量无法用过代理转发）。</p><blockquote><p>如果你用的是VPN方式代理，那么估计你没有这个烦恼</p><p>原因是主流的VPN协议（包括PPTP / L2TP / OPENVPN / SSTP）跑在第二层（数据链路层）和第三层（网络层），基本可以说是全流量代理。</p></blockquote><p>那有没有什么方法可以让iterm上的流量能走代理从而提高下载速度呢？</p><p>答案是有的！</p><blockquote><p>下面的操作的前提是你自己有有可用的代理服务</p></blockquote><p>编辑~/.zshrc:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure><p>在配置的最下面添加如下代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function useProxy() &#123;</span><br><span class="line">  export https_proxy=http://127.0.0.1:7890;</span><br><span class="line">  export http_proxy=http://127.0.0.1:7890;</span><br><span class="line">  export all_proxy=socks5://127.0.0.1:7891;</span><br><span class="line">  echo 'open proxy successful';</span><br><span class="line">&#125;</span><br><span class="line">function closeProxy() &#123;</span><br><span class="line">  unset https_proxy;</span><br><span class="line">  unset http_proxy;</span><br><span class="line">  unset all_proxy;</span><br><span class="line">  echo 'close proxy successful';</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">alias openP='useProxy'</span><br><span class="line">alias closeP='closeProxy'</span><br></pre></td></tr></table></figure><p>保存更改，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure><p>接着只要在终端执行<code>openP</code>就能打开终端代理，执行<code>closeP</code>就能关闭终端代理</p><h3 id="ZSH常用技能"><a href="#ZSH常用技能" class="headerlink" title="ZSH常用技能"></a>ZSH常用技能</h3><ul><li>自动补全<ul><li>ZSH的补全功能非常贴心，按TAB可以补全命令、路径还有参数。</li></ul></li><li>杀进程<ul><li>Bash杀进程需要先用<code>ps aux | grep xxx</code>查找进程的PID，然后才能用<code>kill PID</code>。ZSH可以直接就<code>kill xxx</code>后按TAB会显示对应的PID，非常方便。</li></ul></li><li>历史记录<ul><li>ZSH的history可以跨session，可以共享，这样就一进行历史记录的受限查询。比如，输入git，再按向上箭头，会搜索前面所有的git命令。</li></ul></li><li>通配符搜索<ul><li>l <em>.png查找当前目录下所有png文件，l **/</em>.png递归查找。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac终端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用软件大全</title>
      <link href="/others-%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
      <url>/others-%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<h2 id="windows篇"><a href="#windows篇" class="headerlink" title="windows篇"></a>windows篇</h2><div class="story post-story"><h3 id="1-Listary"><a href="#1-Listary" class="headerlink" title="1. Listary"></a>1. Listary</h3><p>它不仅可以在本地非常快速的搜索，还可以打开网站、在搜索引擎中搜索、随时随地打开快捷菜单、文件快速定位、快速打开cmd窗口等等优秀的功能；</p><p>比如输入 cmd打开cmd窗口，输入 cmda使用管理员权限打开cmd窗口，输入 wyyyy打开网易云音乐，找到某个文件的时候 Enter直接打开， Ctrl+Enter 是打开文件所在文件夹；</p><p>值得一提的是搜索关键词功能，让我们可以非常便捷的打开相应网站或在对应网站搜索，比如输入 gg我的存款呢？就可以直接使用默认浏览器在谷歌搜索中搜索了，我们还可以自定义输入其他关键字，只需把搜索链接中的关键字换成 {query} ~</p><h3 id="2-uTools"><a href="#2-uTools" class="headerlink" title="2. uTools"></a>2. uTools</h3><p>可以作为程序启动器外，uTools最大的特点就是拥有强大的插件系统，每个插件都有简洁美观、易于操作的界面，输入plugins进入插件管理，你就可以根据自己的需求挑选安装，组合成自己最趁手的工具合集，为各种日常操作提供便利。不断产生的新插件，也将为你带来无限可能。</p><blockquote><p>个人常用图床、剪切板、todo、各种技术文档等</p></blockquote><h3 id="3-Ditto"><a href="#3-Ditto" class="headerlink" title="3. Ditto"></a>3. Ditto</h3><p>Ditto 是一款免费开源的windows剪切板管理工具，作为 CtrlC V工程师，复制粘贴少不了，更厉害的是，可以用它来批量的复制， Ctrl+C一堆别人的代码，一次性全粘上，岂不美哉；</p><p>使用快捷键打开剪切板历史，然后 Ctrl/Shift来选择你希望粘贴的内容， Enter即可选择性的粘贴多行内容；另外剪切板历史还可以搜索，快速找到复制内容；</p><p>只需设置寥寥几个快捷键，就可以很方便的操作剪切板，带来极大幸福~<br><img src="http://yanxuan.nosdn.127.net/10fd3cf8452793dde3fd68c9d914f044.png" class="lazyload" data-srcset="http://yanxuan.nosdn.127.net/10fd3cf8452793dde3fd68c9d914f044.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="UTOOLS1590592067470.png"></p><h3 id="4-Winsnap"><a href="#4-Winsnap" class="headerlink" title="4. Winsnap"></a>4. Winsnap</h3><p>看到上面的截图没，旁边都有很骚包的阴影，怎么做到的？不需要各种高大上的图片处理软件，只需 Winsnap ，它可以在截图的时候自动帮你加上背景阴影，然后帮你自动复制到剪切板；</p><p>它可以使用全屏、应用程序、窗口、对象等捕捉模式，更牛的是它还可以在截图的时候同时选择和捕捉多个对象，按住 Ctrl或 Shift选择多个窗口或对象…这个就比较厉害了，不信你试试？</p><p><img src="http://yanxuan.nosdn.127.net/89455e91edbd563fc808103fd3662506.png" class="lazyload" data-srcset="http://yanxuan.nosdn.127.net/89455e91edbd563fc808103fd3662506.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="UTOOLS1590592103032.png"></p><h3 id="5-Cmder"><a href="#5-Cmder" class="headerlink" title="5. Cmder"></a>5. Cmder</h3><p>Cmder 是一个美观又实用的命令行工具，它支持大部分Linux命令，支持ssh连Linux，还可以在它的窗口中新建cmd和powershell，更多玩法等你来战~</p><p>比较方便的是在安装目录下 \config\user-aliases.cmd设置 alias 别名，比如参见的 Git 操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ga=git add $*</span><br><span class="line"></span><br><span class="line">gb=git branch $*</span><br><span class="line"></span><br><span class="line">gc=git commit $*</span><br><span class="line"></span><br><span class="line">gch=git checkout $*</span><br><span class="line"></span><br><span class="line">gd=git diff $*</span><br><span class="line"></span><br><span class="line">gl=git <span class="built_in">log</span> $*</span><br><span class="line"></span><br><span class="line">gs=git status $*</span><br></pre></td></tr></table></figure><p>还可以将cmder配置到右键菜单，快捷在当前目录打开cmder，方法是先把这个地址加到系统的path环境变量里面，比如我的是 D:cmder，然后右键 Cmder.exe属性-兼容性-以管理员身份运行此程序，再重新打开 Cmder.exe输入 Cmder.exe/REGISTER ALL就行了~</p><p>记得安装完在配置 Setting-Startup-Environment里面加上 setLANG=zh_CN.UTF8，否则输出的一些中文会乱码；</p><p><img src="http://yanxuan.nosdn.127.net/4eca0107c4b9cf08de8de8ae6ec58269.png" class="lazyload" data-srcset="http://yanxuan.nosdn.127.net/4eca0107c4b9cf08de8de8ae6ec58269.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="UTOOLS1590592268002.png"></p><h3 id="6-Typora"><a href="#6-Typora" class="headerlink" title="6. Typora"></a>6. Typora</h3><p>使用过很多 Markdown 编辑器，最后选择了 Typora，与主流编辑器一边编辑一边预览的形式，Typora 是将编辑和预览合并到一起，简洁大方，目光也不需要在复杂的编辑区和预览区中来回切换了，只有当焦点移入的时候才显示 Markdown 语法；</p><p>另外 Typora 还支持 Latex、 [TOC]动态目录、拖拽图片自动生成本地预览链接、自定义主题等方便的功能；<br><img src="http://yanxuan.nosdn.127.net/f6c6fec071e757f18925e5c034a16c59.png" class="lazyload" data-srcset="http://yanxuan.nosdn.127.net/f6c6fec071e757f18925e5c034a16c59.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="UTOOLS1590592303191.png"></p><h3 id="7-Quick-Look"><a href="#7-Quick-Look" class="headerlink" title="7. Quick Look"></a>7. Quick Look</h3><p>QuickLook 是在 Microsoft Store 里面下载的一个速览工具，有时候打开一个PDF、TXT、图片之类的需要等关联程序启动半天，有了它之后只要选中目标文件，按空格，就可以快速预览了，速度非常快，支持图片、视频、音频、压缩包、PDF、文本文件、Markdown、HTML等格式；</p><p>用它来看一些代码什么的，甚至不需要 Sublime\VSCode 启动就可以直接看了，如果只是速览一下的话是非常适合的了。</p><h3 id="8-Myper-Splash"><a href="#8-Myper-Splash" class="headerlink" title="8. Myper Splash"></a>8. Myper Splash</h3><p>Myper Splash 也是可以在 Microsoft Store 里面下载的一款高质量壁纸库，所有壁纸来源 Unsplash 网站，均无版权可以免费使用，再加上简洁美观的UI/UX设计，让你体验一见钟情的感觉。</p><p>另外 MyperSplash 可以设置自动每天自动更换壁纸或锁屏，每天早晨来到办公室点亮屏幕就可以看到 Awesome 的锁屏或壁纸，让你带着好心情开启一天的工作。</p><h3 id="9-GifCam-ScreenToGif"><a href="#9-GifCam-ScreenToGif" class="headerlink" title="9. GifCam / ScreenToGif"></a>9. GifCam / ScreenToGif</h3><p>相信大家都有过需要截一个 Gif 的时候，这里有两个免费 Gif 屏幕录制工具都很不错，小而美的 GifCam 和开源强大的 ScreenToGif ；</p><h3 id="10-Free-Download-Manage"><a href="#10-Free-Download-Manage" class="headerlink" title="10. Free Download Manage"></a>10. Free Download Manage</h3><p>Free Download Manage (FDM) 是一款免费的下载工具，如果你已经受够了国内一些软件的广告和限速，那么 FDM 是一个不错的选择，另外多线程、断点续传、计划任务等功能让 FDM 值得推介。</p><h3 id="11-Sourcetree"><a href="#11-Sourcetree" class="headerlink" title="11. Sourcetree"></a>11. Sourcetree</h3><p>Sourcetree 是跨平台免费的 Git 客户端管理工具，如果受够了手打各种 Git 操作命令，那么 Sourcetree 是一个不错的选择；</p><p>Sourcetree 可以大大简化你的代码操作，特别是对于一些不甚熟悉 Git 命令的人来说灰常实用；一些对 Git 操作比较熟练的用户也可以用它来提升效率，减少出错。</p></div>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> software </tag>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centOS7安装Java环境</title>
      <link href="/others-centOS7%E5%AE%89%E8%A3%85Java%E7%8E%AF%E5%A2%83/"/>
      <url>/others-centOS7%E5%AE%89%E8%A3%85Java%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>记录一次在阿里云（系统CentOS 7.4 64位）安装配置Java环境的过程</p><a id="more"></a><h3 id="1-选择合适的jdk版本"><a href="#1-选择合适的jdk版本" class="headerlink" title="1. 选择合适的jdk版本"></a>1. 选择合适的jdk版本</h3><blockquote><p><a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html" target="_blank" rel="noopener">jdk下载地址</a></p></blockquote><p>选择一下版本获取下载链接<br><img src="http://yanxuan.nosdn.127.net/3f479b3d56b3bfc9acad57e9a09fa94f.png" class="lazyload" data-srcset="http://yanxuan.nosdn.127.net/3f479b3d56b3bfc9acad57e9a09fa94f.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="UTOOLS1590136537164.png"></p><h3 id="2-下载"><a href="#2-下载" class="headerlink" title="2. 下载"></a>2. 下载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.oracle.com/otn/java/jdk/8u251-b08/3d5a2bb8f8d4428bbe94aed7ec7ae784/jdk-8u251-linux-x64.tar.gz?AuthParam=1590135363_2f6dbe12605da3b1164a50e7c1a8db7b</span><br></pre></td></tr></table></figure><blockquote><p>此链接地址可能失效，请自行在步骤1中获取最新下载链接</p></blockquote><p>下载后检查安装包大小是否符合预期（判断安装包是否损坏）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -lht</span><br></pre></td></tr></table></figure><p><img src="http://yanxuan.nosdn.127.net/a9167b8a26ab786fadfaad86f432d0e9.png" class="lazyload" data-srcset="http://yanxuan.nosdn.127.net/a9167b8a26ab786fadfaad86f432d0e9.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="UTOOLS1590136951543.png"></p><h3 id="3-安装"><a href="#3-安装" class="headerlink" title="3. 安装"></a>3. 安装</h3><p>3.1. 创建安装目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/local/java/</span><br></pre></td></tr></table></figure><p>3.2 解压到安装目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf jdk-8u251-linux-x64.tar.gz?AuthParam=1590135363_2f6dbe12605da3b1164a50e7c1a8db7b -C /usr/local/java</span><br></pre></td></tr></table></figure><h3 id="4-配置环境变量"><a href="#4-配置环境变量" class="headerlink" title="4. 配置环境变量"></a>4. 配置环境变量</h3><p>打开profile文件</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vim</span> /etc/<span class="keyword">profile</span></span><br></pre></td></tr></table></figure><p>在末尾添加一下代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/java/jdk1.8.0_251</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure><p>使环境变量生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>添加软链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/local/java/jdk1.8.0_251/bin/java /usr/bin/java</span><br></pre></td></tr></table></figure><p>验证是否安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p><img src="http://yanxuan.nosdn.127.net/7e0334391843b73fbfbc4963591ab65e.png" class="lazyload" data-srcset="http://yanxuan.nosdn.127.net/7e0334391843b73fbfbc4963591ab65e.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="UTOOLS1590137306874.png"></p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> centOS </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECMAScript新特性</title>
      <link href="/javascript-ECMAScript%E7%89%B9%E6%80%A7%E5%88%86%E6%9E%90/"/>
      <url>/javascript-ECMAScript%E7%89%B9%E6%80%A7%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>2015年6月发布了ES 6，也就是我们今天广泛使用的版本。这之后每年6月发布一个极小更新的ES版本，比如2016年6月发布的 ES  2016 叫做ES 7，而这个版本只增加了两个新特性。截止目前，ES 11的提案已经定稿了。</p><a id="more"></a><h2 id="ES-7-新特性"><a href="#ES-7-新特性" class="headerlink" title="ES 7 新特性"></a>ES 7 新特性</h2><div class="story post-story"><table><thead><tr><th align="left">功能点</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Array.prototype.includes</td><td align="left">查找数组</td></tr><tr><td align="left">Exponentiation operator</td><td align="left">指数函数的中缀表示法</td></tr></tbody></table><h3 id="Array-prototype-includes"><a href="#Array-prototype-includes" class="headerlink" title="Array.prototype.includes"></a>Array.prototype.includes</h3><p>includes是一个Array上很有用的方法，用于快速查找数组中是否包含某个元素，包括NaN（和indexOf不一样的点)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (arr.includes(<span class="number">2</span>)) &#123;</span><br><span class="line">  <span class="comment">//查找2是否存在于arr数组中</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"找到了!"</span>); <span class="comment">//&gt;&gt; 找到了！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!arr.includes(<span class="number">2</span>, <span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="comment">//第二个参数3表示数组下标为3的项，也即第4项开始查找</span></span><br><span class="line">  <span class="built_in">console</span>.warn(<span class="string">"不存在!"</span>); <span class="comment">//&gt;&gt; 不存在！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面两句说明incluedes和indexOf的区别</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="literal">NaN</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="literal">NaN</span>) != <span class="number">-1</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h3 id="指数函数用法"><a href="#指数函数用法" class="headerlink" title="指数函数用法"></a>指数函数用法</h3><p>JavaScript采用两个星符号**来表示Math.pow，相对于Math.pow的好处：</p><ol><li>中缀表示法比函数表示法更简洁，这使它更可取。</li><li>方便数学、物理、机器人学等领域的计算。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用法一：x ** y</span></span><br><span class="line"><span class="keyword">let</span> squared = <span class="number">2</span> ** <span class="number">2</span>;<span class="comment">//等同于: 2 * 2</span></span><br><span class="line"><span class="keyword">let</span> cubed = <span class="number">2</span> ** <span class="number">3</span>;<span class="comment">//等同于: 2 * 2 * 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用法二：x **= y</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">a **= <span class="number">2</span>;<span class="comment">//等同于: a = a * a;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">3</span>;</span><br><span class="line">b **= <span class="number">3</span>;<span class="comment">//等同于: b = b * b * b;</span></span><br></pre></td></tr></table></figure></div><h2 id="ES-8-新特性"><a href="#ES-8-新特性" class="headerlink" title="ES 8 新特性"></a>ES 8 新特性</h2><div class="story post-story"><table><thead><tr><th align="left">功能点</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Object.values / Object.entries</td><td align="left"></td></tr><tr><td align="left">String padding</td><td align="left">字符串追加</td></tr><tr><td align="left">Object.getOwnPropertyDescriptors</td><td align="left">返回指定对象自己所有的属性内容</td></tr><tr><td align="left">Async functions</td><td align="left">异步函数</td></tr><tr><td align="left">Shared memory and atomics</td><td align="left">共享内存和 Atomics 对象</td></tr></tbody></table><h3 id="Object-values-Object-entries"><a href="#Object-values-Object-entries" class="headerlink" title="Object.values() / Object.entries"></a>Object.values() / Object.entries</h3><ul><li>Object.values(obj)，obj 参数是对目标对象的操作，它可以是一个对象或者数组</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">x</span>: <span class="string">'xxx'</span>, <span class="attr">y</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.values(obj); <span class="comment">// ['xxx', 1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = [<span class="string">'e'</span>, <span class="string">'s'</span>, <span class="string">'8'</span>]; <span class="comment">// 等同于 &#123; 0: 'e', 1: 's', 2: '8' &#125;;</span></span><br><span class="line"><span class="built_in">Object</span>.values(obj); <span class="comment">// ['e', 's', '8']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当把数字对象的当键的时候，返回的数组以键的值升序排序</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="number">10</span>: <span class="string">'xxx'</span>, <span class="number">1</span>: <span class="string">'yyy'</span>, <span class="number">3</span>: <span class="string">'zzz'</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.values(obj); <span class="comment">// ['yyy', 'zzz', 'xxx']</span></span><br><span class="line"><span class="built_in">Object</span>.values(<span class="string">'es8'</span>); <span class="comment">// ['e', 's', '8']</span></span><br></pre></td></tr></table></figure><ul><li>Object.entries方法返回一个给定对象可枚举属性值的数组[key, value]，与Object.values类似</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">x</span>: <span class="string">'xxx'</span>, <span class="attr">y</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.entries(obj); <span class="comment">// [['x', 'xxx'], ['y', 1]]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = [<span class="string">'e'</span>, <span class="string">'s'</span>, <span class="string">'8'</span>];</span><br><span class="line"><span class="built_in">Object</span>.entries(obj); <span class="comment">// [['0', 'e'], ['1', 's'], ['2', '8']]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="number">10</span>: <span class="string">'xxx'</span>, <span class="number">1</span>: <span class="string">'yyy'</span>, <span class="number">3</span>: <span class="string">'zzz'</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.entries(obj); <span class="comment">// [['1', 'yyy'], ['3', 'zzz'], ['10', 'xxx']]</span></span><br><span class="line"><span class="built_in">Object</span>.entries(<span class="string">'es8'</span>); <span class="comment">// [['0', 'e'], ['1', 's'], ['2', '8']]</span></span><br></pre></td></tr></table></figure><h3 id="字符串追加"><a href="#字符串追加" class="headerlink" title="字符串追加"></a>字符串追加</h3><p>在 ES 8 中String新增了两个实例函数String.prototype.padStart和String.prototype.padEnd，允许将空字符串或其他字符串添加到原始字符串的开头或结尾。<br><code>String.padStart(targetLength,[padString])</code><br>targetLength：当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。<br>padString：(可选)填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断，此参数的缺省值为空格。<br><code>String.padEnd(targetLength,padString]) 参数释义同上。</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'es8'</span>.padStart(<span class="number">2</span>);          <span class="comment">// 'es8'</span></span><br><span class="line"><span class="string">'es8'</span>.padStart(<span class="number">5</span>);          <span class="comment">// '  es8'</span></span><br><span class="line"><span class="string">'es8'</span>.padStart(<span class="number">6</span>, <span class="string">'1891'</span>);  <span class="comment">// '189es8'</span></span><br><span class="line"><span class="string">'es8'</span>.padStart(<span class="number">14</span>, <span class="string">'coffe'</span>);  <span class="comment">// 'coffecoffecoffes8'</span></span><br><span class="line"><span class="string">'es8'</span>.padStart(<span class="number">7</span>, <span class="string">'0'</span>);     <span class="comment">// '0000es8'</span></span><br><span class="line"></span><br><span class="line"><span class="string">'es8'</span>.padEnd(<span class="number">2</span>);            <span class="comment">// 'es8'</span></span><br><span class="line"><span class="string">'es8'</span>.padEnd(<span class="number">5</span>);            <span class="comment">// 'es8  '</span></span><br><span class="line"><span class="string">'es8'</span>.padEnd(<span class="number">6</span>, <span class="string">'1891'</span>);    <span class="comment">// 'es81891'</span></span><br><span class="line"><span class="string">'es8'</span>.padEnd(<span class="number">14</span>, <span class="string">'coffe'</span>);    <span class="comment">// 'es8coffecoffecoff'</span></span><br><span class="line"><span class="string">'es8'</span>.padEnd(<span class="number">7</span>, <span class="string">'9'</span>);       <span class="comment">// 'es89999'</span></span><br></pre></td></tr></table></figure><h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors"></a>Object.getOwnPropertyDescriptors</h3><p><code>getOwnPropertyDescriptors</code>方法返回指定对象自己所有的属性内容，并且属性内容只是自身直接定义的，而不是从object的原型继承而来的。<br>定义是：<code>Object.getOwnPropertyDescriptors(obj)</code>，<code>obj</code> 是指目标对象，这个方法返回的值可能是 configurable、enumerable、writable、get、set 和 value。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="keyword">get</span> es7() &#123; <span class="keyword">return</span> <span class="number">7</span>; &#125;,</span><br><span class="line">  <span class="keyword">get</span> es8() &#123; <span class="keyword">return</span> <span class="number">8</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptors(obj);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   es7: &#123;</span></span><br><span class="line"><span class="comment">//     configurable: true,</span></span><br><span class="line"><span class="comment">//     enumerable: true,</span></span><br><span class="line"><span class="comment">//     get: function es7()&#123;&#125;, //the getter function</span></span><br><span class="line"><span class="comment">//     set: undefined</span></span><br><span class="line"><span class="comment">//   &#125;,</span></span><br><span class="line"><span class="comment">//   es8: &#123;</span></span><br><span class="line"><span class="comment">//     configurable: true,</span></span><br><span class="line"><span class="comment">//     enumerable: true,</span></span><br><span class="line"><span class="comment">//     get: function es8()&#123;&#125;, //the getter function</span></span><br><span class="line"><span class="comment">//     set: undefined</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>getOwnPropertyDescriptors可以用来创建子类：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">superclass</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">superclass.prototype = &#123;</span><br><span class="line">  <span class="comment">// 在这里定义方法和属性</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subclass</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">subclass.prototype = <span class="built_in">Object</span>.create(superclass.prototype, <span class="built_in">Object</span>.getOwnPropertyDescriptors(&#123;</span><br><span class="line">  <span class="comment">// 在这里定义方法和属性</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h3 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h3><p>Async Functions也就是我们常说的Async/Await,已经用的很频繁了，在此不再赘述。</p><h3 id="SharedArrayBuffer-amp-Atomics"><a href="#SharedArrayBuffer-amp-Atomics" class="headerlink" title="SharedArrayBuffer &amp; Atomics"></a>SharedArrayBuffer &amp; Atomics</h3><p>SharedArrayBuffer 对象用来表示一个通用的，固定长度的原始二进制数据缓冲区，类似于 ArrayBuffer 对象，它们都可以用来在共享内存（shared memory）上创建视图。与 ArrayBuffer 不同的是，SharedArrayBuffer 不能被分离。</p><blockquote><p>请注意，作为对Spectre的响应，所有主流浏览器均默认于2018年1月5日禁用SharedArrayBuffer。 Chrome在启用了网站隔离功能的平台上的v67中重新启用了该功能，以防止出现Spectre风格的漏洞。</p></blockquote><ul><li>语法：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>length 所创建的数组缓冲区的大小，以字节(byte)为单位。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;SharedArrayBuffer&#125;</span> </span>一个大小指定的新 SharedArrayBuffer 对象。其内容被初始化为 0。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">new</span> SharedArrayBuffer(length)</span><br></pre></td></tr></table></figure><p>共享内存能被同时创建和更新于工作者线程或主线程。依赖于系统（CPU，操作系统，浏览器），变化传递给所有上下文环境需要一段时间。需要通过 atomic 操作来进行同步。</p><p><code>Atomics</code> 对象提供了一组静态方法用来对 <code>SharedArrayBuffer</code> 对象进行原子操作。这些原子操作属于 <code>Atomics</code> 模块。与一般的全局对象不同，Atomics 不是构造函数，因此不能使用 new 操作符调用，也不能将其当作函数直接调用。Atomics 的所有属性和方法都是静态的（与 <code>Math</code>  对象一样）。</p><p>多个共享内存的线程能够同时读写同一位置上的数据。原子操作会确保正在读或写的数据的值是符合预期的，即下一个原子操作一定会在上一个原子操作结束后才会开始，其操作过程不会中断。</p><table><thead><tr><th align="left">方法名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Atomics/add" target="_blank" rel="noopener">Atomics.add()</a></td><td align="left">将指定位置上的数组元素与给定的值相加，并返回相加前该元素的值</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Atomics/and" target="_blank" rel="noopener">Atomics.and()</a></td><td align="left">将指定位置上的数组元素与给定的值相与，并返回与操作前该元素的值。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Atomics/compareExchange" target="_blank" rel="noopener">Atomics.compareExchange()</a></td><td align="left">如果数组中指定的元素与给定的值相等，则将其更新为新的值，并返回该元素原先的值。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Atomics/exchange" target="_blank" rel="noopener">Atomics.exchange()</a></td><td align="left">将数组中指定的元素更新为给定的值，并返回该元素更新前的值。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Atomics/load" target="_blank" rel="noopener">Atomics.load()</a></td><td align="left">返回数组中指定元素的值。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Atomics/or" target="_blank" rel="noopener">Atomics.or()</a></td><td align="left">将指定位置上的数组元素与给定的值相或，并返回或操作前该元素的值。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Atomics/store" target="_blank" rel="noopener">Atomics.store()</a></td><td align="left">将数组中指定的元素设置为给定的值，并返回该值。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Atomics/sub" target="_blank" rel="noopener">Atomics.sub()</a></td><td align="left">将指定位置上的数组元素与给定的值相减，并返回相减前该元素的值。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Atomics/xor" target="_blank" rel="noopener">Atomics.xor()</a></td><td align="left">将指定位置上的数组元素与给定的值相异或，并返回异或操作前该元素的值。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Atomics/wait" target="_blank" rel="noopener">Atomics.wait()</a></td><td align="left">检测数组中某个指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒或超时。返回值为 “ok”、”not-equal” 或 “time-out”。调用时，如果当前线程不允许阻塞，则会抛出异常（大多数浏览器都不允许在主线程中调用 wait()）。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Atomics/wake" target="_blank" rel="noopener">Atomics.wake()</a></td><td align="left">唤醒等待队列中正在数组指定位置的元素上等待的线程。返回值为成功唤醒的线程数量。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Atomics/isLockFree" target="_blank" rel="noopener">Atomics.isLockFree(size)</a></td><td align="left">可以用来检测当前系统是否支持硬件级的原子操作。对于指定大小的数组，如果当前系统支持硬件级的原子操作，则返回 true；否则就意味着对于该数组，Atomics 对象中的各原子操作都只能用锁来实现。此函数面向的是技术专家。</td></tr></tbody></table></div><h2 id="ES-9-新特性"><a href="#ES-9-新特性" class="headerlink" title="ES 9 新特性"></a>ES 9 新特性</h2><div class="story post-story"><table><thead><tr><th align="left">新特性</th><th align="left">中文说明</th></tr></thead><tbody><tr><td align="left">Asynchronous Iteration</td><td align="left">异步迭代器</td></tr><tr><td align="left"><code>Promise.prototype.finally</code></td><td align="left"></td></tr><tr><td align="left">Lifting template literal restriction</td><td align="left">重新修订了字面量的转义</td></tr><tr><td align="left">Rest/Spread Properties</td><td align="left">Rest/Spread 属性</td></tr><tr><td align="left"><code>s</code> (dotAll) flag for regular expressions</td><td align="left">正则表达式dotAll模式</td></tr><tr><td align="left">RegExp named capture groups</td><td align="left">正则表达式命名捕获组</td></tr><tr><td align="left">RegExp Lookbehind Assertions</td><td align="left">正则表达式反向断言</td></tr><tr><td align="left">RegExp Unicode Property Escapes</td><td align="left">正则表达式 Unicode 转义</td></tr></tbody></table><h3 id="异步迭代器"><a href="#异步迭代器" class="headerlink" title="异步迭代器"></a>异步迭代器</h3><p>在<code>async</code>/<code>await</code>的某些时刻，你可能尝试在同步循环中调用异步函数。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> array) &#123;</span><br><span class="line">    <span class="keyword">await</span> someFunc(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码不会达到预期目的，下面这段同样也不会：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  array.forEach(<span class="keyword">async</span> i =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> someFunc(i);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码中，循环本身依旧保持同步，并在内部异步函数之前全部调用完成。</p><p>引入异步迭代器后，就像常规迭代器，除了<code>next()</code>方法返回一个Promise。因此<code>await</code>可以和<code>for...of</code>循环一起使用，以串行的方式运行异步操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> i <span class="keyword">of</span> array) &#123;<span class="comment">//异步迭代</span></span><br><span class="line">    someFunc(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多详细论述见“壹.2.12”。</p><h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally"></a>Promise.prototype.finally</h3><p>一个Promise调用链要么成功到达最后一个<code>.then()</code>，要么失败触发<code>.catch()</code>。在某些情况下，你想要在无论Promise运行成功还是失败，运行相同的代码，例如清除数组、删除对话、关闭数据库连接等，<code>.finally()</code>允许实现这样的目的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  promiseFunc() <span class="comment">//返回一个Promise对象</span></span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;)</span><br><span class="line">    .finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//无论promiseFunc()运行成功还是失败，这里的代码会被调用到</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多详细论述见“壹.2.12”。</p><h3 id="重新修订了字面量的转义"><a href="#重新修订了字面量的转义" class="headerlink" title="重新修订了字面量的转义"></a>重新修订了字面量的转义</h3><p>ES9 之前，<code>\u</code>表示 unicode 转义，<code>\x</code>表示十六进制转义，<code>\</code>后跟一个数字表示八进制转义，这使得创建特定的字符串变得不可能，例如Windows文件路径<code>C:\uuu\xxx\111</code>。</p><p>要取消转义序列的语法限制，可在模板字符串之前使用标记函数<code>String.raw</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">`\u&#123;54&#125;`</span> <span class="comment">//会转义成unicode "T"</span></span><br><span class="line"><span class="built_in">console</span>.log(s);<span class="comment">//&gt;&gt; T</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="built_in">String</span>.raw<span class="string">`\u&#123;54&#125;`</span>; <span class="comment">//不会被转义</span></span><br><span class="line"><span class="built_in">console</span>.log(str);<span class="comment">//&gt;&gt; \u&#123;54&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Rest-Spread-属性"><a href="#Rest-Spread-属性" class="headerlink" title="Rest / Spread 属性"></a>Rest / Spread 属性</h3><p>这个就是我们通常所说的三个点<code>...</code>，在<code>=</code>左边的是<strong>rest参数</strong>，放在<code>=</code>右边或者作为参数的是<strong>扩展运算符</strong>，这项特性在ES6中已经引入，但是ES6中的作用对象仅限于数组。在ES9中，为对象提供了像数组一样的rest参数和扩展运算符：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; a, ...param &#125; = obj; <span class="comment">//这里...是rest参数</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//&gt;&gt; 1</span></span><br><span class="line"><span class="built_in">console</span>.log(param); <span class="comment">//&gt;&gt; &#123;b: 2, c: 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123; a, ...param &#125;</span>) </span>&#123;<span class="comment">//这里...是扩展运算符</span></span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">//&gt;&gt; 1</span></span><br><span class="line">  <span class="built_in">console</span>.log(param); <span class="comment">//&gt;&gt; &#123;b: 2, c: 3&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正则表达式dotAll模式"><a href="#正则表达式dotAll模式" class="headerlink" title="正则表达式dotAll模式"></a>正则表达式dotAll模式</h3><p>正则表达式中点<code>.</code>匹配除回车外的任何单字符，标记<code>s</code>改变这种行为，允许匹配回车换行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/hello.world/.test(<span class="string">'hello\nworld'</span>);  <span class="comment">// false</span></span><br><span class="line">/hello.world/s.test(<span class="string">'hello\nworld'</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/hello.world/</span>s.test(<span class="string">`hello</span></span><br><span class="line"><span class="string">world`</span>))   <span class="comment">//&gt;&gt; true</span></span><br></pre></td></tr></table></figure><h3 id="正则表达式命名捕获组"><a href="#正则表达式命名捕获组" class="headerlink" title="正则表达式命名捕获组"></a>正则表达式命名捕获组</h3><p>Javascript正则表达式中使用<code>exec()</code>匹配后，能够返回一个包含匹配字符串的类数组对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reDate = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>,</span><br><span class="line">  match = reDate.exec(<span class="string">"2018-08-06"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(match);<span class="comment">//&gt;&gt; [2018-08-06, 2018, 08, 06]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这样就可以直接用索引来获取年月日：</span></span><br><span class="line"><span class="keyword">let</span> year = match[<span class="number">1</span>]; <span class="comment">//&gt;&gt; 2018</span></span><br><span class="line"><span class="keyword">let</span> month = match[<span class="number">2</span>]; <span class="comment">//&gt;&gt; 08</span></span><br><span class="line"><span class="keyword">let</span> day = match[<span class="number">3</span>]; <span class="comment">//&gt;&gt; 06</span></span><br></pre></td></tr></table></figure><p>返回数组的第0项为与正则表达式相匹配的文本，第 1 项是与 <code>reDate</code> 的第 1 个分组<code>\d{4}</code>相匹配的文本（如果有的话），第 2 项是与 <code>reDate</code> 的第 2 个分组<code>\d{2}</code>相匹配的文本（如果有的话），以此类推。正则表达式的组以<code>()</code>包起来。</p><p>上面的案例，若是日期格式变成<code>月日年</code>，那么改变正则表达式的结构后，还有可能会改变变量的赋值部分的代码。如下示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reDate = <span class="regexp">/(\d&#123;2&#125;)-(\d&#123;2&#125;)-(\d&#123;4&#125;)/</span>,<span class="comment">//表达式结构变化了</span></span><br><span class="line">  match = reDate.exec(<span class="string">"08-06-2018"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(match);<span class="comment">//&gt;&gt; [08-06-2018, 08, 06, 2018]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此时年月日的赋值代码也要改了,改的地方真多啊！怎么办？</span></span><br><span class="line"><span class="keyword">let</span> year = match[<span class="number">3</span>]; <span class="comment">//&gt;&gt; 2018</span></span><br><span class="line"><span class="keyword">let</span> month = match[<span class="number">1</span>]; <span class="comment">//&gt;&gt; 08</span></span><br><span class="line"><span class="keyword">let</span> day = match[<span class="number">2</span>]; <span class="comment">//&gt;&gt; 06</span></span><br></pre></td></tr></table></figure><p>可以发现上面的写法改的地方太多了，有没有办法少改点代码省省事呢？有！ ES9 允许使用符号<code>?&lt;name&gt;</code>来命名<strong>捕获组</strong>（也即“匹配到的组”），示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reDate = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span>,</span><br><span class="line">  match = reDate.exec(<span class="string">"2018-08-06"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(match);</span><br><span class="line"><span class="comment">//&gt;&gt; [2018-08-06, 08, 06, 2018, groups: &#123;day: 06, month: 08, year: 2018&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此时用groups对象来获取年月日，无论正则表达式怎么变换，这下面三行不用改了，省事！</span></span><br><span class="line"><span class="keyword">let</span> year = match.groups.year; <span class="comment">//&gt;&gt; 2018</span></span><br><span class="line"><span class="keyword">let</span> month = match.groups.month; <span class="comment">//&gt;&gt; 08</span></span><br><span class="line"><span class="keyword">let</span> day = match.groups.day; <span class="comment">//&gt;&gt; 06</span></span><br></pre></td></tr></table></figure><p>命名捕获组的写法相当于是把每个捕获组都定义了一个名字，然后存储到返回值的<code>groups</code>属性中。</p><h3 id="正则表达式后行断言"><a href="#正则表达式后行断言" class="headerlink" title="正则表达式后行断言"></a>正则表达式后行断言</h3><p>先看看正则表达式<strong>先行断言</strong>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> re1 = <span class="regexp">/\D(\d+)/</span>,</span><br><span class="line">    re2 = <span class="regexp">/\D(?=\d+)/</span>,<span class="comment">//"?="是正向先行断言</span></span><br><span class="line">    match1 = re1.exec(<span class="string">"$123.45"</span>),</span><br><span class="line">    match2 = re2.exec(<span class="string">"$123.45"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(match1[<span class="number">0</span>]); <span class="comment">//&gt;&gt; $123</span></span><br><span class="line"><span class="built_in">console</span>.log(match2[<span class="number">0</span>]); <span class="comment">//&gt;&gt; $</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>(?=pattern)</strong> 零宽正向先行断言(zero-width positive lookahead assertion)<br>代表字符串中的一个位置，<strong>紧接该位置之后</strong>的字符序列<strong>能够匹配</strong>pattern；</p><p>(<strong>?!pattern)</strong> 零宽负向先行断言(zero-width negative lookahead assertion)<br>代表字符串中的一个位置，<strong>紧接该位置之后</strong>的字符序列<strong>不能匹配</strong>pattern；</p><p><strong>(?&lt;=pattern)</strong> 零宽正向后行断言(zero-width positive lookbehind assertion)<br>代表字符串中的一个位置，<strong>紧接该位置之前</strong>的字符序列<strong>能够匹配</strong>pattern；</p><p><strong>(?&lt;!pattern)</strong> 零宽负向后行断言(zero-width negative lookbehind assertion)<br>代表字符串中的一个位置，<strong>紧接该位置之前</strong>的字符序列<strong>不能匹配</strong>pattern。</p></blockquote><p>在ES9中，可以允许使用<code>?&lt;=</code>进行<strong>正向后行断言</strong>，可以获取货币的价格而忽略货币符号。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> re= <span class="regexp">/(?&lt;=\D)[\d\.]+/</span>,</span><br><span class="line">    match = re.exec(<span class="string">"$123.45"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(match[<span class="number">0</span>]); <span class="comment">//&gt;&gt; 123.45</span></span><br></pre></td></tr></table></figure><p>上面的正向后行断言，也就是说<code>\D</code>这个条件必须满足，但<code>\D</code>匹配的字符不会作为结果输出（因为<strong>先行/后行断言</strong>其实只是匹配了一个位置）。如果是下面这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> re= <span class="regexp">/(?&lt;=\D)[\d\.]+/</span>,</span><br><span class="line">    match1 = re.exec(<span class="string">"123.45"</span>),</span><br><span class="line">    match2 = re.exec(<span class="string">"12345"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(match1 &amp;&amp; match1[<span class="number">0</span>]); <span class="comment">//&gt;&gt; 45</span></span><br><span class="line"><span class="built_in">console</span>.log(match2 &amp;&amp; match1[<span class="number">0</span>]); <span class="comment">//&gt;&gt; null</span></span><br></pre></td></tr></table></figure><p>可以看到<code>match1</code>匹配到的是<code>45</code>,这是由于在<code>.</code>前面没有任何符合<code>\D</code>的匹配内容，它会一直找到符合<code>\D</code>的内容，也就是<code>.</code>然后返回后面的内容。而<code>match2</code>若是没有满足前面肯定反向断言的条件的话，则结果返回<code>null</code>。</p><h3 id="正则表达式-Unicode-转义"><a href="#正则表达式-Unicode-转义" class="headerlink" title="正则表达式 Unicode 转义"></a>正则表达式 Unicode 转义</h3><p>ES9 之前，在正则表达式中本地访问 Unicode 字符属性是不被允许的。ES9 添加了 Unicode 属性转义，形式为<code>\p{...}</code>和<code>\P{...}</code>，在正则表达式中使用标记 <code>u</code> (unicode) 设置，在<code>\p</code>的<code>{...}</code>内，可用键值对的方式设置需要匹配的属性而非具体内容。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/\p&#123;Script=Greek&#125;/u</span>;<span class="comment">//Greek为希腊语的意思</span></span><br><span class="line"><span class="built_in">console</span>.log(regex.test(<span class="string">'a'</span>)); <span class="comment">//&gt;&gt; flase</span></span><br><span class="line"><span class="built_in">console</span>.log(regex.test(<span class="string">'Σ'</span>)); <span class="comment">//&gt;&gt; true</span></span><br></pre></td></tr></table></figure></div><h2 id="ES-10-新特性"><a href="#ES-10-新特性" class="headerlink" title="ES 10 新特性"></a>ES 10 新特性</h2><div class="story post-story"><table><thead><tr><th align="left">新特性</th><th align="left">中文说明</th></tr></thead><tbody><tr><td align="left">Optional <code>catch</code> binding</td><td align="left">可选的 catch 变量绑定</td></tr><tr><td align="left">JSON superset</td><td align="left">JSON超集</td></tr><tr><td align="left"><code>Symbol.prototype.description</code></td><td align="left">Symbol 对象的 description 属性</td></tr><tr><td align="left"><code>Function.prototype.toString</code> revision</td><td align="left">修订<code>Function.prototype.toString</code></td></tr><tr><td align="left"><code>Object.fromEntries</code></td><td align="left"></td></tr><tr><td align="left">Well-formed <code>JSON.stringify</code></td><td align="left">更加友好的JSON.stringify</td></tr><tr><td align="left"><code>String.prototype.{trimStart,trimEnd}</code></td><td align="left"></td></tr><tr><td align="left"><code>Array.prototype.{flat,flatMap}</code></td><td align="left"></td></tr></tbody></table><h3 id="可选的-catch-变量绑定"><a href="#可选的-catch-变量绑定" class="headerlink" title="可选的 catch 变量绑定"></a>可选的 catch 变量绑定</h3><p>在 ES10 之前，我们必须通过语法为 catch 子句绑定异常变量，无论是否有必要。很多时候 catch 块是多余的，而 ES10 使我们能够简单的把变量省略掉。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//之前是</span></span><br><span class="line"><span class="keyword">try</span> &#123;&#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES10之后可以写成，</span></span><br><span class="line"><span class="keyword">try</span> &#123;&#125; <span class="keyword">catch</span> &#123;&#125;<span class="comment">//省掉了变量e</span></span><br></pre></td></tr></table></figure><h3 id="JSON超集"><a href="#JSON超集" class="headerlink" title="JSON超集"></a>JSON超集</h3><p>什么是 JSON 超集？简单来说就是 JSON 是 ECMAScript 的子集，也就是说让 ECMAScript 兼容 JSON 的内容所支持的全部文本。</p><p>ECMAScript 在标准 <a href="https://tc39.es/ecma262/#sec-json.parse" target="_blank" rel="noopener">JSON.parse</a> 部分阐明了 JSON 确为其一个子集，但由于 JSON 的内容可以正常包含 <code>U+2028</code> 行分隔符与 <code>U+2029</code> 段落分隔符，而 ECMAScript 却不行，所以，该草案旨在解决这一问题。在这之前，如果你使用 <code>JSON.parse()</code> 执行带如上特殊字符的字符串时，只会收到 <code>SyntaxError</code> 的错误提示。该草案同样是向后兼容的，其对用户唯一的影响是保持原样，即在暂不支持特殊字符解析的运行环境中保持报错 <code>SyntaxError</code> 。</p><h3 id="Symbol-对象的-description-属性"><a href="#Symbol-对象的-description-属性" class="headerlink" title="Symbol 对象的 description 属性"></a>Symbol 对象的 description 属性</h3><p>ES10 中为 Symbol 对象添加了只读属性 <code>description</code> ，该对象返回包含 Symbol 描述的字符串。在创建Symbol时向其添加<code>description</code> (描述)，能够直接访问<code>description</code> ，对调试是很有用的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);<span class="comment">//添加的描述内容为“foo”</span></span><br><span class="line"><span class="built_in">console</span>.log(sym.description);<span class="comment">//&gt;&gt; foo</span></span><br><span class="line"></span><br><span class="line">sym = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(sym.description);<span class="comment">//&gt;&gt; undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//和 Symbol() 不同的是，用 Symbol.for() 方法创建的的 symbol 会被放入一个全局</span></span><br><span class="line"><span class="comment">//symbol 注册表中。Symbol.for() 并不是每次都会创建一个新的 symbol，它会首先检</span></span><br><span class="line"><span class="comment">//查给定的 key 是否已经在注册表中了。假如是，则会直接返回上次存储的那个。否则，它</span></span><br><span class="line"><span class="comment">//会再新建一个。</span></span><br><span class="line">sym = <span class="built_in">Symbol</span>.for(<span class="string">'bar'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sym.description);<span class="comment">//&gt;&gt; bar</span></span><br></pre></td></tr></table></figure><h3 id="修订Function-prototype-toString"><a href="#修订Function-prototype-toString" class="headerlink" title="修订Function.prototype.toString"></a>修订Function.prototype.toString</h3><p>函数原型上的方法<code>toString()</code>现在返回精确字符，包括空格和注释。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> /* <span class="title">comment</span> */ <span class="title">foo</span> /* <span class="title">another</span> <span class="title">comment</span> */(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES10之前不会打印注释部分</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.toString()); <span class="comment">//&gt;&gt; function foo()&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ES10里，会把注释一同打印</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.toString()); <span class="comment">//&gt;&gt; function /* comment */ foo /* another comment */ ()&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：</span></span><br><span class="line"><span class="comment">//箭头函数是个例外</span></span><br><span class="line"><span class="keyword">const</span> bar <span class="comment">/* comment */</span> = <span class="comment">/* another comment */</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(bar.toString()); <span class="comment">//&gt;&gt; () =&gt; &#123;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries"></a>Object.fromEntries</h3><p>在 JavaScript 操作中，数据在各种数据结构之间的转换都是很容易的，比如 Map 到数组、Map 到 Set、对象到 Map 等等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">'foo'</span>, <span class="literal">true</span>).set(<span class="string">'bar'</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(map);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set(map.values());</span><br><span class="line"></span><br><span class="line">let obj = &#123; foo: <span class="literal">true</span>, <span class="attr">bar</span>: <span class="literal">false</span> &#125;;</span><br><span class="line"><span class="comment">//下一句 Object.entries() 方法返回给定对象 obj 自身可枚举属性的键值对数组,</span></span><br><span class="line"><span class="comment">//形如：[["foo",true],["bar",false]]</span></span><br><span class="line"><span class="keyword">let</span> newMap = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(obj));</span><br></pre></td></tr></table></figure><p>但是如果我们需要将一个键值对列表转换为对象，就要写点费劲的代码了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">"foo"</span>, <span class="literal">true</span>).set(<span class="string">"bar"</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Array</span>.from(map).reduce(<span class="function">(<span class="params">acc, [key, val]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(acc, &#123;</span><br><span class="line">    [key]: val</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, &#123;&#125;);</span><br></pre></td></tr></table></figure><p>该特性的目的在于为对象添加一个新的静态方法 <code>Object.fromEntries</code>，用于将符合键值对的列表（例如 Map、数组等）转换为一个对象。上一块的代码中的转换逻辑，现在我们只需要一行代码即可搞定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">"foo"</span>, <span class="literal">true</span>).set(<span class="string">"bar"</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.fromEntries(map);</span><br></pre></td></tr></table></figure><h3 id="更加友好的-JSON-stringify"><a href="#更加友好的-JSON-stringify" class="headerlink" title="更加友好的 JSON.stringify"></a>更加友好的 JSON.stringify</h3><p>ES10 之前，当你使用 <code>JSON.stringify()</code> 处理无法用 UTF-8 编码表示的字符时（U+D800 至 U+DFFF），返回的结果会是一个乱码 Unicode 字符“�”。该特性提出用<code>JSON.stringify()</code>来安全的表示这些不正常的UTF-8字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r;</span><br><span class="line">r = <span class="built_in">JSON</span>.stringify(<span class="string">"❤"</span>); <span class="comment">//正常的UTF-8字符原样输出</span></span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">//&gt;&gt; "❤"</span></span><br><span class="line"></span><br><span class="line">r = <span class="built_in">JSON</span>.stringify(<span class="string">'\u2764'</span>); <span class="comment">//正常的UTF-8字符编码，输出解码之后的模样</span></span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">//&gt;&gt; "❤"</span></span><br><span class="line"></span><br><span class="line">r = <span class="built_in">JSON</span>.stringify(<span class="string">"\uDF06\uD834"</span>); <span class="comment">//不正常的UTF-8字符编码，则以unicode形式输出</span></span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">//&gt;&gt; "\udf06\ud834"</span></span><br><span class="line"></span><br><span class="line">r = <span class="built_in">JSON</span>.stringify(<span class="string">"\uDEAD"</span>); <span class="comment">//不正常的UTF-8字符编码，则以unicode形式输出</span></span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">//&gt;&gt; "\udead"</span></span><br></pre></td></tr></table></figure><h3 id="String-prototype-trimStart-trimEnd"><a href="#String-prototype-trimStart-trimEnd" class="headerlink" title="String.prototype.{trimStart,trimEnd}"></a>String.prototype.{trimStart,trimEnd}</h3><p>新增了String的<code>trimStart()</code>方法和<code>trimEnd()</code>方法，这两个方法很好理解，分别去除字符串首、尾的空白字符，就不举例占篇幅了。</p><h3 id="Array-prototype-flat-flatMap"><a href="#Array-prototype-flat-flatMap" class="headerlink" title="Array.prototype.{flat,flatMap}"></a>Array.prototype.{flat,flatMap}</h3><p>这个特性新创造了两个方法，其中：</p><ul><li><code>Array.prototype.flat</code> 数组的所有项会以指定的维度降维（扁平化），然后组成新数组返回；</li><li><code>Array.prototype.flatMap</code> 首先会执行一次<code>map()</code>方法，然后再通过类似<code>flat()</code>方法<strong>扁平化</strong>数组。它等同于执行完 <code>map()</code> 后再执行一次 <code>flat()</code> 方法，所以当你执行 <code>map()</code> 返回的结果如果是个数组，然后又要将其扁平化时，这个方法会显得方便。</li></ul><p>来看几个例子解释一下，首先 <code>flat()</code> 方法支持多维数组的扁平化，其中<code>Infinity</code>可以将多维数组压扁成一维数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r;</span><br><span class="line">r = [<span class="string">"1"</span>, [<span class="string">"8"</span>, [<span class="string">"9"</span>, [<span class="string">"1"</span>]]]].flat();<span class="comment">//4维数组，默认降维1，变成3维数组</span></span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">//&gt;&gt; [ '1', '8', [ '9', ['1'] ] ]</span></span><br><span class="line"></span><br><span class="line">r = [<span class="string">"1"</span>, [<span class="string">"8"</span>, [<span class="string">"9"</span>, [<span class="string">"1"</span>]]]].flat(<span class="number">2</span>); <span class="comment">//4维数组，降维2，变成2维数组</span></span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">//&gt;&gt; [ '1', '8', '9', ['1'] ]</span></span><br><span class="line"></span><br><span class="line">r = [<span class="string">"1"</span>, [<span class="string">"8"</span>, [<span class="string">"9"</span>, [<span class="string">"1"</span>]]]].flat(<span class="literal">Infinity</span>);<span class="comment">//4维数组，最多变成1维数组</span></span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">//&gt;&gt; [ '1', '8', '9', '1' ]</span></span><br></pre></td></tr></table></figure><p>接着来看看<code>flatMap()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r;</span><br><span class="line">r = [<span class="string">"I love"</span>, <span class="string">"coffe 1891"</span>].map(<span class="function"><span class="params">item</span> =&gt;</span> item.split(<span class="string">" "</span>));</span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">//&gt;&gt; [ [ 'I', 'love' ], [ 'coffe', '1891' ] ]</span></span><br><span class="line"></span><br><span class="line">r = [<span class="string">"I love"</span>, <span class="string">"coffe 1891"</span>].flatMap(<span class="function"><span class="params">item</span> =&gt;</span> item.split(<span class="string">" "</span>));</span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">//&gt;&gt;[ 'I', 'love', 'coffe', '1891' ]</span></span><br></pre></td></tr></table></figure></div><h2 id="ES-11-新特性一览"><a href="#ES-11-新特性一览" class="headerlink" title="ES 11 新特性一览"></a>ES 11 新特性一览</h2><div class="story post-story"><table><thead><tr><th align="left">新特性</th><th align="left">中文说明</th></tr></thead><tbody><tr><td align="left"><code>String.prototype.matchAll</code></td><td align="left"></td></tr><tr><td align="left"><code>import()</code></td><td align="left">import()函数</td></tr><tr><td align="left"><code>Promise.allSettled</code></td><td align="left"></td></tr></tbody></table><h3 id="String-prototype-matchAll"><a href="#String-prototype-matchAll" class="headerlink" title="String.prototype.matchAll"></a>String.prototype.matchAll</h3><p><code>matchAll()</code> 方法返回一个包含所有匹配正则表达式及分组捕获结果的迭代器（iterator）。 在 <code>matchAll</code> 出现之前，通过在循环中调用<code>Regexp.exec</code>来获取所有匹配项信息（<code>Regexp</code>需使用<code>/g</code>标志）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> regexp = <span class="built_in">RegExp</span>(<span class="string">'foo*'</span>,<span class="string">'g'</span>);</span><br><span class="line"><span class="keyword">const</span> str = <span class="string">'coffe football, foosball'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((matches = regexp.exec(str)) !== <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`找到 <span class="subst">$&#123;matches[<span class="number">0</span>]&#125;</span>，下一轮循环从位置 <span class="subst">$&#123;regexp.lastIndex&#125;</span> 开始`</span>);</span><br><span class="line">  <span class="comment">//&gt;&gt; 找到 foo，下一轮循环从位置 9 开始</span></span><br><span class="line">  <span class="comment">//&gt;&gt; 找到 foo，下一轮循环从位置 19 开始</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用<code>matchAll</code> ，就可以不必使用<code>while</code>循环加<code>exec</code>方式（且正则表达式需使用<code>/g</code>标志）。使用<code>matchAll</code> 会得到一个迭代器的返回值，配合 <code>for...of</code>，<code>array spread</code>，<code>Array.from()</code> 可以更方便实现功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> regexp = <span class="built_in">RegExp</span>(<span class="string">'foo*'</span>,<span class="string">'g'</span>);</span><br><span class="line"><span class="keyword">const</span> str = <span class="string">'coffe football, foosball'</span>;</span><br><span class="line"><span class="keyword">let</span> matches = str.matchAll(regexp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> match <span class="keyword">of</span> matches) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(match);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//&gt;&gt; [ "foo" ]</span></span><br><span class="line"><span class="comment">//&gt;&gt; [ "foo" ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：</span></span><br><span class="line"><span class="comment">//matches的迭代器在for..of之后已经被消耗掉了，</span></span><br><span class="line"><span class="comment">//需要再次调用matchAll创建一个新的迭代器</span></span><br><span class="line">matches = str.matchAll(regexp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(matches, m =&gt; m[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">//&gt;&gt; [ "foo", "foo" ]</span></span><br></pre></td></tr></table></figure><h3 id="import-函数"><a href="#import-函数" class="headerlink" title="import()函数"></a>import()函数</h3><p>这个特性为JavaScript添加了一个类函数（function-like）的<code>import()</code>功能，以便可以像函数传参那样传入参数实现<strong>动态</strong>（没错，<code>import</code>是静态引用的）引用模块（module）。下面有个单页应用简单示例，演示了用<code>import()</code>开启懒加载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;nav&gt;</span><br><span class="line">  &lt;a href&#x3D;&quot;books.html&quot; data-entry-module&#x3D;&quot;books&quot;&gt;书籍&lt;&#x2F;a&gt;</span><br><span class="line">  &lt;a href&#x3D;&quot;movies.html&quot; data-entry-module&#x3D;&quot;movies&quot;&gt;电影&lt;&#x2F;a&gt;</span><br><span class="line">  &lt;a href&#x3D;&quot;video-games.html&quot; data-entry-module&#x3D;&quot;video-games&quot;&gt;电视游戏&lt;&#x2F;a&gt;</span><br><span class="line">&lt;&#x2F;nav&gt;</span><br><span class="line"></span><br><span class="line">&lt;main&gt;内容将会加载到这里！&lt;&#x2F;main&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const main &#x3D; document.querySelector(&quot;main&quot;);</span><br><span class="line">  for (const link of document.querySelectorAll(&quot;nav &gt; a&quot;)) &#123;</span><br><span class="line">    link.addEventListener(&quot;click&quot;, e &#x3D;&gt; &#123;</span><br><span class="line">      e.preventDefault();</span><br><span class="line"></span><br><span class="line">      import(&#96;.&#x2F;section-modules&#x2F;$&#123;link.dataset.entryModule&#125;.js&#96;)&#x2F;&#x2F;动态引用</span><br><span class="line">        .then(module &#x3D;&gt; &#123;&#x2F;&#x2F;加载模块成功以后，该模块会当作then方法的参数</span><br><span class="line">          module.loadPageInto(main);</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(err &#x3D;&gt; &#123;&#x2F;&#x2F;捕捉异常</span><br><span class="line">          main.textContent &#x3D; err.message;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>请注意<code>import()</code>和<code>import</code>的区别：</p><ul><li>import() 可以用在script脚本区，不止是模块内；</li><li>如果在模块内使用import()，它可以在任何地方任何级别执行，而不是被提升到顶级（优先执行）；</li><li>import() 是运行时执行，也即什么时候运行到这句，就会加载参数指定的模块；参数也可以是动态可变的，不止是静态参数；</li><li>import() 不建立可静态分析的依赖关系（静态分析的情况下可以做很多优化），但是，在一些比较简单的情况下，比如<code>import（“/foo.js”）</code>中，实现仍然可以执行静态分析优化。</li></ul><p>如果模块采用<code>default</code>的形式对外暴露接口，则可用<code>default</code>属性直接获得。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">'./module.js'</span>)</span><br><span class="line">.then(<span class="function"><span class="params">module</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">module</span>.default);<span class="comment">//直接通过default属性获得模块暴露的接口</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h3><p>为什么要有<code>Promise.allSettled()</code>？</p><p>举例说明，比如各位用户在页面上面同时填了3个独立的表单，这三个表单分三个接口提交到后端，三个接口独立，没有顺序依赖，这个时候我们需要等到请求全部完成后给与用户提示表单提交的情况。</p><p>在多个<code>promise</code>同时进行时咱们很快会想到使用<code>Promise.all</code>来进行包装，但是由于<code>Promise.all</code>的一票否决的特性，三个提交中若前面任意一个提交失败，则后面的表单也不会进行提交了，这就与咱们需求不符合。</p><p><code>Promise.allSettled</code>跟<code>Promise.all</code>类似，其参数接受一个<code>Promise</code>的数组，返回一个新的<code>Promise</code>，唯一的不同在于，其没有一票否决的特性，也就是说当<code>Promise</code>全部处理完成后我们可以拿到每个<code>Promise</code>的状态，而不管其是否处理成功。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.allSettled([<span class="built_in">Promise</span>.resolve(<span class="string">"coffe"</span>), <span class="built_in">Promise</span>.reject(<span class="string">"1891"</span>)]).then(</span><br><span class="line">  arr =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr); <span class="comment">//&gt;&gt; [ &#123; status: "fulfilled", value: "coffe"&#125;,</span></span><br><span class="line">                      <span class="comment">//&gt;&gt;   &#123; status: "rejected", reason: "1891" &#125; ]</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><h2 id="本篇结语"><a href="#本篇结语" class="headerlink" title="本篇结语"></a>本篇结语</h2><div class="story post-story"><p>很显然ECMAScript接下来会持续不断地更新，按TC39的计划是每年都会发一个新版本。虽然节奏很快，但是我们完全没必要担心跟不上节奏。除了ES6这个史无前例的版本带来了超大量的新特性外，之后每年发的版本都仅仅带有少量的增量更新，你只需要花45分钟就能搞明白这一年更新的特性。保持一颗好奇的心，你会不断进步，变得更强！</p></div>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>post</title>
      <link href="/framework-virtual-dom/"/>
      <url>/framework-virtual-dom/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>typeof 实现原理</title>
      <link href="/javascript-typeof/"/>
      <url>/javascript-typeof/</url>
      
        <content type="html"><![CDATA[<p><code>typeof</code> 一般被用于判断一个变量的类型，我们可以利用 <code>typeof</code> 来判断 <code>number</code>, <code>string</code>, <code>object</code>, <code>boolean</code>, <code>function</code>, <code>undefined</code>,<code>symbol</code> 这七种类型，这种判断能帮助我们搞定一些问题，比如在判断不是 <code>object</code> 类型的数据的时候，<code>typeof</code> 能比较清楚的告诉我们具体是哪一类的类型。但是，很遗憾的一点是，<code>typeof</code>在判断一个 <code>object</code> 的数据的时候只能告诉我们这个数据是 <code>object</code>, 而不能细致的具体到是哪一种 <code>object</code>, 比如</p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"abc"</span>);</span><br><span class="line"><span class="keyword">typeof</span> s === <span class="string">"object"</span>; <span class="comment">// true</span></span><br><span class="line">s <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>要想判断一个数据具体是哪一种 <code>object</code> 的时候，我们需要利用 <code>instanceof</code> 这个操作符来判断，这个我们后面会说到。</p><p>来谈谈关于 <code>typeof</code> 的原理吧，我们可以先想一个很有意思的问题，js 在底层是怎么存储数据的类型信息呢？或者说，一个 js 的变量，在它的底层实现中，它的类型信息是怎么实现的呢？</p><p>其实，js 在底层存储变量的时候，会在变量的机器码的低位 1-3 位存储其类型信息</p><ul><li>000：对象</li><li>010：浮点数</li><li>100：字符串</li><li>110：布尔</li><li>1：整数</li></ul><p>but, 对于 <code>undefined</code> 和 <code>null</code> 来说，这两个值的信息存储是有点特殊的。</p><pre><code>`null`：所有机器码均为0`undefined`：用 −2^30 整数来表示</code></pre><p>所以，<code>typeof</code> 在判断 null 的时候就出现问题了，由于 null 的所有机器码均为 0，因此直接被当做了对象来看待。</p><p>然而用 <code>instanceof</code> 来判断的话</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> <span class="literal">null</span>; <span class="comment">// TypeError: Right-hand side of 'instanceof' is not an object</span></span><br></pre></td></tr></table></figure><p><code>null</code> 直接被判断为不是 <code>object</code>，这也是 <code>JavaScript</code> 的历史遗留 bug，可以参考 <code>typeof</code>.</p><p>因此在用 <code>typeof</code> 来判断变量类型的时候，我们需要注意，最好是用 <code>typeof</code> 来判断基本数据类型（包括 symbol），避免对 <code>null</code> 的判断。</p><p>还有一个不错的判断类型的方法，就是 <code>Object.prototype.toString</code>，我们可以利用这个方法来对一个变量的类型来进行比较准确的判断</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>); <span class="comment">// "[object Number]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">"hi"</span>); <span class="comment">// "[object String]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123; <span class="attr">a</span>: <span class="string">"hi"</span> &#125;); <span class="comment">// "[object Object]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([<span class="number">1</span>, <span class="string">"a"</span>]); <span class="comment">// "[object Array]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>); <span class="comment">// "[object Boolean]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;); <span class="comment">// "[object Function]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>); <span class="comment">// "[object Null]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>); <span class="comment">// "[object Undefined]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>(<span class="number">1</span>)); <span class="comment">// "[object Symbol]"</span></span><br></pre></td></tr></table></figure><h3 id="instanceof-操作符的实现原理"><a href="#instanceof-操作符的实现原理" class="headerlink" title="instanceof 操作符的实现原理"></a>instanceof 操作符的实现原理</h3><p>之前我们提到了 instanceof 来判断对象的具体类型，其实 instanceof 主要的作用就是判断一个实例是否属于某种类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> nicole = <span class="keyword">new</span> person();</span><br><span class="line">nicole <span class="keyword">instanceof</span> person; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>当然，instanceof 也可以判断一个实例是否是其父类型或者祖先类型的实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> programmer = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">programmer.prototype = <span class="keyword">new</span> person();</span><br><span class="line"><span class="keyword">let</span> nicole = <span class="keyword">new</span> programmer();</span><br><span class="line">nicole <span class="keyword">instanceof</span> person; <span class="comment">// true</span></span><br><span class="line">nicole <span class="keyword">instanceof</span> programmer; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>instanceof 实现原理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new_instance_of</span>(<span class="params">leftVaule, rightVaule</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> rightProto = rightVaule.prototype; <span class="comment">// 取右表达式的 prototype 值</span></span><br><span class="line">  leftVaule = leftVaule.__proto__; <span class="comment">// 取左表达式的__proto__值</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftVaule === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (leftVaule === rightProto) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    leftVaule = leftVaule.__proto__;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>简单来说，我们使用 <code>typeof</code> 来判断基本数据类型是 ok 的，不过需要注意当用 <code>typeof</code> 来判断 null 类型时的问题，如果想要判断一个对象的具体类型可以考虑用 <code>instanceof</code>，但是 <code>instanceof</code> 也可能判断不准确，比如一个数组，他可以被 <code>instanceof</code> 判断为 Object。所以我们要想比较准确的判断对象实例的类型时，可以采取 <code>Object.prototype.toString.call</code> 方法。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些 JS 关键技术的底层实现汇总</title>
      <link href="/javascript-js-basic-implementation/"/>
      <url>/javascript-js-basic-implementation/</url>
      
        <content type="html"><![CDATA[<p>在这里汇总一些 JS 常用技术的源码实现，通过源码了解其内部原理，可以加深对其的理解。</p><a id="more"></a><ul><li><a href="#functionprototypecall">Function.prototype.call()</a></li><li><a href="#functionprototypeapply">Function.prototype.apply()</a></li><li><a href="#functionprototypebind">Function.prototype.bind()</a></li><li><a href="#new-的原理">new 的原理</a></li><li><a href="#reduce-实现原理">reduce 实现原理</a></li><li><a href="#双向绑定">双向绑定</a></li><li><a href="#继承">继承</a></li><li><a href="#objectcreate">Object.create</a></li><li><a href="#instanceof-实现">instanceof 实现</a></li><li><a href="#arrayisarray-实现">Array.isArray 实现</a></li><li><a href="#getownpropertynames-实现">getOwnPropertyNames 实现</a></li><li><a href="#promise-实现">Promise 实现</a></li><li><a href="#防抖节流">防抖/节流</a></li><li><a href="#函数柯里化实现">函数柯里化实现</a></li><li><a href="#实现简单深拷贝">实现简单深拷贝</a></li></ul><!-- # 一些 JS 关键技术的底层实现汇总 --><h2 id="Function-prototype-call"><a href="#Function-prototype-call" class="headerlink" title="Function.prototype.call()"></a>Function.prototype.call()</h2><div class="story post-story"><p><code>call()</code> 方法调用一个函数, 其具有一个指定的 this 值和分别地提供的参数。</p><p>语法：<code>fun.call(thisArg, arg1, arg2, ...)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * call的实现原理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> getGlobal = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">"undefined"</span>) <span class="keyword">return</span> self;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">"undefined"</span>) <span class="keyword">return</span> <span class="built_in">window</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> global !== <span class="string">"undefined"</span>) <span class="keyword">return</span> global;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Function</span>.prototype.mcall = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context = context ? <span class="built_in">Object</span>(context) : getGlobal();</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>(<span class="string">"anything"</span>); <span class="comment">//创建一个不重复的常量</span></span><br><span class="line">  context[fn] = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> r = context[fn](...args);</span><br><span class="line">  <span class="keyword">delete</span> context[fn];</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个用call实现继承的例子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">name</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">price</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Product</span>(<span class="params">name, price</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fruit</span>(<span class="params">name, price</span>) </span>&#123;</span><br><span class="line">  Product.mcall(<span class="keyword">this</span>, name, price);</span><br><span class="line">  <span class="keyword">this</span>.category = <span class="string">"fruit"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> apple = <span class="keyword">new</span> Fruit(<span class="string">"apple"</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(apple);</span><br></pre></td></tr></table></figure></div><h2 id="Function-prototype-apply"><a href="#Function-prototype-apply" class="headerlink" title="Function.prototype.apply()"></a>Function.prototype.apply()</h2><div class="story post-story"><p><code>apply()</code>调用一个指定 this 值的函数, 接收作为一个数组或者类数组对象提供的参数.</p><p>语法： <code>func.apply(thisArg, [argsArray])</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getGlobal = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">"undefined"</span>) <span class="keyword">return</span> self;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">"undefined"</span>) <span class="keyword">return</span> <span class="built_in">window</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> global !== <span class="string">"undefined"</span>) <span class="keyword">return</span> global;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * apply原理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">context, arr</span>) </span>&#123;</span><br><span class="line">  context = context ? <span class="built_in">Object</span>(context) : getGlobal();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"context"</span>, context);</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>(<span class="string">"anything"</span>); <span class="comment">//创建一个不重复的常量</span></span><br><span class="line">  context[fn] = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// let args = [...arguments][1];</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!arr) &#123;</span><br><span class="line">    <span class="keyword">let</span> r = context[fn]();</span><br><span class="line">    <span class="keyword">delete</span> context[fn];</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> r = context[fn](...arr);</span><br><span class="line">  <span class="keyword">delete</span> context[fn];</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//使用例子</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="string">"a"</span>, <span class="string">"b"</span>];</span><br><span class="line"><span class="keyword">var</span> elements = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">array.push.apply(array, elements);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"array"</span>, array); <span class="comment">// ["a", "b", 0, 1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.b + <span class="string">" "</span> + x + <span class="string">" "</span> + y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> B = &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;;</span><br><span class="line">A.apply(B, [<span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure></div><h2 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind()"></a>Function.prototype.bind()</h2><div class="story post-story"><p><code>bind()</code>方法创建一个新函数, 在调用时设置 this 关键字为提供的值。</p><p>语法：<code>fun.bind(thisArg, arg1, arg2, ...)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getGlobal = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">"undefined"</span>) <span class="keyword">return</span> self;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">"undefined"</span>) <span class="keyword">return</span> <span class="built_in">window</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> global !== <span class="string">"undefined"</span>) <span class="keyword">return</span> global;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bind实现原理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context = context ? <span class="built_in">Object</span>(context) : getGlobal();</span><br><span class="line">  <span class="keyword">const</span> me = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    me.apply(context, [...args, ...arguments]);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.b + <span class="string">", "</span> + x + <span class="string">", "</span> + y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> B = &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> fnc = A.bind(B, <span class="number">2</span>); <span class="comment">//1 2 3</span></span><br><span class="line">fnc(<span class="number">3</span>);</span><br></pre></td></tr></table></figure></div><h2 id="new-的原理"><a href="#new-的原理" class="headerlink" title="new 的原理"></a>new 的原理</h2><div class="story post-story"><p>在了解 new 原理之前先看看 js 的内部机制图</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/14/1697cc831ea2af8e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" class="lazyload" data-srcset="https://user-gold-cdn.xitu.io/2019/3/14/1697cc831ea2af8e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="js内部机制"></p><pre><code>我们需要知道当 new 的时候做了什么事情</code></pre><ol><li>创建一个新对象；</li><li>将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）</li><li>执行构造函数中的代码（为这个新对象添加属性）</li><li>返回新对象。</li></ol><p>new 没法重写，这里是有 mockNew 函数来模拟</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * new实现原理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mockNew</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//创建一个实例</span></span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="comment">//获得构造器</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">constructor</span> = [].shift.call(arguments);</span><br><span class="line">  //实现继承，实例可以访问构造器熟悉</span><br><span class="line">  obj.__proto__ = <span class="keyword">constructor</span>.prototype;</span><br><span class="line">  //调用构造器，改变this指向为实例</span><br><span class="line">  const res = <span class="keyword">constructor</span>.apply(obj, arguments);</span><br><span class="line">  //如果构造器函数返回值为对象，则返回这个对象，否则返回新的实例对象</span><br><span class="line">  return res instanceof Object ? res : obj;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 使用例子</span><br><span class="line"> * @param &#123;*&#125; color</span><br><span class="line"> * @param &#123;*&#125; name</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">function Car(color, name) &#123;</span></span><br><span class="line"><span class="regexp">  this.color = color;</span></span><br><span class="line"><span class="regexp">  return &#123;</span></span><br><span class="line"><span class="regexp">    name: name,</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">let car = mockNew(Car, "black", "BMW");</span></span><br><span class="line"><span class="regexp">console.log(car.color);</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ undefined</span></span><br><span class="line"><span class="regexp">console.log(car.name);</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ "BMW"</span></span><br></pre></td></tr></table></figure></div><h2 id="reduce-实现原理"><a href="#reduce-实现原理" class="headerlink" title="reduce 实现原理"></a>reduce 实现原理</h2><div class="story post-story"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现原理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.mockReduce = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> length = <span class="keyword">this</span>.length;</span><br><span class="line">  <span class="keyword">let</span> reducer = <span class="literal">undefined</span>, <span class="comment">//累加器，最终返回这个值</span></span><br><span class="line">    k = <span class="number">0</span>, <span class="comment">//数组下标</span></span><br><span class="line">    initVal = [...arguments].length &gt; <span class="number">1</span> ? [...arguments][<span class="number">1</span>] : <span class="literal">undefined</span>; <span class="comment">//传入reduce的初始值</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">" is not a function"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (length === <span class="number">0</span> &amp;&amp; !initVal) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Reduce of empty array with no initial value"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (initVal) &#123;</span><br><span class="line">    reducer = initVal;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reducer = <span class="keyword">this</span>[<span class="number">0</span>];</span><br><span class="line">    k++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (k &lt; length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.hasOwnProperty(k)) &#123;</span><br><span class="line">      <span class="keyword">const</span> kValue = <span class="keyword">this</span>[k];</span><br><span class="line">      reducer = callback(reducer, kValue);</span><br><span class="line">    &#125;</span><br><span class="line">    k++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> reducer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rReduce = [].reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> mReduce = [].mockReduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(rReduce, mReduce);</span><br></pre></td></tr></table></figure></div><h2 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h2><div class="story post-story"><p><code>defineProperty</code>实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据</span></span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  text: <span class="string">"hello"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> input = <span class="built_in">document</span>.getElementById(<span class="string">"input"</span>);</span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">document</span>.getElementById(<span class="string">"p"</span>);</span><br><span class="line"><span class="comment">// 数据劫持</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(data, <span class="string">"text"</span>, &#123;</span><br><span class="line">  <span class="comment">// 数据变化 --&gt; 修改视图</span></span><br><span class="line">  <span class="keyword">set</span>(newVal) &#123;</span><br><span class="line">    input.value = newVal;</span><br><span class="line">    p.innerHTML = newVal;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 视图更改 --&gt; 数据变化</span></span><br><span class="line">input.addEventListener(<span class="string">"keyup"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  data.text = e.target.value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>proxy</code>实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据</span></span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  text: <span class="string">"default"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> input = <span class="built_in">document</span>.getElementById(<span class="string">"input"</span>);</span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">document</span>.getElementById(<span class="string">"p"</span>);</span><br><span class="line"><span class="comment">// 数据劫持</span></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="keyword">set</span>(target, key, value) &#123;</span><br><span class="line">    target[key] = value;</span><br><span class="line">    <span class="comment">// 数据变化 --&gt; 修改视图</span></span><br><span class="line">    input.value = value;</span><br><span class="line">    p.innerHTML = value;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 视图更改 --&gt; 数据变化</span></span><br><span class="line">input.addEventListener(<span class="string">"keyup"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  proxy.text = e.target.value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><div class="story post-story"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> protoType = <span class="built_in">Object</span>.create(superType.prototype); <span class="comment">//创建对象</span></span><br><span class="line">  protoType.constructor = subType; <span class="comment">//增强对象</span></span><br><span class="line">  subType.prototype = protoType; <span class="comment">//指定对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType(<span class="string">"Bob"</span>, <span class="number">18</span>);</span><br><span class="line">instance.sayName();</span><br><span class="line">instance.sayAge();</span><br></pre></td></tr></table></figure></div><h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h2><div class="story post-story"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Object</span>.create !== <span class="string">"function"</span>) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span> (<span class="params">prototype, properties</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> prototype !== <span class="string">"object"</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">TypeError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Ctor</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    Ctor.prototype = prototype;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> Ctor();</span><br><span class="line">    <span class="keyword">if</span> (prototype) &#123;</span><br><span class="line">      o.constructor = Ctor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (properties !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (properties !== <span class="built_in">Object</span>(properties)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">TypeError</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperties(o, properties);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="instanceof-实现"><a href="#instanceof-实现" class="headerlink" title="instanceof 实现"></a>instanceof 实现</h2><div class="story post-story"><p>原理： L 的 __proto__ 是不是等于 R.prototype，不等于再找 L.__proto__.__proto__ 直到 __proto__ 为 null</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// L 表示左表达式，R 表示右表达式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instance_of</span>(<span class="params">L, R</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> O = R.prototype;</span><br><span class="line">  L = L.__proto__;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (L === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 这里重点：当 O 严格等于 L 时，返回 true</span></span><br><span class="line">    <span class="keyword">if</span> (O === L) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    L = L.__proto__;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="Array-isArray-实现"><a href="#Array-isArray-实现" class="headerlink" title="Array.isArray 实现"></a>Array.isArray 实现</h2><div class="story post-story"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.myIsArray = <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Object</span>(o)) === <span class="string">"[object Array]"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.myIsArray([])); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div><h2 id="getOwnPropertyNames-实现"><a href="#getOwnPropertyNames-实现" class="headerlink" title="getOwnPropertyNames 实现"></a>getOwnPropertyNames 实现</h2><div class="story post-story"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Object</span>.getOwnPropertyNames !== <span class="string">"function"</span>) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyNames = <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o !== <span class="built_in">Object</span>(o)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">TypeError</span>(<span class="string">"Object.getOwnPropertyNames called on non-object"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> props = [],</span><br><span class="line">      p;</span><br><span class="line">    <span class="keyword">for</span> (p <span class="keyword">in</span> o) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(o, p)) &#123;</span><br><span class="line">        props.push(p);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> props;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="Promise-实现"><a href="#Promise-实现" class="headerlink" title="Promise 实现"></a>Promise 实现</h2><div class="story post-story"><p>实现原理：其实就是一个发布订阅者模式</p><ol><li>构造函数接收一个 executor 函数，并会在 new Promise() 时立即执行该函数</li><li>then 时收集依赖，将回调函数收集到 成功/失败队列</li><li>executor 函数中调用 resolve/reject 函数</li><li>resolve/reject 函数被调用时会通知触发队列中的回调</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isFunction = <span class="function"><span class="params">variable</span> =&gt;</span> <span class="keyword">typeof</span> variable === <span class="string">'function'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义Promise的三种状态常量</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'fulfilled'</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 构造函数，new 时触发</span></span><br><span class="line">  <span class="keyword">constructor</span>(handle: Function) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      handle(<span class="keyword">this</span>._resolve, <span class="keyword">this</span>._reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="keyword">this</span>._reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 状态 pending fulfilled rejected</span></span><br><span class="line">  private _status: string = PENDING;</span><br><span class="line">  <span class="comment">// 储存 value，用于 then 返回</span></span><br><span class="line">  private _value: string | <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="comment">// 失败队列，在 then 时注入，resolve 时触发</span></span><br><span class="line">  private _rejectedQueues: any = [];</span><br><span class="line">  <span class="comment">// 成功队列，在 then 时注入，resolve 时触发</span></span><br><span class="line">  private _fulfilledQueues: any = [];</span><br><span class="line">  <span class="comment">// resovle 时执行的函数</span></span><br><span class="line">  private _resolve = <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> run = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._status !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">this</span>._status = FULFILLED;</span><br><span class="line">      <span class="comment">// 依次执行成功队列中的函数，并清空队列</span></span><br><span class="line">      <span class="keyword">const</span> runFulfilled = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cb;</span><br><span class="line">        <span class="keyword">while</span> ((cb = <span class="keyword">this</span>._fulfilledQueues.shift())) &#123;</span><br><span class="line">          cb(value);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 依次执行失败队列中的函数，并清空队列</span></span><br><span class="line">      <span class="keyword">const</span> runRejected = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cb;</span><br><span class="line">        <span class="keyword">while</span> ((cb = <span class="keyword">this</span>._rejectedQueues.shift())) &#123;</span><br><span class="line">          cb(error);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 如果resolve的参数为Promise对象，</span></span><br><span class="line"><span class="comment">       * 则必须等待该Promise对象状态改变后当前Promsie的状态才会改变</span></span><br><span class="line"><span class="comment">       * 且状态取决于参数Promsie对象的状态</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (val <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">        val.then(</span><br><span class="line">          value =&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>._value = value;</span><br><span class="line">            runFulfilled(value);</span><br><span class="line">          &#125;,</span><br><span class="line">          err =&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>._value = err;</span><br><span class="line">            runRejected(err);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>._value = val;</span><br><span class="line">        runFulfilled(val);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 异步调用</span></span><br><span class="line">    setTimeout(run);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// reject 时执行的函数</span></span><br><span class="line">  private _reject = <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._status !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 依次执行失败队列中的函数，并清空队列</span></span><br><span class="line">    <span class="keyword">const</span> run = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>._status = REJECTED;</span><br><span class="line">      <span class="keyword">this</span>._value = err;</span><br><span class="line">      <span class="keyword">let</span> cb;</span><br><span class="line">      <span class="keyword">while</span> ((cb = <span class="keyword">this</span>._rejectedQueues.shift())) &#123;</span><br><span class="line">        cb(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 为了支持同步的Promise，这里采用异步调用</span></span><br><span class="line">    setTimeout(run);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// then 方法</span></span><br><span class="line">  then(onFulfilled?, onRejected?) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; _value, _status &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 返回一个新的Promise对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">onFulfilledNext, onRejectedNext</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 封装一个成功时执行的函数</span></span><br><span class="line">      <span class="keyword">const</span> fulfilled = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!isFunction(onFulfilled)) &#123;</span><br><span class="line">            onFulfilledNext(value);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> res = onFulfilled(value);</span><br><span class="line">            <span class="keyword">if</span> (res <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">              <span class="comment">// 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调</span></span><br><span class="line">              res.then(onFulfilledNext, onRejectedNext);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span></span><br><span class="line">              onFulfilledNext(res);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">          <span class="comment">// 如果函数执行出错，新的Promise对象的状态为失败</span></span><br><span class="line">          onRejectedNext(err);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 封装一个失败时执行的函数</span></span><br><span class="line">      <span class="keyword">const</span> rejected = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!isFunction(onRejected)) &#123;</span><br><span class="line">            onRejectedNext(error);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> res = onRejected(error);</span><br><span class="line">            <span class="keyword">if</span> (res <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">              <span class="comment">// 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调</span></span><br><span class="line">              res.then(onFulfilledNext, onRejectedNext);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span></span><br><span class="line">              onFulfilledNext(res);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">          <span class="comment">// 如果函数执行出错，新的Promise对象的状态为失败</span></span><br><span class="line">          onRejectedNext(err);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (_status) &#123;</span><br><span class="line">        <span class="comment">// 当状态为pending时，将then方法回调函数加入执行队列等待执行</span></span><br><span class="line">        <span class="keyword">case</span> PENDING:</span><br><span class="line">          <span class="keyword">this</span>._fulfilledQueues.push(fulfilled);</span><br><span class="line">          <span class="keyword">this</span>._rejectedQueues.push(rejected);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 当状态已经改变时，立即执行对应的回调函数</span></span><br><span class="line">        <span class="keyword">case</span> FULFILLED:</span><br><span class="line">          fulfilled(_value);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REJECTED:</span><br><span class="line">          rejected(_value);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// catch 方法</span></span><br><span class="line">  <span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">undefined</span>, onRejected);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// finally 方法</span></span><br><span class="line">  <span class="keyword">finally</span>(cb) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">      value =&gt; MyPromise.resolve(cb()).then(<span class="function"><span class="params">()</span> =&gt;</span> value),</span><br><span class="line">      reason =&gt;</span><br><span class="line">        MyPromise.resolve(cb()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 静态 resolve 方法</span></span><br><span class="line">  <span class="keyword">static</span> resolve(value) &#123;</span><br><span class="line">    <span class="comment">// 如果参数是MyPromise实例，直接返回这个实例</span></span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) <span class="keyword">return</span> value;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(value));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 静态 reject 方法</span></span><br><span class="line">  <span class="keyword">static</span> reject(value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(value));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 静态 all 方法</span></span><br><span class="line">  <span class="keyword">static</span> all(list) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 返回值的集合</span></span><br><span class="line">      <span class="keyword">let</span> values = [];</span><br><span class="line">      <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> [i, p] <span class="keyword">of</span> list.entries()) &#123;</span><br><span class="line">        <span class="comment">// 数组参数如果不是MyPromise实例，先调用MyPromise.resolve</span></span><br><span class="line">        <span class="keyword">this</span>.resolve(p).then(</span><br><span class="line">          res =&gt; &#123;</span><br><span class="line">            values[i] = res;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">// 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled</span></span><br><span class="line">            <span class="keyword">if</span> (count === list.length) resolve(values);</span><br><span class="line">          &#125;,</span><br><span class="line">          err =&gt; &#123;</span><br><span class="line">            <span class="comment">// 有一个被rejected时返回的MyPromise状态就变成rejected</span></span><br><span class="line">            reject(err);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加静态race方法</span></span><br><span class="line">  <span class="keyword">static</span> race(list) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> list) &#123;</span><br><span class="line">        <span class="comment">// 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变</span></span><br><span class="line">        <span class="keyword">this</span>.resolve(p).then(</span><br><span class="line">          res =&gt; &#123;</span><br><span class="line">            resolve(res);</span><br><span class="line">          &#125;,</span><br><span class="line">          err =&gt; &#123;</span><br><span class="line">            reject(err);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="防抖-节流"><a href="#防抖-节流" class="headerlink" title="防抖/节流"></a>防抖/节流</h2><div class="story post-story"><pre><code>防抖函数 onscroll 结束时触发一次，延迟执行</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">callback, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">if</span> (timeout) clearTimeout(timeout);</span><br><span class="line">    timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      callback.apply(context, args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="built_in">window</span>.onscroll = debounce(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"debounce"</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><pre><code>节流函数 onscroll 时，每隔一段时间触发一次，像水滴一样</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">callback, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prevTime = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> curTime = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">if</span> (curTime - prevTime &gt; delay) &#123;</span><br><span class="line">      callback.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      prevTime = curTime;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="built_in">window</span>.onscroll = throttle(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"throtte"</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></div><h2 id="函数柯里化实现"><a href="#函数柯里化实现" class="headerlink" title="函数柯里化实现"></a>函数柯里化实现</h2><div class="story post-story"><pre><code>其实我们无时无刻不在使用柯里化函数，只是没有将它总结出来而已。它的本质就是将一个参数很多的函数分解成单一参数的多个函数。</code></pre><p>应用场景：</p><ul><li>延迟计算 （用闭包把传入参数保存起来，当传入参数的数量足够执行函数时，开始执行函数）</li><li>动态创建函数 （参数不够时会返回接受剩下参数的函数）</li><li>参数复用（每个参数可以多次复用）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curry = <span class="function">(<span class="params">fn</span>) =&gt;</span></span><br><span class="line">  (judge = <span class="function">(<span class="params">...args</span>) =&gt;</span></span><br><span class="line">    args.length &gt;= fn.length</span><br><span class="line">      ? fn(...args)</span><br><span class="line">      : <span class="function">(<span class="params">...arg</span>) =&gt;</span> judge(...args, ...arg));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> a + b + c + d;</span><br><span class="line"><span class="keyword">const</span> currySum = curry(sum);</span><br><span class="line"></span><br><span class="line">currySum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>); <span class="comment">// 10</span></span><br><span class="line">currySum(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>); <span class="comment">// 10</span></span><br><span class="line">currySum(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>)(<span class="number">4</span>); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></div><h2 id="实现简单深拷贝"><a href="#实现简单深拷贝" class="headerlink" title="实现简单深拷贝"></a>实现简单深拷贝</h2><div class="story post-story"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> str = <span class="built_in">Object</span>.prototype.toString.call(obj);</span><br><span class="line">  <span class="keyword">const</span> map = &#123;</span><br><span class="line">    <span class="string">"[object Boolean]"</span>: <span class="string">"boolean"</span>,</span><br><span class="line">    <span class="string">"[object Number]"</span>: <span class="string">"number"</span>,</span><br><span class="line">    <span class="string">"[object String]"</span>: <span class="string">"string"</span>,</span><br><span class="line">    <span class="string">"[object Function]"</span>: <span class="string">"function"</span>,</span><br><span class="line">    <span class="string">"[object Array]"</span>: <span class="string">"array"</span>,</span><br><span class="line">    <span class="string">"[object Date]"</span>: <span class="string">"date"</span>,</span><br><span class="line">    <span class="string">"[object RegExp]"</span>: <span class="string">"regExp"</span>,</span><br><span class="line">    <span class="string">"[object Undefined]"</span>: <span class="string">"undefined"</span>,</span><br><span class="line">    <span class="string">"[object Null]"</span>: <span class="string">"null"</span>,</span><br><span class="line">    <span class="string">"[object Object]"</span>: <span class="string">"object"</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">    <span class="comment">// 判断是否是dom元素，如div等</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"element"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> map[str];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> type = getType(original);</span><br><span class="line">  <span class="keyword">let</span> copy;</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"array"</span>:</span><br><span class="line">      <span class="keyword">return</span> copyArray(original, copy);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"object"</span>:</span><br><span class="line">      <span class="keyword">return</span> copyObject(original, copy);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"function"</span>:</span><br><span class="line">      <span class="keyword">return</span> copyFunction(original, copy);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> original;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyArray</span>(<span class="params">original, copy = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> [index, value] <span class="keyword">of</span> original.entries()) &#123;</span><br><span class="line">    copy[index] = deepCopy(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyObject</span>(<span class="params">original, copy = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(original)) &#123;</span><br><span class="line">    copy[key] = deepCopy(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyFunction</span>(<span class="params">original, copy = (</span>) =&gt; </span>&#123;&#125;) &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="built_in">eval</span>(original.toString());</span><br><span class="line">  fn.prototype = original.prototype;</span><br><span class="line">  <span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], &#123; <span class="attr">i</span>: <span class="number">6</span>, <span class="attr">j</span>: <span class="number">6</span> &#125;, (k, m) =&gt; k + m];</span><br><span class="line"><span class="built_in">console</span>.log(deepCopy(arr1));</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端如何学数据结构与算法 - 一篇讲完关于`堆`的一切</title>
      <link href="/algorithms-heap-knowledge/"/>
      <url>/algorithms-heap-knowledge/</url>
      
        <content type="html"><![CDATA[<p>对于前端来说，堆是一个不好理解的知识，但也是必不可少的知识点，是面试时经常考的重难点，本文是笔者自身学习<code>堆</code>的心得记录，意在能对<code>堆</code>有个更加系统的了解。</p><a id="more"></a><h3 id="一、什么是堆"><a href="#一、什么是堆" class="headerlink" title="一、什么是堆"></a>一、什么是堆</h3><p>在了解什么是堆前，需要先了解什么是<code>完全二叉树</code>。</p><ul><li>完全二叉树</li></ul><p>一种特殊的二叉树，叶子节点都在最底下两层，最后一层叶子节都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫做完全二叉树。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfvcmzvjm4j31b00iijtq.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfvcmzvjm4j31b00iijtq.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><ul><li>堆</li></ul><p>堆是一种特殊的完全二叉树，堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。<br>如果堆上的任意节点都大于等于子节点值，则称为 <code>大顶堆</code>;<br>如果堆上的任意节点都小于等于子节点值，则称为 <code>小顶堆</code>;<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfvcmzvjm4j31b00iijtq.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfvcmzvjm4j31b00iijtq.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><h3 id="二、堆的存储"><a href="#二、堆的存储" class="headerlink" title="二、堆的存储"></a>二、堆的存储</h3><p>完全二叉树可以用数组存储，如果一个节点存储在数组中的下标为 i（ i从1开始） ，那么它的左子节点的存储下标为 2 * i ，右子节点的下标为 2 * i + 1，反过来，下标 i / 2 位置存储的就是该节点的父节点。完全二叉树用数组来存储是最省内存的方式。</p><p>因为堆是一种特殊的完全二叉树，所以堆也适用于上面的存储方法。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfvcv3i9l8j31b00iijtq.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfvcv3i9l8j31b00iijtq.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><h3 id="三、如何创建堆"><a href="#三、如何创建堆" class="headerlink" title="三、如何创建堆"></a>三、如何创建堆</h3><p>常用的创建堆方式有两种：</p><ul><li>插入式创建：每次插入一个节点，实现一个大顶堆（或小顶堆）</li><li>原地创建：又称堆化，给定一组节点，实现一个大顶堆（或小顶堆）</li></ul><p>下面都已创建大顶堆为例。</p><h4 id="3-1-插入式建堆"><a href="#3-1-插入式建堆" class="headerlink" title="3.1 插入式建堆"></a>3.1 插入式建堆</h4><p>步骤：</p><ol><li>将元素插入到队尾；</li><li>将插入节点与其父节点比较，如果插入节点大于父节点（对于大顶堆）或插入节点小于父节点（对于小顶堆），则插入节点与父节点调换位置。</li><li>如果需要调换位置，则调换后继续第2步向上比较，直到达到根节点，或者不需要调换为止。</li></ol><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfvd2cpts0j313s0u0416.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfvd2cpts0j313s0u0416.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><p>实现代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入式建堆</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MaxHeap</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> heaps = [,]; <span class="comment">//初始化一个堆，从1开始</span></span><br><span class="line">  <span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    heaps.push(value);</span><br><span class="line">    <span class="keyword">let</span> i = heaps.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">Math</span>.floor(i / <span class="number">2</span>) &gt; <span class="number">0</span> &amp;&amp; heaps[i] &gt; heaps[<span class="built_in">Math</span>.floor(i / <span class="number">2</span>)]) &#123;</span><br><span class="line">      [heaps[i], heaps[<span class="built_in">Math</span>.floor(i / <span class="number">2</span>)]] = [</span><br><span class="line">        heaps[<span class="built_in">Math</span>.floor(i / <span class="number">2</span>)],</span><br><span class="line">        heaps[i],</span><br><span class="line">      ]; <span class="comment">// 交换</span></span><br><span class="line">      i = <span class="built_in">Math</span>.floor(i / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.get = <span class="function"><span class="keyword">function</span> (<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> heaps</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> maxHeap = <span class="keyword">new</span> MaxHeap();</span><br><span class="line">maxHeap.insert(<span class="number">3</span>);</span><br><span class="line">maxHeap.insert(<span class="number">5</span>);</span><br><span class="line">maxHeap.insert(<span class="number">1</span>);</span><br><span class="line">maxHeap.insert(<span class="number">2</span>);</span><br><span class="line">maxHeap.insert(<span class="number">3</span>);</span><br><span class="line">maxHeap.insert(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">let</span> result = maxHeap.get();</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="comment">// =&gt; [empty, 5, 3, 4, 2, 3, 1]</span></span><br></pre></td></tr></table></figure><h4 id="3-2-原地建堆"><a href="#3-2-原地建堆" class="headerlink" title="3.2 原地建堆"></a>3.2 原地建堆</h4><p>原地建堆有两种思路：</p><ul><li>自下而上式堆化 ：将节点与其父节点比较，如果节点大于父节点（大顶堆）或节点小于父节点（小顶堆），则节点与父节点调整位置</li><li>自上往下式堆化 ：将节点与其左右子节点比较，如果存在左右子节点大于该节点（大顶堆）或小于该节点（小顶堆），则将子节点的最大值（大顶堆）或最小值（小顶堆）与之交换</li></ul><p>自下而上式堆是调整节点与父节点（往上走），自上往下式堆化是调整节点与其左右子节点（往下走）。</p><h5 id="3-2-1-从前往后、自下而上式堆化建堆。"><a href="#3-2-1-从前往后、自下而上式堆化建堆。" class="headerlink" title="3.2.1. 从前往后、自下而上式堆化建堆。"></a>3.2.1. 从前往后、自下而上式堆化建堆。</h5><p>假设有个序列：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfvek9jr3cj30pd0g0jv2.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfvek9jr3cj30pd0g0jv2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><p>实现代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildHeap</span>(<span class="params">items, heapSize = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (heapSize &lt; items.length - <span class="number">1</span>) &#123;</span><br><span class="line">    heapSize++;</span><br><span class="line">    heapify(items, heapSize);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapify</span>(<span class="params">items, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">Math</span>.floor(i / <span class="number">2</span>) &gt; <span class="number">0</span> &amp;&amp; items[i] &gt; items[<span class="built_in">Math</span>.floor(i / <span class="number">2</span>)]) &#123;</span><br><span class="line">    [items[i], items[<span class="built_in">Math</span>.floor(i / <span class="number">2</span>)]] = [items[<span class="built_in">Math</span>.floor(i / <span class="number">2</span>)], items[i]]; <span class="comment">//利用解构方式交换元素</span></span><br><span class="line">    i = <span class="built_in">Math</span>.floor(i / <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">buildHeap(arr);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; [ empty, 6, 4, 5, 2, 3, 1 ]</span></span><br></pre></td></tr></table></figure><h5 id="3-2-2-从后往前、自上而下式堆化建堆"><a href="#3-2-2-从后往前、自上而下式堆化建堆" class="headerlink" title="3.2.2. 从后往前、自上而下式堆化建堆"></a>3.2.2. 从后往前、自上而下式堆化建堆</h5><p>因为叶子节点没有子节点，不需要自上而下式堆化，所以从后往前是从序列的最后一个非叶子节点开始（即 n/2）。</p><p>假设有个序列：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200629110822.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200629110822.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20200629110822"></p><p>实现代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildHeap</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> heapSize = items.length - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 从最后一个非叶子节点开始遍历</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">Math</span>.floor(heapSize / <span class="number">2</span>); i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">    heapify(items, heapSize, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapify</span>(<span class="params">items, heapSize, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> maxIndex = i; <span class="comment">// 用maxIndex表示 i 的最大子节点的下标</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * i &lt;= heapSize &amp;&amp; items[i] &lt; items[<span class="number">2</span> * i]) &#123;</span><br><span class="line">      maxIndex = <span class="number">2</span> * i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * i + <span class="number">1</span> &lt;= heapSize &amp;&amp; items[maxIndex] &lt; items[<span class="number">2</span> * i + <span class="number">1</span>]) &#123;</span><br><span class="line">      maxIndex = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (maxIndex === i) <span class="keyword">break</span>;</span><br><span class="line">    [items[maxIndex], items[i]] = [items[i], items[maxIndex]]; <span class="comment">//交换 i 与其最大的子节点</span></span><br><span class="line">    i = maxIndex;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">buildHeap(arr);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; [ empty, 6, 5, 4, 3, 2, 1 ]</span></span><br></pre></td></tr></table></figure><h3 id="四、堆排序"><a href="#四、堆排序" class="headerlink" title="四、堆排序"></a>四、堆排序</h3><p>由于大顶堆的堆顶点（i=1）存放的是最大值，所以可以每次让堆顶与最后一个节点交换数据，此时最大值放入了有效序列的最后一位，并且有效序列减1，有效堆依然保持完全二叉树的结构，然后堆化，成为新的大顶堆，重复此操作，直到有效堆的长度为 0，排序完成。</p><p>详细步骤：</p><ol><li>将原序列转化成一个大顶堆；</li><li>设置堆的有效序列长度为 heapSize；</li><li>将堆顶元素与最后一个子元素（最后一个有效序列）交换，并有效序列长度减1；</li><li>堆化有效序列，使有效序列重新称为一个大顶堆；</li><li>重复以上2、3步，直到有效序列的长度为 1，排序完成；</li></ol><p>实现代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 设置堆的初始有效序列长度为 items.length - 1</span></span><br><span class="line">  <span class="keyword">let</span> heapSize = items.length - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 构建大顶堆</span></span><br><span class="line">  buildHeap(items, heapSize);</span><br><span class="line">  <span class="keyword">while</span> (heapSize &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 交换堆顶元素与最后一个有效子元素</span></span><br><span class="line">    [items[<span class="number">1</span>], items[heapSize]] = [items[heapSize], items[<span class="number">1</span>]];</span><br><span class="line">    <span class="comment">// 有效序列长度减 1</span></span><br><span class="line">    heapSize--;</span><br><span class="line">    heapify(items, heapSize, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> items;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 原地建堆: 自上而下建堆，</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;原始序列&#125;</span> <span class="variable">items</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;有效序列长度&#125;</span> <span class="variable">heapSize</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildHeap</span>(<span class="params">items, heapSize</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 从最后一个非叶子节点开始，自上而下式堆化</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">Math</span>.floor(heapSize / <span class="number">2</span>); i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">    heapify(items, heapSize, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里不适合用自下而上方式，因为交换过后，有效序列里唯一没有堆化的是堆顶元素，</span></span><br><span class="line"><span class="comment"> * 所以直接从堆顶开始自上而下堆化是最快的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapify</span>(<span class="params">items, heapSize, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> maxIndex = i; <span class="comment">// 用maxIndex表示 i 的最大子节点的下标</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * i &lt;= heapSize &amp;&amp; items[i] &lt; items[<span class="number">2</span> * i]) &#123;</span><br><span class="line">      maxIndex = <span class="number">2</span> * i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * i + <span class="number">1</span> &lt;= heapSize &amp;&amp; items[maxIndex] &lt; items[<span class="number">2</span> * i + <span class="number">1</span>]) &#123;</span><br><span class="line">      maxIndex = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (maxIndex === i) <span class="keyword">break</span>;</span><br><span class="line">    [items[maxIndex], items[i]] = [items[i], items[maxIndex]]; <span class="comment">//交换 i 与其最大的子节点</span></span><br><span class="line">    i = maxIndex;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> items = [, <span class="number">8</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>]</span><br><span class="line">heapSort(items)</span><br><span class="line"><span class="built_in">console</span>.log(items);</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; [ empty, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]</span></span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>时间复杂度： <code>建堆</code> - O(nlogn),  <code>排序</code> - O(nlogn), <code>整体</code> - O(nlogn);</li><li>空间复杂度： O(1);</li></ul><h3 id="堆的典型应用场景：-Top-K-问题"><a href="#堆的典型应用场景：-Top-K-问题" class="headerlink" title="堆的典型应用场景： Top K 问题"></a>堆的典型应用场景： Top K 问题</h3><blockquote><p>什么是 Top K 问题？简单来说就是在一组数据里面找到频率出现最高的前K个数，或前K大（或前K小）的数。</p></blockquote><p>下面以取前K大为例来讲解：</p><ol><li>从数组中取前 K 个数，构造成小顶堆；</li><li>从 K+1 位开始遍历数组，每一个数据都和小顶堆的堆顶元素进行比较，如果小于堆顶元素，则不做任何处理，继续遍历下一元素；如果大于堆顶元素，则将这个元素替换掉堆顶元素，然后再堆化成一个小顶堆。</li><li>遍历完成后，堆中的数据就是前 K 大的数据；</li></ol><p>实现代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findKthLargest</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">  nums.splice(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">  buildHeap(nums, k);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = k + <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; nums[<span class="number">1</span>]) &#123;</span><br><span class="line">      nums[<span class="number">1</span>] = nums[i];</span><br><span class="line">      heapify(nums, k, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 原地建堆: 自上而下建堆，</span></span><br><span class="line"><span class="comment"> * 这里不适合用自下而上方式，因为交换过后，有效序列里唯一没有堆化的是堆顶元素，</span></span><br><span class="line"><span class="comment"> * 所以直接从堆顶开始自上而下堆化是最快的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;原始序列&#125;</span> <span class="variable">items</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;有效序列长度&#125;</span> <span class="variable">heapSize</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildHeap</span>(<span class="params">items, heapSize</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 从最后一个非叶子节点开始，自上而下式堆化</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">Math</span>.floor(heapSize / <span class="number">2</span>); i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">    heapify(items, heapSize, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapify</span>(<span class="params">items, heapSize, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> minIndex = i; <span class="comment">// 用minIndex表示 i 的最小子节点的下标</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * i &lt;= heapSize &amp;&amp; items[i] &gt; items[<span class="number">2</span> * i]) &#123;</span><br><span class="line">      minIndex = <span class="number">2</span> * i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * i + <span class="number">1</span> &lt;= heapSize &amp;&amp; items[minIndex] &gt; items[<span class="number">2</span> * i + <span class="number">1</span>]) &#123;</span><br><span class="line">      minIndex = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (minIndex === i) <span class="keyword">break</span>;</span><br><span class="line">    [items[minIndex], items[i]] = [items[i], items[minIndex]]; <span class="comment">//交换</span></span><br><span class="line">    i = minIndex;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> nums = [<span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">let</span> kth = findKthLargest(nums, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(kth);</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>时间复杂度：遍历数组需要 O(n) 的时间复杂度，一次堆化需要 O(logk) 时间复杂度，所以利用堆求 Top k 问题的时间复杂度为 O(nlogk)</li><li>空间复杂度：O(k)</li></ul><p>当然，topK的最简单实现是用排序，但是用堆方式的话，最大好处就是求<code>动态数组</code>的topK。如果用排序方式的话，每次进来一个新元素都得重新排序，这是非常不可取的，而堆方式可以有效处理这个问题。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端如何学数据结构与算法 - 一篇讲完经典排序算法</title>
      <link href="/algorithms-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/algorithms-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>二叉树通常作为数据结构应用，典型用法是对节点定义一个标记函数，将一些值与每个节点相关系。这样标记的二叉树就可以实现二叉查找树和二叉堆，并应用于高效率的搜索和排序。</p><a id="more"></a><h3 id="什么是二叉树"><a href="#什么是二叉树" class="headerlink" title="什么是二叉树"></a>什么是二叉树</h3><p>二叉树（英语：Binary tree）是每个节点最多只有两个分支（即不存在分支度大于2的节点）的树结构。通常分支被称作“左子树”或“右子树”。二叉树的分支具有左右次序，不能随意颠倒。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200928145802.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200928145802.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20200928145802"></p><h3 id="二叉树的分类"><a href="#二叉树的分类" class="headerlink" title="二叉树的分类"></a>二叉树的分类</h3><ul><li>满二叉树</li></ul><p>一种特殊的二叉树，除了叶子节点外，每个节点都有左右两个子节点，这种二叉树叫做满二叉树。满二叉树中，第i层拥有2<sup>i-1</sup>个节点。</p><ul><li>完全二叉树</li></ul><p>一种特殊的二叉树，叶子节点都在最底下两层，最后一层叶子节都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫做完全二叉树。</p><ul><li>堆</li></ul><p>堆是一个完全二叉树, 并且堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值。<br>对于每个节点的值都大于等于子树中每个节点值的堆，我们叫作<code>大顶堆</code>。对于每个节点的值都小于等于子树中每个节点值的堆，我们叫作<code>小顶堆</code>。</p><ul><li>二叉查找树（Binary Search Tree）</li></ul><p>一种特殊的二叉树，相对较小的值保存在左节点中，较大的值保存在右节点中，叫二叉查找树，也叫二叉搜索树。 二叉查找树是一种有序的树，所以支持快速查找、快速插入、删除一个数据。</p><p>下图中， 3 个都是二叉查找树</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200928154737.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200928154737.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20200928154737"></p><ul><li>平衡二叉查找树</li></ul><p>一种特殊的二叉树, 二叉树中任意一个节点的左右子树的高度相差不能大于 1。</p><p>完全二叉树、满二叉树其实都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树.</p><p>平衡二叉查找树中平衡的意思，其实就是让整棵树左右看起来比较对称、比较平衡，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。</p><h3 id="完全二叉树的存储"><a href="#完全二叉树的存储" class="headerlink" title="完全二叉树的存储"></a>完全二叉树的存储</h3><ul><li>二叉链表存储</li></ul><p>每个节点由 3 个字段，其中一个存储数据，另外两个是指向左右子节点的指针。 我们只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。 这种存储方式比较常用，大部分二叉树代码都是通过这种方式实现的。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200928155716.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200928155716.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20200928155716"></p><ul><li>顺序存储</li></ul><p>用数组来存储，对于完全二叉树，如果节点 X 存储在数组中的下标为 i ，那么它的左子节点的存储下标为 2 * i ，右子节点的下标为 2 * i + 1，反过来，下标 i / 2 位置存储的就是该节点的父节点。 注意，根节点存储在下标为 1 的位置。完全二叉树用数组来存储是最省内存的方式。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200928155756.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200928155756.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20200928155756"></p><h3 id="实现二叉查找树"><a href="#实现二叉查找树" class="headerlink" title="实现二叉查找树"></a>实现二叉查找树</h3><p>实现以下方法：</p><ul><li>insert(key)：向树中插入一个新的键。</li><li>search(key)：在树中查找一个键，如果节点存在，则返回 true；如果不存在，则返回 false。</li><li>min：返回树中最小的值/键。</li><li>max：返回树中最大的值/键。</li><li>remove(key)：从树中移除某个键。</li></ul><h4 id="实现二叉查找树类"><a href="#实现二叉查找树类" class="headerlink" title="实现二叉查找树类"></a>实现二叉查找树类</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BinarySearchTree</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 节点结构</span></span><br><span class="line">  <span class="keyword">const</span> Node = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="keyword">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//根节点</span></span><br><span class="line">  <span class="keyword">let</span> root = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h4><p> 遍历树，将插入节点的键值与遍历到的节点键值比较，如果前者大于后者，继续递归遍历右子节点，反之，继续遍历左子节点，直到找到一个空的节点，在该位置插入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入新节点</span></span><br><span class="line"><span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//创建节点</span></span><br><span class="line">  <span class="keyword">const</span> node = <span class="keyword">new</span> Node(key);</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//判断是否为根节点</span></span><br><span class="line">    root = node;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不是根节点则新增节点</span></span><br><span class="line">    insertNode(root, node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//新增节点</span></span><br><span class="line"><span class="keyword">const</span> insertNode = <span class="function"><span class="keyword">function</span> (<span class="params">node, newNode</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//约定右孩子都大于左孩子节点</span></span><br><span class="line">  <span class="keyword">if</span> (newNode.key &lt; node.key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.left === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//没有左孩子，则新增左孩子</span></span><br><span class="line">      node.left = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果有左孩子则递归算法实现插入左孩子节点</span></span><br><span class="line">      insertNode(node.left, newNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果没有右孩子，则新增右孩子</span></span><br><span class="line">    <span class="keyword">if</span> (node.right === <span class="literal">null</span>) &#123;</span><br><span class="line">      node.right = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果有右孩子则递归算法实现插入右孩子节点</span></span><br><span class="line">      insertNode(node.right, newNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="搜索最小值"><a href="#搜索最小值" class="headerlink" title="搜索最小值"></a>搜索最小值</h4><p>在二叉搜索树里，不管是整个树还是其子树，最小值一定在树最左侧的最底层。 因此给定一颗树或其子树，只需要一直向左节点遍历到底就行了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.min = <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// min方法允许传入子树</span></span><br><span class="line">  node = node || root;</span><br><span class="line">  <span class="comment">// 一直遍历左侧子节点，直到底部</span></span><br><span class="line">  <span class="keyword">while</span> (node &amp;&amp; node.left !== <span class="literal">null</span>) &#123;</span><br><span class="line">    node = node.left;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="搜索最大值"><a href="#搜索最大值" class="headerlink" title="搜索最大值"></a>搜索最大值</h4><p>搜索最大值与搜索最小值类似，只是沿着树的右侧遍历。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.max = <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// max方法允许传入子树</span></span><br><span class="line">  node = node || root;</span><br><span class="line">  <span class="comment">// 一直遍历左侧子节点，直到底部</span></span><br><span class="line">  <span class="keyword">while</span> (node &amp;&amp; node.right !== <span class="literal">null</span>) &#123;</span><br><span class="line">    node = node.right;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="搜索指定节点"><a href="#搜索指定节点" class="headerlink" title="搜索指定节点"></a>搜索指定节点</h4><p>遍历树，将要搜索的值与遍历到的节点比较，如果前者大于后者，则递归遍历右子树，反之，则递归遍历左子树。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.search = <span class="function"><span class="keyword">function</span> (<span class="params">key, node</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 同样的，search方法允许在子树中查找值</span></span><br><span class="line">  node = node || root;</span><br><span class="line">  <span class="keyword">return</span> searchNode(key, node);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> searchNode = <span class="function"><span class="keyword">function</span> (<span class="params">key, node</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果node是null，说明树中没有要查找的值，返回false</span></span><br><span class="line">  <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (key &lt; node.key) &#123;</span><br><span class="line">    <span class="comment">// 如果要查找的值小于该节点，继续递归遍历其左侧节点</span></span><br><span class="line">    <span class="keyword">return</span> searchNode(key, node.left);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node.key) &#123;</span><br><span class="line">    <span class="comment">// 如果要查找的值大于该节点，继续递归遍历其右侧节点</span></span><br><span class="line">    <span class="keyword">return</span> searchNode(key, node.right);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果要查找的值等于该节点，说明查找成功，返回该节点</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span> (<span class="params">key, node</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 同样的，允许仅在子树中删除节点</span></span><br><span class="line">  node = node || root;</span><br><span class="line">  <span class="keyword">return</span> removeNode.call(<span class="keyword">this</span>, key, node);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> removeNode = <span class="function"><span class="keyword">function</span> (<span class="params">key, node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (key == node.key) &#123;</span><br><span class="line">    <span class="comment">// 没有子节点（子树）</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只有右子节点（子树）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> node.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只有左子节点（子树）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有两个子节点（子树）</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> tempNode = <span class="keyword">this</span>.min(node.right);</span><br><span class="line">      node.key = tempNode.key;</span><br><span class="line">      node.right = removeNode.call(<span class="keyword">this</span>, tempNode.key, node.right);</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; node.key) &#123;</span><br><span class="line">    node.left = removeNode.call(<span class="keyword">this</span>, key, node.left);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    node.right = removeNode.call(<span class="keyword">this</span>, key, node.right);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><ul><li>前序遍历</li></ul><p>先处理中节点，接着处理左节点再处理右节点，递归遍历所有所有节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.preOrderTraverse = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 同样的，callback用于对遍历到的节点做操作</span></span><br><span class="line">  preOrderTraverseNode(root, callback);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> preOrderTraverseNode = <span class="function"><span class="keyword">function</span> (<span class="params">node, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历到node为null为止</span></span><br><span class="line">  <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">    callback(node.key); <span class="comment">// 先处理当前节点</span></span><br><span class="line">    preOrderTraverseNode(node.left, callback); <span class="comment">// 再继续遍历左子节点</span></span><br><span class="line">    preOrderTraverseNode(node.right, callback); <span class="comment">// 最后遍历右子节点</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>中序遍历</li></ul><p>先处理左节点，接着处理中节点再处理右节点，递归遍历所有所有节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.inOrderTraverse = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// callback用于对遍历到的节点做操作</span></span><br><span class="line">  inOrderTraverseNode(root, callback);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> inOrderTraverseNode = <span class="function"><span class="keyword">function</span> (<span class="params">node, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历到node为null为止</span></span><br><span class="line">  <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 优先遍历左边节点，保证从小到大遍历</span></span><br><span class="line">    inOrderTraverseNode(node.left, callback);</span><br><span class="line">    <span class="comment">// 处理当前的节点</span></span><br><span class="line">    callback(node.key);</span><br><span class="line">    <span class="comment">// 遍历右侧节点</span></span><br><span class="line">    inOrderTraverseNode(node.right, callback);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>后序遍历</li></ul><p>先处理左节点，接着处理右节点再处理中节点，递归遍历所有所有节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.postOrderTraverse = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    postOrderTraverseNode(root, callback);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> postOrderTraverseNode = <span class="function"><span class="keyword">function</span> (<span class="params">node, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">      postOrderTraverseNode(node.left, callback);</span><br><span class="line">      postOrderTraverseNode(node.right, callback);</span><br><span class="line">      callback(node.key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h4 id="广度遍历"><a href="#广度遍历" class="headerlink" title="广度遍历"></a>广度遍历</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//广度遍历BFS</span></span><br><span class="line"><span class="keyword">this</span>.BFS = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">const</span> res = [],</span><br><span class="line">    queue = [root];</span><br><span class="line">  <span class="keyword">while</span> (queue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> rows = [];</span><br><span class="line">    <span class="keyword">const</span> size = queue.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> item = queue.shift();</span><br><span class="line">      rows.push(item.key);</span><br><span class="line">      <span class="keyword">if</span> (item.left) queue.push(item.left);</span><br><span class="line">      <span class="keyword">if</span> (item.right) queue.push(item.right);</span><br><span class="line">    &#125;</span><br><span class="line">    res.push(rows);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="附：完整代码"><a href="#附：完整代码" class="headerlink" title="附：完整代码"></a>附：完整代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//js实现二叉查找树</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BinarySearchTree</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 节点结构</span></span><br><span class="line">  <span class="keyword">const</span> Node = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="keyword">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//根节点</span></span><br><span class="line">  <span class="keyword">let</span> root = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入新节点</span></span><br><span class="line">  <span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//创建节点</span></span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> Node(key);</span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//判断是否为根节点</span></span><br><span class="line">      root = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不是根节点则新增节点</span></span><br><span class="line">      insertNode(root, node);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//新增节点</span></span><br><span class="line">  <span class="keyword">const</span> insertNode = <span class="function"><span class="keyword">function</span> (<span class="params">node, newNode</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//约定右孩子都大于左孩子节点</span></span><br><span class="line">    <span class="keyword">if</span> (newNode.key &lt; node.key) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node.left === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//没有左孩子，则新增左孩子</span></span><br><span class="line">        node.left = newNode;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果有左孩子则递归算法实现插入左孩子节点</span></span><br><span class="line">        insertNode(node.left, newNode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果没有右孩子，则新增右孩子</span></span><br><span class="line">      <span class="keyword">if</span> (node.right === <span class="literal">null</span>) &#123;</span><br><span class="line">        node.right = newNode;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果有右孩子则递归算法实现插入右孩子节点</span></span><br><span class="line">        insertNode(node.right, newNode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取最小节点</span></span><br><span class="line">  <span class="keyword">this</span>.min = <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// min方法允许传入子树</span></span><br><span class="line">    node = node || root;</span><br><span class="line">    <span class="comment">// 一直遍历左侧子节点，直到底部</span></span><br><span class="line">    <span class="keyword">while</span> (node &amp;&amp; node.left !== <span class="literal">null</span>) &#123;</span><br><span class="line">      node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//获取最大节点</span></span><br><span class="line">  <span class="keyword">this</span>.max = <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// min方法允许传入子树</span></span><br><span class="line">    node = node || root;</span><br><span class="line">    <span class="comment">// 一直遍历左侧子节点，直到底部</span></span><br><span class="line">    <span class="keyword">while</span> (node &amp;&amp; node.right !== <span class="literal">null</span>) &#123;</span><br><span class="line">      node = node.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//搜索指定节点</span></span><br><span class="line">  <span class="keyword">this</span>.search = <span class="function"><span class="keyword">function</span> (<span class="params">key, node</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 同样的，search方法允许在子树中查找值</span></span><br><span class="line">    node = node || root;</span><br><span class="line">    <span class="keyword">return</span> searchNode(key, node);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> searchNode = <span class="function"><span class="keyword">function</span> (<span class="params">key, node</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果node是null，说明树中没有要查找的值，返回false</span></span><br><span class="line">    <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; node.key) &#123;</span><br><span class="line">      <span class="comment">// 如果要查找的值小于该节点，继续递归遍历其左侧节点</span></span><br><span class="line">      <span class="keyword">return</span> searchNode(key, node.left);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node.key) &#123;</span><br><span class="line">      <span class="comment">// 如果要查找的值大于该节点，继续递归遍历其右侧节点</span></span><br><span class="line">      <span class="keyword">return</span> searchNode(key, node.right);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果要查找的值等于该节点，说明查找成功，返回该节点</span></span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span> (<span class="params">key, node</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 同样的，允许仅在子树中删除节点</span></span><br><span class="line">    node = node || root;</span><br><span class="line">    <span class="keyword">return</span> removeNode.call(<span class="keyword">this</span>, key, node);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> removeNode = <span class="function"><span class="keyword">function</span> (<span class="params">key, node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key == node.key) &#123;</span><br><span class="line">      <span class="comment">// 没有子节点（子树）</span></span><br><span class="line">      <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 只有右子节点（子树）</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> node.right;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 只有左子节点（子树）</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> node.left;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 有两个子节点（子树）</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> tempNode = <span class="keyword">this</span>.min(node.right);</span><br><span class="line">        node.key = tempNode.key;</span><br><span class="line">        node.right = removeNode.call(<span class="keyword">this</span>, tempNode.key, node.right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; node.key) &#123;</span><br><span class="line">      node.left = removeNode.call(<span class="keyword">this</span>, key, node.left);</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      node.right = removeNode.call(<span class="keyword">this</span>, key, node.right);</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//先序遍历</span></span><br><span class="line">  <span class="keyword">this</span>.preOrderTraverse = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 同样的，callback用于对遍历到的节点做操作</span></span><br><span class="line">    preOrderTraverseNode(root, callback);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> preOrderTraverseNode = <span class="function"><span class="keyword">function</span> (<span class="params">node, callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历到node为null为止</span></span><br><span class="line">    <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">      callback(node.key); <span class="comment">// 先处理当前节点</span></span><br><span class="line">      preOrderTraverseNode(node.left, callback); <span class="comment">// 再继续遍历左子节点</span></span><br><span class="line">      preOrderTraverseNode(node.right, callback); <span class="comment">// 最后遍历右子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//中序遍历</span></span><br><span class="line">  <span class="keyword">this</span>.inOrderTraverse = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// callback用于对遍历到的节点做操作</span></span><br><span class="line">    inOrderTraverseNode(root, callback);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> inOrderTraverseNode = <span class="function"><span class="keyword">function</span> (<span class="params">node, callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历到node为null为止</span></span><br><span class="line">    <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 优先遍历左边节点，保证从小到大遍历</span></span><br><span class="line">      inOrderTraverseNode(node.left, callback);</span><br><span class="line">      <span class="comment">// 处理当前的节点</span></span><br><span class="line">      callback(node.key);</span><br><span class="line">      <span class="comment">// 遍历右侧节点</span></span><br><span class="line">      inOrderTraverseNode(node.right, callback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//后序遍历</span></span><br><span class="line">  <span class="keyword">this</span>.postOrderTraverse = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    postOrderTraverseNode(root, callback);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> postOrderTraverseNode = <span class="function"><span class="keyword">function</span> (<span class="params">node, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">      postOrderTraverseNode(node.left, callback);</span><br><span class="line">      postOrderTraverseNode(node.right, callback);</span><br><span class="line">      callback(node.key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//广度遍历BFS</span></span><br><span class="line">  <span class="keyword">this</span>.BFS = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">const</span> res = [],</span><br><span class="line">      queue = [root];</span><br><span class="line">    <span class="keyword">while</span> (queue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> rows = [];</span><br><span class="line">      <span class="keyword">const</span> size = queue.length;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> item = queue.shift();</span><br><span class="line">        rows.push(item.key);</span><br><span class="line">        <span class="keyword">if</span> (item.left) queue.push(item.left);</span><br><span class="line">        <span class="keyword">if</span> (item.right) queue.push(item.right);</span><br><span class="line">      &#125;</span><br><span class="line">      res.push(rows);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"root :"</span>, root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = BinarySearchTree;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端如何学数据结构与算法 - JavaScript里的栈与堆</title>
      <link href="/algorithms-JavaScript%E9%87%8C%E7%9A%84%E6%A0%88%E5%86%85%E5%AD%98%E4%B8%8E%E5%A0%86%E5%86%85%E5%AD%98/"/>
      <url>/algorithms-JavaScript%E9%87%8C%E7%9A%84%E6%A0%88%E5%86%85%E5%AD%98%E4%B8%8E%E5%A0%86%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍堆与栈，以及他们在JavaScript语言底层的应用。</p><a id="more"></a><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul><li>定义<ul><li>后进者先出，先进者后出，简称 后进先出（LIFO），这就是典型的栈结构。</li><li>在栈里，新元素都靠近栈顶，旧元素都接近栈底。</li><li>从栈的操作特性来看，是一种 操作受限的线性表，只允许在一端插入和删除数据。</li><li>不包含任何元素的栈称为空栈。</li></ul></li></ul><p>栈被用在编程语言的编译器和内存中保存变量、方法调用等，比如函数的调用栈、前端路由等。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhfvwdizbj30lc0i43zg.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhfvwdizbj30lc0i43zg.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul><li><p>定义</p><ul><li>堆数据结构是一种树状结构</li><li>它的存取数据的方式，与书架相似：我们不关心书的放置顺序是怎样的，只需知道书的名字就可以取出我们想要的书</li></ul></li><li><p>堆与栈比较</p><ul><li>栈，线性结构，后进先出，便于管理。</li><li>堆，非线性结构，杂乱无章，方便存储和开辟内存空间。</li><li>堆是动态分配内存，内存大小不一，不会自动释放。</li><li>栈是自动分配相对固定大小的内存空间，并由系统自动释放。</li></ul></li></ul><h3 id="JS在浏览器上的运行机制"><a href="#JS在浏览器上的运行机制" class="headerlink" title="JS在浏览器上的运行机制"></a>JS在浏览器上的运行机制</h3><p>我们知道 JavaScript 是单线程的，所谓单线程，是指在 JavaScript 引擎中负责解释和执行 JavaScript 代码的线程唯一，同一时间上只能执行一件任务。</p><p>为什么是单线程？这是因为 JavaScript 可以修改 DOM 结构，如果 JavaScript 引擎线程不是单线程的，那么可以同时执行多段 JavaScript，如果这多段 JavaScript 都修改 DOM，那么就会出现 DOM 冲突。</p><p>为了避免 DOM 渲染的冲突，可以采用单线程或者死锁，JavaScript 采用了单线程方案。</p><p>但单线程有一个问题：如果任务队列里有一个任务耗时很长，导致这个任务后面的任务一直排队等待，就会发生页面卡死，严重影响用户体验。</p><p>为了解决这个问题，JavaScript 将任务的执行模式分为两种：同步和异步。</p><ul><li><p>同步</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步任务</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p>异步</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步任务</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure></li></ul><p>同步任务都在主线程（ JavaScript 引擎线程）上执行，会形成一个 <code>调用栈</code>(执行栈)；</p><p>除了主线程外，还有一个<code>任务队列</code>（也称消息队列），用于管理异步任务的 事件回调 ，在 调用栈 的任务执行完毕之后，系统会检查任务队列，看是否有可以执行的异步任务。</p><blockquote><p>注意：任务队列存放的是异步任务的事件回调</p></blockquote><p>例如上例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>在执行这段代码时，并不会立刻打印 ，只有定时结束后（1s）才打印。 setTimeout 本身是同步执行的，放入任务队列的是它的回调函数。</p><p>下面我们重点看一下主线程上的调用栈。</p><h3 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h3><p>调用栈是用来管理函数调用关系的一种栈结构 。</p><p>下面通过一个简单例子说明调用栈如何管理函数调用关系：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line">  <span class="keyword">let</span> c = <span class="number">3</span></span><br><span class="line">  <span class="keyword">return</span> a + b + c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数调用</span></span><br><span class="line">add(a)</span><br></pre></td></tr></table></figure><p>在执行这段代码之前，JavaScript 引擎会先创建一个全局执行上下文，包含所有已声明的函数与变量：</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200623183605.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200623183605.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20200623183605"></p><p>从图中可以看出，代码中的全局变量 a 及函数 add 保存在变量环境中。</p><p>执行上下文准备好后，开始执行全局代码，首先执行 a = 1 的赋值操作，<br><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200623183718.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200623183718.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20200623183718"></p><p>赋值完成后 a 的值由 undefined 变为 1，然后执行 add 函数，JavaScript 判断出这是一个函数调用，然后执行以下操作：</p><p>首先，从全局执行上下文中，取出 add 函数代码<br>其次，对 add 函数的这段代码进行编译，并创建该函数的执行上下文和可执行代码，并将执行上下文压入栈中<br><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200623183755.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200623183755.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20200623183755"></p><p>然后，执行代码，返回结果，并将 add 的执行上下文也会从栈顶部弹出，此时调用栈中就只剩下全局上下文了。<br><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200623183853.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200623183853.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20200623183853"></p><p>至此，整个函数调用执行结束了。</p><p>所以说，调用栈是 JavaScript 用来管理函数执行上下文的一种数据结构，它记录了当前函数执行的位置，哪个函数正在被执行。 如果我们执行一个函数，就会为函数创建执行上下文并放入栈顶。 如果我们从函数返回，就将它的执行上下文从栈顶弹出。 也可以说调用栈是用来管理这种执行上下文的栈，或称执行上下文栈（执行栈）。</p><p>了解了什么是调用栈，就能方便的理解<code>栈溢出</code>了，因为调用栈是一个栈结构，它有容量上限，当入栈的上下文过多的时候，它就会报栈溢出。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200623185331.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200623185331.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><blockquote><p>可以通过<code>console.trace()</code>来查看函数的调用栈路径</p></blockquote><h3 id="栈内存与堆内存"><a href="#栈内存与堆内存" class="headerlink" title="栈内存与堆内存"></a>栈内存与堆内存</h3><p>JavaScript 中的变量分为基本类型和引用类型。</p><p><code>基本类型</code>是保存在栈内存中的简单数据段，它们的值都有固定的大小，通过按值访问，并由系统自动分配和自动释放。 这样带来的好处就是，内存可以及时得到回收，相对于堆来说，更加<code>容易管理内存空间</code>。 JavaScript 中的 <code>Boolean、Null、Undefined、Number、String、Symbol</code> 都是基本类型。</p><p><code>引用类型</code>（如对象、数组、函数等）是保存在堆内存中的对象，值大小不固定，栈内存中存放的该对象的访问地址指向堆内存中的对象，JavaScript 不允许直接访问堆内存中的位置，因此操作对象时，实际操<code>作对象的引用</code>。 JavaScript 中的 <code>Object、Array、Function、RegExp、Date</code>是引用类型。</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line">  <span class="keyword">var</span> c = &#123; <span class="attr">name</span>: <span class="string">'an'</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数调用</span></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200623185724.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200623185724.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><p>当我们要访问堆内存中的引用数据类型时:</p><ol><li>从栈中获取该对象的地址引用;</li><li>再从堆内存中取得我们需要的数据;</li></ol><ul><li>复制基本类型</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line">b = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfjs47bav7j30yg0ajq43.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfjs47bav7j30yg0ajq43.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""><br>在栈内存中的数据发生复制行为时，系统会自动为新的变量分配一个新值，最后这些变量都是 相互独立，互不影响的。</p><ul><li>复制引用类型</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line">b.x = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.x); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>引用类型的复制，同样为新的变量 b 分配一个新的值，保存在栈内存中，不同的是，这个值仅仅是引用类型的一个<code>地址指针</code>。<br>他们两个指向<code>同一个堆内存空间</code>，在堆内存中访问到的具体对象实际上是<code>同一个</code>。<br>因此改变 b.x 时，a.x 也发生了变化，这就是引用类型的特性。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfjsc37dtkj30yg0u0dio.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfjsc37dtkj30yg0u0dio.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><ul><li>总结</li></ul><table><thead><tr><th align="left">栈内存</th><th align="left">堆内存</th></tr></thead><tbody><tr><td align="left">存储基础数据类型</td><td align="left">存储引用数据类型</td></tr><tr><td align="left">按值访问</td><td align="left">按引用访问</td></tr><tr><td align="left">存储的值大小固定</td><td align="left">存储的值大小不定，可动态调整</td></tr><tr><td align="left">由系统自动分配内存空间</td><td align="left">由代码进行指定分配</td></tr><tr><td align="left">空间小，运行效率高</td><td align="left">空间大，运行效率相对较低</td></tr><tr><td align="left">先进后出，后进先出</td><td align="left">无序存储，可根据引用直接获取</td></tr></tbody></table><h3 id="浅拷贝-与-深拷贝"><a href="#浅拷贝-与-深拷贝" class="headerlink" title="浅拷贝 与 深拷贝"></a>浅拷贝 与 深拷贝</h3><p>上面讲的引用类型的复制就是<code>浅拷贝</code>，复制得到的访问地址都指向同一个内存空间。所以修改了其中一个的值，另外一个也跟着改变了。</p><p><code>深拷贝</code>：复制得到的访问地址指向不同的内存空间，互不相干。所以修改其中一个值，另外一个不会改变。</p><p>浅拷贝的优势在于性能出色，但是并不能都满足日常需求，很多时候我们需要改变拷贝数组的时候，原数组不受影响，这时候就需要用到深拷贝了。</p><ul><li>一个通用深拷贝的实现<br>主要思想：<ul><li>通过判断拷贝对象的类型，如果是基本类型，直接赋值，如果是引用类型(array/object/function),则进入核心步骤</li><li>深拷贝的实现最重要的是处理<code>循环引用</code>的问题，以下用WeakMap的方式阻止循环引用:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阻止循环引用</span></span><br><span class="line"><span class="keyword">if</span> (cache.has(target)) &#123;</span><br><span class="line">  <span class="keyword">return</span> cache.get(target);</span><br><span class="line">&#125;</span><br><span class="line">cache.set(target, copy);</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>完整实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> str = <span class="built_in">Object</span>.prototype.toString.call(obj);</span><br><span class="line">  <span class="keyword">const</span> map = &#123;</span><br><span class="line">    <span class="string">"[object Boolean]"</span>: <span class="string">"boolean"</span>,</span><br><span class="line">    <span class="string">"[object Number]"</span>: <span class="string">"number"</span>,</span><br><span class="line">    <span class="string">"[object String]"</span>: <span class="string">"string"</span>,</span><br><span class="line">    <span class="string">"[object Function]"</span>: <span class="string">"function"</span>,</span><br><span class="line">    <span class="string">"[object Array]"</span>: <span class="string">"array"</span>,</span><br><span class="line">    <span class="string">"[object Date]"</span>: <span class="string">"date"</span>,</span><br><span class="line">    <span class="string">"[object RegExp]"</span>: <span class="string">"regExp"</span>,</span><br><span class="line">    <span class="string">"[object Undefined]"</span>: <span class="string">"undefined"</span>,</span><br><span class="line">    <span class="string">"[object Null]"</span>: <span class="string">"null"</span>,</span><br><span class="line">    <span class="string">"[object Object]"</span>: <span class="string">"object"</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> map[str];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">target, cache = new WeakMap(</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> type = getType(target);</span><br><span class="line">  <span class="comment">// 值类型数组</span></span><br><span class="line">  <span class="keyword">const</span> valTypes = [</span><br><span class="line">    <span class="string">"undefined"</span>,</span><br><span class="line">    <span class="string">"null"</span>,</span><br><span class="line">    <span class="string">"boolean"</span>,</span><br><span class="line">    <span class="string">"number"</span>,</span><br><span class="line">    <span class="string">"string"</span>,</span><br><span class="line">    <span class="string">"symbol"</span>,</span><br><span class="line">    <span class="string">"bigInt"</span>,</span><br><span class="line">  ];</span><br><span class="line">  <span class="keyword">if</span> (valTypes.includes(type)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> copy;</span><br><span class="line">  <span class="comment">// 初始化clone值</span></span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">"function"</span>) &#123;</span><br><span class="line">    copy = &#123;&#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    copy = <span class="keyword">new</span> target.constructor();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 阻止循环引用</span></span><br><span class="line">  <span class="keyword">if</span> (cache.has(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> cache.get(target);</span><br><span class="line">  &#125;</span><br><span class="line">  cache.set(target, copy);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"array"</span>:</span><br><span class="line">      <span class="keyword">return</span> copyArray(target, copy, cache);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"object"</span>:</span><br><span class="line">      <span class="keyword">return</span> copyObject(target, copy, cache);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"function"</span>:</span><br><span class="line">      <span class="keyword">return</span> copyFunction(target, cache);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyArray</span>(<span class="params">target, copy = [], cache</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> [index, value] <span class="keyword">of</span> target.entries()) &#123;</span><br><span class="line">    copy[index] = deepCopy(value, cache);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyObject</span>(<span class="params">target, copy = &#123;&#125;, cache</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(target)) &#123;</span><br><span class="line">    copy[key] = deepCopy(value, cache);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyFunction</span>(<span class="params">target, copy = (</span>) =&gt; </span>&#123;&#125;) &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="built_in">eval</span>(target.toString());</span><br><span class="line">  fn.prototype = target.prototype;</span><br><span class="line">  <span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>JavaScript 中的垃圾数据都是由垃圾回收器自动回收的，不需要手动释放。</p><h4 id="回收栈空间"><a href="#回收栈空间" class="headerlink" title="回收栈空间"></a>回收栈空间</h4><p>在 JavaScript 执行代码时，主线程上会存在 ESP 指针，用来指向调用栈中当前正在执行的上下文。</p><p>当 foo 函数执行完成后，ESP 向下指向全局执行上下文，foo 函数执行上下文就变成无效的，当有新的执行上下文进来时，可以直接覆盖这块内存空间。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200623190138.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200623190138.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20200623190138"></p><blockquote><p>JavaScript 引擎通过向下移动 ESP 指针来销毁存放在栈空间中的执行上下文。</p></blockquote><h4 id="回收堆空间"><a href="#回收堆空间" class="headerlink" title="回收堆空间"></a>回收堆空间</h4><p>V8 中把堆分成新生代与老生代两个区域：</p><ul><li>新生代：用来存放生存周期较短的小对象，一般只支持1～8M的容量</li><li>老生代：用来存放生存周期较长的对象或大对象</li></ul><p>V8 对这两块区域使用了不同的回收器：</p><ul><li>新生代使用副垃圾回收器</li><li>老生代使用主垃圾回收器</li></ul><p><strong>副垃圾回收器:</strong></p><p>采用 <code>Scavenge</code> 算法及<code>对象晋升</code>策略来进行垃圾回收</p><p>所谓 Scavenge 算法，即把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域。</p><p>新加入的对象都加入对象区域，当对象区满的时候，就执行一次垃圾回收，执行流程如下：</p><ul><li>标记：首先要对区域内的对象进行标记（活动对象、非活动对象）</li><li>垃圾清理：将对象区的活动对象复制到空闲区域，并进行有序的排列，当复制完成后，对象区域与空闲区域进行翻转，<code>空闲区域晋升为对象区域，对象区域为空闲区域</code></li></ul><blockquote><p>翻转后，对象区域是没有碎片的，此时不需要进行内存整理。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200623190716.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200623190716.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><p>所谓对象<code>晋升策略</code>，因为新生代区域很小的，一般1～8M的容量，所以它很容易满，所以，JavaScript 引擎采用对象晋升策略来处理: 即只要对象经过 <strong><code>两次</code></strong> 垃圾回收之后依然继续存活，就会被晋升到老生代区域中。</p><p><strong>主垃圾回收器：</strong></p><p>老生代区域里有两块对象：</p><ul><li>从新生代晋升来的存活时间久的对象</li><li>大对象（直接分配到老生代）</li></ul><p>V8 中主垃圾回收器主要采用<code>标记-清除法</code>进行垃圾回收。</p><p>主要流程如下：</p><ul><li>标记：遍历调用栈，看老生代区域堆中的对象是否被引用，被引用的对象标记为<code>活动对象</code>，没有被引用的对象（待清理）标记为<code>垃圾数据</code>。</li><li>垃圾清理：将所有垃圾数据清理掉</li><li>内存整理：标记-整理策略，将活动对象整理到一起</li></ul><p><strong>增量标记：</strong></p><p>V8 浏览器会自动执行垃圾回收，但由于 垃圾回收 也是运行在主线程上的，一旦执行垃圾回收，就要打断 JavaScript 的运行，可能会造成页面的卡顿，影响用户体验，所以 V8 采用增量 标记算法回收：</p><p><strong>即把垃圾回收拆成一个个小任务，穿插在 JavaScript 中执行。</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文内容回顾：</p><ol><li><p>栈与堆的定义与对比：</p><ul><li>栈：线性结构，LIFO</li><li>堆：非线性结构，杂乱无章，方便存储与开辟内存空间</li></ul></li><li><p>以及JS的运行机制：</p><ul><li>调用栈</li><li>任务队列</li></ul></li><li><p>调用栈</p><ul><li>调用栈是 JavaScript 用来管理函数执行上下文的一种数据结构，它记录了当前函数执行的位置，哪个函数正在被执行</li></ul></li><li><p>栈内存与堆内存</p><ul><li>栈内存： 基本类型（Boolean、Null、Undefined、Number、String、Symbol）</li><li>堆内存： 引用类型（Object、Array、Function、RegExp、Date）</li></ul></li><li><p>浅拷贝 与 深拷贝</p></li><li><p>垃圾回收</p><ul><li>回收栈空间：<ul><li>JavaScript 引擎通过向下移动 ESP 指针来销毁存放在栈空间中的执行上下文。</li></ul></li><li>回收堆空间：<ul><li>副垃圾回收器 与 主垃圾回收器 的区别</li><li>增量标记： 解决阻塞主进程问题</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端如何学数据结构与算法 - 线性表</title>
      <link href="/algorithms-%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%9F%BA%E7%A1%80%E6%B1%87%E6%80%BB/"/>
      <url>/algorithms-%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%9F%BA%E7%A1%80%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>数据结构和算法是编程的内功，深厚的内功可以有效保障写出的代码性能良好，可以提前预估代码运行达到预期目的，提高工作产出，也能让学习其他编程语言和框架变得事半功倍。</p><p>本系列所有示例均采用JavaScript，旨在入门数据结构与算法。</p><p>本节主要是讲解下基础数据结构 - 线性表 相关的内容。</p><a id="more"></a><h3 id="线性表-与-非线性表"><a href="#线性表-与-非线性表" class="headerlink" title="线性表 与 非线性表"></a>线性表 与 非线性表</h3><p>线性表（Linear List）：就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。数组、链表、队列、栈 等就是典型线性表结构。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhenoep0wj30yg0pb76e.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhenoep0wj30yg0pb76e.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><p>非线性表：数据之间并不是简单的前后关系。二叉树、堆、图 就是非线性表。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfheoebis1j30yg0p0gn2.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfheoebis1j30yg0p0gn2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li>定义<br>数组 (Array) 是一个有序的数据集合，我们可以通过数组名称 (name) 和索引 (index) 进行访问。<br>数组的索引是从 0 开始的。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhfkg30mej30em0fymxv.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhfkg30mej30em0fymxv.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><ul><li>特点<br>数组是用一组连续的内存空间来存储的。 所以数组支持 随机访问，根据下标随机访问的时间复杂度为 O(1)。</li></ul><p>低效的插入和删除。 数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效，因为底层通常是要进行大量的数据搬移来保持数据的连续性。 插入与删除的时间复杂度如下： 插入：从最好 O(1) ，最坏 O(n) ，平均 O(n) 删除：从最好 O(1) ，最坏 O(n) ，平均 O(n)</p><ul><li>实现<br>JavaScript 原生支持数组，而且提供了很多操作方法，JavaScript数组支持的方法可见下表：</li></ul><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">concat()</td><td align="left">连接两个或更多的数组，并返回结果。</td></tr><tr><td align="left">copyWithin()</td><td align="left">从数组的指定位置拷贝元素到数组的另一个指定位置中。</td></tr><tr><td align="left">entries()</td><td align="left">返回数组的可迭代对象。</td></tr><tr><td align="left">every()</td><td align="left">检测数值元素的每个元素是否都符合条件。</td></tr><tr><td align="left">fill()</td><td align="left">使用一个固定值来填充数组。</td></tr><tr><td align="left">filter()</td><td align="left">检测数值元素，并返回符合条件所有元素的数组。</td></tr><tr><td align="left">find()</td><td align="left">返回符合传入测试（函数）条件的数组元素。</td></tr><tr><td align="left">findIndex()</td><td align="left">返回符合传入测试（函数）条件的数组元素索引。</td></tr><tr><td align="left">forEach()</td><td align="left">数组每个元素都执行一次回调函数。</td></tr><tr><td align="left">from()</td><td align="left">通过给定的对象中创建一个数组。</td></tr><tr><td align="left">includes()</td><td align="left">判断一个数组是否包含一个指定的值。</td></tr><tr><td align="left">indexOf()</td><td align="left">搜索数组中的元素，并返回它所在的位置。</td></tr><tr><td align="left">isArray()</td><td align="left">判断对象是否为数组。</td></tr><tr><td align="left">join()</td><td align="left">把数组的所有元素放入一个字符串。</td></tr><tr><td align="left">keys()</td><td align="left">返回数组的可迭代对象，包含原始数组的键(key)。</td></tr><tr><td align="left">lastIndexOf()</td><td align="left">搜索数组中的元素，并返回它最后出现的位置。</td></tr><tr><td align="left">map()</td><td align="left">通过指定函数处理数组的每个元素，并返回处理后的数组。</td></tr><tr><td align="left">pop()</td><td align="left">删除数组的最后一个元素并返回删除的元素。</td></tr><tr><td align="left">push()</td><td align="left">向数组的末尾添加一个或更多元素，并返回新的长度。</td></tr><tr><td align="left">reduce()</td><td align="left">将数组元素计算为一个值（从左到右）。</td></tr><tr><td align="left">reduceRight()</td><td align="left">将数组元素计算为一个值（从右到左）。</td></tr><tr><td align="left">reverse()</td><td align="left">反转数组的元素顺序。</td></tr><tr><td align="left">shift()</td><td align="left">删除并返回数组的第一个元素。</td></tr><tr><td align="left">slice()</td><td align="left">选取数组的的一部分，并返回一个新数组。</td></tr><tr><td align="left">some()</td><td align="left">检测数组元素中是否有元素符合指定条件。</td></tr><tr><td align="left">sort()</td><td align="left">对数组的元素进行排序。</td></tr><tr><td align="left">splice()</td><td align="left">从数组中添加或删除元素。</td></tr><tr><td align="left">toString()</td><td align="left">把数组转换为字符串，并返回结果。</td></tr><tr><td align="left">unshift()</td><td align="left">向数组的开头添加一个或更多元素，并返回新的长度。</td></tr><tr><td align="left">valueOf()</td><td align="left">返回数组对象的原始值。</td></tr></tbody></table><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul><li>定义<ul><li>后进者先出，先进者后出，简称 后进先出（LIFO），这就是典型的栈结构。</li><li>在栈里，新元素都靠近栈顶，旧元素都接近栈底。</li><li>从栈的操作特性来看，是一种 操作受限的线性表，只允许在一端插入和删除数据。</li><li>不包含任何元素的栈称为空栈。</li></ul></li></ul><p>栈被用在编程语言的编译器和内存中保存变量、方法调用等，比如函数的调用栈、前端路由等。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhfvwdizbj30lc0i43zg.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhfvwdizbj30lc0i43zg.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><ul><li>实现</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.data = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 添加一个（或几个）新元素到栈顶。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">this</span>.push = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data.push(element);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 移除栈顶的元素，同时返回被移除的元素。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">this</span>.pop = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.pop();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回栈顶的元素，不对栈做任何修改。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">this</span>.peek = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data[<span class="keyword">this</span>.data.length - <span class="number">1</span>];</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 如果栈里没有任何元素就返回 true，否则返回 false</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.length === <span class="number">1</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 移除栈里的所有元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data = [];</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回栈里的元素个数。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.length;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 打印栈里的元素</span></span><br><span class="line">  <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.data.toString());</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用场景</li></ul><p>举一个判断回文的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindrome</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s = <span class="keyword">new</span> Stack();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; word.length; i++) &#123;</span><br><span class="line">    s.push(word[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> rword = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">while</span> (s.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    rword += s.pop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> word == rword;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isPalindrome(<span class="string">"level"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isPalindrome(<span class="string">"1001"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isPalindrome(<span class="string">"word"</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul><li>定义<ul><li>队列是遵循 FIFO（First In First Out，先进先出）原则的一组有序的项。</li><li>队列在尾部添加新元素，并从顶部移除元素。</li><li>最新添加的元素必须排在队列的末尾。</li><li>队列只有 入队 push() 和出队 pop()。</li><li>队列又可以细分为普通队列、优先队列、循环队列。</li></ul></li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhg3y5rzfj30pw0ck74z.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhg3y5rzfj30pw0ck74z.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><h4 id="普通队列"><a href="#普通队列" class="headerlink" title="普通队列"></a>普通队列</h4><ul><li>实现</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Queue类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.data = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向队列尾部添加元素</span></span><br><span class="line">  <span class="keyword">this</span>.enqueue = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data.push(element);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除队列的第一个元素，并返回被移除的元素</span></span><br><span class="line">  <span class="keyword">this</span>.dequeue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.shift();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回队列的第一个元素</span></span><br><span class="line">  <span class="keyword">this</span>.front = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data[<span class="number">0</span>];</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否为空队列</span></span><br><span class="line">  <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.length === <span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取队列的长度</span></span><br><span class="line">  <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.length;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清空队列</span></span><br><span class="line">  <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data = [];</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印队列里的元素</span></span><br><span class="line">  <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.data.toString());</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><ul><li><p>定义<br>优先队列中元素的添加和移除会根据<code>优先级</code>来处理</p></li><li><p>场景<br>优先队列一个典型的场景就是机场登机，头等舱和商务舱乘客的优先级要高于经济舱乘客。</p></li><li><p>分类</p><ul><li>最小优先队列，优先级值越小的元素在越前面</li><li>最大优先队列，优先级值越大的元素在越前面</li></ul></li><li><p>实现<br>实现最小优先队列</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MinPriorityQueue类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MinPriorityQueue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.data = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向队列尾部添加元素</span></span><br><span class="line">  <span class="keyword">this</span>.enqueue = <span class="function"><span class="keyword">function</span> (<span class="params">element, priority</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//若队列为空则直接将元素入列，否则需要比较该元素与其他元素的优先级</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.data.push(&#123; element, priority &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> added = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, length = <span class="keyword">this</span>.size(); i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (priority &lt; <span class="keyword">this</span>.data[i].priority) &#123;</span><br><span class="line">          <span class="keyword">this</span>.data.splice(i, <span class="number">0</span>, &#123; element, priority &#125;);</span><br><span class="line">          added = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!added) &#123;</span><br><span class="line">        <span class="keyword">this</span>.data.push(&#123; element, priority &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除队列的第一个元素，并返回被移除的元素</span></span><br><span class="line">  <span class="keyword">this</span>.dequeue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.shift();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回队列的第一个元素</span></span><br><span class="line">  <span class="keyword">this</span>.front = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data[<span class="number">0</span>];</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否为空队列</span></span><br><span class="line">  <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.length === <span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取队列的长度</span></span><br><span class="line">  <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.length;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清空队列</span></span><br><span class="line">  <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data = [];</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印队列里的元素</span></span><br><span class="line">  <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> info = <span class="keyword">this</span>.data.map(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;item.priority&#125;</span>: <span class="subst">$&#123;item.element&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(info.toString());</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现最大优先队列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MaxPriorityQueue类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MaxPriorityQueue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.data = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向队列尾部添加元素</span></span><br><span class="line">  <span class="keyword">this</span>.enqueue = <span class="function"><span class="keyword">function</span> (<span class="params">element, priority</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//若队列为空则直接将元素入列，否则需要比较该元素与其他元素的优先级</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.data.push(&#123; element, priority &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> added = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, length = <span class="keyword">this</span>.size(); i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (priority &gt; <span class="keyword">this</span>.data[i].priority) &#123;</span><br><span class="line">          <span class="keyword">this</span>.data.splice(i, <span class="number">0</span>, &#123; element, priority &#125;);</span><br><span class="line">          added = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!added) &#123;</span><br><span class="line">        <span class="keyword">this</span>.data.push(&#123; element, priority &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除队列的第一个元素，并返回被移除的元素</span></span><br><span class="line">  <span class="keyword">this</span>.dequeue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.shift();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回队列的第一个元素</span></span><br><span class="line">  <span class="keyword">this</span>.front = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data[<span class="number">0</span>];</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否为空队列</span></span><br><span class="line">  <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.length === <span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取队列的长度</span></span><br><span class="line">  <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.length;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清空队列</span></span><br><span class="line">  <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data = [];</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印队列里的元素</span></span><br><span class="line">  <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> info = <span class="keyword">this</span>.data.map(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;item.priority&#125;</span>: <span class="subst">$&#123;item.element&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(info.toString());</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><p>循环队列的一个例子就是击鼓传花游戏（Hot Potato）。在这个游戏中，孩子们围城一个圆圈，击鼓的时候把花尽快的传递给旁边的人。某一时刻击鼓停止，这时花在谁的手里，谁就退出圆圈直到游戏结束。重复这个过程，直到最后一个孩子为最后胜利者。</p><p>基于上面的普通队列，实现这个游戏：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 实现击鼓传花</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hotPotato</span>(<span class="params">nameList, num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> queue = <span class="keyword">new</span> Queue();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nameList.length; i++) &#123;</span><br><span class="line">    queue.enqueue(nameList[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> eliminated = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (queue.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 循环 num 次，队首出来去到队尾</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">      queue.enqueue(queue.dequeue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环 num 次过后，移除当前队首的元素</span></span><br><span class="line">    eliminated = queue.dequeue();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;eliminated&#125;</span> 在击鼓传花中被淘汰！`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后只剩一个元素</span></span><br><span class="line">  <span class="keyword">return</span> queue.dequeue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> nameList = [<span class="string">"张三"</span>, <span class="string">"李四"</span>, <span class="string">"王五"</span>, <span class="string">"马六"</span>, <span class="string">"牛七"</span>];</span><br><span class="line"><span class="keyword">var</span> winner = hotPotato(nameList, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`最后的胜利者是：<span class="subst">$&#123;winner&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; 牛七 在击鼓传花中被淘汰！</span></span><br><span class="line"><span class="comment">// =&gt; 张三 在击鼓传花中被淘汰！</span></span><br><span class="line"><span class="comment">// =&gt; 王五 在击鼓传花中被淘汰！</span></span><br><span class="line"><span class="comment">// =&gt; 马六 在击鼓传花中被淘汰！</span></span><br><span class="line"><span class="comment">// =&gt; 最后的胜利者是：李四</span></span><br></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul><li>定义<br>链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的，它是通过 <code>指针</code> 将 <code>零散的内存块</code> 串连起来的。</li></ul><p>每个元素由一个存储元素本身的 <code>节点</code>和一个指向下一个元素的 <code>指针</code>组成。</p><p>简单的链接结构图:<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhi0zdf6wj30ug08ggmb.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhi0zdf6wj30ug08ggmb.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><p>上图中，data 中保存着数据，next 保存着下一个链表的指针。 上图中，我们说 data2 跟在 data1 后面，而不是说 data2 是链表中的第二个元素。需要注意的是，我们将链表的尾元素指向了 null 节点，表示链接结束的位置。</p><ul><li><p>特点</p><ul><li><p>低效的访问： 链表是通过指针将零散的内存块串连起来的。 所以链表不支持 <code>随机访问</code>，如果要找特定的项，只能从头开始遍历，直到找到某个项。 所以访问的时间复杂度为 <code>O(n)</code>。</p></li><li><p>高效的插入和删除。 链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移节点，因为链表的存储空间本身就不是连续的，只需要考虑相邻节点的指针改变。 所以，在链表中插入和删除一个数据是非常快速的，时间复杂度为 <code>O(1)</code>。</p></li></ul></li><li><p>分类<br>常见列表可以分为三类：</p><ul><li>单向链表</li><li>双向链表</li><li>循环链表</li></ul></li></ul><h4 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h4><ul><li>定义</li></ul><p>由于链表的起始点的确定比较麻烦，因此很多链表的实现都会在链表的最前面添加一个特殊的节点，称为 <code>头节点</code>，表示链表的头部。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhi70lhuxj30u4078gmf.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhi70lhuxj30u4078gmf.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><ul><li><p>特点</p><ul><li>只能单向遍历，操作灵活性不高</li></ul></li><li><p>实现</p></li></ul><p>需要实现的以下常用操作：</p><table><thead><tr><th align="left">方法名</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">append(element)</td><td align="left">尾部添加元素。</td></tr><tr><td align="left">insert(position, element)</td><td align="left">特定位置插入一个新的项。</td></tr><tr><td align="left">removeAt(position)</td><td align="left">特定位置移除一项。</td></tr><tr><td align="left">remove(element)</td><td align="left">移除一项。</td></tr><tr><td align="left">indexOf(element)</td><td align="left">返回元素在链表中的索引。如果链表中没有该元素则返回 -1。</td></tr><tr><td align="left">isEmpty()</td><td align="left">如果链表中不包含任何元素，返回 true，如果链表长度大于 0，返回 false。</td></tr><tr><td align="left">size()</td><td align="left">返回链表包含的元素个数，与数组的 length 属性类似。</td></tr><tr><td align="left">getHead()</td><td align="left">返回链表的第一个元素。</td></tr><tr><td align="left">toString()</td><td align="left">由于链表使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString() 方法，让其只输出元素的值。</td></tr><tr><td align="left">print()</td><td align="left">打印链表的所有元素。</td></tr><tr><td align="left">list()</td><td align="left">获取整个链表</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单链表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SinglyLinkedList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 节点</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.element = element; <span class="comment">// 当前节点的元素</span></span><br><span class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span>; <span class="comment">// 下一个节点指针</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> length = <span class="number">0</span>; <span class="comment">// 链表的长度</span></span><br><span class="line">  <span class="keyword">let</span> head = <span class="literal">null</span>; <span class="comment">// 链表的头节点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向链表尾部添加一个新的节点</span></span><br><span class="line">  <span class="keyword">this</span>.append = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否为空链表</span></span><br><span class="line">    <span class="keyword">if</span> (head === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 是空链表，就把当前节点作为头部节点</span></span><br><span class="line">      head = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> currentNode = head;</span><br><span class="line">      <span class="comment">// 从 head 开始一直找到最后一个 node</span></span><br><span class="line">      <span class="keyword">while</span> (currentNode.next) &#123;</span><br><span class="line">        <span class="comment">// 后面还有 node</span></span><br><span class="line">        currentNode = currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 把最后一个节点的 next 指针指向新的节点</span></span><br><span class="line">      currentNode.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 链表的长度加 1</span></span><br><span class="line">    length++;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向链表特定位置插入一个新节点</span></span><br><span class="line">  <span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span> (<span class="params">position, element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt; length) &#123;</span><br><span class="line">      <span class="comment">// 越界</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">let</span> currentNode = head;</span><br><span class="line">      <span class="keyword">let</span> previousNode;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 在最前插入节点</span></span><br><span class="line">      <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">        node.next = currentNode;</span><br><span class="line">        head = node;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 循环找到位置</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt; position) &#123;</span><br><span class="line">          index++;</span><br><span class="line">          previousNode = currentNode;</span><br><span class="line">          currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把前一个节点的指针指向新节点，新节点的指针指向当前节点，保持连接性</span></span><br><span class="line">        previousNode.next = node;</span><br><span class="line">        node.next = currentNode;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      length++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从链表的特定位置移除一项</span></span><br><span class="line">  <span class="keyword">this</span>.removeAt = <span class="function"><span class="keyword">function</span> (<span class="params">position</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((position &lt; <span class="number">0</span> || position &gt;= length) || length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 越界</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> currentNode = head;</span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">let</span> previousNode;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">        head = currentNode.next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 循环找到位置</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt; position) &#123;</span><br><span class="line">          index++;</span><br><span class="line">          previousNode = currentNode;</span><br><span class="line">          currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把当前节点的 next 指针 指向 当前节点的 next 指针，即是 删除了当前节点</span></span><br><span class="line">        previousNode.next = currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      length--;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从链表中移除指定项</span></span><br><span class="line">  <span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="keyword">this</span>.indexOf(element);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.removeAt(index);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回元素在链表的索引，如果链表中没有该元素则返回 -1</span></span><br><span class="line">  <span class="keyword">this</span>.indexOf = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = head;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (currentNode) &#123;</span><br><span class="line">      <span class="keyword">if</span> (currentNode.element === element) &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      index++;</span><br><span class="line">      currentNode = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果链表中不包含任何元素，返回 true，如果链表长度大于 0，返回 false</span></span><br><span class="line">  <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length === <span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回链表包含的元素个数，与数组的 length 属性类似</span></span><br><span class="line">  <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取链表头部元素</span></span><br><span class="line">  <span class="keyword">this</span>.getHead = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> head.element;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 由于链表使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString() 方法，让其只输出元素的值</span></span><br><span class="line">  <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span> (<span class="params">cur</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = cur || head;</span><br><span class="line">    <span class="keyword">let</span> string = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (currentNode) &#123;</span><br><span class="line">      string += <span class="string">","</span> + currentNode.element;</span><br><span class="line">      currentNode = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> string.slice(<span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印链表数据</span></span><br><span class="line">  <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params">cur</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.toString(cur));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取整个链表</span></span><br><span class="line">  <span class="keyword">this</span>.list = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"head: "</span>, head);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>上面说的单向链表只有一个方向，节点只有一个后继指针 next 指向后面的节点。</p><p>最为对比，双向链表就有两个方向的指针，每个节点不止有一个后继指针 next 指向后面的节点，还有一个前驱指针 prev 指向前面的节点。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhipkm5rrj30pi082mxt.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhipkm5rrj30pi082mxt.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><ul><li><p>与单向列表比较</p><ul><li>内存空间比单向链表大，双向链表需要额外的两个空间来存储后继结点和前驱结点的地址</li><li>可以双向操作，灵活性更高，查找/插入/删除更高效</li></ul></li><li><p>实现<br>在实现了单向链表后，双向链表就没那么难了，直接上代码：</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建双向链表 DoublyLinkedList 类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DoublyLinkedList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.element = element; <span class="comment">//当前节点的元素</span></span><br><span class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span>; <span class="comment">//下一个节点指针</span></span><br><span class="line">    <span class="keyword">this</span>.previous = <span class="literal">null</span>; <span class="comment">//上一个节点指针</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> length = <span class="number">0</span>; <span class="comment">// 链表长度</span></span><br><span class="line">  <span class="keyword">let</span> head = <span class="literal">null</span>; <span class="comment">// 链表头部</span></span><br><span class="line">  <span class="keyword">let</span> tail = <span class="literal">null</span>; <span class="comment">// 链表尾部</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向链表尾部添加一个新的项</span></span><br><span class="line">  <span class="keyword">this</span>.append = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line">    <span class="keyword">let</span> currentNode = tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否为空链表</span></span><br><span class="line">    <span class="keyword">if</span> (currentNode === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 空链表</span></span><br><span class="line">      head = node;</span><br><span class="line">      tail = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      currentNode.next = node;</span><br><span class="line">      node.previous = currentNode;</span><br><span class="line">      tail = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    length++;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向链表特定位置插入一个新的项</span></span><br><span class="line">  <span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span> (<span class="params">position, element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt; length) &#123;</span><br><span class="line">      <span class="comment">// 越界</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">let</span> currentNode = head;</span><br><span class="line">      <span class="keyword">let</span> previousNode;</span><br><span class="line">      <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//在头部添加</span></span><br><span class="line">        <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">          head = node;</span><br><span class="line">          tail = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          node.next = currentNode;</span><br><span class="line">          currentNode.previous = node;</span><br><span class="line">          head = node;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position === length) &#123;</span><br><span class="line">        <span class="comment">//在末尾添加</span></span><br><span class="line">        <span class="keyword">this</span>.append(element);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (length - <span class="number">1</span> - position &gt; position) &#123;</span><br><span class="line">        <span class="comment">//position离head更近</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt; position) &#123;</span><br><span class="line">          index++;</span><br><span class="line">          previousNode = currentNode;</span><br><span class="line">          currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        previousNode.next = node;</span><br><span class="line">        node.next = currentNode;</span><br><span class="line"></span><br><span class="line">        node.previous = previousNode;</span><br><span class="line">        currentNode.previous = node;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//position离tail更近，则从tail开始向前查找</span></span><br><span class="line">        index = length - <span class="number">1</span>;</span><br><span class="line">        currentNode = tail;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (index &gt; position) &#123;</span><br><span class="line">          index--;</span><br><span class="line">          currentNode = currentNode.previous;</span><br><span class="line">          previousNode = currentNode.previous;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        previousNode.next = node;</span><br><span class="line">        node.next = currentNode;</span><br><span class="line">        node.previous = previousNode;</span><br><span class="line">        currentNode.previous = node;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      length++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从链表的特定位置移除一项</span></span><br><span class="line">  <span class="keyword">this</span>.removeAt = <span class="function"><span class="keyword">function</span> (<span class="params">position</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= length || length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 越界</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> currentNode = head;</span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">let</span> previousNode;</span><br><span class="line">      <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 移除第一项</span></span><br><span class="line">        <span class="keyword">if</span> (length === <span class="number">1</span>) &#123;</span><br><span class="line">          head = <span class="literal">null</span>;</span><br><span class="line">          tail = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          head = currentNode.next;</span><br><span class="line">          head.previous = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position === length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 移除最后一项</span></span><br><span class="line">        <span class="keyword">if</span> (length === <span class="number">1</span>) &#123;</span><br><span class="line">          head = <span class="literal">null</span>;</span><br><span class="line">          tail = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          currentNode = tail;</span><br><span class="line">          tail = currentNode.previous;</span><br><span class="line">          tail.next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (length - <span class="number">1</span> - position &gt; position) &#123;</span><br><span class="line">        <span class="comment">//position离head更近</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt; position) &#123;</span><br><span class="line">          index++;</span><br><span class="line">          previousNode = currentNode;</span><br><span class="line">          currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        previousNode.next = currentNode.next;</span><br><span class="line">        currentNode.next.previous = previousNode;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//position离tail更近，则从tail开始向前查找</span></span><br><span class="line">        index = length - <span class="number">1</span>;</span><br><span class="line">        currentNode = tail;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (index &gt; position) &#123;</span><br><span class="line">          index--;</span><br><span class="line">          currentNode = currentNode.previous;</span><br><span class="line">          previousNode = currentNode.previous;</span><br><span class="line">        &#125;</span><br><span class="line">        previousNode.next = currentNode.next;</span><br><span class="line">        currentNode.next.previous = previousNode;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      length--;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从链表中移除指定项</span></span><br><span class="line">  <span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="keyword">this</span>.indexOf(element);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.removeAt(index);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回元素在链表的索引，如果链表中没有该元素则返回 -1</span></span><br><span class="line">  <span class="keyword">this</span>.indexOf = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = head;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> currentNode2 = tail;</span><br><span class="line">    <span class="keyword">let</span> index2 = length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (currentNode) &#123;</span><br><span class="line">      <span class="keyword">if</span> (currentNode.element === element) &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (currentNode2.element === element) &#123;</span><br><span class="line">        <span class="keyword">return</span> index2;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      index++;</span><br><span class="line">      currentNode = currentNode.next;</span><br><span class="line">      index2--;</span><br><span class="line">      currentNode2 = currentNode2.previous;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果链表中不包含任何元素，返回 true ，如果链表长度大于 0 ，返回 false</span></span><br><span class="line">  <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length == <span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回链表包含的元素个数，与数组的 length 属性类似</span></span><br><span class="line">  <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取链表头部元素</span></span><br><span class="line">  <span class="keyword">this</span>.getHead = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> head.element;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 由于链表使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString() 方法，让其只输出元素的值</span></span><br><span class="line">  <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = head;</span><br><span class="line">    <span class="keyword">let</span> string = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (currentNode) &#123;</span><br><span class="line">      string += <span class="string">","</span> + currentNode.element;</span><br><span class="line">      currentNode = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> string.slice(<span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.toString());</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取整个链表</span></span><br><span class="line">  <span class="keyword">this</span>.list = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"head: "</span>, head);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单向链表-VS-双向链表-性能对比"><a href="#单向链表-VS-双向链表-性能对比" class="headerlink" title="单向链表 VS 双向链表 性能对比"></a>单向链表 VS 双向链表 性能对比</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> singlyList = <span class="keyword">new</span> SinglyLinkedList();</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">"singlyList-time"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">  singlyList.insert(i, <span class="string">"Tom"</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">"singlyList-time"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> doublyList = <span class="keyword">new</span> DoublyLinkedList();</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">"doublyLinked-time"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">  doublyList.insert(i, <span class="string">"Tom"</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">"doublyList-time"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &gt;&gt; singlyList-time: 34532.815ms</span></span><br><span class="line"><span class="comment">// &gt;&gt; doublyList-time: 64.111ms</span></span><br></pre></td></tr></table></figure><p>结论： 同样插入100000条数据，双向链表的速度优势明显；</p><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p>循环链表是一种特殊的单链表。 循环链表和单链表相似，节点类型都是一样。 唯一的区别是，循环链表的尾节点指向了头节点，形成了一个循环。如下图所示:</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfiyjjofn3j30j20hedgi.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfiyjjofn3j30j20hedgi.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><ul><li>实现<br>基于单向链表实现循环链表，主要区别在于要将循环链表的尾节点指向头节点</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环链表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CircularLinkedList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 节点</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.element = element; <span class="comment">// 当前节点的元素</span></span><br><span class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span>; <span class="comment">// 下一个节点指针</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> length = <span class="number">0</span>; <span class="comment">// 链表的长度</span></span><br><span class="line">  <span class="keyword">let</span> head = <span class="literal">null</span>; <span class="comment">// 链表的头节点</span></span><br><span class="line">  <span class="keyword">let</span> tail = <span class="literal">null</span>; <span class="comment">// 链表的尾节点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向链表尾部添加一个新的节点</span></span><br><span class="line">  <span class="keyword">this</span>.append = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否为空链表</span></span><br><span class="line">    <span class="keyword">if</span> (head === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 是空链表，就把当前节点作为头部节点</span></span><br><span class="line">      head = node;</span><br><span class="line">      head.next = head;</span><br><span class="line">      tail = head;<span class="comment">//区别于单向链表的点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> currentNode = head;</span><br><span class="line">      <span class="comment">// 从 head 开始一直找到最后一个 node</span></span><br><span class="line">      <span class="keyword">while</span> (currentNode.next !== head) &#123;</span><br><span class="line">        <span class="comment">// 后面还有 node</span></span><br><span class="line">        currentNode = currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 把最后一个节点的 next 指针指向新的节点</span></span><br><span class="line">      currentNode.next = node;</span><br><span class="line">      <span class="comment">// 把新插入的节点的next指向head</span></span><br><span class="line">      node.next = head;</span><br><span class="line">      tail = node; <span class="comment">// 把新加入的节点设为尾节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 链表的长度加 1</span></span><br><span class="line">    length++;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向链表特定位置插入一个新节点</span></span><br><span class="line">  <span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span> (<span class="params">position, element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt; length) &#123;</span><br><span class="line">      <span class="comment">// 越界</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (length === <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">//空链表时使用append插入第一个节点</span></span><br><span class="line">      <span class="keyword">this</span>.append(element);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">let</span> currentNode = head;</span><br><span class="line">      <span class="keyword">let</span> previousNode;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 在最前插入节点</span></span><br><span class="line">      <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">        node.next = head;</span><br><span class="line">        head = node;</span><br><span class="line">        tail.next = head; <span class="comment">//区别于单向链表的点</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 循环找到位置</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt; position) &#123;</span><br><span class="line">          index++;</span><br><span class="line">          previousNode = currentNode;</span><br><span class="line">          currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把前一个节点的指针指向新节点，新节点的指针指向当前节点，保持连接性</span></span><br><span class="line">        previousNode.next = node;</span><br><span class="line">        node.next = currentNode;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      length++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从链表的特定位置移除一项</span></span><br><span class="line">  <span class="keyword">this</span>.removeAt = <span class="function"><span class="keyword">function</span> (<span class="params">position</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= length || length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 越界</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> currentNode = head;</span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">let</span> previousNode;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">        tail.next = head; <span class="comment">//区别于单向链表的点</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 循环找到位置</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt; position) &#123;</span><br><span class="line">          index++;</span><br><span class="line">          previousNode = currentNode;</span><br><span class="line">          currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把当前节点的 next 指针 指向 当前节点的 next 指针，即是 删除了当前节点</span></span><br><span class="line">        previousNode.next = currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      length--;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从链表中移除指定项</span></span><br><span class="line">  <span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="keyword">this</span>.indexOf(element);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.removeAt(index);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回元素在链表的索引，如果链表中没有该元素则返回 -1</span></span><br><span class="line">  <span class="keyword">this</span>.indexOf = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = head;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (currentNode) &#123;</span><br><span class="line">      <span class="keyword">if</span> (currentNode.element === element) &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      index++;</span><br><span class="line">      currentNode = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果链表中不包含任何元素，返回 true，如果链表长度大于 0，返回 false</span></span><br><span class="line">  <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length === <span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回链表包含的元素个数，与数组的 length 属性类似</span></span><br><span class="line">  <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取链表头部元素</span></span><br><span class="line">  <span class="keyword">this</span>.getHead = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> head.element;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 由于链表使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString() 方法，让其只输出元素的值</span></span><br><span class="line">  <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = head;</span><br><span class="line">    <span class="keyword">let</span> string = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (currentNode &amp;&amp; index &lt; length) &#123;</span><br><span class="line">      string += <span class="string">","</span> + currentNode.element;</span><br><span class="line">      currentNode = currentNode.next;</span><br><span class="line">      index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> string.slice(<span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印链表数据</span></span><br><span class="line">  <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params">cur</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.toString(cur));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取整个链表</span></span><br><span class="line">  <span class="keyword">this</span>.list = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"head: "</span>, head);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nodejs读取控制台输入(stdin)的方法总结</title>
      <link href="/node-node-stdin/"/>
      <url>/node-node-stdin/</url>
      
        <content type="html"><![CDATA[<p>在用 Nodejs 写 CLI 应用或者做OJ的时候经常会遇到要从 stdin 读取输入的情况，这里总结了几种不依赖第三方库来按行读取输入的方法。</p><a id="more"></a><h3 id="Readline基础使用"><a href="#Readline基础使用" class="headerlink" title="Readline基础使用"></a>Readline基础使用</h3><ul><li>优点：简洁方便，平台无关。可用于编写 REPL 应用。</li><li>缺点：某些 OJ 的 node 版本可能不支持readline，对此请参考OJ专用的方法。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"readline"</span>)</span><br><span class="line">  .createInterface(&#123;</span><br><span class="line">    input: process.stdin,</span><br><span class="line">    output: process.stdout,</span><br><span class="line">  &#125;)</span><br><span class="line">  .on(<span class="string">"line"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">line</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"the input is: "</span>, line.trim());</span><br><span class="line">    <span class="keyword">this</span>.close();</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="实现互动问答"><a href="#实现互动问答" class="headerlink" title="实现互动问答"></a>实现互动问答</h3><ul><li>优点：便于引导用户正确输入。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rl = <span class="built_in">require</span>(<span class="string">"readline"</span>).createInterface(&#123;</span><br><span class="line">  input: process.stdin,</span><br><span class="line">  output: process.stdout,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> wait = <span class="function">(<span class="params">ms</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> setTimeout(resolve, ms));</span><br><span class="line"><span class="keyword">const</span> question = <span class="function">(<span class="params">query</span>) =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> rl.question(query, (answer) =&gt; resolve(answer)));</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> answer = <span class="keyword">await</span> question(<span class="string">"你觉得node是最棒的吗？ "</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`您的答案是：<span class="subst">$&#123;answer&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">  answer = <span class="keyword">await</span> question(<span class="string">"async/await好不好用啊 "</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`您的答案是：<span class="subst">$&#123;answer&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">  answer = <span class="keyword">await</span> question(<span class="string">"等待多少秒继续执行？ "</span>);</span><br><span class="line">  rl.pause();</span><br><span class="line">  <span class="keyword">await</span> wait(<span class="built_in">parseInt</span>(answer) * <span class="number">1000</span>);</span><br><span class="line">  rl.resume();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ((<span class="keyword">await</span> question(<span class="string">"输入bye退出 "</span>)).trim() !== <span class="string">"bye"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Good day."</span>);</span><br><span class="line"></span><br><span class="line">  rl.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="process-stdin"><a href="#process-stdin" class="headerlink" title="process.stdin"></a>process.stdin</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">process.stdin.setEncoding(<span class="string">"utf8"</span>);</span><br><span class="line"></span><br><span class="line">process.stdin.on(<span class="string">"readable"</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> chunk = process.stdin.read();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> chunk === <span class="string">"string"</span>) &#123;</span><br><span class="line">    chunk = chunk.slice(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">    process.stdout.write(<span class="string">`stringLength:<span class="subst">$&#123;chunk.length&#125;</span>\n`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (chunk === <span class="string">""</span>) &#123;</span><br><span class="line">    process.stdin.emit(<span class="string">"end"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (chunk !== <span class="literal">null</span>) &#123;</span><br><span class="line">    process.stdout.write(<span class="string">`data: <span class="subst">$&#123;chunk&#125;</span>\n`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.stdin.on(<span class="string">"end"</span>, () =&gt; &#123;</span><br><span class="line">  process.stdout.write(<span class="string">"end"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> stdin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>promise高级用法</title>
      <link href="/javascript-promise%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/"/>
      <url>/javascript-promise%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="实现多个promise串行执行"><a href="#实现多个promise串行执行" class="headerlink" title="实现多个promise串行执行"></a>实现多个promise串行执行</h2><div class="story post-story"><p>在 async/await 以前 Promise 串行执行还是比较麻烦的，除了依赖 <a href="https://github.com/caolan/async" target="_blank" rel="noopener">async</a>、<a href="https://github.com/sindresorhus/promise-fun" target="_blank" rel="noopener">promise-fun</a> 等工具库，我们还可以使用 Array.prototype.reduce() 自己实现一个简单的串行Promise了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 核心代码</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runPromiseByQueue</span>(<span class="params">myPromises</span>) </span>&#123;</span><br><span class="line">  myPromises.reduce(</span><br><span class="line">    (previousPromise, nextPromise) =&gt; previousPromise.then(<span class="function"><span class="params">()</span> =&gt;</span> nextPromise()),</span><br><span class="line">    <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上一个 Promise 开始执行（previousPromise.then），当其执行完毕后再调用下一个 Promise，并作为一个新 Promise 返回，下次迭代就会继续这个循环。</p><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createPromise = <span class="function">(<span class="params">time, id</span>) =&gt;</span> <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">solve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">"time"</span> + id);</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"promise"</span>, id);</span><br><span class="line">      <span class="built_in">console</span>.timeEnd(<span class="string">"time"</span> + id);</span><br><span class="line">      <span class="keyword">if</span> (id == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.timeEnd(<span class="string">"timeall"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      solve();</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">"timeall"</span>);</span><br><span class="line">runPromiseByQueue([</span><br><span class="line">  createPromise(<span class="number">3000</span>, <span class="number">1</span>),</span><br><span class="line">  createPromise(<span class="number">2000</span>, <span class="number">2</span>),</span><br><span class="line">  createPromise(<span class="number">1000</span>, <span class="number">3</span>),</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>最后的输出结果如下：<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfexoo9xmvj307702yt8p.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfexoo9xmvj307702yt8p.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><p>说明确实是串行依次执行了三个promise。</p></div><h2 id="实现多个promise并行执行"><a href="#实现多个promise并行执行" class="headerlink" title="实现多个promise并行执行"></a>实现多个promise并行执行</h2><div class="story post-story"><p>这个目前ES官方已经实现了promise.all/promise.allSettled/promise.race等方法，以promise.all()为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(resolve, <span class="number">100</span>, <span class="string">'foo'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([promise1, promise2, promise3]).then(<span class="function">(<span class="params">values</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(values);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// expected output: Array [3, 42, "foo"]</span></span><br></pre></td></tr></table></figure><p><code>Promise.all</code>可以保证，<code>promises</code>数组中所有promise对象都达到<code>resolve</code>状态，才执行<code>then</code>回调。</p><p>那么如果<code>promises</code>数组是包含几十个甚至几百个http请求，直接用<code>Promise.all</code>的话，会瞬间发出所有的http请求，造成请求拥堵甚至失败。</p><p>这时候就需要对<code>Promise.all</code>做并发限制。</p></div><h2 id="promise-all并行限制"><a href="#promise-all并行限制" class="headerlink" title="promise.all并行限制"></a>promise.all并行限制</h2><div class="story post-story"><p>首先需要明白的是，promise并不是在调用Promise.all才执行，而是在实例化promise对象的时候就执行了，在理解这一点的基础上，就可以从promise实例化上下手实现并发限制。具体实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Promise并发限制</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">array</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">poolLimit</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LimitPromiseAll</span>(<span class="params">array, poolLimit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">//待执行元素的数组下标</span></span><br><span class="line">  <span class="keyword">const</span> results = []; <span class="comment">// promise.all的promises数组</span></span><br><span class="line">  <span class="keyword">const</span> executing = []; <span class="comment">// 存放正在执行</span></span><br><span class="line">  <span class="keyword">const</span> enqueue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 边界处理，array为空数组</span></span><br><span class="line">    <span class="keyword">if</span> (i === array.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每调一次enqueue，初始化一个promise</span></span><br><span class="line">    <span class="keyword">const</span> fn = array[i++];</span><br><span class="line">    <span class="comment">// 如果curPromise不是Promise对象。则转成Promise 对象</span></span><br><span class="line">    <span class="comment">// 等同于 const p = Promise.resolve(fn());</span></span><br><span class="line">    <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> fn());</span><br><span class="line">    <span class="comment">// 放入promises数组</span></span><br><span class="line">    results.push(p);</span><br><span class="line">    <span class="comment">// promise执行完毕，从executing数组中删除</span></span><br><span class="line">    <span class="keyword">const</span> e = p.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      executing.splice(executing.indexOf(e), <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//正在执行的promise, 插入executing数组</span></span><br><span class="line">    executing.push(e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当executing数组中promise数量低于poolLimit，就实例化新的promise并执行,</span></span><br><span class="line">    <span class="comment">// 否则调用promise.race()获取到最快执行完成的promise（将其从executing数组删除，便可继续后续执行）</span></span><br><span class="line">    <span class="keyword">let</span> r = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">    <span class="keyword">if</span> (executing.length &gt;= poolLimit) &#123;</span><br><span class="line">      r = <span class="built_in">Promise</span>.race(executing);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归，直到遍历完array</span></span><br><span class="line">    <span class="keyword">return</span> r.then(<span class="function"><span class="params">()</span> =&gt;</span> enqueue());</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> enqueue().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.all(results));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">"all-time"</span>);</span><br><span class="line"><span class="keyword">const</span> timeout = <span class="function">(<span class="params">i</span>) =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(i), i));</span><br><span class="line"></span><br><span class="line">LimitPromiseAll(</span><br><span class="line">  [</span><br><span class="line">    timeout.bind(<span class="literal">null</span>, <span class="number">1000</span>),</span><br><span class="line">    timeout.bind(<span class="literal">null</span>, <span class="number">5000</span>),</span><br><span class="line">    timeout.bind(<span class="literal">null</span>, <span class="number">2000</span>),</span><br><span class="line">    timeout.bind(<span class="literal">null</span>, <span class="number">4000</span>),</span><br><span class="line">  ],</span><br><span class="line">  <span class="number">2</span></span><br><span class="line">).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">"all-time"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">输出： [ 1000, 5000, 2000, 4000 ]</span></span><br><span class="line"><span class="comment">      all-time: 7037.285ms</span></span><br><span class="line"><span class="comment"> **/</span></span><br></pre></td></tr></table></figure><p>其实，目前社区里已经有一些开源包实现了这个功能，比如<a href="https://github.com/rxaviers/async-pool" target="_blank" rel="noopener">async-pool</a>、<a href="https://github.com/timdp/es6-promise-pool" target="_blank" rel="noopener">es6-promise-pool</a>、<a href="https://github.com/sindresorhus/p-limit" target="_blank" rel="noopener">p-limit</a>。上述实现代码也是参考async-pool的实现。</p></div><h2 id="使用Promise实现fetch超时处理"><a href="#使用Promise实现fetch超时处理" class="headerlink" title="使用Promise实现fetch超时处理"></a>使用Promise实现fetch超时处理</h2><div class="story post-story"><p>因为<code>fetch</code>默认没有请求超时设置，以及中断请求操作，在这里我们尝试使用<code>Promise</code>结合<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FetchController" target="_blank" rel="noopener">AbortController</a>封装一个简单的请求超时和中断请求的<code>fetch</code>。</p><blockquote><p>AbortController接口代表一个控制器对象，允许你在需要时中止一个或多个DOM请求<br>目前IE外的主流浏览器基本都实现了AbortController功能；</p></blockquote><p>AbortController的浏览器兼容情况：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfg4gbzyt9j30s70c5tax.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfg4gbzyt9j30s70c5tax.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><p>核心代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TimeoutFetch</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.controller = <span class="keyword">new</span> AbortController(); <span class="comment">//实例化AbortController</span></span><br><span class="line">  <span class="keyword">this</span>.signal = <span class="keyword">this</span>.controller.signal; <span class="comment">//signal用来 abort 请求</span></span><br><span class="line">  <span class="keyword">this</span>.timeout = <span class="number">5000</span>; <span class="comment">//默认超时时间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置超时时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TimeoutFetch.prototype.setTimeout = <span class="function"><span class="keyword">function</span> (<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.timeout = ms;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 封装fetch请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TimeoutFetch.prototype.fetch = <span class="function"><span class="keyword">function</span> (<span class="params">url, data = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> timeoutPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(&#123;</span><br><span class="line">        code: <span class="number">1</span>,</span><br><span class="line">        msg: <span class="string">`timeout of <span class="subst">$&#123;<span class="keyword">this</span>.timeout&#125;</span>ms`</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">this</span>.controller.abort();</span><br><span class="line">    &#125;, <span class="keyword">this</span>.timeout);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> fetchPromise = fetch(url, &#123;</span><br><span class="line">    signal: <span class="keyword">this</span>.signal, <span class="comment">//设置信号</span></span><br><span class="line">    ...data,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.race([fetchPromise, timeoutPromise]);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 手动中断请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TimeoutFetch.prototype.abort = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.controller.abort();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timeoutFetch = <span class="keyword">new</span> TimeoutFetch();</span><br><span class="line">timeoutFetch.setTimeout(<span class="number">30</span>);</span><br><span class="line">timeoutFetch.fetch(<span class="string">"http://localhost/data"</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过iframe下载文件如何判断下载完成</title>
      <link href="/javascript-iframe-download-complete/"/>
      <url>/javascript-iframe-download-complete/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>当使用 iframe 作为文件下载的载体时，如何知道文件已经下载完毕。现有的 iframe 的 onLoad 方法具有兼容性问题，在 chrome、IE 下无法监听 onLoad 事件监听文件下载完毕，因为 onLoad 事件本身也是对 iframe 中的 html 结构的加载进度监听。</p><!-- more --><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">"http://www.example.com/file.zip"</span>;</span><br><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">"iframe"</span>);</span><br><span class="line">iframe.src = url;</span><br><span class="line">iframe.style.display = <span class="string">"none"</span>;</span><br><span class="line">iframe.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.debug(<span class="string">"start downloading..."</span>);</span><br><span class="line">  <span class="built_in">document</span>.body.removeAttribute(iframe);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe);</span><br></pre></td></tr></table></figure><p>当 chrome、IE 下时，如果 HTTP 文件头中包含 Content-disposition: attachment；即下载文件的链接的话，不会触发这个事件 onLoad 事件。</p><p>这里说一下 Content-disposition：</p><p><code>Content-disposition 是 MIME 协议的扩展，MIME 协议指示 MIME 用户代理如何显示附加的文件。Content-disposition其实可以控制用户请求所得的内容存为一个文件的时候提供一个默认的文件名，文件直接在浏览器上显示或者在访问时弹出文件下载对话框。 Content-Disposition为属性名disposition-type是以什么方式下载，如attachment为以附件方式下载disposition-parm为默认保存时的文件名服务端向客户端游览器发送文件时，如果是浏览器支持的文件类型，一般会默认使用浏览器打开，比如txt、jpg等，会直接在浏览器中显示 注意事项： 1.当代码里面使用Content-Disposition来确保浏览器弹出下载对话框的时候。 response.addHeader(&#39;Content-Disposition&#39;, &#39;attachment&#39;);一定要确保没有做过关于禁止浏览器缓存的操作。 代码如下: response.setHeader(&#39;Pragma&#39;, &#39;No-cache&#39;); response.setHeader(&#39;Cache-Control&#39;, &#39;No-cache&#39;); response.setDateHeader(&#39;Expires&#39;, 0); 不然会发现下载功能在opera和firefox里面好好的没问题，在IE下面就是不行</code></p><h3 id="解决思路一：利用-cookie"><a href="#解决思路一：利用-cookie" class="headerlink" title="解决思路一：利用 cookie"></a>解决思路一：利用 cookie</h3><p>后端将文件下载进度放在 cookie 中，通过轮询 cookie 的方式，对文件下载进度进行获取，判断文件是否已经下载完毕。 缺陷： 1、需要后端配合 2、如果客户端禁用了 cookie，则该方案完全失效；在无痕浏览模式下，读取 cookie，甚至代码报错。</p><h3 id="解决思路二：添加-header-配置"><a href="#解决思路二：添加-header-配置" class="headerlink" title="解决思路二：添加 header 配置"></a>解决思路二：添加 header 配置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不让浏览器自动检测文件类型</span></span><br><span class="line"><span class="comment">// 说明资料：http://drops.wooyun.org/tips/1166</span></span><br><span class="line">response.addHeader(<span class="string">"X-Content-Type-Options"</span>, <span class="string">"nosniff"</span>);</span><br><span class="line"><span class="comment">// 提示浏览器不让其在frame或iframe中加载资源的文件内容</span></span><br><span class="line"><span class="comment">// https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Options</span></span><br><span class="line">response.addHeader(<span class="string">"X-Frame-Options"</span>, <span class="string">"deny"</span>);</span><br></pre></td></tr></table></figure><p>但是在 chorome v58 版本将 header 的 X-Frame-Options 设为 deny 会报错。并且下载的时候网络连接会出现失败。</p><h3 id="解决思路三：轮询监听-readyState"><a href="#解决思路三：轮询监听-readyState" class="headerlink" title="解决思路三：轮询监听 readyState"></a>解决思路三：轮询监听 readyState</h3><p>定时器轮询监听 readyState 的状态，如果是 complete 或者 interactive 说明文件加载完成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  iframe = <span class="built_in">document</span>.getElementById(<span class="string">"iframedownload"</span>);</span><br><span class="line">  <span class="keyword">var</span> iframeDoc = iframe.contentDocument || iframe.contentWindow.document;</span><br><span class="line">  <span class="comment">// Check if loading is complete</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    iframeDoc.readyState == <span class="string">"complete"</span> ||</span><br><span class="line">    iframeDoc.readyState == <span class="string">"interactive"</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    loadingOff();</span><br><span class="line">    clearInterval(timer);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">4000</span>);</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>第三种方法比较好，因为不需要后端进行配合，且不依赖与 cookie 等变量带来的问题，能更好实现我们的需求。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iframe </tag>
            
            <tag> download </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端如何学数据结构与算法 - 一篇讲完经典排序算法</title>
      <link href="/algorithms-sort-knowledge/"/>
      <url>/algorithms-sort-knowledge/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文中包含了 十大经典排序算法 的思想、代码实现、一些例子、复杂度分析、动画、还有算法可视化工具。</p></blockquote><a id="more"></a><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><div class="story post-story"><blockquote><p>算法为王。</p></blockquote><blockquote><p>想学好前端，先练好内功，内功不行，就算招式练的再花哨，终究成不了高手；只有内功深厚者，前端之路才会走得更远。</p></blockquote><p>笔者写的 <strong>JavaScript 数据结构与算法之美</strong> 系列用的语言是 <strong>JavaScript</strong> ，旨在入门数据结构与算法和方便以后复习。</p><p>文中包含了 <code>十大经典排序算法</code> 的思想、代码实现、一些例子、复杂度分析、动画、还有算法可视化工具。</p><p>这应该是目前最全的 <code>JavaScript 十大经典排序算法</code> 的讲解了吧。</p></div><h2 id="2-如何分析一个排序算法"><a href="#2-如何分析一个排序算法" class="headerlink" title="2. 如何分析一个排序算法"></a>2. 如何分析一个排序算法</h2><div class="story post-story"><p>复杂度分析是整个算法学习的精髓。</p><ul><li>时间复杂度: 一个算法执行所耗费的时间。</li><li>空间复杂度: 运行完一个程序所需内存的大小。</li></ul><p>时间和空间复杂度的详解，请看 <a href="https://juejin.im/post/5cf37b6d6fb9a07eb15d3e88" target="_blank" rel="noopener">JavaScript 数据结构与算法之美 - 时间和空间复杂度</a>。</p><p>学习排序算法，我们除了学习它的算法原理、代码实现之外，更重要的是要学会如何评价、分析一个排序算法。</p><p>分析一个排序算法，要从 <code>执行效率</code>、<code>内存消耗</code>、<code>稳定性</code> 三方面入手。</p><h3 id="2-1-执行效率"><a href="#2-1-执行效率" class="headerlink" title="2.1 执行效率"></a>2.1 执行效率</h3><p><strong>1. 最好情况、最坏情况、平均情况时间复杂度</strong></p><p>我们在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度。 除此之外，你还要说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。</p><p><strong>2. 时间复杂度的系数、常数 、低阶</strong></p><p>我们知道，时间复杂度反应的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。</p><p>但是实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。</p><p><strong>3. 比较次数和交换（或移动）次数</strong></p><p>这一节和下一节讲的都是基于比较的排序算法。基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。</p><p>所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。</p><h3 id="2-2-内存消耗"><a href="#2-2-内存消耗" class="headerlink" title="2.2 内存消耗"></a>2.2 内存消耗</h3><p>也就是看空间复杂度。</p><p>还需要知道如下术语：</p><ul><li><strong>内排序</strong>：所有排序操作都在内存中完成；</li><li><strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li><li><strong>原地排序</strong>：原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。</li></ul><h3 id="2-3-稳定性"><a href="#2-3-稳定性" class="headerlink" title="2.3 稳定性"></a>2.3 稳定性</h3><ul><li>稳定：如果待排序的序列中存在值<code>相等</code>的元素，经过排序之后，相等元素之间原有的先后顺序<code>不变</code>。 比如： a 原本在 b 前面，而 a = b，排序之后，a 仍然在 b 的前面；</li><li>不稳定：如果待排序的序列中存在值<code>相等</code>的元素，经过排序之后，相等元素之间原有的先后顺序<code>改变</code>。 比如：a 原本在 b 的前面，而 a = b，排序之后， a 在 b 的后面；</li></ul></div><h2 id="3-十大经典排序算法"><a href="#3-十大经典排序算法" class="headerlink" title="3. 十大经典排序算法"></a>3. 十大经典排序算法</h2><div class="story post-story"><h3 id="3-1-冒泡排序（Bubble-Sort）"><a href="#3-1-冒泡排序（Bubble-Sort）" class="headerlink" title="3.1 冒泡排序（Bubble Sort）"></a>3.1 冒泡排序（Bubble Sort）</h3><p><img src="https://upload-images.jianshu.io/upload_images/12890819-d6851592702b589c.gif?imageMogr2/auto-orient/strip" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/12890819-d6851592702b589c.gif?imageMogr2/auto-orient/strip" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="冒泡"></p><p><strong>思想</strong></p><ul><li>冒泡排序只会操作相邻的两个数据。</li><li>每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。</li><li>一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。</li></ul><p><strong>特点</strong></p><ul><li>优点：排序算法的基础，简单实用易于理解。</li><li>缺点：比较次数多，效率较低。</li></ul><p><strong>实现</strong></p><pre><code>const bubbleSort = arr =&gt; {    console.time(&apos;改进前冒泡排序耗时&apos;);    const length = arr.length;    if (length &lt;= 1) return;    for (let i = 0; i &lt; length - 1; i++) {        for (let j = 0; j &lt; length - i - 1; j++) {            if (arr[j] &gt; arr[j + 1]) {                const temp = arr[j];                arr[j] = arr[j + 1];                arr[j + 1] = temp;            }        }    }    console.log(&apos;改进前 arr :&apos;, arr);    console.timeEnd(&apos;改进前冒泡排序耗时&apos;);};</code></pre><p>优化：当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。</p><pre><code>const bubbleSort2 = arr =&gt; {    console.time(&apos;改进后冒泡排序耗时&apos;);    const length = arr.length;    if (length &lt;= 1) return;    for (let i = 0; i &lt; length - 1; i++) {        let hasChange = false;        for (let j = 0; j &lt; length - i - 1; j++) {            if (arr[j] &gt; arr[j + 1]) {                const temp = arr[j];                arr[j] = arr[j + 1];                arr[j + 1] = temp;                hasChange = true;            }        }        if (!hasChange) break;    }    console.log(&apos;改进后 arr :&apos;, arr);    console.timeEnd(&apos;改进后冒泡排序耗时&apos;);};</code></pre><p><strong>测试</strong></p><pre><code>// 测试const arr = [7, 8, 4, 5, 6, 3, 2, 1];bubbleSort(arr);// 改进前 arr : [1, 2, 3, 4, 5, 6, 7, 8]// 改进前冒泡排序耗时: 0.43798828125msconst arr2 = [7, 8, 4, 5, 6, 3, 2, 1];bubbleSort2(arr2);// 改进后 arr : [1, 2, 3, 4, 5, 6, 7, 8]// 改进后冒泡排序耗时: 0.318115234375ms</code></pre><p><strong>分析</strong></p><ul><li>第一，冒泡排序是原地排序算法吗 ？ 冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个<code>原地</code>排序算法。</li><li>第二，冒泡排序是稳定的排序算法吗 ？ 在冒泡排序中，只有交换才可以改变两个元素的前后顺序。 为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序。 所以冒泡排序是<code>稳定</code>的排序算法。</li><li>第三，冒泡排序的时间复杂度是多少 ？ 最佳情况：T(n) = O(n)，当数据已经是正序时。 最差情况：T(n) = O(n2)，当数据是反序时。 平均情况：T(n) = O(n2)。</li></ul><p><strong>动画</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-68d55469ac439bc6.gif?imageMogr2/auto-orient/strip" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/12890819-68d55469ac439bc6.gif?imageMogr2/auto-orient/strip" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="冒泡排序动画"></p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-3948de96d4a28530.gif?imageMogr2/auto-orient/strip" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/12890819-3948de96d4a28530.gif?imageMogr2/auto-orient/strip" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="冒泡排序动画"></p><h3 id="3-2-插入排序（Insertion-Sort）"><a href="#3-2-插入排序（Insertion-Sort）" class="headerlink" title="3.2 插入排序（Insertion Sort）"></a>3.2 插入排序（Insertion Sort）</h3><p>插入排序又为分为 <strong>直接插入排序</strong> 和优化后的 <strong>拆半插入排序</strong> 与 <strong>希尔排序</strong>，我们通常说的插入排序是指直接插入排序。</p><p><strong>一、直接插入</strong></p><p><strong>思想</strong></p><p>一般人打扑克牌，整理牌的时候，都是按牌的大小（从小到大或者从大到小）整理牌的，那每摸一张新牌，就扫描自己的牌，把新牌插入到相应的位置。</p><p>插入排序的工作原理：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p><strong>步骤</strong></p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤 2 ~ 5。</li></ul><p><strong>实现</strong></p><pre><code>const insertionSort = array =&gt; {    const len = array.length;    if (len &lt;= 1) return    let preIndex, current;    for (let i = 1; i &lt; len; i++) {        preIndex = i - 1;        current = array[i];        while (preIndex &gt;= 0 &amp;&amp; array[preIndex] &gt; current) {            array[preIndex + 1] = array[preIndex];            preIndex--;        }        if (preIndex + 1 != i) {            array[preIndex + 1] = current;            console.log(&apos;array :&apos;, array);        }    }    return array;};</code></pre><p>测试</p><pre><code>// 测试const array = [5, 4, 3, 2, 1];console.log(&quot;原始 array :&quot;, array);insertionSort(array);// 原始 array:    [5, 4, 3, 2, 1]// array:           [4, 5, 3, 2, 1]// array:           [3, 4, 5, 2, 1]// array:          [2, 3, 4, 5, 1]// array:           [1, 2, 3, 4, 5]</code></pre><p><strong>分析</strong></p><ul><li>第一，插入排序是原地排序算法吗 ？ 插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，所以，这是一个<code>原地</code>排序算法。</li><li>第二，插入排序是稳定的排序算法吗 ？ 在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是<code>稳定</code>的排序算法。</li><li>第三，插入排序的时间复杂度是多少 ？ 最佳情况：T(n) = O(n)，当数据已经是正序时。 最差情况：T(n) = O(n2)，当数据是反序时。 平均情况：T(n) = O(n2)。</li></ul><p><strong>动画</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-8ba117506372e97e.gif?imageMogr2/auto-orient/strip" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/12890819-8ba117506372e97e.gif?imageMogr2/auto-orient/strip" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="insertion-sort.gif"></p><p><strong>二、拆半插入</strong></p><p>插入排序也有一种优化算法，叫做<code>拆半插入</code>。</p><p><strong>思想</strong></p><p>折半插入排序是直接插入排序的升级版，鉴于插入排序第一部分为已排好序的数组，我们不必按顺序依次寻找插入点，只需比较它们的中间值与待插入元素的大小即可。</p><p><strong>步骤</strong></p><ul><li>取 0 ~ i-1 的中间点 ( m = (i-1) &gt;&gt; 1 )，array[i] 与 array[m] 进行比较，若 array[i] &lt; array[m]，则说明待插入的元素 array[i] 应该处于数组的 0 ~ m 索引之间；反之，则说明它应该处于数组的 m ~ i-1 索引之间。</li><li>重复步骤 1，每次缩小一半的查找范围，直至找到插入的位置。</li><li>将数组中插入位置之后的元素全部后移一位。</li><li>在指定位置插入第 i 个元素。</li></ul><blockquote><p>注：x &gt;&gt; 1 是位运算中的右移运算，表示右移一位，等同于 x 除以 2 再取整，即 x &gt;&gt; 1 == Math.floor(x/2) 。</p></blockquote><pre><code>const binaryInsertionSort = array =&gt; {    const len = array.length;    if (len &lt;= 1) return;    let current, i, j, low, high, m;    for (i = 1; i &lt; len; i++) {        low = 0;        high = i - 1;        current = array[i];        while (low &lt;= high) {            m = (low + high) &gt;&gt; 1;            if (array[i] &gt;= array[m]) {                low = m + 1;            } else {                high = m - 1;            }        }        for (j = i; j &gt; low; j--) {            array[j] = array[j - 1];            console.log(&apos;array2 :&apos;, JSON.parse(JSON.stringify(array)));        }        array[low] = current;    }    console.log(&apos;array2 :&apos;, JSON.parse(JSON.stringify(array)));    return array;};</code></pre><p>测试</p><pre><code>const array2 = [5, 4, 3, 2, 1];console.log(&apos;原始 array2:&apos;, array2);binaryInsertionSort(array2);// 原始 array2:  [5, 4, 3, 2, 1]// array2 :     [5, 5, 3, 2, 1]// array2 :     [4, 5, 5, 2, 1]// array2 :     [4, 4, 5, 2, 1]// array2 :     [3, 4, 5, 5, 1]// array2 :     [3, 4, 4, 5, 1]// array2 :     [3, 3, 4, 5, 1]// array2 :     [2, 3, 4, 5, 5]// array2 :     [2, 3, 4, 4, 5]// array2 :     [2, 3, 3, 4, 5]// array2 :     [2, 2, 3, 4, 5]// array2 :     [1, 2, 3, 4, 5]</code></pre><p><code>注意</code>：和直接插入排序类似，折半插入排序每次交换的是相邻的且值为不同的元素，它并不会改变值相同的元素之间的顺序，因此它是稳定的。</p><p><strong>三、希尔排序</strong></p><p>希尔排序是一个平均时间复杂度为 O(n log n) 的算法，会在下一个章节和 归并排序、快速排序、堆排序 一起讲，本文就不展开了。</p><h3 id="3-3-选择排序（Selection-Sort）"><a href="#3-3-选择排序（Selection-Sort）" class="headerlink" title="3.3 选择排序（Selection Sort）"></a>3.3 选择排序（Selection Sort）</h3><p><strong>思路</strong></p><p>选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p><p><strong>步骤</strong></p><ol><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li>重复第二步，直到所有元素均排序完毕。</li></ol><p><strong>实现</strong></p><pre><code>const selectionSort = array =&gt; {    const len = array.length;    let minIndex, temp;    for (let i = 0; i &lt; len - 1; i++) {        minIndex = i;        for (let j = i + 1; j &lt; len; j++) {            if (array[j] &lt; array[minIndex]) {                minIndex = j;            }        }        temp = array[i];        array[i] = array[minIndex];        array[minIndex] = temp;        console.log(&apos;array: &apos;, array);    }    return array;};</code></pre><p>测试</p><pre><code>// 测试const array = [5, 4, 3, 2, 1];console.log(&apos;原始array:&apos;, array);selectionSort(array);// 原始 array:  [5, 4, 3, 2, 1]// array:           [1, 4, 3, 2, 5]// array:           [1, 2, 3, 4, 5]// array:          [1, 2, 3, 4, 5]// array:           [1, 2, 3, 4, 5]</code></pre><p><strong>分析</strong></p><ul><li>第一，选择排序是原地排序算法吗 ？ 选择排序空间复杂度为 O(1)，是一种<code>原地</code>排序算法。</li><li>第二，选择排序是稳定的排序算法吗 ？ 选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。所以，选择排序是一种<code>不稳定</code>的排序算法。</li><li>第三，选择排序的时间复杂度是多少 ？ 无论是正序还是逆序，选择排序都会遍历 n2 / 2 次来排序，所以，最佳、最差和平均的复杂度是一样的。 最佳情况：T(n) = O(n2)。 最差情况：T(n) = O(n2)。 平均情况：T(n) = O(n2)。</li></ul><p><strong>动画</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-27ddfb636eabff03.gif?imageMogr2/auto-orient/strip" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/12890819-27ddfb636eabff03.gif?imageMogr2/auto-orient/strip" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="selection-sort.gif"></p><h3 id="3-4-归并排序（Merge-Sort）"><a href="#3-4-归并排序（Merge-Sort）" class="headerlink" title="3.4 归并排序（Merge Sort）"></a>3.4 归并排序（Merge Sort）</h3><p><strong>思想</strong></p><p>排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p><p>归并排序采用的是<code>分治思想</code>。</p><p>分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。</p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-a186be41b62d6f65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/12890819-a186be41b62d6f65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="merge-sort-example.png"></p><blockquote><p>注：x &gt;&gt; 1 是位运算中的右移运算，表示右移一位，等同于 x 除以 2 再取整，即 x &gt;&gt; 1 === Math.floor(x / 2) 。</p></blockquote><p><strong>实现</strong></p><pre><code>const mergeSort = arr =&gt; {    const len = arr.length;    if (len &lt; 2) {        return arr;    }    let middle = Math.floor(len / 2),        left = arr.slice(0, middle),        right = arr.slice(middle);    return merge(mergeSort(left), mergeSort(right));};const merge = (left, right) =&gt; {    const result = [];    while (left.length &amp;&amp; right.length) {        if (left[0] &lt;= right[0]) {            result.push(left.shift());        } else {            result.push(right.shift());        }    }    while (left.length) result.push(left.shift());    while (right.length) result.push(right.shift());    return result;};</code></pre><p><strong>测试</strong></p><pre><code>// 测试const arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];console.time(&apos;归并排序耗时&apos;);console.log(&apos;arr :&apos;, mergeSort(arr));console.timeEnd(&apos;归并排序耗时&apos;);// arr : [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]// 归并排序耗时: 0.739990234375ms</code></pre><p><strong>分析</strong></p><ul><li><p>第一，归并排序是原地排序算法吗 ？ 这是因为归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。 实际上，尽管每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 O(n)。 所以，归并排序<code>不是</code>原地排序算法。</p></li><li><p>第二，归并排序是稳定的排序算法吗 ？ merge 方法里面的 left[0] &lt;= right[0] ，保证了值相同的元素，在合并前后的先后顺序不变。归并排序<code>是稳定</code>的排序方法。</p></li><li><p>第三，归并排序的时间复杂度是多少 ？ 从效率上看，归并排序可算是排序算法中的<code>佼佼者</code>。假设数组长度为 n，那么拆分数组共需 logn 步，又每步都是一个普通的合并子数组的过程，时间复杂度为 O(n)，故其综合时间复杂度为 O(n log n)。 最佳情况：T(n) = O(n log n)。 最差情况：T(n) = O(n log n)。 平均情况：T(n) = O(n log n)。</p></li></ul><p><strong>动画</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-32372625906df3ae.gif?imageMogr2/auto-orient/strip" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/12890819-32372625906df3ae.gif?imageMogr2/auto-orient/strip" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="merge-sort.gif"></p><h3 id="3-5-快速排序-（Quick-Sort）"><a href="#3-5-快速排序-（Quick-Sort）" class="headerlink" title="3.5 快速排序 （Quick Sort）"></a>3.5 快速排序 （Quick Sort）</h3><p>快速排序的特点就是快，而且效率高！它是处理大数据最快的排序算法之一。</p><p><strong>思想</strong></p><ul><li>先找到一个基准点（一般指数组的中部），然后数组被该基准点分为两部分，依次与该基准点数据比较，如果比它小，放左边；反之，放右边。</li><li>左右分别用一个空数组去存储比较后的数据。</li><li>最后递归执行上述操作，直到数组长度 &lt;= 1;</li></ul><p>特点：快速，常用。</p><p>缺点：需要另外声明两个数组，浪费了内存空间资源。</p><p><strong>实现</strong></p><p>方法一：</p><pre><code>const quickSort1 = arr =&gt; {    if (arr.length &lt;= 1) {        return arr;    }    const midIndex = Math.floor(arr.length / 2);    const valArr = arr.splice(midIndex, 1);    const midIndexVal = valArr[0];    const left = [];    const right = [];    for (let i = 0; i &lt; arr.length; i++) {        if (arr[i] &lt; midIndexVal) {            left.push(arr[i]);        } else {            right.push(arr[i]);        }    }    return quickSort1(left).concat(midIndexVal, quickSort1(right));};const array2 = [5, 4, 3, 2, 1];console.log(&apos;quickSort1 &apos;, quickSort1(array2));</code></pre><p>方法二：</p><pre><code>const quickSort = (arr, left, right) =&gt; {    let len = arr.length,        partitionIndex;    left = typeof left != &apos;number&apos; ? 0 : left;    right = typeof right != &apos;number&apos; ? len - 1 : right;    if (left &lt; right) {        partitionIndex = partition(arr, left, right);        quickSort(arr, left, partitionIndex - 1);        quickSort(arr, partitionIndex + 1, right);    }    return arr;};const partition = (arr, left, right) =&gt; {    let pivot = left,        index = pivot + 1;    for (let i = index; i &lt;= right; i++) {        if (arr[i] &lt; arr[pivot]) {            swap(arr, i, index);            index++;        }    }    swap(arr, pivot, index - 1);    return index - 1;};const swap = (arr, i, j) =&gt; {    let temp = arr[i];    arr[i] = arr[j];    arr[j] = temp;};</code></pre><p>测试</p><pre><code>// 测试const array = [5, 4, 3, 2, 1];console.log(&apos;原始array:&apos;, array);const newArr = quickSort(array);console.log(&apos;newArr:&apos;, newArr);// 原始 array:  [5, 4, 3, 2, 1]// newArr:     [1, 4, 3, 2, 5]</code></pre><p><strong>分析</strong></p><ul><li><p>第一，快速排序是原地排序算法吗 ？ 因为 partition() 函数进行分区时，不需要很多额外的内存空间，所以快排是<code>原地排序</code>算法。</p></li><li><p>第二，快速排序是稳定的排序算法吗 ？ 和选择排序相似，快速排序每次交换的元素都有可能不是相邻的，因此它有可能打破原来值为相同的元素之间的顺序。因此，快速排序并<code>不稳定</code>。</p></li><li><p>第三，快速排序的时间复杂度是多少 ？ 极端的例子：如果数组中的数据原来已经是有序的了，比如 1，3，5，6，8。如果我们每次选择最后一个元素作为 pivot，那每次分区得到的两个区间都是不均等的。我们需要进行大约 n 次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约 n / 2 个元素，这种情况下，快排的时间复杂度就从 O(nlogn) 退化成了 O(n2)。 最佳情况：T(n) = O(n log n)。 最差情况：T(n) = O(n2)。 平均情况：T(n) = O(n log n)。</p></li></ul><p><strong>动画</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-708f5b687f6bde65.gif?imageMogr2/auto-orient/strip" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/12890819-708f5b687f6bde65.gif?imageMogr2/auto-orient/strip" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="quick-sort.gif"></p><p><strong>解答开篇问题</strong></p><p>快排和归并用的都是分治思想，递推公式和递归代码也非常相似，那它们的区别在哪里呢 ？</p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-3e29b9d2d936905d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/12890819-3e29b9d2d936905d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="快速排序与归并排序"></p><p>可以发现：</p><ul><li>归并排序的处理过程是<code>由下而上</code>的，先处理子问题，然后再合并。</li><li>而快排正好相反，它的处理过程是<code>由上而下</code>的，先分区，然后再处理子问题。</li><li>归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。</li><li>归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。</li><li>快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。</li></ul><h3 id="3-6-希尔排序（Shell-Sort）"><a href="#3-6-希尔排序（Shell-Sort）" class="headerlink" title="3.6 希尔排序（Shell Sort）"></a>3.6 希尔排序（Shell Sort）</h3><p><strong>思想</strong></p><ul><li>先将整个待排序的记录序列分割成为若干子序列。</li><li>分别进行直接插入排序。</li><li>待整个序列中的记录基本有序时，再对全体记录进行依次直接插入排序。</li></ul><p><strong>过程</strong></p><ol><li>举个易于理解的例子：[35, 33, 42, 10, 14, 19, 27, 44]，我们采取间隔 4。创建一个位于 4 个位置间隔的所有值的虚拟子列表。下面这些值是 { 35, 14 }，{ 33, 19 }，{ 42, 27 } 和 { 10, 44 }。</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/12890819-e58310e3c89561da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/12890819-e58310e3c89561da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="栗子"></p><ol start="2"><li>我们比较每个子列表中的值，并在原始数组中交换它们（如果需要）。完成此步骤后，新数组应如下所示。</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/12890819-4d6b2b51ca3f04bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/12890819-4d6b2b51ca3f04bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="栗子"></p><ol start="3"><li>然后，我们采用 2 的间隔，这个间隙产生两个子列表：{ 14, 27, 35, 42 }， { 19, 10, 33, 44 }。</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/12890819-38dcc34caa3a9d2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/12890819-38dcc34caa3a9d2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="栗子"></p><ol start="4"><li>我们比较并交换原始数组中的值（如果需要）。完成此步骤后，数组变成：[14, 10, 27, 19, 35, 33, 42, 44]，图如下所示，10 与 19 的位置互换一下。</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/12890819-4fdc3019a8c4ec11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/12890819-4fdc3019a8c4ec11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image.png"></p><ol start="5"><li>最后，我们使用值间隔 1 对数组的其余部分进行排序，Shell sort 使用插入排序对数组进行排序。</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/12890819-25f5e05762daaa49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/12890819-25f5e05762daaa49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="栗子"></p><p><strong>实现</strong></p><pre><code>const shellSort = arr =&gt; {    let len = arr.length,        temp,        gap = 1;    console.time(&apos;希尔排序耗时&apos;);    while (gap &lt; len / 3) {        gap = gap * 3 + 1;    }    for (gap; gap &gt; 0; gap = Math.floor(gap / 3)) {        for (let i = gap; i &lt; len; i++) {            temp = arr[i];            let j = i - gap;            for (; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= gap) {                arr[j + gap] = arr[j];            }            arr[j + gap] = temp;            console.log(&apos;arr  :&apos;, arr);        }    }    console.timeEnd(&apos;希尔排序耗时&apos;);    return arr;};</code></pre><p>测试</p><pre><code>// 测试const array = [35, 33, 42, 10, 14, 19, 27, 44];console.log(&apos;原始array:&apos;, array);const newArr = shellSort(array);console.log(&apos;newArr:&apos;, newArr);// 原始 array:   [35, 33, 42, 10, 14, 19, 27, 44]// arr      :   [14, 33, 42, 10, 35, 19, 27, 44]// arr      :   [14, 19, 42, 10, 35, 33, 27, 44]// arr      :   [14, 19, 27, 10, 35, 33, 42, 44]// arr      :   [14, 19, 27, 10, 35, 33, 42, 44]// arr      :   [14, 19, 27, 10, 35, 33, 42, 44]// arr      :   [14, 19, 27, 10, 35, 33, 42, 44]// arr      :   [10, 14, 19, 27, 35, 33, 42, 44]// arr      :   [10, 14, 19, 27, 35, 33, 42, 44]// arr      :   [10, 14, 19, 27, 33, 35, 42, 44]// arr      :   [10, 14, 19, 27, 33, 35, 42, 44]// arr      :   [10, 14, 19, 27, 33, 35, 42, 44]// 希尔排序耗时: 3.592041015625ms// newArr:     [10, 14, 19, 27, 33, 35, 42, 44]</code></pre><p><strong>分析</strong></p><ul><li><p>第一，希尔排序是原地排序算法吗 ？ 希尔排序过程中，只涉及相邻数据的交换操作，只需要常量级的临时空间，空间复杂度为 O(1) 。所以，希尔排序是<code>原地排序</code>算法。</p></li><li><p>第二，希尔排序是稳定的排序算法吗 ？ 我们知道，单次直接插入排序是稳定的，它不会改变相同元素之间的相对顺序，但在多次不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，可能导致相同元素相对顺序发生变化。 因此，希尔排序<code>不稳定</code>。</p></li><li><p>第三，希尔排序的时间复杂度是多少 ？ 最佳情况：T(n) = O(n log n)。 最差情况：T(n) = O(n log2 n)。 平均情况：T(n) = O(n log2 n)。</p></li></ul><p><strong>动画</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-cdac5dafc537a06a.gif?imageMogr2/auto-orient/strip" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/12890819-cdac5dafc537a06a.gif?imageMogr2/auto-orient/strip" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="shell-sort.gif"></p><h3 id="3-7-堆排序（Heap-Sort）"><a href="#3-7-堆排序（Heap-Sort）" class="headerlink" title="3.7 堆排序（Heap Sort）"></a>3.7 堆排序（Heap Sort）</h3><p><strong>堆的定义</strong></p><p>堆其实是一种特殊的树。只要满足这两点，它就是一个堆。</p><ul><li>堆是一个完全二叉树。 完全二叉树：除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。</li><li>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。 也可以说：堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值。这两种表述是等价的。</li></ul><p>对于每个节点的值都<code>大于等于</code>子树中每个节点值的堆，我们叫作<code>大顶堆</code>。 对于每个节点的值都<code>小于等于</code>子树中每个节点值的堆，我们叫作<code>小顶堆</code>。</p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-ba0004cfc2c4c8d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/12890819-ba0004cfc2c4c8d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="区分堆、大顶堆、小顶堆"></p><p>其中图 1 和 图 2 是大顶堆，图 3 是小顶堆，图 4 不是堆。除此之外，从图中还可以看出来，对于同一组数据，我们可以构建多种不同形态的堆。</p><p><strong>思想</strong></p><ol><li>将初始待排序关键字序列 (R1, R2 …. Rn) 构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素 R[1] 与最后一个元素 R[n] 交换，此时得到新的无序区 (R1, R2, ….. Rn-1) 和新的有序区 (Rn) ，且满足 R[1, 2 … n-1] &lt;= R[n]。</li><li>由于交换后新的堆顶 R[1] 可能违反堆的性质，因此需要对当前无序区 (R1, R2 …… Rn-1) 调整为新堆，然后再次将 R[1] 与无序区最后一个元素交换，得到新的无序区 (R1, R2 …. Rn-2) 和新的有序区 (Rn-1, Rn)。不断重复此过程，直到有序区的元素个数为 n - 1，则整个排序过程完成。</li></ol><p><strong>实现</strong></p><pre><code>const heapSort = array =&gt; {    console.time(&apos;堆排序耗时&apos;);    for (let i = Math.floor(array.length / 2 - 1); i &gt;= 0; i--) {        heapify(array, i, array.length);    }    for (let i = Math.floor(array.length - 1); i &gt; 0; i--) {        swap(array, 0, i);        heapify(array, 0, i);    }    console.timeEnd(&apos;堆排序耗时&apos;);    return array;};const swap = (array, i, j) =&gt; {    let temp = array[i];    array[i] = array[j];    array[j] = temp;};const heapify = (array, i, length) =&gt; {    let temp = array[i];    for (let j = 2 * i + 1; j &lt; length; j = 2 * j + 1) {        temp = array[i];        if (j + 1 &lt; length &amp;&amp; array[j] &lt; array[j + 1]) {            j++;        }        if (temp &lt; array[j]) {            swap(array, i, j);            i = j;        } else {            break;        }    }};</code></pre><p>测试</p><pre><code>const array = [4, 6, 8, 5, 9, 1, 2, 5, 3, 2];console.log(&apos;原始array:&apos;, array);const newArr = heapSort(array);console.log(&apos;newArr:&apos;, newArr);// 原始 array:  [4, 6, 8, 5, 9, 1, 2, 5, 3, 2]// 堆排序耗时: 0.15087890625ms// newArr:     [1, 2, 2, 3, 4, 5, 5, 6, 8, 9]</code></pre><p><strong>分析</strong></p><ul><li><p>第一，堆排序是原地排序算法吗 ？ 整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序<code>是</code>原地排序算法。</p></li><li><p>第二，堆排序是稳定的排序算法吗 ？ 因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。 所以，堆排序是<code>不稳定</code>的排序算法。</p></li><li><p>第三，堆排序的时间复杂度是多少 ？ 堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 O(n)，排序过程的时间复杂度是 O(nlogn)，所以，堆排序整体的时间复杂度是 O(nlogn)。 最佳情况：T(n) = O(n log n)。 最差情况：T(n) = O(n log n)。 平均情况：T(n) = O(n log n)。</p></li></ul><p><strong>动画</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-62cc8c35ce449e02.gif?imageMogr2/auto-orient/strip" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/12890819-62cc8c35ce449e02.gif?imageMogr2/auto-orient/strip" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="heap-sort.gif"></p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-7946ab6ef624c184.gif?imageMogr2/auto-orient/strip" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/12890819-7946ab6ef624c184.gif?imageMogr2/auto-orient/strip" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="heap-sort2.gif"></p><h3 id="3-8-桶排序（Bucket-Sort）"><a href="#3-8-桶排序（Bucket-Sort）" class="headerlink" title="3.8 桶排序（Bucket Sort）"></a>3.8 桶排序（Bucket Sort）</h3><p>桶排序是计数排序的升级版，也采用了<code>分治思想</code>。</p><p><strong>思想</strong></p><ul><li>将要排序的数据分到有限数量的几个有序的桶里。</li><li>每个桶里的数据再单独进行排序（一般用插入排序或者快速排序）。</li><li>桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</li></ul><p>比如：</p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-fbe2b3e3d6d56b8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/12890819-fbe2b3e3d6d56b8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><p>桶排序利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p><p>为了使桶排序更加高效，我们需要做到这两点：</p><ul><li>在额外空间充足的情况下，尽量增大桶的数量。</li><li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中。</li></ul><p>桶排序的核心：就在于怎么把元素平均分配到每个桶里，合理的分配将大大提高排序的效率。</p><p><strong>实现</strong></p><pre><code>const bucketSort = (array, bucketSize) =&gt; {  if (array.length === 0) {    return array;  }  console.time(&apos;桶排序耗时&apos;);  let i = 0;  let minValue = array[0];  let maxValue = array[0];  for (i = 1; i &lt; array.length; i++) {    if (array[i] &lt; minValue) {      minValue = array[i];    } else if (array[i] &gt; maxValue) {      maxValue = array[i];    }  }  const DEFAULT_BUCKET_SIZE = 5;  bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;  const bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;  const buckets = new Array(bucketCount);  for (i = 0; i &lt; buckets.length; i++) {    buckets[i] = [];  }  for (i = 0; i &lt; array.length; i++) {    buckets[Math.floor((array[i] - minValue) / bucketSize)].push(array[i]);  }  array.length = 0;  for (i = 0; i &lt; buckets.length; i++) {    quickSort(buckets[i]);    for (var j = 0; j &lt; buckets[i].length; j++) {      array.push(buckets[i][j]);    }  }  console.timeEnd(&apos;桶排序耗时&apos;);  return array;};const quickSort = (arr, left, right) =&gt; {    let len = arr.length,        partitionIndex;    left = typeof left != &apos;number&apos; ? 0 : left;    right = typeof right != &apos;number&apos; ? len - 1 : right;    if (left &lt; right) {        partitionIndex = partition(arr, left, right);        quickSort(arr, left, partitionIndex - 1);        quickSort(arr, partitionIndex + 1, right);    }    return arr;};const partition = (arr, left, right) =&gt; {    let pivot = left,        index = pivot + 1;    for (let i = index; i &lt;= right; i++) {        if (arr[i] &lt; arr[pivot]) {            swap(arr, i, index);            index++;        }    }    swap(arr, pivot, index - 1);    return index - 1;};const swap = (arr, i, j) =&gt; {    let temp = arr[i];    arr[i] = arr[j];    arr[j] = temp;};</code></pre><p><strong>测试</strong></p><pre><code>const array = [4, 6, 8, 5, 9, 1, 2, 5, 3, 2];console.log(&apos;原始array:&apos;, array);const newArr = bucketSort(array);console.log(&apos;newArr:&apos;, newArr);// 原始 array:  [4, 6, 8, 5, 9, 1, 2, 5, 3, 2]// 堆排序耗时:   0.133056640625ms// newArr:       [1, 2, 2, 3, 4, 5, 5, 6, 8, 9]</code></pre><p><strong>分析</strong></p><ul><li><p>第一，桶排序是原地排序算法吗 ？ 因为桶排序的空间复杂度，也即内存消耗为 O(n)，所以<code>不是</code>原地排序算法。</p></li><li><p>第二，桶排序是稳定的排序算法吗 ？ 取决于每个桶的排序方式，比如：快排就不稳定，归并就稳定。</p></li><li><p>第三，桶排序的时间复杂度是多少 ？ 因为桶内部的排序可以有多种方法，是会对桶排序的时间复杂度产生很重大的影响。所以，桶排序的时间复杂度可以是多种情况的。 <code>总的来说</code> 最佳情况：当输入的数据可以均匀的分配到每一个桶中。 最差情况：当输入的数据被分配到了同一个桶中。 以下是<code>桶的内部排序</code>为<code>快速排序</code>的情况： 如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k =n / m 个元素。每个桶内部使用快速排序，时间复杂度为 O(k * logk)。 m 个桶排序的时间复杂度就是 O(m * k * logk)，因为 k = n / m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。 当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。 最佳情况：T(n) = O(n)。当输入的数据可以均匀的分配到每一个桶中。 最差情况：T(n) = O(nlogn)。当输入的数据被分配到了同一个桶中。 平均情况：T(n) = O(n)。</p></li></ul><blockquote><p>桶排序最好情况下使用线性时间 O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为 O(n)。 很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。</p></blockquote><p><strong>适用场景</strong></p><ul><li>桶排序比较适合用在外部排序中。</li><li>外部排序就是数据存储在外部磁盘且数据量大，但内存有限，无法将整个数据全部加载到内存中。</li></ul><p><strong>动画</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-96021a791180eba0.gif?imageMogr2/auto-orient/strip" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/12890819-96021a791180eba0.gif?imageMogr2/auto-orient/strip" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="bocket-sort.gif"></p><h3 id="3-9-计数排序（Counting-Sort）"><a href="#3-9-计数排序（Counting-Sort）" class="headerlink" title="3.9 计数排序（Counting Sort）"></a>3.9 计数排序（Counting Sort）</h3><p><strong>思想</strong></p><ul><li>找出待排序的数组中最大和最小的元素。</li><li>统计数组中每个值为 i 的元素出现的次数，存入新数组 countArr 的第 i 项。</li><li>对所有的计数累加（从 countArr 中的第一个元素开始，每一项和前一项相加）。</li><li>反向填充目标数组：将每个元素 i 放在新数组的第 countArr[i] 项，每放一个元素就将 countArr[i] 减去 1 。</li></ul><p>关键在于理解最后反向填充时的操作。</p><p><strong>使用条件</strong></p><ul><li>只能用在数据范围不大的场景中，若数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序。</li><li>计数排序只能给非负整数排序，其他类型需要在不改变相对大小情况下，转换为非负整数。</li><li>比如如果考试成绩精确到小数后一位，就需要将所有分数乘以 10，转换为整数。</li></ul><p><strong>实现</strong></p><p>方法一：</p><pre><code>const countingSort = array =&gt; {    let len = array.length,        result = [],        countArr = [],        min = (max = array[0]);    console.time(&apos;计数排序耗时&apos;);    for (let i = 0; i &lt; len; i++) {        // 获取最小，最大 值        min = min &lt;= array[i] ? min : array[i];        max = max &gt;= array[i] ? max : array[i];        countArr[array[i]] = countArr[array[i]] ? countArr[array[i]] + 1 : 1;    }    console.log(&apos;countArr :&apos;, countArr);    // 从最小值 -&gt; 最大值,将计数逐项相加    for (let j = min; j &lt; max; j++) {        countArr[j + 1] = (countArr[j + 1] || 0) + (countArr[j] || 0);    }    console.log(&apos;countArr 2:&apos;, countArr);    // countArr 中,下标为 array 数值，数据为 array 数值出现次数；反向填充数据进入 result 数据    for (let k = len - 1; k &gt;= 0; k--) {        // result[位置] = array 数据        result[countArr[array[k]] - 1] = array[k];        // 减少 countArr 数组中保存的计数        countArr[array[k]]--;        // console.log(&quot;array[k]:&quot;, array[k], &apos;countArr[array[k]] :&apos;, countArr[array[k]],)        console.log(&apos;result:&apos;, result);    }    console.timeEnd(&apos;计数排序耗时&apos;);    return result;};</code></pre><p>测试</p><pre><code>const array = [2, 2, 3, 8, 7, 1, 2, 2, 2, 7, 3, 9, 8, 2, 1, 4, 2, 4, 6, 9, 2];console.log(&apos;原始 array: &apos;, array);const newArr = countingSort(array);console.log(&apos;newArr: &apos;, newArr);</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/12890819-f2541143bcd69138.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/12890819-f2541143bcd69138.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="测试结果"></p><p>方法二：</p><pre><code>const countingSort2 = (arr, maxValue) =&gt; {    console.time(&apos;计数排序耗时&apos;);    maxValue = maxValue || arr.length;    let bucket = new Array(maxValue + 1),        sortedIndex = 0;    (arrLen = arr.length), (bucketLen = maxValue + 1);    for (let i = 0; i &lt; arrLen; i++) {        if (!bucket[arr[i]]) {            bucket[arr[i]] = 0;        }        bucket[arr[i]]++;    }    for (let j = 0; j &lt; bucketLen; j++) {        while (bucket[j] &gt; 0) {            arr[sortedIndex++] = j;            bucket[j]--;        }    }    console.timeEnd(&apos;计数排序耗时&apos;);    return arr;};</code></pre><p>测试</p><pre><code>const array2 = [2, 2, 3, 8, 7, 1, 2, 2, 2, 7, 3, 9, 8, 2, 1, 4, 2, 4, 6, 9, 2];console.log(&apos;原始 array2: &apos;, array2);const newArr2 = countingSort2(array2, 21);console.log(&apos;newArr2: &apos;, newArr2);</code></pre><p><strong>例子</strong></p><p>可以认为，<strong>计数排序其实是桶排序的一种特殊情况</strong>。</p><p>当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。</p><p>我们都经历过高考，高考查分数系统你还记得吗？我们查分数的时候，系统会显示我们的成绩以及所在省的排名。如果你所在的省有 50 万考生，如何通过成绩快速排序得出名次呢？</p><ul><li>考生的满分是 900 分，最小是 0 分，这个数据的范围很小，所以我们可以分成 901 个桶，对应分数从 0 分到 900 分。</li><li>根据考生的成绩，我们将这 50 万考生划分到这 901 个桶里。桶内的数据都是分数相同的考生，所以并不需要再进行排序。</li><li>我们只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了 50 万考生的排序。</li><li>因为只涉及扫描遍历操作，所以时间复杂度是 O(n)。</li></ul><p><strong>分析</strong></p><ul><li>第一，计数排序是原地排序算法吗 ？ 因为计数排序的空间复杂度为 O(k)，k 桶的个数，所以不是原地排序算法。</li><li>第二，计数排序是稳定的排序算法吗 ？ 计数排序不改变相同元素之间原本相对的顺序，因此它是稳定的排序算法。</li><li>第三，计数排序的时间复杂度是多少 ？ 最佳情况：T(n) = O(n + k) 最差情况：T(n) = O(n + k) 平均情况：T(n) = O(n + k) k 是待排序列最大值。</li></ul><p><strong>动画</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-43b26f260d905c77.gif?imageMogr2/auto-orient/strip" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/12890819-43b26f260d905c77.gif?imageMogr2/auto-orient/strip" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="counting-sort.gif"></p><h3 id="3-10-基数排序（Radix-Sort）"><a href="#3-10-基数排序（Radix-Sort）" class="headerlink" title="3.10 基数排序（Radix Sort）"></a>3.10 基数排序（Radix Sort）</h3><p><strong>思想</strong></p><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。</p><p><strong>例子</strong></p><p>假设我们有 10 万个手机号码，希望将这 10 万个手机号码从小到大排序，你有什么比较快速的排序方法呢 ？</p><p>这个问题里有这样的规律：假设要比较两个手机号码 a，b 的大小，如果在前面几位中，a 手机号码已经比 b 手机号码大了，那后面的几位就不用看了。所以是基于<code>位</code>来比较的。</p><p>桶排序、计数排序能派上用场吗 ？手机号码有 11 位，范围太大，显然不适合用这两种排序算法。针对这个排序问题，有没有时间复杂度是 O(n) 的算法呢 ？ 有，就是基数排序。</p><p><strong>使用条件</strong></p><ul><li>要求数据可以分割独立的<code>位</code>来比较；</li><li>位之间由递进关系，如果 a 数据的高位比 b 数据大，那么剩下的地位就不用比较了；</li><li>每一位的数据范围不能太大，要可以用线性排序，否则基数排序的时间复杂度无法做到 O(n)。</li></ul><p><strong>方案</strong></p><p>按照优先从高位或低位来排序有两种实现方案:</p><ul><li>MSD：由高位为基底，先按 k1 排序分组，同一组中记录, 关键码 k1 相等，再对各组按 k2 排序分成子组, 之后，对后面的关键码继续这样的排序分组，直到按最次位关键码 kd 对各子组排序后，再将各组连接起来，便得到一个有序序列。MSD 方式适用于位数多的序列。</li><li>LSD：由低位为基底，先从 kd 开始排序，再对 kd - 1 进行排序，依次重复，直到对 k1 排序后便得到一个有序序列。LSD 方式适用于位数少的序列。</li></ul><p><strong>实现</strong></p><pre><code>const radixSort = (array, max) =&gt; {    console.time(&apos;计数排序耗时&apos;);    const buckets = [];    let unit = 10,        base = 1;    for (let i = 0; i &lt; max; i++, base *= 10, unit *= 10) {        for (let j = 0; j &lt; array.length; j++) {            let index = ~~((array[j] % unit) / base);            if (buckets[index] == null) {                buckets[index] = [];            }            buckets[index].push(array[j]);        }        let pos = 0,            value;        for (let j = 0, length = buckets.length; j &lt; length; j++) {            if (buckets[j] != null) {                while ((value = buckets[j].shift()) != null) {                    array[pos++] = value;                }            }        }    }    console.timeEnd(&apos;计数排序耗时&apos;);    return array;};</code></pre><p>测试</p><pre><code>const array = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];console.log(&apos;原始array:&apos;, array);const newArr = radixSort(array, 2);console.log(&apos;newArr:&apos;, newArr);// 原始 array:  [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48]// 堆排序耗时:   0.064208984375ms// newArr:       [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</code></pre><p><strong>分析</strong></p><ul><li><p>第一，基数排序是原地排序算法吗 ？ 因为计数排序的空间复杂度为 O(n + k)，所以不是原地排序算法。</p></li><li><p>第二，基数排序是稳定的排序算法吗 ？ 基数排序不改变相同元素之间的相对顺序，因此它是稳定的排序算法。</p></li><li><p>第三，基数排序的时间复杂度是多少 ？ 最佳情况：T(n) = O(n * k) 最差情况：T(n) = O(n * k) 平均情况：T(n) = O(n * k) 其中，k 是待排序列最大值。</p></li></ul><p><strong>动画</strong></p><p>LSD 基数排序动图演示：</p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-aff01ef4a1e19f74.gif?imageMogr2/auto-orient/strip" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/12890819-aff01ef4a1e19f74.gif?imageMogr2/auto-orient/strip" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="radixSort.gif"></p></div><h2 id="4-复杂度对比"><a href="#4-复杂度对比" class="headerlink" title="4. 复杂度对比"></a>4. 复杂度对比</h2><div class="story post-story"><p>十大经典排序算法的 <strong>时间复杂度与空间复杂度</strong> 比较。</p><table><thead><tr><th>名称</th><th>平均</th><th>最好</th><th>最坏</th><th>空间</th><th>稳定性</th><th>排序方式</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n2)</td><td>O(n)</td><td>O(n2)</td><td>O(1)</td><td>Yes</td><td>In-place</td></tr><tr><td>插入排序</td><td>O(n2)</td><td>O(n)</td><td>O(n2)</td><td>O(1)</td><td>Yes</td><td>In-place</td></tr><tr><td>选择排序</td><td>O(n2)</td><td>O(n2)</td><td>O(n2)</td><td>O(1)</td><td>No</td><td>In-place</td></tr><tr><td>归并排序</td><td>O(n log n)</td><td>O(n log n)</td><td>O(n log n)</td><td>O(n)</td><td>Yes</td><td>Out-place</td></tr><tr><td>快速排序</td><td>O(n log n)</td><td>O(n log n)</td><td>O(n2)</td><td>O(logn)</td><td>No</td><td>In-place</td></tr><tr><td>希尔排序</td><td>O(n log n)</td><td>O(n log2 n)</td><td>O(n log2 n)</td><td>O(1)</td><td>No</td><td>In-place</td></tr><tr><td>堆排序</td><td>O(n log n)</td><td>O(n log n)</td><td>O(n log n)</td><td>O(1)</td><td>No</td><td>In-place</td></tr><tr><td>桶排序</td><td>O(n + k)</td><td>O(n + k)</td><td>O(n2)</td><td>O(n + k)</td><td>Yes</td><td>Out-place</td></tr><tr><td>计数排序</td><td>O(n + k)</td><td>O(n + k)</td><td>O(n + k)</td><td>O(k)</td><td>Yes</td><td>Out-place</td></tr><tr><td>基数排序</td><td>O(n * k)</td><td>O(n * k)</td><td>O(n * k)</td><td>O(n + k)</td><td>Yes</td><td>Out-place</td></tr></tbody></table><p>名词解释：</p><ul><li>n：数据规模；</li><li>k：桶的个数；</li><li>In-place: 占用常数内存，不占用额外内存；</li><li>Out-place: 占用额外内存。</li></ul></div><h2 id="5-算法可视化工具"><a href="#5-算法可视化工具" class="headerlink" title="5. 算法可视化工具"></a>5. 算法可视化工具</h2><div class="story post-story"><ul><li><p>算法可视化工具 <a href="https://github.com/algorithm-visualizer/algorithm-visualizer" target="_blank" rel="noopener">algorithm-visualizer</a> 算法可视化工具 algorithm-visualizer 是一个交互式的在线平台，可以从代码中可视化算法，还可以看到代码执行的过程。旨在通过交互式可视化的执行来揭示算法背后的机制。 效果如下图： <img src="https://upload-images.jianshu.io/upload_images/12890819-0af779615ee7fc27.gif?imageMogr2/auto-orient/strip" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/12890819-0af779615ee7fc27.gif?imageMogr2/auto-orient/strip" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="算法可视化工具"></p></li><li><p>算法可视化动画网站 <a href="https://visualgo.net/en" target="_blank" rel="noopener">https://visualgo.net/en</a> 效果如下图： <img src="https://upload-images.jianshu.io/upload_images/12890819-661bf75741df7c9a.gif?imageMogr2/auto-orient/strip" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/12890819-661bf75741df7c9a.gif?imageMogr2/auto-orient/strip" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="quick-sort.gif"></p></li><li><p>算法可视化动画网站 <a href="https://www.ee.ryerson.ca/~courses/coe428/sorting/insertionsort.html" target="_blank" rel="noopener">www.ee.ryerson.ca</a> 效果如下图： <img src="https://upload-images.jianshu.io/upload_images/12890819-2453edc1c19e14b8.gif?imageMogr2/auto-orient/strip" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/12890819-2453edc1c19e14b8.gif?imageMogr2/auto-orient/strip" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="insert-sort.gif"></p></li></ul><ul><li><a href="https://github.com/skidding/illustrated-algorithms" target="_blank" rel="noopener">illustrated-algorithms</a> 变量和操作的可视化表示增强了控制流和实际源代码。您可以快速前进和后退执行，以密切观察算法的工作方式。 效果如下图： <img src="https://upload-images.jianshu.io/upload_images/12890819-22bd05d89a89af8c.gif?imageMogr2/auto-orient/strip" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/12890819-22bd05d89a89af8c.gif?imageMogr2/auto-orient/strip" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="binary-search.gif"></li></ul></div><h2 id="6-系列文章"><a href="#6-系列文章" class="headerlink" title="6. 系列文章"></a>6. 系列文章</h2><div class="story post-story"><p><strong>JavaScript 数据结构与算法之美</strong> 系列文章，暂时写了如下的 11 篇文章，后续还有想写的内容，再补充。</p><p>所写的内容只是数据结构与算法内容的冰山一角，如果你还想学更多的内容，推荐学习王争老师的 <a href="https://time.geekbang.org/column/intro/126" target="_blank" rel="noopener">数据结构与算法之美</a>。</p><p>从时间和空间复杂度、基础数据结构到排序算法，文章的内容有一定的关联性，所以阅读时推荐按顺序来阅读，效果更佳。</p><ul><li><a href="https://github.com/biaochenxuying/blog/issues/29" target="_blank" rel="noopener">1. JavaScript 数据结构与算法之美 - 时间和空间复杂度</a></li><li><a href="https://github.com/biaochenxuying/blog/issues/34" target="_blank" rel="noopener">2. JavaScript 数据结构与算法之美 - 线性表（数组、队列、栈、链表）</a></li><li><a href="https://github.com/biaochenxuying/blog/issues/30" target="_blank" rel="noopener">3. JavaScript 数据结构与算法之美 - 实现一个前端路由，如何实现浏览器的前进与后退 ？</a></li><li><a href="https://github.com/biaochenxuying/blog/issues/35" target="_blank" rel="noopener">4. JavaScript 数据结构与算法之美 - 栈内存与堆内存 、浅拷贝与深拷贝</a></li><li><a href="https://github.com/biaochenxuying/blog/issues/36" target="_blank" rel="noopener">5. JavaScript 数据结构与算法之美 - 递归</a></li><li><a href="https://github.com/biaochenxuying/blog/issues/37" target="_blank" rel="noopener">6. JavaScript 数据结构与算法之美 - 非线性表（树、堆）</a></li><li><a href="https://github.com/biaochenxuying/blog/issues/39" target="_blank" rel="noopener">7. JavaScript 数据结构与算法之美 - 冒泡排序、选择排序、插入排序</a></li><li><a href="https://github.com/biaochenxuying/blog/issues/40" target="_blank" rel="noopener">8. JavaScript 数据结构与算法之美 - 归并排序、快速排序、希尔排序、堆排序</a></li><li><a href="https://github.com/biaochenxuying/blog/issues/41" target="_blank" rel="noopener">9. JavaScript 数据结构与算法之美 - 计数排序、桶排序、基数排序</a></li><li><a href="https://github.com/biaochenxuying/blog/issues/42" target="_blank" rel="noopener">10. JavaScript 数据结构与算法之美 - 十大经典排序算法汇总</a></li><li><a href="https://github.com/biaochenxuying/blog/issues/43" target="_blank" rel="noopener">11. JavaScript 数据结构与算法之美 - 强烈推荐 GitHub 上值得前端学习的数据结构与算法项目</a></li></ul><blockquote><p>如果有错误或者不严谨的地方，请务必给予指正，以免误人子弟，十分感谢。</p></blockquote><p><a href="https://biaochenxuying.cn/articleDetail?article_id=5d4059b896cf541789792485" target="_blank" rel="noopener">Source</a></p></div>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx初试</title>
      <link href="/others-nginx-basic/"/>
      <url>/others-nginx-basic/</url>
      
        <content type="html"><![CDATA[<blockquote><p>“Nginx 是一款轻量级的 HTTP 服务器，采用事件驱动的异步非阻塞处理方式框架，这让其具有极好的 IO 性能，时常用于服务端的反向代理和负载均衡。”</p></blockquote><p>作为前端开发，即使没用过 Nginx，但一定听说过 Nginx。上述这段描述，基本构成了所有人对 Nginx 的第一印象。笔者对于 Nginx 也是慕名已久，直到现在才开始试尝这道大餐，本文是记录笔者学习并使用 Nginx 的过程，通过此文可以简单入门并搭建一套 Nginx 服务。</p> <a id="more"></a><h3 id="一、初试-Nginx"><a href="#一、初试-Nginx" class="headerlink" title="一、初试 Nginx"></a>一、初试 Nginx</h3><p>想要成为一个合格的大前端，又怎能不会 Nginx 呢？</p><p>Nginx 从 2004 年发展至今，从一开始的完善沉淀，再迅速蹿升为“网红”，再到现在占服务器市场中接近 1/3 份额，成为互联网网站搭建的必选技术之一。发展可谓相当迅速，之所以能取得如此成就，主要还是相对于其他 HTTP 服务器其有着不可替代的优势：</p><ul><li>支持海量高并发：采用 IO 多路复用 epoll。官方测试 Nginx 能够支持 5 万并发链接，实际生产环境中可以支撑 2-4 万并发连接数。</li><li>内存消耗少：在主流的服务器中 Nginx 目前是内存消耗最小的了，比如我们用 Nginx+PHP，在 3 万并发链接下，开启 10 个 Nginx 进程消耗 150M 内存。</li><li>免费使用可以商业化：Nginx 为开源软件，采用的是 2-clause BSD-like 协议，可以免费使用，并且可以用于商业。</li><li>配置文件简单：网络和程序配置通俗易懂，即使非专业运维也能看懂。</li></ul><p>而对于前端童鞋，在实际工作上，更倾向于用 Nodejs 来搭建服务器，进而实现一些需求，对 Nginx 有天然的疏远感。的确，Nginx 中的绝大部分功能，如果单纯的使用 Node.js 也可以满足和实现。但实际上，Nginx 和 Node.js 并不冲突，都有自己擅长的领域：Nginx 更擅长于底层服务器端资源的处理（静态资源处理转发、反向代理，负载均衡等），Node.js 更擅长于上层具体业务逻辑的处理。如果将两者组合一起，则可以更加助力前端开发。</p><p>开始动手之前先交代下具体的系统环境：</p><blockquote><p>系统环境说明：<br>服务器：阿里云 ECS<br>操作系统： CentOS 7.4 64 位<br>Nginx 版本：nginx/1.16.1</p></blockquote><h3 id="二、Nginx-的安装"><a href="#二、Nginx-的安装" class="headerlink" title="二、Nginx 的安装"></a>二、Nginx 的安装</h3><p>首先可以查看下系统的 yum 源下是否有可用的 Nginx 包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list | grep nginx</span><br></pre></td></tr></table></figure><p>如果结果类似如图内容，说明 yum 源是存在的<br><img src="http://yanxuan.nosdn.127.net/a46cc75592cd4639abc0dd6f64b5cbff.png" class="lazyload" data-srcset="http://yanxuan.nosdn.127.net/a46cc75592cd4639abc0dd6f64b5cbff.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="UTOOLS1590462877021.png"></p><p>如果不存在或者没有需要的 Nginx 版本，则可以自己配一个 yum 源。</p><p>打开终端，输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.repos.d/nginx.repo</span><br></pre></td></tr></table></figure><p>往里面添加如下脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[nginx]</span><br><span class="line">name=nginx repo</span><br><span class="line">baseurl=http://nginx.org/packages/<span class="variable">$&#123;OS&#125;</span>/<span class="variable">$&#123;OSRELEASE&#125;</span>/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure><blockquote><p>需要注意：<br>OS: 操作系统名称，如：centos<br>OSRELEASE: 操作系统版本，如： 7<br>对应的 baseurl: baseurl=<a href="http://nginx.org/packages/centos/7/$basearch/" target="_blank" rel="noopener">http://nginx.org/packages/centos/7/$basearch/</a></p></blockquote><p>保存修改后，就可以安装 Nginx 了，安装命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx</span><br></pre></td></tr></table></figure><p>安装完成后查看安装的 Nginx 版本:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -v</span><br></pre></td></tr></table></figure><h3 id="三、Nginx-基本配置"><a href="#三、Nginx-基本配置" class="headerlink" title="三、Nginx 基本配置"></a>三、Nginx 基本配置</h3><p>安装完 Nginx 后，需要知道系统中多了那些文件，它们都安装到了那里。可以使用下面的命令进行查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ql nginx</span><br></pre></td></tr></table></figure><p>rpm 是 linux 的 rpm 包管理工具，-q 代表询问模式，-l 代表返回列表，这样我们就可以找到 nginx 的所有安装位置了。</p><p>下面重点罗列下一些重要的文件</p><p><strong>nginx.conf</strong></p><p>nginx.conf 文件是 Nginx 总配置文件，在我们搭建服务器时经常调整的文件。</p><p>进入 etc/nginx 目录下，然后用 vim 进行打开</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/nginx</span><br><span class="line">vim nginx.conf</span><br></pre></td></tr></table></figure><p>下面是文件的详细注释:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#运行用户，默认即是nginx，可以不进行设置</span></span><br><span class="line">user  nginx;</span><br><span class="line"><span class="comment">#Nginx进程，一般设置为和CPU核数一样</span></span><br><span class="line">worker_processes  1;</span><br><span class="line"><span class="comment">#错误日志存放目录</span></span><br><span class="line">error_log  /var/<span class="built_in">log</span>/nginx/error.log warn;</span><br><span class="line"><span class="comment">#进程pid存放位置</span></span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024; <span class="comment"># 单个后台进程的最大并发数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;   <span class="comment">#文件扩展名与类型映射表</span></span><br><span class="line">    default_type  application/octet-stream;  <span class="comment">#默认文件类型</span></span><br><span class="line">    <span class="comment">#设置日志模式</span></span><br><span class="line">    log_format  main  <span class="string">'$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">                      <span class="string">'$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">                      <span class="string">'"$http_user_agent" "$http_x_forwarded_for"'</span>;</span><br><span class="line"></span><br><span class="line">    access_log  /var/<span class="built_in">log</span>/nginx/access.log  main;   <span class="comment">#nginx访问日志存放位置</span></span><br><span class="line"></span><br><span class="line">    sendfile        on;   <span class="comment">#开启高效传输模式</span></span><br><span class="line">    <span class="comment">#tcp_nopush     on;    #减少网络报文段的数量</span></span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;  <span class="comment">#保持连接的时间，也叫超时时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;  #开启gzip压缩</span></span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf; <span class="comment">#包含的子配置项位置和文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>default.conf</strong><br>进入 conf.d 目录，打开 default.conf，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;   <span class="comment">#配置监听端口</span></span><br><span class="line">    server_name  localhost;  //配置域名</span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line">    <span class="comment">#access_log  /var/log/nginx/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /usr/share/nginx/html;     <span class="comment">#服务默认启动目录</span></span><br><span class="line">        index  index.html index.htm;    <span class="comment">#默认访问文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404              /404.html;   # 配置404页面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    error_page   500 502 503 504  /50x.html;   <span class="comment">#错误状态码的显示页面，配置后需要重启</span></span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    proxy_pass   http://127.0.0.1;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    root           html;</span></span><br><span class="line">    <span class="comment">#    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line">    <span class="comment">#    fastcgi_index  index.php;</span></span><br><span class="line">    <span class="comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class="line">    <span class="comment">#    include        fastcgi_params;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># deny access to .htaccess files, if Apache's document root</span></span><br><span class="line">    <span class="comment"># concurs with nginx's one</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ /\.ht &#123;</span></span><br><span class="line">    <span class="comment">#    deny  all;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、Nginx-常用操作"><a href="#四、Nginx-常用操作" class="headerlink" title="四、Nginx 常用操作"></a>四、Nginx 常用操作</h3><h4 id="启动-Nginx-服务"><a href="#启动-Nginx-服务" class="headerlink" title="启动 Nginx 服务"></a>启动 Nginx 服务</h4><ul><li>Nginx 直接启动（CentOS7.4 以上版本）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure><ul><li>使用 systemctl 命令启动</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx.service</span><br></pre></td></tr></table></figure><ul><li>查看服务运行状态</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep nginx</span><br></pre></td></tr></table></figure><p><img src="http://yanxuan.nosdn.127.net/98dfae9ae9ddbe95796aa142053b583a.png" class="lazyload" data-srcset="http://yanxuan.nosdn.127.net/98dfae9ae9ddbe95796aa142053b583a.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="UTOOLS1590464174436.png"></p><h4 id="关停-Nginx-服务"><a href="#关停-Nginx-服务" class="headerlink" title="关停 Nginx 服务"></a>关停 Nginx 服务</h4><ul><li>立即停止服务</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx  -s stop</span><br></pre></td></tr></table></figure><p>这种方法比较强硬，无论进程是否在工作，都直接停止进程。</p><ul><li>从容停止服务</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s quit</span><br></pre></td></tr></table></figure><p>这种方法较 stop 相比就比较温和一些了，需要进程完成当前工作后再停止。</p><ul><li>killall 方法杀死进程</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall nginx</span><br></pre></td></tr></table></figure><p>这种方法也是比较野蛮的，直接杀死进程。</p><ul><li>systemctl 停止</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop nginx.service</span><br></pre></td></tr></table></figure><h4 id="重启-Nginx-服务"><a href="#重启-Nginx-服务" class="headerlink" title="重启 Nginx 服务"></a>重启 Nginx 服务</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx.service</span><br></pre></td></tr></table></figure><h4 id="重新载入配置文件"><a href="#重新载入配置文件" class="headerlink" title="重新载入配置文件"></a>重新载入配置文件</h4><p>在重新编写或者修改 Nginx 的配置文件后，需要作一下重新载入，这时候可以用这个命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><h4 id="查看端口号"><a href="#查看端口号" class="headerlink" title="查看端口号"></a>查看端口号</h4><p>如果 80 端口被占用，可以使用此命令查看端口占用情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tlnp 80</span><br></pre></td></tr></table></figure><h3 id="五、自定义错误页面以及访问控制"><a href="#五、自定义错误页面以及访问控制" class="headerlink" title="五、自定义错误页面以及访问控制"></a>五、自定义错误页面以及访问控制</h3><ul><li>多错误指向一个页面</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error_page   500 502 503 504  /50x.html;</span><br></pre></td></tr></table></figure><ul><li>单独为错误置顶处理方式</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error_page 404  /404_error.html;</span><br></pre></td></tr></table></figure><ul><li>把错误码换成一个地址</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error_page  404 http://blog.kobingo.xyz;</span><br></pre></td></tr></table></figure><ul><li>简单实现访问控制</li></ul><p>有时候我们的服务器只允许特定主机访问，比如内部 OA 系统，或者应用的管理后台系统，更或者是某些应用接口，这时候我们就需要控制一些 IP 访问，我们可以直接在 location 里进行配置。</p><p>可以直接在 default.conf 里进行配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">        deny   123.9.51.42;</span><br><span class="line">        allow  45.76.202.231;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>指令优先级</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">        allow  45.76.202.231;</span><br><span class="line">        deny   all;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面的配置表示只允许<code>45.76.202.231</code>进行访问，其他的 IP 是禁止访问的。但是如果我们把<code>deny all</code>指令，移动到 <code>allow 45.76.202.231</code>之前，会发生什么那？</p><p>会发现所有的 IP 都不允许访问了。这说明了一个问题：就是在同一个块下的两个权限指令，先出现的设置会覆盖后出现的设置（<code>也就是谁先触发，谁起作用</code>）。</p><ul><li>复杂访问控制权限匹配</li></ul><p>在工作中，访问权限的控制需求更加复杂，例如，对于网站下的 img（图片目录）是运行所有用户访问，但对于网站下的 admin 目录则只允许公司内部固定 IP 访问。这时候仅靠 deny 和 allow 这两个指令，是无法实现的。我们需要 location 块来完成相关的需求匹配。</p><p>上面的需求，配置代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location =/img&#123;</span><br><span class="line">    allow all;</span><br><span class="line">&#125;</span><br><span class="line">location =/admin&#123;</span><br><span class="line">    deny all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用正则表达式设置访问权限</li></ul><p>只有精确匹配(=)有时是完不成我们的工作任务的，比如现在我们要禁止访问所有 php 的页面，php 的页面大多是后台的管理或者接口代码，所以为了安全我们经常要禁止所有用户访问，而只开放公司内部访问的。</p><p>代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~\.php$ &#123;</span><br><span class="line">       deny all;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这样我们再访问的时候就不能访问以 php 结尾的文件了。是不是让网站变的安全很多了那？</p><h3 id="六、Nginx-配置虚拟主机"><a href="#六、Nginx-配置虚拟主机" class="headerlink" title="六、Nginx 配置虚拟主机"></a>六、Nginx 配置虚拟主机</h3><p>虚拟主机是指在一台物理主机服务器上划分出多个磁盘空间，每个磁盘空间都是一个虚拟主机，每台虚拟主机都可以对外提供 Web 服务，并且互不干扰。用户能够利用虚拟主机把多个不同域名的网站部署在同一台服务器上。可以大大节约服务器成本与维护成本。</p><ul><li>基于端口号配置虚拟主机</li></ul><p>基于端口号来配置虚拟主机，算是 Nginx 中最简单的一种方式了。原理就是 Nginx 监听多个端口，根据不同的端口号，来区分不同的网站</p><p>我习惯在 conf.d 里新建一个配置文件来配置新的虚拟主机，但也可以配置在主配置 <code>etc/nginx/nginx.conf</code>里，也可以配置在<code>etc/nginx/conf.d/default.conf</code>里。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">listen 8088;</span><br><span class="line">server_name localhost;</span><br><span class="line">location / &#123;</span><br><span class="line">          root /usr/share/nginx/html/html8001;</span><br><span class="line">          index index.html;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>基于 IP 的虚拟主机</li></ul><p>基于 IP 和基于端口的配置几乎一样，只是把<code>server_name</code>选项，配置成 IP 就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name 112.74.164.244;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root /usr/share/nginx/html/html8001;</span><br><span class="line">            index index.html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>基于域名的虚拟主机</li></ul><p>域名设置虚拟主机也非常简单，主要操作的是配置文件的 <code>server_name</code> 项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name nginx.kobin.com;</span><br><span class="line">        location / &#123;</span><br><span class="line">                root /usr/share/nginx/html/html;</span><br><span class="line">                index index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name nginx2.kobin.com;</span><br><span class="line">        location / &#123;</span><br><span class="line">                root /usr/share/nginx/html/html8001;</span><br><span class="line">                index index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七、Nginx-反向代理的设置"><a href="#七、Nginx-反向代理的设置" class="headerlink" title="七、Nginx 反向代理的设置"></a>七、Nginx 反向代理的设置</h3><p>什么是反向代理？ 互联网应用基本都基于 CS 基本结构，即 client 端和 server 端。代理其实就是在 client 端和真正的 server 端之前增加一层提供特定服务的服务器，即代理服务器。</p><p>在了解反向代理前先了解什么是正向代理。</p><ul><li>正向代理</li></ul><p>翻墙工具就是一个典型的正向代理工具。它会把我们不能访问的墙外服务器 server 的网页请求，代理到一个可以访问该网站的代理服务器 proxy，这个代理服务器 proxy 把墙外服务器 server 上的网页内容获取，再转发给客户。具体的流程如下图。<br><img src="http://yanxuan.nosdn.127.net/20284ff2217ab7398f7ed808018b0dc0.png" class="lazyload" data-srcset="http://yanxuan.nosdn.127.net/20284ff2217ab7398f7ed808018b0dc0.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="UTOOLS1590478206582.png"></p><p>其特点如下：</p><ul><li>客户端和代理服务器可以直接互相访问，属于一个 LAN（局域网）</li><li>代理对用户是非透明的，即用户需要自己操作或者感知得到自己的请求被发送到代理服务器</li><li>代理服务器通过代理用户端的请求来向域外服务器请求响应内容。</li></ul><blockquote><p>一句话总结： 代理的是客户端</p></blockquote><ul><li>反向代理</li></ul><p>反向代理正好相反，客户端发送的请求，想要访问 server 服务器上的内容。发送的内容被发送到代理服务器上，这个代理服务器再把请求发送到自己设置好的内部服务器上，而用户真实想获得的内容就在这些设置好的服务器上。<br><img src="http://yanxuan.nosdn.127.net/5f949b17f0ce40d745549acd519bc0ca.png" class="lazyload" data-srcset="http://yanxuan.nosdn.127.net/5f949b17f0ce40d745549acd519bc0ca.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="UTOOLS1590478385142.png"></p><p>其特点如下：</p><ul><li>代理服务器和真正 server 服务器可以直接互相访问，属于一个 LAN（服务器内网）</li><li>代理对用户是透明的，即无感知。不论加不加这个反向代理，用户都是通过相同的请求进行的，且不需要任何额外的操作；</li><li>代理服务器通过代理内部服务器接受域外客户端的请求，并将请求发送到对应的内部服务器上。</li></ul><blockquote><p>一句话总结： 代理的是服务器</p></blockquote><ul><li><p>反向代理的好处：</p><ul><li><p>安全及权限<br>使用反向代理后，用户端将无法直接通过请求访问真正的内容服务器，而必须通过 Nginx。可以通过在 Nginx 层上将危险或者没有权限的请求内容过滤掉，从而保证了服务器的安全。</p></li><li><p>负载均衡<br>一个网站的内容被部署在若干服务器上，可以把这些机子看成一个集群，那 Nginx 可以将接收到的客户端请求“均匀地”分配到这个集群中所有的服务器上，从而实现服务器压力的平均分配</p></li></ul></li><li><p>简单实现反向代理</p></li></ul><p>举个例子，我们访问 home.blog.kobingo.xyz 这个网站，然后反向代理到 baidu.com 上。可做如下配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name home.blog.kobingo.xyz;</span><br><span class="line">        location / &#123;</span><br><span class="line">               proxy_pass https://www.baidu.com;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：<br><img src="http://yanxuan.nosdn.127.net/5f2dbe03d87bf90594f84aa9d94442de.png" class="lazyload" data-srcset="http://yanxuan.nosdn.127.net/5f2dbe03d87bf90594f84aa9d94442de.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="UTOOLS1590479272673.png"></p><p>其他常用的反向代理配置：</p><ul><li><p>proxy_set_header :在将客户端请求发送给后端服务器之前，更改来自客户端的请求头信息。</p></li><li><p>proxy_connect_timeout:配置 Nginx 与后端代理服务器尝试建立连接的超时时间。</p></li><li><p>proxy_read_timeout : 配置 Nginx 向后端服务器组发出 read 请求后，等待相应的超时时间。</p></li><li><p>proxy_send_timeout：配置 Nginx 向后端服务器组发出 write 请求后，等待相应的超时时间。</p></li><li><p>proxy_redirect :用于修改后端服务器返回的响应头中的 Location 和 Refresh。</p></li></ul><h3 id="八、Nginx-适配移动端与-PC-端"><a href="#八、Nginx-适配移动端与-PC-端" class="headerlink" title="八、Nginx 适配移动端与 PC 端"></a>八、Nginx 适配移动端与 PC 端</h3><p>Nginx 通过内置变量<code>$http_user_agent</code>，可以获取到请求客户端的<code>userAgent</code>，就可以用户目前处于移动端还是 PC 端，进而展示不同的页面给用户。</p><p>在 conf.d 目录下新建一个 demo.conf 文件，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name blog.blog.kobingo.xyz;</span><br><span class="line">location / &#123;</span><br><span class="line">root /yangling/app/pc; <span class="comment"># 默认展示PC端页面</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$http_user_agent</span> ~* <span class="string">'(Android|webOS|iPhone|iPod|BlackBerry)'</span>) &#123; <span class="comment"># 如果匹配到mobile端的user_agent则展示mobile页面</span></span><br><span class="line">root /yangling/app/mobile;</span><br><span class="line">&#125;</span><br><span class="line">index index.html;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="九、Nginx-实现-Gzip-压缩"><a href="#九、Nginx-实现-Gzip-压缩" class="headerlink" title="九、Nginx 实现 Gzip 压缩"></a>九、Nginx 实现 Gzip 压缩</h3><p>Gzip 是网页的一种网页压缩技术，经过 gzip 压缩后，页面大小可以变为原来的 30%甚至更小。更小的网页会让用户浏览的体验更好，速度更快。gzip 网页压缩的实现需要浏览器和服务器的支持。</p><p>gzip 是需要服务器和浏览器同事支持的。当浏览器支持 gzip 压缩时，会在请求消息中包含 Accept-Encoding:gzip,这样 Nginx 就会向浏览器发送听过 gzip 后的内容，同时在相应信息头中加入 Content-Encoding:gzip，声明这是 gzip 后的内容，告知浏览器要先解压后才能解析输出。</p><p>gzip 配置：</p><ul><li>gzip : 该指令用于开启或 关闭 gzip 模块。</li><li>gzip_buffers : 设置系统获取几个单位的缓存用于存储 gzip 的压缩结果数据流。</li><li>gzip_comp_level : gzip 压缩比，压缩级别是 1-9，1 的压缩级别最低，9 的压缩级别最高。压缩级别越高压缩率越大，压缩时间越长。</li><li>gzip_disable : 可以通过该指令对一些特定的 User-Agent 不使用压缩功能。</li><li>gzip_min_length:设置允许压缩的页面最小字节数，页面字节数从相应消息头的 Content-length 中进行获取。</li><li>gzip_http_version：识别 HTTP 协议版本，其值可以是 1.1.或 1.0.</li><li>gzip_proxied : 用于设置启用或禁用从代理服务器上收到相应内容 gzip 压缩。</li><li>gzip_vary : 用于在响应消息头中添加 Vary：Accept-Encoding,使代理服务器根据请求头中的 Accept-Encoding 识别是否启用 gzip 压缩。</li></ul><p>简单配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">   .....</span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_types text/plain application/javascript text/css;</span><br><span class="line">   .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gzip on</code>是启用 gizp 模块，下面的一行是用于在客户端访问网页时，对文本、JavaScript 和 CSS 文件进行压缩输出。</p><h3 id="十、Nginx-与跨域请求"><a href="#十、Nginx-与跨域请求" class="headerlink" title="十、Nginx 与跨域请求"></a>十、Nginx 与跨域请求</h3><p>举个例子：在 a.com 页面中有请求 b.com 的接口<code>http://b.com/getHomeData</code>, 出现了跨域问题。当然这种跨域问题的处理方式很多，这里主要说下用 Nginx 如何解决。</p><p>在 a.com 启个 Nginx 服务，配置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name a.com;</span><br><span class="line">  <span class="comment">#请求跨域，这里约定代理请求url path是以/apis/开头</span></span><br><span class="line">  location ^~/apis/ &#123;</span><br><span class="line">      <span class="comment"># 这里重写了请求，将正则匹配中的第一个()中$1的path，拼接到真正的请求后面，并用break停止后续匹配</span></span><br><span class="line">      rewrite ^/apis/(.*)$ /<span class="variable">$1</span> <span class="built_in">break</span>;</span><br><span class="line">      proxy_pass https://www.b.com/;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时请求接口 URL 换成<a href="http://a.com/apis/getHomeData，就可以正常请求到数据了。其本质还是利用了服务端不受跨域限制的原理。" target="_blank" rel="noopener">http://a.com/apis/getHomeData，就可以正常请求到数据了。其本质还是利用了服务端不受跨域限制的原理。</a></p><h3 id="十一、Nginx-与合并请求"><a href="#十一、Nginx-与合并请求" class="headerlink" title="十一、Nginx 与合并请求"></a>十一、Nginx 与合并请求</h3><p>通过<a href="https://github.com/alibaba/nginx-http-concat" target="_blank" rel="noopener">nginx-http-concat</a>插件可以实现将多个资源请求合并为一个请求，达到性能优化目的。</p><h3 id="十二、Nginx-与图片处理"><a href="#十二、Nginx-与图片处理" class="headerlink" title="十二、Nginx 与图片处理"></a>十二、Nginx 与图片处理</h3><p>通过<a href="http://nginx.org/en/docs/http/ngx_http_image_filter_module.html" target="_blank" rel="noopener">ngx_http_image_filter_module</a>插件实现日常对图片的处理，包括缩放、裁剪、旋转、图片质量等的控制。</p><h3 id="十三、使用Let’s-Encrypt配置ssl证书"><a href="#十三、使用Let’s-Encrypt配置ssl证书" class="headerlink" title="十三、使用Let’s Encrypt配置ssl证书"></a>十三、使用Let’s Encrypt配置ssl证书</h3><h4 id="安装certbot"><a href="#安装certbot" class="headerlink" title="安装certbot"></a>安装certbot</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y python3 &amp;&amp; pip3 install certbot</span><br></pre></td></tr></table></figure><p>查看certbot使用方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p>certbot 默认使用http方式对域名所有权进行验证，该操作需要绑定vps的80端口。如果80端口已被占用，请先停止占用的进程，例如停止Nginx：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall nginx</span><br></pre></td></tr></table></figure><p>为指定域名生成证书：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot certonly --standalone -d 域名1 -d 域名2</span><br></pre></td></tr></table></figure><p>查看域名证书的路径和国旗时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot certificates</span><br></pre></td></tr></table></figure><p>生成的证文件位置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/letsencrypt/live/blog.kobingo.xyz/</span><br></pre></td></tr></table></figure><h4 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h4><p>编辑/etc/nginx/conf.d/default.conf:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name blog.kobingo.xyz;</span><br><span class="line">    rewrite ^(.*) https://<span class="variable">$server_name</span><span class="variable">$1</span> permanent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       443 ssl;</span><br><span class="line">    server_name  blog.kobingo.xyz;</span><br><span class="line">    charset utf-8;</span><br><span class="line"></span><br><span class="line">    ssl_certificate /etc/letsencrypt/live/blog.kobingo.xyz/fullchain.pem;</span><br><span class="line">    ssl_certificate_key /etc/letsencrypt/live/blog.kobingo.xyz/privkey.pem;</span><br><span class="line">    ssl_protocols TLSv1.2 TLSv1.3; <span class="comment"># TLSv1.3需要nginx 1.13.0以上版本</span></span><br><span class="line">    <span class="comment"># 如果nginx版本低，建议使用这种加密算法配置</span></span><br><span class="line">    <span class="comment"># ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span></span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-SHA384;</span><br><span class="line">    ssl_ecdh_curve secp384r1;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    ssl_session_cache shared:SSL:10m;</span><br><span class="line">    ssl_session_timeout 10m;</span><br><span class="line">    ssl_session_tickets off;</span><br><span class="line">    keepalive_timeout 70;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里填写其他配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看配置有无错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure><p>如果没有错误，则启动Nginx：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx.service</span><br></pre></td></tr></table></figure><h4 id="证书自动更新"><a href="#证书自动更新" class="headerlink" title="证书自动更新"></a>证书自动更新</h4><p>Let’s Encrypt证书的有效期是三个月，超过期限则需要续签。证书续期可以手动完成，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop nginx</span><br><span class="line">certbot renew</span><br><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure><p>也可以配置crontab任务自动续签，在/etc/crontab文件末添加一行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 1 */2 0 root systemctl stop nginx; /usr/<span class="built_in">local</span>/bin/certbot renew; systemctl restart nginx</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 全栈 </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文章摘录</title>
      <link href="/collection/"/>
      <url>/collection/</url>
      
        <content type="html"><![CDATA[<p>在这里记录一些看到的好文章好博客</p><a id="more"></a><p><a href="https://www.cnblogs.com/tugenhua0707" target="_blank" rel="noopener">龙恩 0707</a></p><p><a href="https://github.com/renaesop/blog/issues/1" target="_blank" rel="noopener">cdn</a></p><p><a href="https://biaochenxuying.cn/" target="_blank" rel="noopener">全栈修炼</a></p><p><a href="https://yuchengkai.cn/" target="_blank" rel="noopener">前端进阶之道</a></p><p><a href="https://lucifer.ren/fe-interview/#/" target="_blank" rel="noopener">大前端面试宝典 - 图解前端</a></p><p><a href="https://mp.weixin.qq.com/s/FwrId8d2kCJKvtGTdM2xHw" target="_blank" rel="noopener">未来可期的 TypeScript</a></p><p><a href="https://mp.weixin.qq.com/s/XR3-3MNCYY2pg6yVwVQohQ" target="_blank" rel="noopener">别再说虚拟 DOM 快了，要被打脸的</a></p><p><a href="https://mp.weixin.qq.com/s/cz5DBpqFiadL4IQofiWY3A" target="_blank" rel="noopener">深入理解虚拟 DOM，它真的不快</a></p><p><a href="https://juejin.im/post/5d3e3231e51d4510926a7c39" target="_blank" rel="noopener">Deep In React 之详谈 React 16 Diff 策略(二)</a></p><p><a href="https://zhuanlan.zhihu.com/p/54042084" target="_blank" rel="noopener">ReactFiber 在并发模式下的运行机制</a></p><p><a href="https://zhuanlan.zhihu.com/p/78677852" target="_blank" rel="noopener">前端浏览器输入 URL 后发生什么</a></p><p><a href="https://github.com/fouber/blog/issues/6" target="_blank" rel="noopener">大公司如何部署前端代码</a></p><p><a href="https://zhuanlan.zhihu.com/p/53599723" target="_blank" rel="noopener">Vuex、Flux、Redux、Redux-saga、Dva、MobX</a><br><a href="https://juejin.im/post/5eb3cab66fb9a043856f3987?utm_source=gold_browser_extension" target="_blank" rel="noopener">累死累活做业务，绩效还不怎么样，我只能帮你到这了……</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于hexo搭建个人博客并使用GitHub Actions一键发布到GitHub pages &amp; 阿里云ECS</title>
      <link href="/others-hexo/"/>
      <url>/others-hexo/</url>
      
        <content type="html"><![CDATA[<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。本文记录了使用 Hexo 创建个人博客并使用GitHub Actions一键发布到 GitHub pages 和 阿里云ECS上的全过程。</p><a id="more"></a><h3 id="什么是-Hexo？"><a href="#什么是-Hexo？" class="headerlink" title="什么是 Hexo？"></a>什么是 Hexo？</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h4><p>安装 Hexo 前，请先确保您的电脑上已经安装了下列应用程序：</p><ul><li><a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a> (Node.js 版本需不低于 8.10，建议使用 Node.js 10.0 及以上版本)</li><li><a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a></li></ul><p><em>注： 如果您的电脑未安装 Node 或者 Git，请先安装后再阅读下面内容</em></p><h4 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h4><p>使用 npm:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>使用 yarn:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn global add hexo-cli</span><br></pre></td></tr></table></figure><h3 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h3><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><h4 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h4><p>网站的 <a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">配置</a> 信息，您可以在此配置大部分的参数。</p><h4 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h4><p><a href="https://hexo.io/zh-cn/docs/writing" target="_blank" rel="noopener">模版</a> 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</p><h4 id="source"><a href="#source" class="headerlink" title="source"></a>source</h4><p>资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去</p><h4 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h4><p><a href="https://hexo.io/zh-cn/docs/themes" target="_blank" rel="noopener">主题</a> 文件夹。Hexo 会根据主题来生成静态页面。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><p>新建一篇文章</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><h4 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h4><p>生成静态文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><h4 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h4><p>发表草稿。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure><h4 id="server"><a href="#server" class="headerlink" title="server"></a>server</h4><p>启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/。" target="_blank" rel="noopener">http://localhost:4000/。</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><h4 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h4><p>部署网站。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><h4 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h4><p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。<br>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>列出网站资料。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo list &lt;type&gt;</span><br></pre></td></tr></table></figure><p><em>注： 更多命令见<a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">官网</a></em></p><h3 id="部署-GitHub-pages"><a href="#部署-GitHub-pages" class="headerlink" title="部署 GitHub pages"></a>部署 GitHub pages</h3><p>如果您只是想部署到GitHub Actions上，那么可以直接用这节的方法。如果还想部署到阿里云等私人服务器上，那么可以跳过这步，直接看下一节。</p><h4 id="新建-GitHub-项目"><a href="#新建-GitHub-项目" class="headerlink" title="新建 GitHub 项目"></a>新建 GitHub 项目</h4><p>打开 GitHub 点击右上角的<code>new repository</code><br><img src="http://yanxuan.nosdn.127.net/e4ab3a5d71b66640072d74bd000cae04.png" class="lazyload" data-srcset="http://yanxuan.nosdn.127.net/e4ab3a5d71b66640072d74bd000cae04.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="UTOOLS1588764262695.png"></p><p>然后在下图所示中，输入项目名称（后面一定要加.github.io 后缀），勾选 readme 初始化，点击完成创建<br><img src="http://yanxuan.nosdn.127.net/5204b23ad8733af70ec1d2132e9dacff.png" class="lazyload" data-srcset="http://yanxuan.nosdn.127.net/5204b23ad8733af70ec1d2132e9dacff.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="UTOOLS1588764393885.png"></p><h4 id="安装-hexo-deployer-git。"><a href="#安装-hexo-deployer-git。" class="headerlink" title="安装 hexo-deployer-git。"></a>安装 hexo-deployer-git。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h4 id="修改-config-yml-配置"><a href="#修改-config-yml-配置" class="headerlink" title="修改_config.yml 配置"></a>修改_config.yml 配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:jiangawait&#x2F;jiangawait.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h4 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h4><p>执行 hexo deploy 将生成的文件部署到上一步配置的仓库对应的分支上去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure><blockquote><p>至此，已经实现了个人博客的搭建并完成了一键发布到GitHub Pages的功能，如果只需要发布到GitHub Pages，那么至此已经可以愉快地写文章了。</p><p>但是由于总所周知的原因，GitHub在国内的访问速度总是时好时坏，不够畅快。</p><p>那么如果你手里恰好有闲置的云服务器，那么接下去就更进一步吧！🙂</p></blockquote><h3 id="GitHub-Actions登场"><a href="#GitHub-Actions登场" class="headerlink" title="GitHub Actions登场"></a>GitHub Actions登场</h3><p>GitHub Actions 是 GitHub 于2018年10月推出的持续集成服务。功能非常强大，具体的基础用法不赘述，可以参阅<a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html" target="_blank" rel="noopener">阮一峰老师的教程</a>。</p><p>这里主要介绍如何配置GitHub Actions实现自动部署功能。</p><h4 id="创建workflow-文件"><a href="#创建workflow-文件" class="headerlink" title="创建workflow 文件"></a>创建workflow 文件</h4><p>GitHub Actions 的配置文件叫做 workflow 文件, 存放在代码仓库的.github/workflows目录。</p><p>新建.github/workflows/deploy.yml, 具体配置如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Hexo</span> <span class="string">build</span> <span class="string">and</span> <span class="string">deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">blog</span> <span class="comment"># blog分支是本人的hexo源码分支</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="comment"># 切换分支</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span> <span class="comment"># If you're using actions/checkout@v2 you must set persist-credentials to false in most cases for the deployment to work correctly.</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">persist-credentials:</span> <span class="literal">false</span></span><br><span class="line">          <span class="comment"># checkout到你的hexo代码分支</span></span><br><span class="line">          <span class="attr">ref:</span> <span class="string">blog</span></span><br><span class="line">          <span class="comment"># hexo需要加载内部子模块</span></span><br><span class="line">          <span class="attr">submodules:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 使用 node:10</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">use</span> <span class="string">Node.js</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 安装npm包 &amp; 生成静态文件</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">and</span> <span class="string">publish</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">          <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 将静态文件部署到阿里云</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">aliyun</span> <span class="string">server</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">easingthemes/ssh-deploy@v2.0.7</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">SSH_PRIVATE_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.ALIYUN_SERVER_ACCESS_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">ARGS:</span> <span class="string">"-avz --delete"</span></span><br><span class="line">          <span class="attr">SOURCE:</span> <span class="string">"public"</span></span><br><span class="line">          <span class="attr">REMOTE_HOST:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.ALIYUN_SERVER_HOST</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">REMOTE_USER:</span> <span class="string">"root"</span></span><br><span class="line">          <span class="attr">TARGET:</span> <span class="string">"/code/hexo-blog"</span> <span class="comment"># 静态资源存放目录</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 将静态文件部署到github pages</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">Github</span> <span class="string">Pages</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">JamesIves/github-pages-deploy-action@releases/v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">ACCESS_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.ACCESS_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">BASE_BRANCH:</span> <span class="string">blog</span></span><br><span class="line">          <span class="attr">BRANCH:</span> <span class="string">master</span></span><br><span class="line">          <span class="attr">FOLDER:</span> <span class="string">public</span></span><br></pre></td></tr></table></figure><h4 id="配置参数说明"><a href="#配置参数说明" class="headerlink" title="配置参数说明"></a>配置参数说明</h4><ul><li>ALIYUN_SERVER_HOST： 阿里云服务器公网IP；</li><li>ALIYUN_SERVER_ACCESS_TOKEN：阿里云.ssh下的私钥(id_rsa);<ul><li>如果未生成过，可以执行如下命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -m PEM -t rsa -b 4096</span><br></pre></td></tr></table></figure></li><li>把公钥复制一份到authorized_keys中:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line">chmod 600 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure></li></ul></li><li>ACCESS_TOKEN:  GitHub 密钥, 按照<a href="https://help.github.com/cn/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line" target="_blank" rel="noopener">官方文档</a>生成一个秘钥。</li></ul><p>以上三个参数都保存到自己仓库-&gt;settings-&gt;Secrets里面：</p><p><img src="http://yanxuan.nosdn.127.net/682b4ddff33a7fb61d5a76ca59374e83.png" class="lazyload" data-srcset="http://yanxuan.nosdn.127.net/682b4ddff33a7fb61d5a76ca59374e83.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="UTOOLS1590676585606.png"></p><h4 id="构建结果"><a href="#构建结果" class="headerlink" title="构建结果"></a>构建结果</h4><p>将整个仓库推送到GitHub，GitHub 发现了 workflow 文件以后，就会自动运行。<br><img src="http://yanxuan.nosdn.127.net/afd80ff8efb75954b5ca1723d264e119.png" class="lazyload" data-srcset="http://yanxuan.nosdn.127.net/afd80ff8efb75954b5ca1723d264e119.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="UTOOLS1590679294118.png"></p><p>至此，我们已经将博客部署到GitHub Actions和阿里云上了。阿里云上我们可以使用Nginx托管静态资源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  blog.kobingo.xyz;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root /code/hexo-blog/public; <span class="comment"># 静态资源存放目录</span></span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一切大功告成！收工😄</p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器缓存IntersectionObserver原理分析</title>
      <link href="/%E6%B5%8F%E8%A7%88%E5%99%A8-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"/>
      <url>/%E6%B5%8F%E8%A7%88%E5%99%A8-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>浏览器缓存作为性能优化的重要一环，对于前端而言，重要性不言而喻。以前总是一知半解的，所以这次好好整理总结了一下。</p></blockquote><a id="more"></a><p>首先我们来总体感知一下它的匹配流程，如下：</p><ol><li>浏览器发送请求前，根据请求头的expires和cache-control判断是否命中（包括是否过期）强缓存策略，如果命中，直接从缓存获取资源，并不会发送请求。如果没有命中，则进入下一步。</li><li>没有命中强缓存规则，浏览器会发送请求，根据请求头的last-modified和etag判断是否命中协商缓存，如果命中，直接从缓存获取资源。如果没有命中，则进入下一步。</li><li>如果前两步都没有命中，则直接从服务端获取资源。<br><a href="https://camo.githubusercontent.com/383448e84bfd0fb2382b8956ec5ce2e334f751bf/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3138322f3235382f3138323235383031342d353865383635386462396330345f61727469636c6578" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/383448e84bfd0fb2382b8956ec5ce2e334f751bf/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3138322f3235382f3138323235383031342d353865383635386462396330345f61727469636c6578" class="lazyload" data-srcset="https://camo.githubusercontent.com/383448e84bfd0fb2382b8956ec5ce2e334f751bf/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3138322f3235382f3138323235383031342d353865383635386462396330345f61727469636c6578" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="图片描述"></a></li></ol><p>强缓存：不会向服务器发送请求，直接从缓存中读取资源。</p><h2 id="2-1-强缓存原理"><a href="#2-1-强缓存原理" class="headerlink" title="2.1 强缓存原理"></a>2.1 强缓存原理</h2><div class="story post-story"><p>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：</p><ul><li>第一次请求，不存在缓存结果和缓存标识，直接向服务器发送请求</li></ul><p><a href="https://camo.githubusercontent.com/9c446ac858c7c168b0fe4dbadcb205b4bbc3c613/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3132352f3338372f313235333837343938322d356361303233643534613062665f61727469636c6578" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/9c446ac858c7c168b0fe4dbadcb205b4bbc3c613/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3132352f3338372f313235333837343938322d356361303233643534613062665f61727469636c6578" class="lazyload" data-srcset="https://camo.githubusercontent.com/9c446ac858c7c168b0fe4dbadcb205b4bbc3c613/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3132352f3338372f313235333837343938322d356361303233643534613062665f61727469636c6578" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="图片描述"></a></p><ul><li><p>存在缓存标识和缓存结果，但是已经失效，强制缓存是啊比，则使用协商缓存（暂不分析）<br><a href="https://camo.githubusercontent.com/142f221aa3c9331a00b8e296ed673ce682c3106e/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3130302f3630352f313030363035363132332d356361303234336636313630625f61727469636c6578" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/142f221aa3c9331a00b8e296ed673ce682c3106e/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3130302f3630352f313030363035363132332d356361303234336636313630625f61727469636c6578" class="lazyload" data-srcset="https://camo.githubusercontent.com/142f221aa3c9331a00b8e296ed673ce682c3106e/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3130302f3630352f313030363035363132332d356361303234336636313630625f61727469636c6578" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="图片描述"></a></p></li><li><p>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果<br><a href="https://camo.githubusercontent.com/84806927721fe7f20c9c990b56a6131b1e4918ef/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3235392f3231352f323539323135303838372d356361303234376337306266305f61727469636c6578" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/84806927721fe7f20c9c990b56a6131b1e4918ef/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3235392f3231352f323539323135303838372d356361303234376337306266305f61727469636c6578" class="lazyload" data-srcset="https://camo.githubusercontent.com/84806927721fe7f20c9c990b56a6131b1e4918ef/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3235392f3231352f323539323135303838372d356361303234376337306266305f61727469636c6578" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="图片描述"></a></p></li></ul><p>那么强制缓存的缓存规则是什么？<br>当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是<code>Expires</code>和<code>Cache-Control</code>，其中<code>Cache-Control</code>优先级比<code>Expires</code>高。</p><h3 id="2-1-1、-Expires"><a href="#2-1-1、-Expires" class="headerlink" title="2.1.1、 Expires"></a>2.1.1、 Expires</h3><p>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，<code>Expires=max-age + 请求时间</code>，需要和<code>Last-modified</code>结合使用。<code>Expires</code>是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。</p><blockquote><p>Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</p></blockquote><h3 id="2-1-2、-Cache-Control"><a href="#2-1-2、-Cache-Control" class="headerlink" title="2.1.2、 Cache-Control"></a>2.1.2、 Cache-Control</h3><p>在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为：</p><ul><li>public：所有内容都将被缓存（客户端和代理服务器都可缓存）</li><li>private：所有内容只有客户端可以缓存，<code>Cache-Control</code>的默认取值</li><li>no-cache：客户端缓存内容，但是是否使用缓存则需要经过<strong>协商缓存</strong>来验证决定</li><li>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</li><li>max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效</li></ul><blockquote><p>需要注意的是，<code>no-cache</code>这个名字有一点误导。设置了<code>no-cache</code>之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致，也就是协商缓存。而<code>no-store</code>才表示不会被缓存，即不使用强制缓存，也不使用协商缓存</p></blockquote><h3 id="2-1-3、设置"><a href="#2-1-3、设置" class="headerlink" title="2.1.3、设置"></a>2.1.3、设置</h3><p>强缓存需要服务端设置<code>expires</code>和<code>cache-control</code>。<br><code>nginx</code>代码参考，设置了一年的缓存时间：</p><pre><code>location ~ .*\.(ico|svg|ttf|eot|woff)(.*) {  proxy_cache               pnc;  proxy_cache_valid         200 304 1y;  proxy_cache_valid         any 1m;  proxy_cache_lock          on;  proxy_cache_lock_timeout  5s;  proxy_cache_use_stale     updating error timeout invalid_header http_500 http_502;  expires                   1y;}</code></pre><p>浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？这就是下面我们要讲到的<code>from disk cache</code>和<code>from memory cache</code>。</p></div><h2 id="2-2、from-disk-cache和from-memory-cache"><a href="#2-2、from-disk-cache和from-memory-cache" class="headerlink" title="2.2、from disk cache和from memory cache"></a>2.2、from disk cache和from memory cache</h2><div class="story post-story"><p>细心地同学在开发的时候应该注意到了Chrome的网络请求的Size会出现三种情况<code>from disk cache(磁盘缓存)</code>、<code>from memory cache(内存缓存)</code>、以及资源大小数值。</p><table><thead><tr><th>状态</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>200</td><td>form memory cache</td><td>不请求网络资源，资源在内存当中，一般脚本、字体、图片会存在内存当中</td></tr><tr><td>200</td><td>form disk ceche</td><td>不请求网络资源，在磁盘当中，一般非脚本会存在内存当中，如css等</td></tr><tr><td>200</td><td>资源大小数值</td><td>从服务器下载最新资源</td></tr><tr><td>304</td><td>报文大小</td><td>请求服务端发现资源没有更新，使用本地资源</td></tr></tbody></table><p>浏览器读取缓存的顺序为memory –&gt; disk。<br>以访问<code>https://github.com/xiangxingchen/blog</code>为例<br>我们第一次访问时<code>https://github.com/xiangxingchen/blog</code><br><a href="https://camo.githubusercontent.com/9427d265968167f679b5c972e27a5c177c0fe961/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3139312f3731352f313931373135323436362d356361303263316437323464635f61727469636c6578" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/9427d265968167f679b5c972e27a5c177c0fe961/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3139312f3731352f313931373135323436362d356361303263316437323464635f61727469636c6578" class="lazyload" data-srcset="https://camo.githubusercontent.com/9427d265968167f679b5c972e27a5c177c0fe961/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3139312f3731352f313931373135323436362d356361303263316437323464635f61727469636c6578" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="图片描述"></a><br>关闭标签页，再此打开<code>https://github.com/xiangxingchen/blog</code>时<br><a href="https://camo.githubusercontent.com/faed28ae17e0ebb44a7dd625a45bc4b43c67fc62/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3135372f3139322f313537313932373030332d356361303263356637613339665f61727469636c6578" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/faed28ae17e0ebb44a7dd625a45bc4b43c67fc62/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3135372f3139322f313537313932373030332d356361303263356637613339665f61727469636c6578" class="lazyload" data-srcset="https://camo.githubusercontent.com/faed28ae17e0ebb44a7dd625a45bc4b43c67fc62/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3135372f3139322f313537313932373030332d356361303263356637613339665f61727469636c6578" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="图片描述"></a><br>F5刷新时<br><a href="https://camo.githubusercontent.com/913c4843dcf821d0a2c99e683ea4496306b1595f/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3134362f3831342f313436383134393930322d356361303263386534663564655f61727469636c6578" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/913c4843dcf821d0a2c99e683ea4496306b1595f/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3134362f3831342f313436383134393930322d356361303263386534663564655f61727469636c6578" class="lazyload" data-srcset="https://camo.githubusercontent.com/913c4843dcf821d0a2c99e683ea4496306b1595f/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3134362f3831342f313436383134393930322d356361303263386534663564655f61727469636c6578" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="图片描述"></a></p><p>简单的对比一下<br><a href="https://camo.githubusercontent.com/6ecb52f1e83736ce21d1d540c358e96b35bba786/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3239372f3531372f3239373531373039372d356361303264646161653332325f61727469636c6578" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/6ecb52f1e83736ce21d1d540c358e96b35bba786/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3239372f3531372f3239373531373039372d356361303264646161653332325f61727469636c6578" class="lazyload" data-srcset="https://camo.githubusercontent.com/6ecb52f1e83736ce21d1d540c358e96b35bba786/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3239372f3531372f3239373531373039372d356361303264646161653332325f61727469636c6578" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="图片描述"></a></p><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：</p><ul><li>协商缓存生效，返回304和Not Modified<br><a href="https://camo.githubusercontent.com/eb82c6c036d09e3bb32229b198b5ca11776250d2/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3131322f3732392f3131323732393631372d356361303265373961366431375f61727469636c6578" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/eb82c6c036d09e3bb32229b198b5ca11776250d2/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3131322f3732392f3131323732393631372d356361303265373961366431375f61727469636c6578" class="lazyload" data-srcset="https://camo.githubusercontent.com/eb82c6c036d09e3bb32229b198b5ca11776250d2/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3131322f3732392f3131323732393631372d356361303265373961366431375f61727469636c6578" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="图片描述"></a></li><li>协商缓存失效，返回200和请求结果<br><a href="https://camo.githubusercontent.com/610f7ba79f73d7c618e409c8f1a4fb56afbf68e4/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3237392f3232362f323739323236383834332d356361303265393566306435385f61727469636c6578" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/610f7ba79f73d7c618e409c8f1a4fb56afbf68e4/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3237392f3232362f323739323236383834332d356361303265393566306435385f61727469636c6578" class="lazyload" data-srcset="https://camo.githubusercontent.com/610f7ba79f73d7c618e409c8f1a4fb56afbf68e4/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3237392f3232362f323739323236383834332d356361303265393566306435385f61727469636c6578" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="图片描述"></a></li></ul></div><h2 id="3-1、Last-Modified和If-Modified-Since"><a href="#3-1、Last-Modified和If-Modified-Since" class="headerlink" title="3.1、Last-Modified和If-Modified-Since"></a>3.1、Last-Modified和If-Modified-Since</h2><div class="story post-story"><ol><li>浏览器首先发送一个请求，让服务端在<code>response header</code>中返回请求的资源上次更新时间，就是<code>last-modified</code>，浏览器会缓存下这个时间。</li><li>然后浏览器再下次请求中，<code>request header</code>中带上<code>if-modified-since</code>:<code>[保存的last-modified的值]</code>。根据浏览器发送的修改时间和服务端的修改时间进行比对，一致的话代表资源没有改变，服务端返回正文为空的响应，让浏览器中缓存中读取资源，这就大大减小了请求的消耗。</li></ol><p>由于last-modified依赖的是保存的绝对时间，还是会出现误差的情况：</p><ol><li>保存的时间是以秒为单位的，1秒内多次修改是无法捕捉到的；</li><li>各机器读取到的时间不一致，就有出现误差的可能性。为了改善这个问题，提出了使用etag。</li></ol></div><h2 id="3-2、ETag和If-None-Match"><a href="#3-2、ETag和If-None-Match" class="headerlink" title="3.2、ETag和If-None-Match"></a>3.2、ETag和If-None-Match</h2><div class="story post-story"><p><code>etag</code>是<code>http</code>协议提供的若干机制中的一种<code>Web</code>缓存验证机制，并且允许客户端进行缓存协商。生成etag常用的方法包括对资源内容使用抗碰撞散列函数，使用最近修改的时间戳的哈希值，甚至只是一个版本号。 和<code>last-modified</code>一样.</p><ul><li>浏览器会先发送一个请求得到<code>etag</code>的值，然后再下一次请求在<code>request header</code>中带上<code>if-none-match</code>:<code>[保存的etag的值]</code>。</li><li>通过发送的<code>etag</code>的值和服务端重新生成的<code>etag</code>的值进行比对，如果一致代表资源没有改变，服务端返回正文为空的响应，告诉浏览器从缓存中读取资源。</li></ul><blockquote><p>etag能够解决last-modified的一些缺点，但是etag每次服务端生成都需要进行读写操作，而last-modified只需要读取操作，从这方面来看，etag的消耗是更大的。</p></blockquote><p>二者对比</p><ul><li>精确度上：<code>Etag</code>要优于<code>Last-Modified</code>。</li><li>优先级上：服务器校验优先考虑<code>Etag</code>。</li><li>性能上：<code>Etag</code>要逊于<code>Last-Modified</code></li></ul><ol><li>打开网页，地址栏输入地址： 查找 <code>disk cache</code> 中是否有匹配。如有则使用；如没有则发送网络请求。</li><li>普通刷新 (F5)：因为 TAB 并没有关闭，因此 <code>memory cache</code> 是可用的，会被优先使用(如果匹配的话)。其次才是 <code>disk cache</code>。</li><li>强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 <code>Cache-control:no-cache</code>(为了兼容，还带了 <code>Pragma:no-cache</code>),服务器直接返回 200 和最新内容。</li></ol><p><a href="https://camo.githubusercontent.com/cedc20d313717c7e4ba59c3802fce635306a50ac/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3235362f3839332f323536383933303937372d356361303333643662383565385f61727469636c6578" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/cedc20d313717c7e4ba59c3802fce635306a50ac/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3235362f3839332f323536383933303937372d356361303333643662383565385f61727469636c6578" class="lazyload" data-srcset="https://camo.githubusercontent.com/cedc20d313717c7e4ba59c3802fce635306a50ac/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3235362f3839332f323536383933303937372d356361303333643662383565385f61727469636c6578" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="图片描述"></a></p><p><a href="https://github.com/xiangxingchen/blog/issues/9" target="_blank" rel="noopener">Source</a></p></div>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js浮点数陷进与解法</title>
      <link href="/javascript-js%E6%B5%AE%E7%82%B9%E6%95%B0%E9%99%B7%E8%BF%9B%E4%B8%8E%E8%A7%A3%E6%B3%95/"/>
      <url>/javascript-js%E6%B5%AE%E7%82%B9%E6%95%B0%E9%99%B7%E8%BF%9B%E4%B8%8E%E8%A7%A3%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>众所周知，JavaScript 浮点数运算时经常遇到会 <code>0.000000001</code> 和 <code>0.999999999</code> 这样奇怪的结果，如 <code>0.1+0.2=0.30000000000000004</code>、<code>1-0.9=0.09999999999999998</code>，很多人知道这是浮点数误差问题，但具体原因就说不清楚了。本文帮你理清这背后的原理以及解决方案，还会向你解释JS中的大数危机和四则运算中会遇到的坑。</p><a id="more"></a><h2 id="浮点数的存储"><a href="#浮点数的存储" class="headerlink" title="浮点数的存储"></a>浮点数的存储</h2><div class="story post-story"><p>首先要搞清楚 JavaScript 如何存储小数。和其它语言如 Java 和 Python 不同，JavaScript 中所有数字包括整数和小数都只有一种类型 — <code>Number</code>。它的实现遵循 <a href="https://link.zhihu.com/?target=http%3A//grouper.ieee.org/groups/754/">IEEE 754</a> 标准，使用 64 位固定长度来表示，也就是标准的 double 双精度浮点数（相关的还有float 32位单精度）。计算机组成原理中有过详细介绍，如果你不记得也没关系。</p><blockquote><p>注：大多数语言中的小数默认都是遵循 IEEE 754 的 float 浮点数，包括 Java、Ruby、Python，本文中的浮点数问题同样存在。</p></blockquote><p>这样的存储结构优点是可以归一化处理整数和小数，节省存储空间。</p><p>64位比特又可分为三个部分：</p><ul><li>符号位S：第 1 位是正负数符号位（sign），0代表正数，1代表负数</li><li>指数位E：中间的 11 位存储指数（exponent），用来表示次方数</li><li>尾数位M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零</li></ul><p><img src="https://pic3.zhimg.com/v2-7267a58b29892c3b723e3d6c3f73905a_b.jpg" class="lazyload" data-srcset="https://pic3.zhimg.com/v2-7267a58b29892c3b723e3d6c3f73905a_b.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><p>实际数字就可以用以下公式来计算：</p><p><img src="https://pic3.zhimg.com/v2-2038480c70ce879e866767be10d74686_b.jpg" class="lazyload" data-srcset="https://pic3.zhimg.com/v2-2038480c70ce879e866767be10d74686_b.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><p>注意以上的公式遵循科学计数法的规范，在十进制中 <code>0&lt;M&lt;10</code>，到二进制就是 <code>0&lt;M&lt;2</code>。也就是说整数部分只能是1，所以可以被舍去，只保留后面的小数部分。如 <code>4.5</code> 转成二进制就是 <code>100.1</code>，科学计数法表示是 <code>1.001*2^2</code>，舍去1后 <code>M = 001</code>。E是一个无符号整数，因为长度是11位，取值范围是 0~2047。但是科学计数法中的指数是可以为负数的，所以约定减去一个中间数 1023，<code>[0,1022]</code> 表示为负，<code>[1024,2047]</code> 表示为正。如 4.5 的指数 <code>E = 1025</code>，尾数 <code>M = 001</code>。</p><p>最终的公式变成：</p><p><img src="https://pic1.zhimg.com/v2-0afbaa15606e9ca468bac0bb11cbb644_b.jpg" class="lazyload" data-srcset="https://pic1.zhimg.com/v2-0afbaa15606e9ca468bac0bb11cbb644_b.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><p>所以 <code>4.5</code> 最终表示为（M=001、E=1025）：</p><p><img src="https://pic2.zhimg.com/v2-356a0add175bcf4696d571a8beb2063d_b.jpg" class="lazyload" data-srcset="https://pic2.zhimg.com/v2-356a0add175bcf4696d571a8beb2063d_b.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><p>(图片由此生成 <a href="https://link.zhihu.com/?target=http%3A//www.binaryconvert.com/convert_double.html">http://www.binaryconvert.com/convert_double.html</a>)</p><p>下面再以 <code>0.1</code> 为例解释浮点误差的原因，<code>0.1</code> 转成二进制表示为 <code>0.0001100110011001100</code>(1100循环)，<code>1.100110011001100x2^-4</code>，所以 <code>E=-4+1023=1019</code>；M 舍去首位的1，得到 <code>100110011...</code>。最终就是：</p><p><img src="https://pic4.zhimg.com/v2-615ad461a0e8641f1b89871e2eff87ef_b.jpg" class="lazyload" data-srcset="https://pic4.zhimg.com/v2-615ad461a0e8641f1b89871e2eff87ef_b.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><p>转化成十进制后为 <code>0.100000000000000005551115123126</code>，因此就出现了浮点误差。</p></div><h2 id="为什么-0-1-0-2-0-30000000000000004？"><a href="#为什么-0-1-0-2-0-30000000000000004？" class="headerlink" title="为什么 0.1+0.2=0.30000000000000004？"></a>为什么 <code>0.1+0.2=0.30000000000000004</code>？</h2><div class="story post-story"><p>计算步骤为：</p><pre><code>// 0.1 和 0.2 都转化成二进制后再进行运算0.00011001100110011001100110011001100110011001100110011010 +0.0011001100110011001100110011001100110011001100110011010 =0.0100110011001100110011001100110011001100110011001100111// 转成十进制正好是 0.30000000000000004</code></pre></div><h2 id="为什么-x-0-1-能得到-0-1？"><a href="#为什么-x-0-1-能得到-0-1？" class="headerlink" title="为什么 x=0.1 能得到 0.1？"></a>为什么 <code>x=0.1</code> 能得到 <code>0.1</code>？</h2><div class="story post-story"><p>恭喜你到了看山不是山的境界。因为 mantissa 固定长度是 52 位，再加上省略的一位，最多可以表示的数是 <code>2^53=9007199254740992</code>，对应科学计数尾数是 <code>9.007199254740992</code>，这也是 JS 最多能表示的精度。它的长度是 16，所以可以近似使用 <code>toPrecision(16)</code> 来做精度运算，超过的精度会自动做凑整处理。于是就有：</p><pre><code>0.10000000000000000555.toPrecision(16)// 返回 0.1000000000000000，去掉末尾的零后正好为 0.1// 但你看到的 `0.1` 实际上并不是 `0.1`。不信你可用更高的精度试试：0.1.toPrecision(21) = 0.100000000000000005551</code></pre></div><h2 id="大数危机"><a href="#大数危机" class="headerlink" title="大数危机"></a>大数危机</h2><div class="story post-story"><p>可能你已经隐约感觉到了，如果整数大于 9007199254740992 会出现什么情况呢？<br>由于 E 最大值是 1023，所以最大可以表示的整数是 <code>2^1024 - 1</code>，这就是能表示的最大整数。但你并不能这样计算这个数字，因为从 <code>2^1024</code> 开始就变成了 <code>Infinity</code></p><pre><code>&gt; Math.pow(2, 1023)8.98846567431158e+307&gt; Math.pow(2, 1024)Infinity</code></pre><p>那么对于 <code>(2^53, 2^63)</code> 之间的数会出现什么情况呢？</p><ul><li><code>(2^53, 2^54)</code> 之间的数会两个选一个，只能精确表示偶数</li><li><code>(2^54, 2^55)</code> 之间的数会四个选一个，只能精确表示4个倍数</li><li>… 依次跳过更多2的倍数</li></ul><p>下面这张图能很好的表示 JavaScript 中浮点数和实数（Real Number）之间的对应关系。我们常用的 <code>(-2^53, 2^53)</code> 只是最中间非常小的一部分，越往两边越稀疏越不精确。</p><p><img src="https://pic3.zhimg.com/v2-eee9a2ca28dd3d8e6f0f5c89956ab43a_b.jpg" class="lazyload" data-srcset="https://pic3.zhimg.com/v2-eee9a2ca28dd3d8e6f0f5c89956ab43a_b.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><p>在淘宝早期的订单系统中把订单号当作数字处理，后来随意订单号暴增，已经超过了<br><code>9007199254740992</code>，最终的解法是把订单号改成字符串处理。</p><p>要想解决大数的问题你可以引用第三方库 <a href="https://link.zhihu.com/?target=https%3A//github.com/MikeMcl/bignumber.js/">bignumber.js</a>，原理是把所有数字当作字符串，重新实现了计算逻辑，缺点是性能比原生的差很多，所以原生支持大数就很有必要了。TC39 已经有一个 Stage 3 的提案 <a href="https://link.zhihu.com/?target=https%3A//github.com/tc39/proposal-bigint">proposal bigint</a>，大数问题有望彻底解决。在浏览器正式支持前，可以使用 Babel 7.0 来实现，它的内部是自动转换成 <a href="https://link.zhihu.com/?target=https%3A//github.com/peterolson/BigInteger.js">big-integer</a> 来计算，这样能保持精度但运算效率会降低。</p></div><h2 id="toPrecision-vs-toFixed"><a href="#toPrecision-vs-toFixed" class="headerlink" title="toPrecision vs toFixed"></a><code>toPrecision</code> vs <code>toFixed</code></h2><div class="story post-story"><p>数据处理时，这两个函数很容易混淆。它们的共同点是把数字转成字符串供展示使用。注意在计算的中间过程不要使用，只用于最终结果。</p><p>不同点就需要注意一下：</p><ul><li><code>toPrecision</code> 是处理精度，精度是从左至右第一个不为0的数开始数起。</li><li><code>toFixed</code> 是小数点后指定位数取整，从小数点开始数起。</li></ul><p>两者都能对多余数字做凑整处理，也有些人用 <code>toFixed</code> 来做四舍五入，但一定要知道它是有 Bug 的。</p><p>如：<code>1.005.toFixed(2)</code> 返回的是 <code>1.00</code> 而不是 <code>1.01</code>。</p><p>原因： <code>1.005</code> 实际对应的数字是 <code>1.00499999999999989</code>，在四舍五入时全部被舍去！</p><p>解法：使用四舍五入函数 <code>Math.round()</code> 来处理。但 <code>Math.round(1.005 * 100) / 100</code>还是不行，因为 <code>1.005 * 100 = 100.49999999999999</code>。还需要把乘法和除法精度误差都解决后再使用 <code>Math.round</code>。可以使用后面介绍的 <code>number-precision#round</code> 方法来解决。</p></div><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><div class="story post-story"><p>回到最关心的问题：如何解决浮点误差。首先，理论上用有限的空间来存储无限的小数是不可能保证精确的，但我们可以处理一下得到我们期望的结果。</p></div><h2 id="数据展示类"><a href="#数据展示类" class="headerlink" title="数据展示类"></a>数据展示类</h2><div class="story post-story"><p>当你拿到 <code>1.4000000000000001</code> 这样的数据要展示时，建议使用 <code>toPrecision</code> 凑整并 <code>parseFloat</code> 转成数字后再显示，如下：</p><pre><code>parseFloat(1.4000000000000001.toPrecision(12)) === 1.4  // True</code></pre><p>封装成方法就是：</p><pre><code>function strip(num, precision = 12) {  return +parseFloat(num.toPrecision(precision));}</code></pre><p>为什么选择 <code>12</code> 做为默认精度？这是一个经验的选择，一般选12就能解决掉大部分0001和0009问题，而且大部分情况下也够用了，如果你需要更精确可以调高。</p></div><h2 id="数据运算类"><a href="#数据运算类" class="headerlink" title="数据运算类"></a>数据运算类</h2><div class="story post-story"><p>对于运算类操作，如 <code>+-*/</code>，就不能使用 <code>toPrecision</code> 了。正确的做法是把小数转成整数后再运算。以加法为例：</p><pre><code>/** * 精确加法 */function add(num1, num2) {  const num1Digits = (num1.toString().split(&apos;.&apos;)[1] || &apos;&apos;).length;  const num2Digits = (num2.toString().split(&apos;.&apos;)[1] || &apos;&apos;).length;  const baseNum = Math.pow(10, Math.max(num1Digits, num2Digits));  return (num1 * baseNum + num2 * baseNum) / baseNum;}</code></pre><p>以上方法能适用于大部分场景。遇到科学计数法如 <code>2.3e+1</code>（当数字精度大于21时，数字会强制转为科学计数法形式显示）时还需要特别处理一下。</p><p>能读到这里，说明你非常有耐心，那我就放个福利吧。遇到浮点数误差问题时可以直接使用<br><a href="https://link.zhihu.com/?target=https%3A//github.com/dt-fe/number-precision">https://github.com/dt-fe/number-precision</a></p><p>完美支持浮点数的加减乘除、四舍五入等运算。非常小只有1K，远小于绝大多数同类库（如Math.js、BigDecimal.js），100%测试全覆盖，代码可读性强，不妨在你的应用里用起来！</p></div><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><div class="story post-story"><ul><li><a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Double-precision_floating-point_format">Double-precision floating-point format</a></li><li><a href="https://link.zhihu.com/?target=http%3A//floating-point-gui.de/">What Every Programmer Should Know About Floating-Point Arithmetic</a></li><li><a href="https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DpQs_wx8eoQ8">Why Computers are Bad at Algebra | Infinite Series</a></li><li><a href="https://link.zhihu.com/?target=http%3A//jasss.soc.surrey.ac.uk/9/4/4.html">Is Your Model Susceptible to Floating-Point Errors?</a></li></ul><p><a href="https://zhuanlan.zhihu.com/p/30703042" target="_blank" rel="noopener">原文里链接</a></p></div>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> number </tag>
            
            <tag> bigint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Event Loop详解</title>
      <link href="/javascript-event-loop/"/>
      <url>/javascript-event-loop/</url>
      
        <content type="html"><![CDATA[<p>JavaScript从诞生起就是一门单线程的语言,单线程的缺点是任务执行会阻塞，表现到网页里是：发起数据请求 –&gt; http延迟 –&gt; 等待完成，等待的过程中，其他操作无法执行，导致页面长时间无响应。</p><p>JavaScript用<strong>异步回调（asynchronous callback）</strong>去解决这些问题。实现异步回调的特性，其实是基于Event Loop（事件循环）。</p><a id="more"></a><h2 id="先了解一点基础知识"><a href="#先了解一点基础知识" class="headerlink" title="先了解一点基础知识"></a><strong>先了解一点基础知识</strong></h2><div class="story post-story"><h3 id="1-JavaScript的-Engine-和-Runtime"><a href="#1-JavaScript的-Engine-和-Runtime" class="headerlink" title="1. JavaScript的 Engine 和 Runtime"></a><strong>1.</strong> JavaScript的 Engine 和 Runtime</h3><p>简单来说，为了让 JavaScript 运行起来，要完成两部分工作（当然实际比这复杂得多）：</p><p>第一部分是<strong>Engine（JS引擎）</strong>：编译并执行 JavaScript 代码，完成内存分配、垃圾回收等；<br>第二部分是<strong>是 Runtime（运行时）</strong>：为 JavaScript 提供一些对象或机制，使它能够与外界交互。</p><p>举个例子：</p><p>Chrome浏览器 和 Node.js 都使用了 V8 Engine。V8 实现并提供了 ECMAScript 标准中的所有数据类型、操作符、对象和方法（注意并没有 DOM）。 但它们的 Runtime 并不一样：Chrome 提供了 window、DOM，而 Node.js 则是 require、process 等等。</p><h3 id="2-浏览器的线程"><a href="#2-浏览器的线程" class="headerlink" title="2. 浏览器的线程"></a><strong>2. 浏览器的线程</strong></h3><p>现代浏览器的一个 tab ，其中的线程包括但不局限于：</p><ul><li>GUI 渲染线程</li><li>JS引擎线程</li><li>事件触发线程</li><li>定时器触发线程</li><li>异步http请求线程</li></ul><p>JavaScript中的异步回调是通过 WebAPIs 去支持的，常见的有 <code>XMLHttpRequest</code>，<code>setTimeout</code>，事件回调（<code>onclik</code>, <code>onscroll</code>等）。而这几个 API 浏览器都提供了单独的线程去运行，所以才会有合适的地方去处理定时器的计时、各种请求的回调。即当代码中出现这几个定义的异步任务，<strong>是由浏览器实现了它们与JS引擎的通信，与JS引擎不属与同一个线程</strong>。</p><p>另外，GUI 渲染和JavaScript执行是互斥的。虽然两者属于不同的线程，但是由于JavaScript执行结果可能会对页面产生影响，所以浏览器对此做了处理，大部分情况下JavaScript线程执行，执行渲染（render）的线程就会暂停，等JavaScript的同步代码执行完再去渲染。</p></div><h2 id="Event-loop的定义"><a href="#Event-loop的定义" class="headerlink" title="Event loop的定义"></a>Event loop的定义</h2><div class="story post-story"><p>Event Loop（事件循环） 是让 JavaScript 做到既是单线程，又绝对不会阻塞的核心机制，也是 JavaScript 并发模型（Concurrency Model）的基础，是用来协调各种事件、用户交互、脚本执行、UI 渲染、网络请求等的一种机制。Event Loop的作用很简单： 监控<strong>调用栈</strong>和<strong>任务队列</strong>（见 3），如果调用栈是空的，它就会取出队列中的第一个”callback函数”，然后将它压入到调用栈中，然后执行它。</p><p>总的来说，Event Loop 是<strong>实现异步回调的一种机制</strong>而已。</p><h3 id="1-分两种"><a href="#1-分两种" class="headerlink" title="1.分两种"></a>1.分两种</h3><p>Event Loop 分为两种，一种存在于 Browsing Context 中，还有一种在 Worker 中。</p><ol><li><strong>Browsing Context</strong> 是指一种用来将 Document（文档）展现给用户的环境。例如浏览器中的 tab，window 或 iframe 等，通常都包含 Browsing Context。</li><li><strong>Worker</strong> 是指一种独立于 UI 脚本，可在后台执行脚本的 API。常用来在后台处理一些计算密集型的任务。</li></ol><p>本篇重点介绍的是 Browsing Context 中的 Event Loop，相比 Worker 中的 Event Loop，它也更加复杂一些。</p><blockquote><p>另外，Event Loop 并不是在 ECMAScript 标准中定义的，而是在 HTML 标准中定义的。在 JS引擎中（以V8为例），只是实现了 ECMAScript 标准，而并不关心什么 Event Loop。也就是说 <strong>Event Loop 是属于 JavaScript Runtime</strong> 的，是由宿主环境（比如浏览器）提供的。所以千万不要理解错了，这也是前面介绍 JavaScript Engine 和 Runtime 的原因。</p></blockquote><h3 id="2-独立"><a href="#2-独立" class="headerlink" title="2.独立"></a>2.独立</h3><p>每个”线程“都有自己的 Event Loop。所以，每个 web worker 拥有独立的 Event Loop，它们都可以独立运行；<a href="https://html.spec.whatwg.org/#similar-origin-window-agent" target="_blank" rel="noopener">同源的 windows</a> 共享一个 Event Loop，它们之间可以互相通信。</p></div><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><div class="story post-story"><p>从 JavaScript 内存模型的角度，我们可以将内存划分为调用栈（Call Stack）、堆（Heap）以及任务队列（Queue）等几个部分：<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfczoqm41bj308b07n74l.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfczoqm41bj308b07n74l.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><h3 id="1-调用栈"><a href="#1-调用栈" class="headerlink" title="1. 调用栈"></a>1. 调用栈</h3><p>调用栈会记录所有的函数调用信息，当我们调用某个函数时，会将其参数与局部变量等以栈帧的形式压入栈中（入栈）；在执行完毕后，会弹出栈顶的帧。让我们来看一看下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printSquare</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s = multiply(x, x);</span><br><span class="line">  <span class="built_in">console</span>.log(s);</span><br><span class="line">&#125;</span><br><span class="line">printSquare(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>当程序开始执行的时候，调用栈是空的，然后，步骤如下：</p><p><img src="../.gitbook/assets/image%20%2817%29.png" class="lazyload" data-srcset="../.gitbook/assets/image%20%2817%29.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><h3 id="2-堆"><a href="#2-堆" class="headerlink" title="2. 堆"></a>2. 堆</h3><p>堆则则存放了大量的非结构化数据，譬如程序分配的变量与对象。</p><h3 id="3-任务队列"><a href="#3-任务队列" class="headerlink" title="3. 任务队列"></a>3. 任务队列</h3><p>任务队列包含了一系列待处理的信息与相关联的回调函数。任务队列又分为 <strong>MacroTask Queue</strong> 和 <strong>MicroTask Queue</strong> 两种。</p></div><h2 id="MacroTask-和-MicroTask"><a href="#MacroTask-和-MicroTask" class="headerlink" title="MacroTask 和 MicroTask"></a>MacroTask 和 MicroTask</h2><div class="story post-story"><h3 id="1-MacroTask-Queue（宏任务队列）"><a href="#1-MacroTask-Queue（宏任务队列）" class="headerlink" title="1. MacroTask Queue（宏任务队列）"></a>1. MacroTask Queue（宏任务队列）</h3><p>Event Loop 会有一个或多个 MacroTask Queue，这是一个先进先出（FIFO）的有序列表，存放着来自不同 <strong>Task Source</strong>（任务源）的 Task（也即MacroTask）。</p><blockquote><p>关于 Task，常有人通俗地称它为 MarcoTask，但其实 HTML 标准中并没有这种说法。然而，为了方便理解，本书仍沿用通俗的称谓MacroTask。</p></blockquote><p>在 HTML 标准中，定义了几种常见的 Task Source：</p><ul><li>DOM manipulation（DOM 操作）；</li><li>User interaction（用户交互）；</li><li>Networking（网络请求）；</li><li>History traversal（History API 操作）。</li></ul><p>MacroTask Source 的定义非常的宽泛，常见的鼠标、键盘事件，AJAX，数据库操作（例如 IndexedDB），以及定时器相关的 setTimeout、setInterval 等等都属于 Task Source，所有来自这些 MacroTask Source 的 MacroTask 都会被放到对应的 MacroTask Queue 中等待处理。</p><p>对于 MacroTask、MacroTask Queue 和 Task Source，有如下规定：</p><ol><li>来自相同 Task Source 的 MacroTask，必须放在同一个 MacroTask Queue 中；</li><li>来自不同 Task Source 的 MacroTask，可以放在不同的 MacroTask Queue 中；</li><li>同一个 MacroTask Queue 内的 MacroTask 是按顺序执行的；</li><li>但对于不同的 MacroTask Queue（Task Source），浏览器会进行调度，允许优先执行来自特定 Task Source 的 MacroTask。</li></ol><blockquote><p>例如，鼠标、键盘事件和网络请求都有各自的 MacroTask Queue，当两者同时存时，浏览器可以优先从用户交互相关的 MacroTask Queue 中挑选 MacroTask 并执行，比如这里的鼠标、键盘事件，从而保证流畅的用户体验。</p></blockquote><h3 id="2-MicroTask-Queue（微任务队列）"><a href="#2-MicroTask-Queue（微任务队列）" class="headerlink" title="2. MicroTask Queue（微任务队列）"></a>2. MicroTask Queue（微任务队列）</h3><p>MicroTask Queue 与 MacroTask Queue 类似，也是一个有序列表。不同之处在于，<strong>一个 Event Loop 只有一个 MicroTask Queue</strong>。</p><p>在 HTML 标准中，并没有明确规定 MicroTask Source，通常认为有以下几种：</p><ul><li>Promise</li></ul><blockquote><p>在 Promises/A+ Note 3.1 中提到了 then、onFulfilled、onRejected 的实现方法，但 Promise 本身属于平台代码，由具体实现来决定是否使用 Microtask，因此在不同浏览器上可能会出现执行顺序不一致的问题。不过好在目前的共识是用 Microtask 来实现事件队列。</p></blockquote><ul><li>MutationObserver</li><li>Object.observe (已废弃)</li></ul><p>这里要特别提一下：网上有很多文章把 Node.js 的 <code>process.nextTick</code> 和 Microtask 混为一谈，事实上虽然两者层级（运行时机）非常接近，但并不是同一个东西。<code>process.nextTick</code> 是 Node.js 自身定义实现的一种机制，有自己的 nextTickQueue，与 HTML 标准中的 MicroTask 不是一回事。在 Node.js 中，<code>process.nextTick</code> 会先于 Microtask Queue 被执行。</p><h3 id="3-二者关系图例"><a href="#3-二者关系图例" class="headerlink" title="3. 二者关系图例"></a>3. 二者关系图例</h3><p>Event Loop中，每一次循环称为tick，每一次tick的任务细节如下：</p><ul><li>调用栈选择最先进入队列的MacroTask（通常是script整体代码），如果有则执行；</li><li>检查是否存在 MicroTask，如果存在则不停的执行，直至清空 MicroTask Queue；</li><li>浏览器更新渲染（render），每一次事件循环，浏览器都可能会去更新渲染；</li><li>重复以上步骤。</li></ul><p>MacroTask Queue和MicroTask Queue二者的关系如下图：</p><p><img src="https://pic1.zhimg.com/80/v2-a24e582fda37065755f10bd4dc5a3dc0_hd.jpg" class="lazyload" data-srcset="https://pic1.zhimg.com/80/v2-a24e582fda37065755f10bd4dc5a3dc0_hd.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><p>如图所示，二者互相穿插：MacroTask –&gt; MicroTask Queue –&gt; MacroTask。</p><p><strong>一个Event Loop会有一个或多个 MacroTask Queue，而 Event Loop 仅有一个 MicroTask Queue。</strong></p><p>这句话可能比较令人费解，因为图中似乎有2 个MicroTask Queue！</p><p>其实是这样的，每个 MacroTask Queue 都保证按照回调函数（callback）入队列的顺序依次执行MacroTask，在 MacroTask 或者 MicroTask 中产生的新 MicroTask 会被压入到 MicroTask Queue中并执行。而在 执行两个MacroTask之间，也即在执行下一个MacroTask之前，<strong>会优先执行完所有MicroTask，也即会优先清空已有的 MicroTask Queue</strong>。</p><p>因此，图中第二个MicroTask Queue产生的时候，第一个MicroTask Queue其实已经被清空了。所以Event Loop实际上仅有一个MicroTask Queue。</p></div><h2 id="JavaScript-Runtime-的运行机制"><a href="#JavaScript-Runtime-的运行机制" class="headerlink" title="JavaScript Runtime 的运行机制"></a>JavaScript Runtime 的运行机制</h2><div class="story post-story"><p>了解了 Event Loop 和任务队列的基本概念后，就可以从相对宏观的角度先了解一下 JavaScript Runtime 的运行机制了，简化后的步骤如下：</p><ol><li><p>主线程不断循环；</p></li><li><p>对于<strong>同步任务</strong>，创建执行上下文（Execution Context），按顺序进入调用栈；</p></li><li><p>对于<strong>异步任务</strong>：</p><ul><li>与步骤 2 相同，同步执行这段代码；</li><li>将相应的 MacroTask（或 Microtask）添加到任务队列；</li><li>由其他线程来执行具体的异步操作。</li></ul></li></ol><blockquote><p>其他线程是指：尽管 JavaScript 是单线程的，但浏览器内核是多线程的，它会将 GUI 渲染、定时器触发、HTTP 请求等工作交给专门的线程来处理。另外，在 Node.js 中，异步操作会优先由 OS 或第三方系统提供的<strong>异步接口</strong>来执行，然后才由线程池处理。</p></blockquote><ol start="4"><li>当主线程执行完当前调用栈中的所有任务，就会去读取 Event Loop 的任务队列，取出并执行任务；</li><li>重复以上步骤。</li></ol><p>用一张简图来表示一下这种运行机制：</p><p><img src="https://pic4.zhimg.com/80/v2-64476c110e4efcd85df76dc49b510abb_hd.jpg" class="lazyload" data-srcset="https://pic4.zhimg.com/80/v2-64476c110e4efcd85df76dc49b510abb_hd.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><p>还是拿 setTimeout 举例：</p><ol><li>主线程同步执行这个 setTimeout 函数本身。</li><li>将负责执行这个 setTimeout 的回调函数的 MacroTask 添加到 MacroTask Queue。</li><li>定时器开始工作（实际上是靠 Event Loop 不断循环检查系统时间来判断是否已经到达指定的时间点）。</li><li>主线程继续执行其他任务。</li><li>当调用栈为空，且定时器触发时，主线程取出 MacroTask 并执行相应的回调函数。</li></ol><p>很明显，执行 setTimeout 不会导致阻塞。当然，如果主线程很忙的话（调用栈一直非空），就会出现明明时间已经到了，却也不执行回调的现象，所以类似 setTimeout 这样的回调函数都是没法保证执行时机的。</p><blockquote><p>setTimeout和setInterval取的时间是不准确的，因为当调用栈若不为空，它们的回调函数永远不会别执行。所以，我们会经常碰到setTimeout和setInterval用来做动画的时候，很不流畅或者卡顿。</p></blockquote></div><h2 id="面试题解析"><a href="#面试题解析" class="headerlink" title="面试题解析"></a>面试题解析</h2><div class="story post-story"><p>在面试中我们常常会碰到如下类似的代码题，面试官要你写出输出结果，其要目的是考察对JavaScript不同任务的执行先后顺序的理解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行顺序问题，考察频率挺高</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  resolve(<span class="number">3</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>根据本文的解析，我们可以得到：</p><ol><li>先执行同步代码<ul><li>首先，执行<code>new Promise</code>中的<code>console.log(2)</code>，then后面的属于MicroTask所以跳过；</li><li>然后，执行<code>console.log(4)</code>。</li></ul></li><li>执行完script这个MacroTask后，执行MicroTask（也即<code>Promise.then</code>） 中的<code>console.log(val)</code>，此时<code>val</code>的值由<code>resolve(3)</code>传递过来，值为<code>3</code>。后面无其他微任务。</li><li>执行另一个MacroTask也即定时器<code>setTimeout</code>中的<code>console.log(1)</code>。 根据本文的内容，可以很轻松，且有理有据的猜出写出正确答案：2，4，3，1。</li></ol></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>javascript的继承实现</title>
      <link href="/javascript-javascript%E7%9A%84%E7%BB%A7%E6%89%BF%E5%AE%9E%E7%8E%B0/"/>
      <url>/javascript-javascript%E7%9A%84%E7%BB%A7%E6%89%BF%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>抛开JavaScript自带的class语法糖实现类的继承，如果用原生JavaScript实现类的继承，有以下六种方式，其实现代码与优缺点分析如下</p><a id="more"></a><h2 id="01-类式继承-classical-inheritance"><a href="#01-类式继承-classical-inheritance" class="headerlink" title="01.类式继承(classical inheritance)"></a>01.类式继承(classical inheritance)</h2><div class="story post-story"><p> 实现本质：重写子类的原型，代之以父类的实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">username</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.username = username ? username : <span class="string">"Unknown"</span>;</span><br><span class="line">   <span class="keyword">this</span>.books = [<span class="string">"coffe"</span>, <span class="string">"1891"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CoffeUser</span>(<span class="params">username</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (username)</span><br><span class="line">      <span class="keyword">this</span>.username = username;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关键</span></span><br><span class="line">CoffeUser.prototype = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user1 = <span class="keyword">new</span> CoffeUser();</span><br><span class="line"><span class="keyword">const</span> user2 = <span class="keyword">new</span> CoffeUser();</span><br><span class="line"></span><br><span class="line"><span class="comment">//instanceof是检测某个对象是否是某个类的实例</span></span><br><span class="line"><span class="built_in">console</span>.log(user1 <span class="keyword">instanceof</span> User);<span class="comment">//&gt;&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以直接访问原型链上的属性</span></span><br><span class="line"><span class="built_in">console</span>.log(user1.username);<span class="comment">//&gt;&gt; Unknown</span></span><br><span class="line"><span class="built_in">console</span>.log(user1.books); <span class="comment">//&gt;&gt; ["coffe", "1891"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改来自原型上的引用类型的属性，则有副作用：会影响到所有实例</span></span><br><span class="line">user1.books.push(<span class="string">"hello"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(user1.books); <span class="comment">//&gt;&gt; ["coffe", "1891", "hello"]</span></span><br><span class="line"><span class="built_in">console</span>.log(user2.books); <span class="comment">//&gt;&gt; ["coffe", "1891", "hello"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改来自原型上的值类型的属性，无副作用</span></span><br><span class="line">user1.username = <span class="string">'U'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(user1.username, user2.username); <span class="comment">//&gt;&gt; U Unknown</span></span><br></pre></td></tr></table></figure><p>缺陷：</p><ul><li><strong>引用类型属性的误修改。</strong>原型属性中的引用类型属性会被所有实例共享，若子类实例更改从父类原型继承来的引用类型的共有属性，会影响其他子类。</li><li><strong>无法传递参数。</strong>在创建子类型的实例时，不能向父类的构造函数中传递参数。这点如过不好理解的话，接着看下面的“构造函数式继承”。</li></ul><p>综上，我们在实际开发中很少单独使用类式继承。</p></div><h2 id="02-构造函数式继承"><a href="#02-构造函数式继承" class="headerlink" title="02.构造函数式继承"></a>02.构造函数式继承</h2><div class="story post-story"><p>通过call/apply调用来实现继承：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.password = password;</span><br><span class="line">   <span class="keyword">this</span>.username = username;</span><br><span class="line">   User.prototype.login = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.username + <span class="string">'要登录Github，密码是'</span> + <span class="keyword">this</span>.password);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CoffeUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">   User.call(<span class="keyword">this</span>, username, password);<span class="comment">//通过call向父类的构造函数传递参数</span></span><br><span class="line">   <span class="keyword">this</span>.articles = <span class="number">3</span>; <span class="comment">// 文章数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user1 = <span class="keyword">new</span> CoffeUser(<span class="string">'coffe1891'</span>, <span class="string">'123456'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(user1 <span class="keyword">instanceof</span> User);<span class="comment">//&gt;&gt; false</span></span><br><span class="line"><span class="built_in">console</span>.log(user1.username, user1.password); <span class="comment">//&gt;&gt; coffe1891 123456</span></span><br><span class="line"><span class="built_in">console</span>.log(user1.login()); <span class="comment">// TypeError: user1.login is not a function</span></span><br></pre></td></tr></table></figure><p>存在明显的缺陷：</p><ul><li>无法通过instanceof的测试；</li><li>并没有继承父类原型上的方法。</li></ul></div><h2 id="03-组合式继承"><a href="#03-组合式继承" class="headerlink" title="03.组合式继承"></a>03.组合式继承</h2><div class="story post-story"><p>既然上述两种方法各有缺点，但是又各有所长，那么我们是否可以将其结合起来使用呢？即原型链继承方法，而在构造函数继承属性，这种继承方式就叫做“组合式继承”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.password = password;</span><br><span class="line">   <span class="keyword">this</span>.username = username;</span><br><span class="line">   User.prototype.login = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.username + <span class="string">'要登录Github，密码是'</span> + <span class="keyword">this</span>.password);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CoffeUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">   User.call(<span class="keyword">this</span>, username, password); <span class="comment">// 第2次执行 User 的构造函数</span></span><br><span class="line">   <span class="keyword">this</span>.articles = <span class="number">3</span>; <span class="comment">// 文章数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CoffeUser.prototype = <span class="keyword">new</span> User(); <span class="comment">// 第1次执行 User 的构造函数</span></span><br><span class="line"><span class="keyword">const</span> user1 = <span class="keyword">new</span> CoffeUser(<span class="string">"coffe1891"</span>, <span class="string">"123456"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(user1 <span class="keyword">instanceof</span> User);<span class="comment">//&gt;&gt; true</span></span><br><span class="line">user1.login();<span class="comment">//&gt;&gt; coffe1891要登录Github，密码是123456</span></span><br></pre></td></tr></table></figure><p>虽然这种方式弥补了上述两种方式的一些缺陷，但有些问题仍然存在：</p><ul><li>父类的构造函数被调用了两次，显得多余；</li><li><strong>污染：</strong>若再添加一个子类型，给其原型单独添加一个方法，那么其他子类型也同时拥有了这个方法。</li></ul><p>综上，组合式继承也不是我们最终想要的。</p></div><h2 id="04-原型继承-prototypal-inheritance"><a href="#04-原型继承-prototypal-inheritance" class="headerlink" title="04.原型继承(prototypal inheritance)"></a>04.原型继承(prototypal inheritance)</h2><div class="story post-story"><p>原型继承实际上是对类式继承的一种封装，只不过其独特之处在于，定义了一个干净的中间类，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObject</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建临时类</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改类的原型为o, 于是f的实例都将继承o上的方法</span></span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这不就是ES5的 <code>Object.create</code> 吗？没错，你可以认为是如此。</p><p>既然只是类式继承的一种封装，其使用方式自然如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CoffeUser.prototype &#x3D; createObject(User)</span><br></pre></td></tr></table></figure><p>也就仍然没有解决类式继承的一些问题。从这个角度而言，原型继承和类式继承应该直接归为一种继承。</p></div><h2 id="05-寄生式继承"><a href="#05-寄生式继承" class="headerlink" title="05.寄生式继承"></a>05.寄生式继承</h2><div class="story post-story"><p>寄生式继承是与原型继承紧密相关的一种思路，它依托于一个内部对象而生成一个新对象，因此称之为寄生。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UserSample = &#123;</span><br><span class="line">   username: <span class="string">"coffe1891"</span>,</span><br><span class="line">   password: <span class="string">"123456"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CoffeUser</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> o = <span class="built_in">Object</span>.create(obj);<span class="comment">//o继承obj的原型</span></span><br><span class="line">   o.__proto__.readArticle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">//扩展方法</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Read article'</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> CoffeUser(UserSample);</span><br><span class="line">user.readArticle();<span class="comment">//&gt;&gt; Read article</span></span><br><span class="line"><span class="built_in">console</span>.log(user.username, user.password);<span class="comment">//&gt;&gt; coffe1891 123456</span></span><br></pre></td></tr></table></figure></div><h2 id="06-寄生组合式继承"><a href="#06-寄生组合式继承" class="headerlink" title="06.寄生组合式继承"></a>06.寄生组合式继承</h2><div class="story post-story"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//寄生组合式继承的核心方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">child, parent</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 继承父类的原型</span></span><br><span class="line">   <span class="keyword">const</span> p = <span class="built_in">Object</span>.create(parent.prototype);</span><br><span class="line">   <span class="comment">// 重写子类的原型</span></span><br><span class="line">   child.prototype = p;</span><br><span class="line">   <span class="comment">// 重写被污染的子类的constructor</span></span><br><span class="line">   p.constructor = child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User, 父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> _password = password</span><br><span class="line">   <span class="keyword">this</span>.username = username</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">User.prototype.login = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.username + <span class="string">'要登录Github，密码是'</span> + _password);</span><br><span class="line">   <span class="comment">//&gt;&gt; ReferenceError: _password is not defined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CoffeUser, 子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CoffeUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">   User.call(<span class="keyword">this</span>, username, password) <span class="comment">// 继承属性</span></span><br><span class="line">   <span class="keyword">this</span>.articles = <span class="number">3</span> <span class="comment">// 文章数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承</span></span><br><span class="line">inherit(CoffeUser, User);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在原型上添加新方法</span></span><br><span class="line">CoffeUser.prototype.readArticle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'Read article'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user1 = <span class="keyword">new</span> CoffeUser(<span class="string">"Coffe1891"</span>, <span class="string">"123456"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(user1);</span><br></pre></td></tr></table></figure><p>观察chrome浏览器的输出结果：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcxvt27izj309k03j3yv.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcxvt27izj309k03j3yv.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><p>简单说明一下：</p><ul><li>子类继承了父类的属性和方法，同时，属性没有被创建在原型链上，因此多个子类不会共享同一个属性；</li><li>子类可以传递动态参数给父类；</li><li>父类的构造函数只执行了一次。</li></ul><p>Nice！这才是我们想要的继承方法。然而，仍然存在一个美中不足的问题：</p><ul><li>子类想要在原型上添加方法，必须在继承之后添加，否则将覆盖掉原有原型上的方法。这样的话若是已经存在的两个类，就不好办了。</li></ul><p>所以，我们可以将其优化一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">child, parent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 继承父类的原型</span></span><br><span class="line">    <span class="keyword">const</span> parentPrototype = <span class="built_in">Object</span>.create(parent.prototype)</span><br><span class="line">    <span class="comment">// 将父类原型和子类原型合并，并赋值给子类的原型</span></span><br><span class="line">    child.prototype = <span class="built_in">Object</span>.assign(parentPrototype, child.prototype)</span><br><span class="line">    <span class="comment">// 重写被污染的子类的constructor</span></span><br><span class="line">    p.constructor = child</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但实际上，使用<code>Object.assign</code> 来进行 copy 仍然不是最好的方法。因为上述的继承方法只适用于 copy 原型链上可枚举的方法，而ES6中，类的方法默认都是不可枚举的。此外，如果子类本身已经继承自某个类，以上的继承将不能满足要求。</p></div><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="story post-story"><p><a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance" target="_blank" rel="noopener">Inheritance in JavaScript</a></p></div>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>敲入URL到看到页面的全过程分析</title>
      <link href="/Chrome%E6%BA%90%E7%A0%81-%E6%95%B2%E5%85%A5URL%E5%88%B0%E7%9C%8B%E5%88%B0%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/"/>
      <url>/Chrome%E6%BA%90%E7%A0%81-%E6%95%B2%E5%85%A5URL%E5%88%B0%E7%9C%8B%E5%88%B0%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>这是一个经典的面试题，相信每个人都会说出一些点来，但是要想全面细致的解答这个问题，就必须对网络通信、webkit内核有一定的了解。本文试图从更细微的层面剖析这个问题。</p><a id="more"></a><h4 id="1-输入地址"><a href="#1-输入地址" class="headerlink" title="1. 输入地址"></a>1. 输入地址</h4><p>浏览器引入了 DNS 预取技术。它是利用现有的 DNS 机制，提前解析网页中可能的网络连接。</p><p>当我们开始在浏览器中输入网址的时候，浏览器其实就已经在智能的匹配可能得 url 了。它会从历史记录，书签等地方，找到已经输入的字符串可能对应的 url ，找到同输入的地址很匹配的项，然后给出智能提示，让你可以补全 url 地址。用户还没有按下 enter 键， 浏览器已经开始使用 DNS 预取技术解析该域名了。</p><p>对于 chrome 的浏览器，如果有该域名相关的缓存，它会直接从缓存中把网页展示出来，就是说，你还没有按下 enter，页面就出来了。如果没有缓存，就还是会重新请求资源。</p><h4 id="2-查询-DNS-查找对应的请求-IP-地址"><a href="#2-查询-DNS-查找对应的请求-IP-地址" class="headerlink" title="2. 查询 DNS 查找对应的请求 IP 地址"></a>2. 查询 DNS 查找对应的请求 IP 地址</h4><p>假设输入 <a href="http://www.baidu.com，大概过程：">www.baidu.com，大概过程：</a></p><p>浏览器搜索自己的 DNS 缓存。</p><p>在浏览器缓存中没找到，就在操作系统缓存中查找，这一步中也会查找本机的 hosts 看看有没有对应的域名映射。</p><p>在系统中也没有的话，就到你的路由器来查找，因为路由器一般也会有自己的 DNS 缓存。</p><p>若没有，则操作系统将域名发送至 本地域名服务器——递归查询方式，本地域名服务器 查询自己的 DNS 缓存，查找成功则返回结果，否则，采用迭代查询方式。本地域名服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。</p><p>本地域名服务器 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来。</p><p>操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</p><p>至此，浏览器已经得到了域名对应的 IP 地址。</p><h4 id="3-建立-TCP-连接"><a href="#3-建立-TCP-连接" class="headerlink" title="3. 建立 TCP 连接"></a>3. 建立 TCP 连接</h4><p>TCP 是一种面向有连接的传输层协议。 它可以保证两端（发送端和接收端）通信主机之间的通信可达。 它能够处理在传输过程中丢包、传输顺序乱掉等异常情况；此外它还能有效利用宽带，缓解网络拥堵。</p><p>三次握手的步骤：（抽象派）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">客户端：hello，你是server么？</span><br><span class="line">服务端：hello，我是server，你是client么</span><br><span class="line">客户端：yes，我是client</span><br></pre></td></tr></table></figure><p>在 TCP 连接建立完成之后就可以发送 HTTP 请求了。</p><p>然后，待到断开连接时，需要进行四次挥手（因为是全双工的，所以需要四次挥手）</p><p>四次挥手的步骤：（抽象派）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主动方：我已经关闭了向你那边的主动通道了，只能被动接收了</span><br><span class="line">被动方：收到通道关闭的信息</span><br><span class="line">被动方：那我也告诉你，我这边向你的主动通道也关闭了</span><br><span class="line">主动方：最后收到数据，之后双方无法通信</span><br></pre></td></tr></table></figure><h4 id="4-服务器收到请求并响应-HTTP-请求"><a href="#4-服务器收到请求并响应-HTTP-请求" class="headerlink" title="4. 服务器收到请求并响应 HTTP 请求"></a>4. 服务器收到请求并响应 HTTP 请求</h4><p>在接收和解释请求消息后，服务器返回一个HTTP响应消息。</p><p>HTTP 响应由三个部分组成，分别是：状态行、消息报头、响应正文。</p><p>状态代码：由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：</p><p>1xx：指示信息–表示请求已接收，继续处理<br>2xx：成功–表示请求已被成功接收、理解、接受<br>3xx：重定向–要完成请求必须进行更进一步的操作<br>4xx：客户端错误–请求有语法错误或请求无法实现<br>5xx：服务器端错误–服务器未能实现合法的请求<br>常见状态代码、状态描述、说明：</p><p>200 OK ：客户端请求成功<br>400 Bad Request ：客户端请求有语法错误，不能被服务器所理解<br>401 Unauthorized ：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用<br>403 Forbidden ：服务器收到请求，但是拒绝提供服务<br>404 Not Found ：请求资源不存在，eg：输入了错误的URL<br>500 Internal Server Error ：服务器发生不可预期的错误<br>503 Server Unavailable ：服务器当前不能处理客户端的请求，一段时间后可能恢复正常<br>HTTP消息报头包括：普通报头、请求报头、响应报头、实体报头。具体不作介绍。</p><p>响应正文：就是服务器返回的资源的内容</p><h4 id="5-浏览器接收服务器响应结果并处理"><a href="#5-浏览器接收服务器响应结果并处理" class="headerlink" title="5.浏览器接收服务器响应结果并处理"></a>5.浏览器接收服务器响应结果并处理</h4><p>在浏览器没有完整接受全部HTML文档时，它就已经开始显示这个页面了，不同浏览器可能解析的过程不太一样，这里我们只介绍 WebKit 的渲染过程。</p><p>渲染步骤大致可以分为以下几步：</p><ol><li><p>解析HTML，构建 DOM 树</p></li><li><p>解析 CSS ，生成 CSS 规则树</p></li><li><p>合并 DOM 树和 CSS 规则，生成 render 树</p></li><li><p>布局 render 树（ Layout / reflow ），负责各元素尺寸、位置的计算</p></li><li><p>绘制 render 树（ paint ），绘制页面像素信息</p></li><li><p>浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（ composite ），显示在屏幕上</p></li></ol><p>其中每个解释的过程中，WebKit 都提供了很多相关的类来一步一步地解释对应的内部模块，这里面不做详细描述。</p><p>下面根据上面的大致过程来一步步细解。</p><h5 id="5-1-构造-DOM-树"><a href="#5-1-构造-DOM-树" class="headerlink" title="5.1 构造 DOM 树"></a>5.1 构造 DOM 树</h5><p>浏览器在解析html文件时, 是WebKit 中的 HTML 解释器的将网络或者本地磁盘获取的 HTML 网页和资源从字节流解释成 DOM 树结构。具体过程如下 ：</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200927153750.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200927153750.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20200927153750"></p><p>在 WebKit 中这一过程如下：首先是字节流，经过解码之后是字符流，然后通过词法分析器会被解释成词语（Tokens），之后经过语法分析器构建成节点，最后这些节点被组建成一棵 DOM 树。</p><p>浏览器在解析html文件过程中，会 ”自上而下“ 加载，并在加载过程中进行解析渲染。在解析过程中，如果遇到请求外部资源时，如图片、外链的CSS、iconfont等，请求过程是异步的，并不会影响html文档进行加载，且统一交由 Browser 进程来处理，这使得资源在不同网页间的共享变得很容易。</p><p>HTML 的解释、布局和渲染等工作基本上就是工作在渲染线程完成的（这不是绝对的）。因为 DOM 树只能在渲染线程上创建和访问，这也就是说构建 DOM 树的过程只能在渲染线程中进行，但是，从字符到词语这个阶段可以交给另外的单独的线程来做。</p><p>而且因为有 DNS 预取技术，当用户正在浏览当前网页的时候，Chromium 提取网页中的超链接，将域名抽取出来，利用比较少的 CPU 和网络带宽来解析这些域名或者 IP 地址，这样一来，用户根本感觉不到这一过程。当用户单击这些链接的时候，可以节省不少时间，特别在域名解析比较慢的时候，效果特别明显。</p><p>解析过程中，浏览器首先会解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建 Render树，等到 Render 树构建完成后，浏览器开始布局 Render 树并将其绘制到屏幕上。</p><h5 id="5-2-解释-CSS"><a href="#5-2-解释-CSS" class="headerlink" title="5.2 解释 CSS"></a>5.2 解释 CSS</h5><p>CSS 解释过程是指从 CSS 字符串 经过 CSS 解释器 处理后变成渲染引擎内部规则的表示过程。</p><p>生成样式规则之后，会进行样式规则匹配，WebKit 会为其中的一些节点（只限于可视节点）选择合适的样式信息，规则的匹配则是由 ElementRuleCollector 类来计算并获得，它根据元素的属性等，并从 DocumentRuleSets 类中获取规则集合，依次按照 ID、类别、标签等选择器信息逐次匹配获得元素的样式。</p><p>最后，WebKit 对这些规则进行排序。对于该元素需要的样式属性，WebKit 选择从高优先级规则中选取，并将样式属性值返回。</p><p>从整个网页的加载和渲染过程来看，CSS 解释和规则匹配处于 DOM 树建立之后，RenderObject 树建立之前，CSS 解释器解释后的结果会保存起来，然后 RenderObject 树基于该结果来进行规范匹配和布局计算。当网页有用户交互或者动画等动作的时候，通过 CSSDOM 等技术，JavaScript 代码同样可以非常方便地修改 CSS 代码，WebKit 此时需要重新解释样式并重复以上这一过程。</p><h5 id="5-3-渲染过程遇到-JavaScript"><a href="#5-3-渲染过程遇到-JavaScript" class="headerlink" title="5.3  渲染过程遇到 JavaScript"></a>5.3  渲染过程遇到 JavaScript</h5><p>当文档加载过程中遇到 js 文件，html 文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中 js 文件加载完毕，还要等待解析执行完毕，才可以恢复 html 文档的渲染线程。因为 JS 有可能会修改 DOM，最为经典的 document.write，这意味着，在 JS 执行完成前，后续所有资源的下载可能是没有必要的，这是 js 阻塞后续资源下载的根本原因。所以我们平时的代码中，js 是放在 html 文档末尾的。</p><p>而且当遇到执行 JavaScript 代码的时候，WebKit 先暂停当前 JavaScript 代码的执行，使用预先扫描器 HTMLPreloadScanner 类来扫描后面的词语。如果 WebKit 发现它们需要使用其他资源，那么使用预资源加载器 HTMLPreloadScanner 类来发送请求，在这之后，才执行 JavaScript 代码。预先扫描器本身并不创建节点对象，也不会构建 DOM 树，所以速度比较快。</p><p>当 DOM 树构建完之后，WebKit 触发 “DOMContentLoaded” 事件，注册在该事件上的 JavaScript 函数会被调用。当所在资源都被加载完之后，WebKit 触发 “onload” 事件。</p><p>WebKit 将 DOM 树创建过程中需要执行的 JavaScript 代码交由 HTMLScriptRunner 类来负责。工作方式很简单，就是利用 JavaScript 引擎来执行 Node 节点中包含的代码。</p><p>JS 的解析是由浏览器中的 JavaScript 引擎完成的。JS是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如 IO 读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。</p><p>JS 的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈; 异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。</p><h5 id="5-4-渲染合成-Render-树"><a href="#5-4-渲染合成-Render-树" class="headerlink" title="5.4 渲染合成 Render 树"></a>5.4 渲染合成 Render 树</h5><p>HTML 经过 WebKit 解释之后，生成 DOM 树。在 DOM 树构建完成之后，WebKit 会为 DOM 树节点构建 RenderObject 树，再通过 RenderObject 树构建出 RenderLayer 树。</p><p>RenderObject 树是基于 DOM 树建立起来的一棵新树，是为了布局计算和渲染等机制而构建的一种新的内部表示。RenderObject 树节点和 DOM 节点不是一一对应关系，因为有可视节点（常用的 div img 标签等）与不可视节点（如 head、meta 标签），不可视节点是不会构成 RenderObject 树的。</p><p>网页是有层次结构的，可以分层的，一是为了方便设置网页的层次，二是为了 WebKit 处理上的便利，为了简化渲染的逻辑。</p><p>而且 RenderLayer 节点和 RenderObject 节点不是一一对应关系，而是一对多的关系。</p><h5 id="5-5-布局"><a href="#5-5-布局" class="headerlink" title="5.5 布局"></a>5.5 布局</h5><p>当 WebKit 创建 RenderObject 对象之后，每个对象是不知道自己的位置、大小等信息的，WebKit 根据框模型来计算它们的位置，大小等信息的过程称为布局计算。</p><p>布局计算是一个递归的过程，因为一个节点的大小通常需要先计算它的子女节点的位置，大小等信息。</p><p>当用户 网页的动画、翻滚网页、JavaScript 代码通过 CSSDOM 等操作时还会有重新布局。</p><h5 id="5-6-绘制"><a href="#5-6-绘制" class="headerlink" title="5.6 绘制"></a>5.6 绘制</h5><p>在 WebKit 中，绘图操作就是绘图上下文，所有绘图的操作都是在该上下文中来进行的。</p><p>绘图上下文可以分成两种类型：</p><p>一是 2D 图形上下文（GraphicsContext），用来绘制 2D 图形的的上下文；</p><p>二是 3D 绘图上下文，是用来绘制 3D 图形的上下文。</p><p>2D 绘图上下文具体的作用：提供基本绘图单元的绘制接口以及设置绘图的样式。绘图接口包括画点，画线、画图片、画多边形、画文字等，绘图样式包括颜色、线宽、字号大小、渐变等。</p><p>关于 3D 绘图上下文，它的主要用处是支持 CSS3D、WebGL 等。</p><p>网页的渲染方式，有三种方式，一是软件渲染，二是硬件加速渲染，三可以说是混合模式。</p><p>如果绘图操作使用 CPU 来完成，称之为软件绘图。</p><p>如果绘图操作由 GPU 来完成，称之为 GPU 硬件加速绘图。</p><p>理想情况下，每个层都有个绘制的存储区域，这个存储区域用来保存绘图的结果。最后，需要将这些层的内容合并到同一个图像之中，可以称之为合成（Compositing），使用了合成技术的渲染称之为合成化渲染。</p><p>所以，在完成构建 DOM 树之后，WebKit 会调用绘图操作、软件渲染或者硬件加速渲染或者两者都有，将模型绘制出来，呈现在屏幕上。 至此，浏览器渲染完成。</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型与原型链</title>
      <link href="/javascript-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/javascript-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<p>在ES6之前，JavaScript 中除了基础类型外的数据类型都是对象（引用类型），没有类（class），为了实现类似继承以便复用代码的能力，JavaScript选择了原型和原型链。甚至在ES6之后，JavaScript也没有真正的类（class）。ES6虽然提供了class关键字让我么可以伪造一个“类”，但其实只是语法糖而已，本质上仍然是一个对象。ES6实现的继承，本质仍是基于原型和原型链。</p><a id="more"></a><h2 id="原型、prototype、-proto"><a href="#原型、prototype、-proto" class="headerlink" title="原型、prototype、__proto__"></a>原型、prototype、__<strong>proto__</strong></h2><div class="story post-story"><ol><li><p><strong>原型</strong>是一个对象。</p></li><li><p><strong><code>prototype</code>是函数的一个属性而已，也是一个对象，它和原型没有绝对的关系</strong>（很多书、很多网络文章都模糊地将prototype表述为原型，这是严重不对的）。JavaScript里函数也是一种对象，每个对象都有一个原型，但不是所有对象都有<code>prototype</code>属性，实际上只有函数才有这个属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> b=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数才有prototype属性</span></span><br><span class="line"><span class="built_in">console</span>.log(a.prototype);<span class="comment">//&gt;&gt; function()&#123;&#125;</span></span><br><span class="line"><span class="comment">//非函数，没有prototype属性</span></span><br><span class="line"><span class="built_in">console</span>.log(b.prototype);<span class="comment">//&gt;&gt; undefined</span></span><br></pre></td></tr></table></figure></li><li><p>每个对象(实例)都有一个属性<code>__proto__</code>，指向他的构造函数（constructor）的<code>prototype</code>属性。</p></li><li><p><strong>一个对象的原型就是它的构造函数的<code>prototype</code>属性的值</strong>，因此<strong><code>__proto__</code>也即原型的代名词</strong>。</p></li><li><p>对象的<code>__proto__</code>也有自己的<code>__proto__</code>，层层向上，直到<code>__proto__</code>为null。换句话说，原型本身也有自己的原型。这种由原型层层链接起来的数据结构成为 <strong>原型链</strong>。因为null不再有原型，所以原型链的末端是null。</p></li></ol><p>让我们用更多代码来验证一下以上结论：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> b=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//a的构造函数是「Function函数」</span></span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__ == <span class="built_in">Function</span>.prototype);<span class="comment">//&gt;&gt; true</span></span><br><span class="line"><span class="comment">//b的构造函数是「Array函数」</span></span><br><span class="line"><span class="built_in">console</span>.log(b.__proto__ == <span class="built_in">Array</span>.prototype);<span class="comment">//&gt;&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//因为「Function函数」和「Array函数」又都是对象，其构造函数</span></span><br><span class="line"><span class="comment">//是「Object函数」，所以，a和b的原型的原型都是Object.prototype</span></span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__.__proto__ === <span class="built_in">Object</span>.prototype);<span class="comment">//&gt;&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(b.__proto__.__proto__ === <span class="built_in">Object</span>.prototype);<span class="comment">//&gt;&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Object作为顶级对象的构造函数，它实例的原型本身就不再有原型了，因此它原型</span></span><br><span class="line"><span class="comment">//的__proto__属性为null</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Object</span>().__proto__.__proto__);<span class="comment">//&gt;&gt; null</span></span><br><span class="line"><span class="comment">//也即Object类型对象，其原型（Object.prototype）的__proto__为null</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__);<span class="comment">//&gt;&gt; null</span></span><br></pre></td></tr></table></figure><p>三者关系图如下：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcvmzv17tj30go0aymxi.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcvmzv17tj30go0aymxi.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><blockquote><p>使用<code>__proto__</code>是有争议的，也不鼓励使用它。因为它从来没有被包括在EcmaScript语言规范中，但是现代浏览器都实现了它。<code>__proto__</code>属性已在ECMAScript 6语言规范中标准化，用于确保Web浏览器的兼容性，因此它未来将被支持。但是，它已被<strong>不推荐使用</strong>，现在更推荐使用<code>Object.getPrototypeOf</code>/<code>Reflect.getPrototypeOf</code> 和<code>Object.setPrototypeOf</code>/<code>Reflect.setPrototypeOf</code>（尽管如此，设置对象的原型是一个缓慢的操作，如果性能要求很高，应该避免设置对象的原型）。</p></blockquote></div><h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><div class="story post-story"><p>使用最新的方法<code>Object.setPrototypeOf</code>（类似<code>Reflect.setPrototypeOf</code>）可以很方便地给对象设置原型，这个对象会继承该原型所有属性和方法。</p><p>但是，<code>setPrototypeOf</code>的性能很差，我们应该尽量使用 <code>Object.create()</code>来为某个对象设置原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//obj的原型是Object.prototype</span></span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    methodA()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"coffe"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newObj = <span class="built_in">Object</span>.create(obj);<span class="comment">//以obj为原型创建一个新的对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//methodA实际上是newObj原型对象obj上的方法。也即newObj继承了它的原型对象obj的属性和方法。</span></span><br><span class="line">newObj.methodA();<span class="comment">//&gt;&gt; coffe</span></span><br></pre></td></tr></table></figure></div><h2 id="类-class）的prototype和proto"><a href="#类-class）的prototype和proto" class="headerlink" title="类(class）的prototype和proto"></a>类(class）的prototype和<strong>proto</strong></h2><div class="story post-story"><p>ES6之后，类(class)也有了prototype属性，为什么呢，因为class本质上是构造函数的语法糖.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> A;<span class="comment">//&gt;&gt; "function"</span></span><br></pre></td></tr></table></figure><p>说明class本质上也是函数，所以它带有prototype属性是十分正常的事。<br>然后，在Chrome浏览器里调试如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.prototype;</span><br></pre></td></tr></table></figure><p>得到的结果如下图:<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcw0uwfizj308003xaa0.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcw0uwfizj308003xaa0.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><p>上面代码说明类的prototype是一个对象，它包含有constructor属性。这和函数的prototype属性表现具有一致性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A===A.prototype.constructor;<span class="comment">//&gt;&gt; true</span></span><br></pre></td></tr></table></figure><p>上面代码说明一个重要结论：类指向自身构造函数。<br>而且，事实上，类的所有方法都定义在类的prototype属性上面。同样可以通过Chrome调试验证。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toValue() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">A.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;,</span><br><span class="line">  toString() &#123;&#125;,</span><br><span class="line">  toValue() &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果如下：<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcw622mnij308b09nmxg.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcw622mnij308b09nmxg.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt=""></p><h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><p>class 作为构造函数的语法糖，同时有<code>prototype</code>属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p><p>（1）子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类。</p><p>（2）子类<code>prototype</code>属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的<code>prototype</code>属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.__proto__ === A <span class="comment">//&gt;&gt; true</span></span><br><span class="line">B.prototype.__proto__ === A.prototype <span class="comment">//&gt;&gt; true</span></span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包</title>
      <link href="/javascript-%E9%97%AD%E5%8C%85/"/>
      <url>/javascript-%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>闭包是JavaScript的强大的特性，很多强大JavaScript库比如jQuery、Vue.js都使用了闭包的特性来实现的，同时，闭包也是js里的理解难点之一。</p><a id="more"></a><h2 id="热身：循环中的闭包"><a href="#热身：循环中的闭包" class="headerlink" title="热身：循环中的闭包"></a>热身：循环中的闭包</h2><div class="story post-story"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">   setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i) <span class="comment">//&gt;&gt; 6 6 6 6 6</span></span><br><span class="line">    &#125;, i * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本意是想每隔一秒依次输出“1 2 3 4 5”，结果变成输出“6 6 6 6 6 ”。为什么会这样呢，根据作用域链上变量查找机制，<code>setTimeout</code>第一个参数的函数体内的<code>i</code>引用了去全局作用域里面的<code>i</code>，当for循环完毕后，<code>i</code>的值为6，所以输出了“6 6 6 6 6 ”。</p><p>如何实现正确的输出呢？</p><p>其实用闭包就能轻松解决这个问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;<span class="comment">//包了一层IIFE形式的函数，这个函数是闭包</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;<span class="comment">//函数体内的j引用了外层匿名函数的参数j</span></span><br><span class="line">      <span class="built_in">console</span>.log(j); <span class="comment">//&gt;&gt; 1 2 3 4 5</span></span><br><span class="line">    &#125;, j * <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><div class="story post-story"><h3 id="1-闭包的定义"><a href="#1-闭包的定义" class="headerlink" title="1. 闭包的定义"></a>1. 闭包的定义</h3><p>关于JavaScript闭包的定义有很多种，每本书、每个作者都有不完全相同的描述，虽然笔者认为<strong>函数就是闭包</strong>这个定义才是最简单最直白的，但其实笔者看到过不下十种定义，到现在一种都记不住。鉴于此，我们干脆不要记住这些五花八门的定义了，只要记住了产生闭包的时机会更实际一些，面试时，把闭包产生的时机告诉面试官就可以了：</p><h4 id="内层的作用域访问它外层函数作用域里的参数-变量-函数时，闭包就产生了。"><a href="#内层的作用域访问它外层函数作用域里的参数-变量-函数时，闭包就产生了。" class="headerlink" title="内层的作用域访问它外层函数作用域里的参数/变量/函数时，闭包就产生了。"></a>内层的作用域访问它外层函数作用域里的参数/变量/函数时，闭包就产生了。</h4><p>让我们用代码来说事儿吧：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;<span class="comment">//func1引用了它外层的变量a，因此func成为了闭包</span></span><br><span class="line">    <span class="keyword">let</span> a=<span class="string">"coffe"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a);<span class="comment">//访问了外层函数func体内的变量a</span></span><br><span class="line">        <span class="keyword">debugger</span>;<span class="comment">//断点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func();</span><br></pre></td></tr></table></figure><p>我们在chrome浏览器的“开发者工具”里面的控制台，运行上面的代码，可以很方便看到闭包。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfctlwy6ipj30lq0bqdhc.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfctlwy6ipj30lq0bqdhc.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image1"></p><p>看上面这个图，Closure出现在Scope一栏里面，所以可以认为闭包也是一种作用域。既然闭包也是一种作用域，闭包能够解决经典的“循环中的闭包”的问题，那是不是利用作用域就能解决问题？这让人想到了关键字let，试试看吧，把本文开头的代码改造一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">let</span> j = i;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(j) <span class="comment">//&gt;&gt; 1 2 3 4 5</span></span><br><span class="line">       &#125;, j * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>果然，用<code>let</code>关键字包上一个作用域，也能和闭包一样解决问题达成目的。因此可以说，<strong>闭包是一种作用域，它拷贝了一套外层函数作用域中被访问的参数、变量/函数</strong>，这个拷贝都是浅拷贝</p><h3 id="2-写成闭包形式有什么好处呢？"><a href="#2-写成闭包形式有什么好处呢？" class="headerlink" title="2. 写成闭包形式有什么好处呢？"></a>2. 写成闭包形式有什么好处呢？</h3><p>当然有好处！还是以之前的代码为例，变量<code>a</code>类似于高级语言的私有属性，无法被<code>func</code>外部作用域访问和修改，只有<code>func</code>内部的作用域（含嵌套作用域）可以访问。这样可以实现软件设计上的<strong>封装</strong>，设计出很强大的类库、框架，比如我们常用的jQuery、AngularJS、Vue.js。</p><p>看一个ES6出现之前最常见的模块化封装的例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个模块</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">module</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//私有属性</span></span><br><span class="line">  <span class="keyword">let</span> name = n;</span><br><span class="line">  <span class="comment">//私有方法</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getModuleName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//私有方法</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">someMethod</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"coffe1891"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//以一个对象的形式返回</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getModuleName: getModuleName,</span><br><span class="line">    getXXX: someMethod</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myapp = <span class="built_in">module</span>(<span class="string">"myModule"</span>);<span class="comment">//定义一个模块</span></span><br><span class="line"><span class="built_in">console</span>.log(myapp.getModuleName()); <span class="comment">//&gt;&gt; myModule</span></span><br><span class="line"><span class="built_in">console</span>.log(myapp.getXXX()); <span class="comment">//&gt;&gt; coffe1891</span></span><br></pre></td></tr></table></figure><h3 id="3-闭包有什么缺点吗？"><a href="#3-闭包有什么缺点吗？" class="headerlink" title="3. 闭包有什么缺点吗？"></a>3. 闭包有什么缺点吗？</h3><p>javascript中的垃圾回收（GC）规则是这样的：如果对象不再被引用，或者对象互相引用形成数据孤岛后且没有被孤岛之外的其他对象引用，那么这些对象将会被JS引擎的垃圾回收器回收；反之，这些对象一直会保存在内存中。</p><p>由于闭包会引用包含它的外层函数作用域里的变量/函数，因此会比其他非闭包形式的函数占用更多内存。当外层函数执行完毕退出函数调用栈（call stack）的时候，外层函数作用域里变量因为被引用着，可能并不会被JS引擎的垃圾回收器回收，因而会引起内存泄漏。过度使用闭包，会导致内存占用过多，甚至内存泄漏。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       count ++;</span><br><span class="line">       <span class="built_in">console</span>.log(count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> B;<span class="comment">//函数B保持了对count的引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = A();</span><br><span class="line">b();<span class="comment">//&gt;&gt; 1</span></span><br><span class="line">b();<span class="comment">//&gt;&gt; 2</span></span><br><span class="line">b();<span class="comment">//&gt;&gt; 3</span></span><br></pre></td></tr></table></figure><p><code>count</code>是函数A中的一个变量，它的值在函数B中被改变，B每执行一次，<code>count</code>的值就在原来的基础上累加1。因此，函数A中的<code>count</code>一直保存在内存中，并没有因为函数A执行完毕退出函数调用栈后被JS引擎的垃圾回收器回收掉。</p><p>避免闭包导致内存泄漏的解决方法是，在函数A执行完毕退出函数调用栈之前，将不再使用的局部变量全部删除或者赋值为null。</p></div><h2 id="其他使用场景介绍"><a href="#其他使用场景介绍" class="headerlink" title="其他使用场景介绍"></a>其他使用场景介绍</h2><div class="story post-story"><p>除了上面介绍过的循环中的闭包、模块化封装之外，闭包还有一些其他写法。</p><h3 id="1-返回一个新函数"><a href="#1-返回一个新函数" class="headerlink" title="1. 返回一个新函数"></a>1. 返回一个新函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello2</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> text = <span class="string">"Hello "</span> + name; <span class="comment">// 局部变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> sayAlert = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(text);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sayAlert;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> say2 = sayHello2(<span class="string">"coffe1891"</span>);</span><br><span class="line">say2(); <span class="comment">//&gt;&gt; Hello coffe1891</span></span><br></pre></td></tr></table></figure><p>调用<code>sayHello2()</code>函数返回了<code>sayAlert</code>，赋值给<code>say2</code>。注意<code>say2</code>是一个引用变量，指向一个函数本身，而不是指向一个变量。</p><h3 id="2-扩展全局对象的方法"><a href="#2-扩展全局对象的方法" class="headerlink" title="2. 扩展全局对象的方法"></a>2. 扩展全局对象的方法</h3><p>下面这种利用闭包扩展全局对象，可以有效地保护私有变量，形成一定的封装、持久性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupSomeGlobals</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//私有变量</span></span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">666</span>;</span><br><span class="line"></span><br><span class="line">    gAlertNumber = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="comment">//没有用var和let关键字声明，会成为全局对象的方法</span></span><br><span class="line">        <span class="built_in">console</span>.log(num);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    gIncreaseNumber = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    gSetNumber = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        num = x;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupSomeGlobals();</span><br><span class="line">gAlertNumber(); <span class="comment">//&gt;&gt; 666</span></span><br><span class="line"></span><br><span class="line">gIncreaseNumber();</span><br><span class="line">gAlertNumber(); <span class="comment">//&gt;&gt; 667</span></span><br><span class="line"></span><br><span class="line">gSetNumber(<span class="number">1891</span>);</span><br><span class="line">gAlertNumber(); <span class="comment">//&gt;&gt; 1891</span></span><br></pre></td></tr></table></figure><p>三个全局函数<code>gAlertNumber</code>，<code>gIncreaseNumber</code>，<code>gSetNumber</code>指向了同一个闭包，因为它们是在同一次<code>setupSomeGlobals()</code>调用中声明的。它们所指向的闭包是与<code>setupSomeGlobals()</code>函数关联一个作用域，该作用域包括了<code>num</code>变量的拷贝。也就是说，这三个函数操作的是同一个<code>num</code>变量。</p><h3 id="3-延长局部变量的生命"><a href="#3-延长局部变量的生命" class="headerlink" title="3. 延长局部变量的生命"></a>3. 延长局部变量的生命</h3><p>日常开发时，Image对象经常被用于数据统计的上报，示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> report = <span class="function"><span class="keyword">function</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">    img.src = src;</span><br><span class="line">&#125;</span><br><span class="line">report(<span class="string">'http://www.xxx.com/getClientInfo'</span>);<span class="comment">//把客户端信息上报数据</span></span><br></pre></td></tr></table></figure><p>这段代码在运行时，发现在一些低版本浏览器上存在bug，会丢失部分数据上报。原因是Image对象是<code>report</code>函数中的局部变量，当<code>report</code>函数调用结束后，Image对象随即被JS引擎垃圾回收器回收，而此时可能还没来得及发出http请求，所以可能导致此次上报数据的请求失败。</p><p>怎么办呢？我们可以使用闭包把Image对象封闭起来，就可以解决数据丢失的问题，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> report = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> imgs = [];<span class="comment">//在内存里持久化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">        imgs.push(img);<span class="comment">//引用局部变量imgs</span></span><br><span class="line">        img.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br><span class="line">report(<span class="string">'http://www.xxx.com/getClientInfo'</span>);<span class="comment">//把客户端信息上报数据</span></span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>完全理解javascript里的this</title>
      <link href="/javascript-javascript%E9%87%8C%E7%9A%84this/"/>
      <url>/javascript-javascript%E9%87%8C%E7%9A%84this/</url>
      
        <content type="html"><![CDATA[<p><code>this</code>是JavaScript世界最让人迷惑的关键字之一，很多人对它一知半解，本文希望详细的把<code>this</code>说明白。</p><h2 id="为什么要有this？"><a href="#为什么要有this？" class="headerlink" title="为什么要有this？"></a>为什么要有this？</h2><div class="story post-story"><p>JavaScript 允许在函数体内部，引用当前执行上下文的其他变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码，函数<code>func</code>引用了当前执行上下文的变量<code>a</code>，问题是这个函数<code>func</code>可以在任意其他执行上下文中被调用，因此这个<code>a</code>可能就指向不同了。正因为如此，JS引擎需要有一个机制，可以依靠其</p><blockquote><p><strong>优雅地、准确地指向当前代码运行时所处的上下文环境</strong>（context）。</p></blockquote><p>因此便催生了“this”。</p><h3 id="何谓”优雅地“？"><a href="#何谓”优雅地“？" class="headerlink" title="何谓”优雅地“？"></a>何谓”优雅地“？</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设有个对象名字很长，而且有可能会改名</span></span><br><span class="line"><span class="keyword">var</span> iAmALongLongLongNameObject=&#123;</span><br><span class="line">    name:<span class="string">"coffe"</span>,</span><br><span class="line">    func1()&#123;</span><br><span class="line">        <span class="keyword">return</span> iAmALongLongLongNameObject.name;</span><br><span class="line">    &#125;,</span><br><span class="line">    func2()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>iAmALongLongLongNameObject</code>的方法<code>func2</code>使用了<code>this</code>关键字，是不是优雅多了？然后即使以后对象名字变化，<code>func2</code>内部的代码也不用改变。<code>func1</code>这种确实也可以实现与<code>func2</code>同样的功能，但是就显得丑陋、不灵活了。</p><h3 id="何谓“准确地”？"><a href="#何谓“准确地”？" class="headerlink" title="何谓“准确地”？"></a>何谓“准确地”？</h3><p><code>this</code>可以准确地指向（某个对象）而不会产生歧义。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">var</span> iAmALongLongLongNameObject = &#123;</span><br><span class="line">  name: <span class="string">"1891"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//局部变量</span></span><br><span class="line">  <span class="keyword">var</span> iAmALongLongLongNameObject = &#123;</span><br><span class="line">    name: <span class="string">"coffe"</span>,</span><br><span class="line">    func1() &#123;</span><br><span class="line">      <span class="comment">//如果光看代码，是不是容易看成调用了全局变量的name？</span></span><br><span class="line">      <span class="keyword">return</span> iAmALongLongLongNameObject.name;</span><br><span class="line">    &#125;,</span><br><span class="line">    func2() &#123;</span><br><span class="line">      <span class="comment">//这里光看代码就很准确地知道是调用了局部变量的name！</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(iAmALongLongLongNameObject.func1());<span class="comment">//&gt;&gt; coffe</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>与“Java等高级语言的<code>this</code>会指向对象的实例本身”不同，JavaScript的<code>this</code>指向函数的<strong>调用位置</strong>的对象<strong>，也即调用该函数的对象</strong>。你需要知道，JavaScript中所有的函数都有属性，就如对象有属性一样。函数执行阶段（也即执行上下文的执行阶段）会获取<code>this</code>属性的值，此时<code>this</code>就是一个变量，<strong>储存着调用该函数的对象的值</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"coffe"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line">func();<span class="comment">//&gt;&gt; coffe</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>func</code>的调用者未通过点操作符<code>.</code>指明，那它的调用者就是默认的全局对象<code>window</code>，<code>func</code>函数作为<code>window</code>的一个方法，其体内的<code>this.a</code>就是明确指代<code>window</code>中属性<code>a</code>，这种指向是准确而清晰的，不会有歧义。<code>this</code>的这种灵活性在设计API的时候，会变得很方便和容易被复用。</p></div><h2 id="调用位置"><a href="#调用位置" class="headerlink" title="调用位置"></a>调用位置</h2><div class="story post-story"><p>调用位置就是函数在代码中被调用的位置，而不是声明的位置。研究调用位置，也即搞清“由谁在哪调用了这个函数”的问题。搞清楚了调用位置，才能准确地找到<code>this</code>的指向。</p><p>要找到调用位置，最重要的是要分析是<strong>被谁、在哪</strong>调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">  x: <span class="string">"1891"</span>,</span><br><span class="line">  getX: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.getX());<span class="comment">//&gt;&gt; 1891</span></span><br><span class="line"><span class="keyword">var</span> getX = <span class="built_in">module</span>.getX;<span class="comment">//注意：getX和module.getX都是指向内存中函数的地址而已，它们并没有被“()”以便执行</span></span><br><span class="line">                       <span class="comment">//这里实际上是【间接引用】的模式，见文尾【壹.2.3.6】解释</span></span><br><span class="line"><span class="built_in">console</span>.log(getX()); <span class="comment">//&gt;&gt; undefined</span></span><br></pre></td></tr></table></figure><p>如上代码，要找到函数<code>getX</code>的调用位置，需要先看哪儿调用了它，很明显，有函数有两处位置调用了函数<code>getX()</code>，接下来分析是谁调用了它。</p><ul><li>作为<code>module</code>对象的<code>getX</code>方法被调用。 这种情况被谁调用？很明显是被对象<code>module</code>调用，this是指向<code>module</code>。<code>module</code>对象里面有一个属性<code>x</code>，它的值是<code>1891</code>，因此<code>console.log(module.getX())</code>输出<code>1891</code>。</li><li>作为全局函数<code>getX</code>被调用。 这种情况是被谁调用？我们都知道全局函数可以看作为<code>window</code>对象的方法，那么，很明显现在<code>getX</code>是被当做全局对象<code>window</code>的一个方法被调用。</li></ul><p>我们搞清楚了调用位置之后，接下来就会着手判断this的指向。</p></div><h2 id="先看看很多人对this指向的一些误解"><a href="#先看看很多人对this指向的一些误解" class="headerlink" title="先看看很多人对this指向的一些误解"></a>先看看很多人对this指向的一些误解</h2><div class="story post-story"><p><code>this</code> 既不指向函数自身也不指向函数的作用域，这之前是很多前端工程师容易误解的地方，现在澄清一下。</p><ol><li><code>this</code>的指向，<strong>是在函数被调用的时候确定的</strong>，也就是执行上下文被创建时确定的；</li><li><code>this</code> 的指向和函数声明的位置没有任何关系，只取决于函数的调用位置（也即由谁、在什么地方调用这个函数）；</li><li>正因为在执行上下文的创建阶段<code>this</code>的指向就已经被确定了，在执行阶段<code>this</code>指向不可再被更改。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="string">"1891"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span> = obj; <span class="comment">//报错，因为在执行阶段试图修改this的指向</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func();</span><br></pre></td></tr></table></figure></div><h2 id="this的指向规则"><a href="#this的指向规则" class="headerlink" title="this的指向规则"></a>this的指向规则</h2><div class="story post-story"><h3 id="1-默认指向"><a href="#1-默认指向" class="headerlink" title="1. 默认指向"></a><strong>1. 默认指向</strong></h3><p>独立函数调用（无法应用后面其他指向规则时），<code>this</code>指向全局对象<code>window</code><strong>。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a ); <span class="comment">// this指向全局对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">func(); <span class="comment">//&gt;&gt; 2</span></span><br></pre></td></tr></table></figure><p>对于<strong>默认指向</strong>来说，决定<code>this</code>指向对象的并不是<strong>调用位置</strong>是否处于严格模式，而是函数体是否处于严格模式。如果函数体处于严格模式，<code>this</code>会指向<code>undefined</code>，否则<code>this</code>会指向全局对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span>;<span class="comment">//函数体处于严格模式下，this指向undefined</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"1891"</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  func(); <span class="comment">//&gt;&gt; 报错</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"1891"</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line">  func(); <span class="comment">//&gt;&gt; 1891</span></span><br><span class="line">  <span class="comment">//这里输出 1891 而不是报错，是因为严格模式下，this的指向与func的调用位置无关</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>还有一种默认指向，就是在SetTimeout或SetInterval结合使用时。代码示例如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(num)&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">    func()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.num);</span><br><span class="line">    &#125;</span><br><span class="line">    func1()&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"setTimeout:"</span>+<span class="keyword">this</span>.num);</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    func2()&#123;</span><br><span class="line">        setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.num);</span><br><span class="line">        &#125;, <span class="number">2000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Obj(<span class="number">1</span>);</span><br><span class="line">obj.func();<span class="comment">//&gt;&gt; 1　             输出的是obj.num</span></span><br><span class="line">obj.func1()<span class="comment">//&gt;&gt; setTimeout:0　  输出的是window.num</span></span><br><span class="line">obj.func2()<span class="comment">//&gt;&gt; 0 0 0 0 ……　    输出的是window.num</span></span><br></pre></td></tr></table></figure><p>可以发现在setInterval和setTimeout中传入函数时，函数中的this会指向window对象。</p><h3 id="2-隐式指向"><a href="#2-隐式指向" class="headerlink" title="2. 隐式指向"></a><strong>2. 隐式指向</strong></h3><p>隐式指向是日常开发中最常见的指向。</p><p>函数体内<code>this</code>的指向由调用位置的调用者决定。<strong>如果调用者调用的函数，为某以个对象的方法，那么该函数在被调用时，其内部的<code>this</code>指向该对象</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  func: func</span><br><span class="line">&#125;;</span><br><span class="line">obj.func(); <span class="comment">//&gt;&gt; 2</span></span><br><span class="line"><span class="comment">// 找到调用位置，由 obj 对象来调用函数func，</span></span><br><span class="line"><span class="comment">// 此时可以说函数func被调用时，obj 对象“拥有”或者“包含”func函数，</span></span><br><span class="line"><span class="comment">// 所以此时的 this 指向调用 func 函数的 obj 对象。</span></span><br></pre></td></tr></table></figure><p><strong>对象属性引用链中只有最顶层或者说最后一层会影响调用位置</strong>，也就是说<code>this</code>指向最终调用函数的对象。这句话可能说得比较拗口，其实简单通俗地说，<code>this</code>指向最靠近被调用函数的对象，离得远的不是。举例来说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  a: <span class="string">"1891"</span>,</span><br><span class="line">  func: func</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  a: <span class="string">"coffe"</span>,</span><br><span class="line">  obj2: obj2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时的 this 指向 obj2 对象，因为obj2离得近！</span></span><br><span class="line">obj1.obj2.func(); <span class="comment">//&gt;&gt; 1891</span></span><br></pre></td></tr></table></figure><p>再来看看<strong>隐式丢失：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="string">"coffe1891"</span>,</span><br><span class="line">    func: func</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.func; <span class="comment">// 间接引用,见本文【壹.2.3.6】。此时bar和obj.func其实</span></span><br><span class="line">                    <span class="comment">// 都指向内存中的函数func本身。</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"oops, global"</span>; <span class="comment">// a 是全局对象window的属性，也是全局变量</span></span><br><span class="line">bar(); <span class="comment">//&gt;&gt; oops, global</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 虽然 bar 是 obj.func 的一个引用，但是实际上，它引用的是func函数本身，</span></span><br><span class="line"><span class="comment">// 因此此时的 bar() 其实是一个不带任何定语的独立函数调用，应用【默认指向】规则,</span></span><br><span class="line"><span class="comment">// 因此函数体内的this指向window，this.a指向window的属性a（全局变量a）</span></span><br></pre></td></tr></table></figure><h3 id="3-显式指向"><a href="#3-显式指向" class="headerlink" title="3. 显式指向"></a>3. 显式指向</h3><p>JavaScript内置对象<code>Function</code>的三个原型方法<code>call()</code>、<code>apply()</code>和<code>bind()</code>，它们的第一个参数是一个对象，它们会把这个对象绑定到<code>this</code>，接着在调用函数时让<code>this</code>指向这个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"makai"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a:<span class="string">"coffe1891"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">func.call(obj); <span class="comment">//&gt;&gt; coffe1891</span></span><br><span class="line"><span class="comment">// 在调用 func 时强制把它的 this 绑定到 obj 上</span></span><br></pre></td></tr></table></figure><p>另外，使用<code>bind</code>可以修正SetTimeout和SetInterval的this指向：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(num)&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">    func()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.num);</span><br><span class="line">    &#125;</span><br><span class="line">    func1()&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"setTimeout:"</span>+<span class="keyword">this</span>.num);</span><br><span class="line">        &#125;.bind(<span class="keyword">this</span>), <span class="number">1000</span>);<span class="comment">//bind</span></span><br><span class="line">    &#125;</span><br><span class="line">    func2()&#123;</span><br><span class="line">        setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.num);</span><br><span class="line">        &#125;.bind(<span class="keyword">this</span>), <span class="number">2000</span>);<span class="comment">//bind</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Obj(<span class="number">1</span>);</span><br><span class="line">obj.func();<span class="comment">//&gt;&gt; 1　             输出的是obj.num</span></span><br><span class="line">obj.func1()<span class="comment">//&gt;&gt; setTimeout:1　  输出的是obj.num</span></span><br><span class="line">obj.func2()<span class="comment">//&gt;&gt; 1 1 1 1 ……　    输出的是obj.num</span></span><br></pre></td></tr></table></figure><h3 id="4-“new”操作符指向"><a href="#4-“new”操作符指向" class="headerlink" title="4. “new”操作符指向"></a>4. “new”操作符指向</h3><p>在JavaScript 中，<strong>构造函数</strong>只是一些<strong>使用<code>new</code>操作符时被调用的函数</strong>。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至都不能算是一种特殊的类型（class），它们<strong>只是被<code>new</code>操作符调用的普通函数而已</strong>。</p><p>使用<code>new</code> 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：</p><ol><li>创建（或者说构造）一个全新的对象；</li><li>将构造函数的作用域赋给新对象（因此<code>this</code>就指向了这个新对象）；</li><li>执行构造函数中的代码（为这个新对象添加属性、方法等）；</li><li>如果函数没有返回其他对象，那么返回这个新对象。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> func(<span class="string">"coffe1891"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar.a); <span class="comment">//&gt;&gt; coffe1891</span></span><br><span class="line"><span class="comment">// 使用new 来调用func(..)时，我们会构造一个新对象并把它绑定到func(..)调用中的this上</span></span><br></pre></td></tr></table></figure><p>可以将函数的返回值分成三种情况：</p><ul><li>返回一个对象</li><li>没有返回值，即默认返回undefined</li><li>返回基本数据类型</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、返回一个对象</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Foo(<span class="string">"kobin"</span>,<span class="string">"18"</span>);</span><br><span class="line"></span><br><span class="line">bar.name; <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">bar.age; <span class="comment">// 18</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、没有返回值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Foo(<span class="string">"kobin"</span>,<span class="string">"18"</span>);</span><br><span class="line"></span><br><span class="line">bar.name; <span class="comment">// kobin</span></span><br><span class="line"></span><br><span class="line">bar.age; <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、返回基本数据类型</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Foo(<span class="string">"kobin"</span>,<span class="string">"18"</span>);</span><br><span class="line"></span><br><span class="line">bar.name; <span class="comment">// kobin</span></span><br><span class="line"></span><br><span class="line">bar.age; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><blockquote><p>所以使用new绑定时，需要判断函数返回的值是否为一个对象，如果是对象，那么this会绑定到返回的对象上</p></blockquote></div><h2 id="如何利用规则判断this的指向"><a href="#如何利用规则判断this的指向" class="headerlink" title="如何利用规则判断this的指向"></a>如何利用规则判断this的指向</h2><div class="story post-story"><p><code>this</code>的指向判断，可以按照下面的优先级顺序来判断函数在某个调用位置应用的是哪条规则</p><h3 id="1-函数是否在new-中被调用（new-操作符指向）？"><a href="#1-函数是否在new-中被调用（new-操作符指向）？" class="headerlink" title="1. 函数是否在new 中被调用（new 操作符指向）？"></a>1. 函数是否在<code>new</code> 中被调用（<code>new</code> 操作符指向）？</h3><p>如果是的话，<strong><code>this</code> 绑定的是新创建的对象</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> func(<span class="string">"coffe"</span>); <span class="comment">//this会指向obj</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.getName()); <span class="comment">//&gt;&gt; coffe</span></span><br></pre></td></tr></table></figure><h3 id="2-函数是否通过call、apply、bind显式指向？"><a href="#2-函数是否通过call、apply、bind显式指向？" class="headerlink" title="2. 函数是否通过call、apply、bind显式指向？"></a>2. 函数是否通过<code>call</code>、<code>apply</code>、<code>bind</code>显式指向？</h3><p>如果是的话，<strong><code>this</code>指向的是call、apply、bind三个方法的第一个参数指定的对象</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">"coffe"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name; <span class="comment">//这里的this本来指向window</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> str = func.call(obj1); <span class="comment">//改变了func函数里面this的指向，指向obj1</span></span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">//&gt;&gt; coffe</span></span><br></pre></td></tr></table></figure><h3 id="3-函数是否被当做某个对象的方法而调用（隐式指向）？"><a href="#3-函数是否被当做某个对象的方法而调用（隐式指向）？" class="headerlink" title="3. 函数是否被当做某个对象的方法而调用（隐式指向）？"></a>3. 函数是否被当做某个对象的方法而调用（隐式指向）？</h3><p>如果是的话，<code>this</code>指向的是这个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">"coffe"</span>,</span><br><span class="line">  func() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name; <span class="comment">//指向obj1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里的obj1.func()，表明func函数被obj1调用，因此func中的this指向obj1</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.func()); <span class="comment">//&gt;&gt; coffe</span></span><br></pre></td></tr></table></figure><h3 id="4-若以上都不是的话，使用默认绑定。"><a href="#4-若以上都不是的话，使用默认绑定。" class="headerlink" title="4. 若以上都不是的话，使用默认绑定。"></a>4. 若以上都不是的话，使用默认绑定。</h3><p>如果在严格模式下，就绑定到<code>undefined</code>，否则绑定到<strong>全局对象</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"coffe"</span>; <span class="comment">//为全局对象window添加一个属性a</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span>;<span class="comment">//开启严格模式</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//严格模式下，this指向undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(func()); <span class="comment">//&gt;&gt; TypeError</span></span><br></pre></td></tr></table></figure></div><h2 id="几个例外情况"><a href="#几个例外情况" class="headerlink" title="几个例外情况"></a>几个例外情况</h2><div class="story post-story"><h3 id="1-被忽略的this"><a href="#1-被忽略的this" class="headerlink" title="1. 被忽略的this"></a><strong>1.</strong> 被忽略的this</h3><p><code>null</code> 或者<code>undefined</code>作为<code>this</code>指向的对象传入<code>call</code>、<code>apply</code>或者<code>bind</code>，这些值在调用时会被忽略，实际应用的是<strong>默认指向规则</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">func.call(<span class="literal">null</span>); <span class="comment">//&gt;&gt; 2</span></span><br><span class="line">                 <span class="comment">//this指向了window</span></span><br></pre></td></tr></table></figure><h3 id="2-间接引用"><a href="#2-间接引用" class="headerlink" title="2. 间接引用"></a>2. 间接引用</h3><p>间接引用最容易在赋值时发生；间接引用时，调用这个函数会应用<strong>默认指向规则</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">func</span>: func &#125;;</span><br><span class="line"><span class="keyword">var</span> p = &#123; <span class="attr">a</span>: <span class="number">4</span> &#125;;</span><br><span class="line">o.func(); <span class="comment">//&gt;&gt; 3</span></span><br><span class="line">(p.func = o.func)(); <span class="comment">//&gt;&gt; 2</span></span><br><span class="line"><span class="comment">// 赋值表达式 p.func=o.func 的返回值是目标函数的引用，也就是 func 函数的引用</span></span><br><span class="line"><span class="comment">// 因此调用位置是 func() 而不是 p.func() 或者 o.func()</span></span><br></pre></td></tr></table></figure><h3 id="3-箭头函数"><a href="#3-箭头函数" class="headerlink" title="3. 箭头函数"></a>3. 箭头函数</h3><p>箭头函数并不是使用<code>function</code>关键字定义的，而是使用被称为“胖箭头”的操作符 <code>=&gt;</code> 定 义的。</p><p>箭头函数不遵守<code>this</code>的四种指向规则，而是<strong>根据函数定义时的作用域来决定 <code>this</code> 的指向。</strong>何谓“定义时的作用域”？就是你定义这个箭头函数的时候，该箭头函数在哪个函数里，那么箭头函数体内的this就是它父函数的this。</p><p>看下面代码加深理解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回一个箭头函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">a</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//this 继承自 func()</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  a: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = func.call(obj1);</span><br><span class="line">bar.call(obj2); <span class="comment">//&gt;&gt; 2         不是 3 ！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// func() 内部创建的箭头函数会捕获调用时 func() 的 this。</span></span><br><span class="line"><span class="comment">// 由于 func() 的 this 绑定到 obj1， bar（引用箭头函数）的 this 也会绑定到 obj1，</span></span><br><span class="line"><span class="comment">// this一旦被确定，就不可更改，所以箭头函数的绑定无法被修改。（new 也不行！）</span></span><br></pre></td></tr></table></figure><p>这个特性甚至被mozilla的MDN称作“<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">没有this</a>”，这种说法很费解。其实应该这么理解：一般而言，this的指向是在函数运行之后才确定的，而箭头函数的this指向在定义时也即调用之前就定死了，在运行之后无法更改，那相当于当成一个固定值的变量，此时this失去了原来作为“指向当前代码运行时所处的上下文环境（context）”的意义，所以MDN说箭头函数没有了this，我觉得翻译成“把this阉割了”更贴切 🤣 。</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何让centOS7下全局安装的npm模块在环境变量中生效</title>
      <link href="/others-centOS7-npm/"/>
      <url>/others-centOS7-npm/</url>
      
        <content type="html"><![CDATA[<p>记一次在centOS7下npm安装全局模块，依然无法使用相关全局命令的问题的解决方案</p><a id="more"></a><h3 id="问题详述"><a href="#问题详述" class="headerlink" title="问题详述"></a>问题详述</h3><p>通过<code>npm i -g cnpm</code>安装的cnpm后，依然无法全局使用<code>cnpm</code>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-bash: cnpm: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure><blockquote><p>解决方案： 需要将node路径关联到环境变量中</p></blockquote><h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><ul><li><p>使用<code>npm root -g</code>获取node目录,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;sbin&#x2F;nodejs&#x2F;lib&#x2F;node_modules</span><br></pre></td></tr></table></figure></li><li><p>通过vim编辑<code>/etc/profile</code>文件, 在文件最底下新增:</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Node所在路径</span></span><br><span class="line"><span class="built_in">export</span> NODE_HOME=/usr/sbin/nodejs</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;NODE_HOME&#125;</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><blockquote><p>如果PATH有其他配置，通过<code>export PATH=&lt;path1&gt;:&lt;path2&gt;:&lt;path3&gt;:$PATH</code>方式配置</p></blockquote><ul><li>最后执行命令使环境变量生效</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><ul><li>查看环境变量</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><ul><li>验证效果<br><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200910180852.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200910180852.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20200910180852"></li></ul><p>以后通过npm全局安装的模块会自动在环境变量中生效</p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> centOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git设置代理</title>
      <link href="/others-git%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/"/>
      <url>/others-git%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>本文讲解如何为github设置代理，让<code>git clone</code> 飞起来</p><a id="more"></a><h1 id="macOS-给-Git-Github-设置代理（HTTP-SSH）"><a href="#macOS-给-Git-Github-设置代理（HTTP-SSH）" class="headerlink" title="macOS 给 Git(Github) 设置代理（HTTP/SSH）"></a>macOS 给 Git(Github) 设置代理（HTTP/SSH）</h1><blockquote><p>macOS 给 Git(Github) 设置代理（HTTP/SSH）. GitHub Gist: instantly share code, notes, and snippets.</p></blockquote><h2 id="分辨需要设置的代理"><a href="#分辨需要设置的代理" class="headerlink" title="分辨需要设置的代理"></a>分辨需要设置的代理</h2><div class="story post-story"><ul><li><p>HTTP 形式：</p><blockquote><p>git clone <a href="https://github.com/owner/git.git" target="_blank" rel="noopener">https://github.com/owner/git.git</a></p></blockquote></li><li><p>SSH 形式：</p><blockquote><p>git clone <a href="mailto:git@github.com">git@github.com</a>:owner/git.git</p></blockquote></li></ul></div><h2 id="一、HTTP-形式"><a href="#一、HTTP-形式" class="headerlink" title="一、HTTP 形式"></a>一、HTTP 形式</h2><div class="story post-story"><h3 id="走-HTTP-代理"><a href="#走-HTTP-代理" class="headerlink" title="走 HTTP 代理"></a>走 HTTP 代理</h3><p>git config –global http.proxy “<a href="http://127.0.0.1:8080&quot;">http://127.0.0.1:8080&quot;</a><br>git config –global https.proxy “<a href="http://127.0.0.1:8080&quot;">http://127.0.0.1:8080&quot;</a></p><h3 id="走-socks5-代理（如-Shadowsocks）"><a href="#走-socks5-代理（如-Shadowsocks）" class="headerlink" title="走 socks5 代理（如 Shadowsocks）"></a>走 socks5 代理（如 Shadowsocks）</h3><p>git config –global http.proxy “socks5://127.0.0.1:1080”<br>git config –global https.proxy “socks5://127.0.0.1:1080”</p><h3 id="取消设置"><a href="#取消设置" class="headerlink" title="取消设置"></a>取消设置</h3><p>git config –global –unset http.proxy<br>git config –global –unset https.proxy</p></div><h2 id="二、SSH-形式"><a href="#二、SSH-形式" class="headerlink" title="二、SSH 形式"></a>二、SSH 形式</h2><div class="story post-story"><p>修改 <code>~/.ssh/config</code> 文件（不存在则新建）：</p><pre><code># 必须是 github.comHost github.com   HostName github.com   User git   # 走 HTTP 代理   # ProxyCommand socat - PROXY:127.0.0.1:%h:%p,proxyport=8080   # 走 socks5 代理（如 Shadowsocks）   # ProxyCommand nc -v -x 127.0.0.1:1080 %h %p</code></pre><p>对于Windows用户，要使用socks5代理却没有 nc 的，可以将<br><code>ProxyCommand nc -v -x 127.0.0.1:1080 %h %p</code><br>换成<br><code>ProxyCommand connect -S 127.0.0.1:1080 %h %p</code></p><p>详细配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Host</span> <span class="string">*</span></span><br><span class="line">  <span class="string">ServerAliveInterval</span> <span class="number">120</span></span><br><span class="line">  <span class="string">ServerAliveCountMax</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># macOS 给 Git(Github) 设置代理（HTTP/SSH）</span></span><br><span class="line"><span class="comment"># https://gist.github.com/chuyik/02d0d37a49edc162546441092efae6a1</span></span><br><span class="line"><span class="comment"># 0x00 克隆 repo 的两种方式：https 和 ssh 方式</span></span><br><span class="line"><span class="comment"># https 方式：git clone https://github.com/owner/git.git</span></span><br><span class="line"><span class="comment"># ssh   方式：git clone     git@github.com:owner/git.git</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0x01 https 方式克隆的 repo，走 http 或 sock5 代理，任选一个</span></span><br><span class="line"><span class="comment"># 0x0101 http 代理</span></span><br><span class="line"><span class="comment"># git config --global http.proxy "http://127.0.0.1:1087"</span></span><br><span class="line"><span class="comment"># git config --global https.proxy "http://127.0.0.1:1087"</span></span><br><span class="line"><span class="comment"># 0x0102 sock5 代理</span></span><br><span class="line"><span class="comment"># git config --global http.proxy "socks5://127.0.0.1:1086"</span></span><br><span class="line"><span class="comment"># git config --global https.proxy "socks5://127.0.0.1:1086"</span></span><br><span class="line"><span class="comment"># 0x0103 取消使用代理</span></span><br><span class="line"><span class="comment"># git config --global --unset http.proxy</span></span><br><span class="line"><span class="comment"># git config --global --unset https.proxy</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0x02 ssh 克隆方式的代理设置，直接在全局设置文件配置，即 ~/.ssh/config 文件</span></span><br><span class="line"><span class="string">Host</span> <span class="string">github.com</span></span><br><span class="line">   <span class="string">HostName</span> <span class="string">github.com</span></span><br><span class="line">   <span class="string">User</span> <span class="string">git</span></span><br><span class="line">   <span class="comment"># 走 HTTP 代理，需要 brew install socat</span></span><br><span class="line">   <span class="comment"># ProxyCommand socat - PROXY:127.0.0.1:%h:%p,proxyport=1087</span></span><br><span class="line">   <span class="comment"># 走 socks5 代理（如 Shadowsocks）</span></span><br><span class="line">   <span class="string">ProxyCommand</span> <span class="string">nc</span> <span class="string">-v</span> <span class="string">-x</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:1086</span> <span class="string">%h</span> <span class="string">%p</span></span><br><span class="line">   <span class="comment"># 走 socks5 代理（如 Shadowsocks），Windows 平台没有 nc 命令</span></span><br><span class="line">   <span class="comment"># ProxyCommand connect -S 127.0.0.1:1086 %h %p</span></span><br></pre></td></tr></table></figure><p><a href="https://gist.github.com/chuyik/02d0d37a49edc162546441092efae6a1" target="_blank" rel="noopener">Source</a></p></div>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>word-wrap,word-break,white-space强制换行和不换行总结</title>
      <link href="/css-%E5%BC%BA%E5%88%B6%E6%8D%A2%E8%A1%8C%E4%B8%8E%E4%B8%8D%E6%8D%A2%E8%A1%8C/"/>
      <url>/css-%E5%BC%BA%E5%88%B6%E6%8D%A2%E8%A1%8C%E4%B8%8E%E4%B8%8D%E6%8D%A2%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>我们一般控制换行所用到的 CSS 属性一共有三个：word-wrap; word-break; white-space。这三个属性可以说是专为了文字断行而创造出来的</p><a id="more"></a><h3 id="word-wrap-语法："><a href="#word-wrap-语法：" class="headerlink" title="word-wrap 语法："></a>word-wrap 语法：</h3><blockquote><p>word-wrap: normal(默认) | break-word</p></blockquote><ul><li>normal: 允许内容顶开指定的容器边界</li><li>break-word: 内容将在边界内换行。必要时会触发 word-break</li></ul><p><strong>说明</strong><br>word-wrap 是控制是否“为词断行”的，设置或检索当前行超过指定容器的边界时是否断开转行。中文没有任何问题，英文语句也没问题。但是对于长串的英文，就不起作用。</p><p><strong>范例</strong><br>congratulation 这个单词属于长串英文，word-wrap:break-word 整个单词看成一个整体，如果该行末端宽度不够显示整个单词，它会自动把整个单词放到下一行，而不会把单词截断，这就是对于长串文字不起作用的解释。word-wrap:normal 是默认情况，英文单词不被拆开。</p><p><strong>结论</strong><br>作用范围仅为 div 这类标准块级元素，th,td 这类 table 元素虽然识别但是没有效果（如果为 td,th 加上宽度 word-wrap 在 IE 下是能够发挥效果的，但根据完全兼容性方便记忆角度上来说还是以前面的结论为准）。</p><h3 id="word-break"><a href="#word-break" class="headerlink" title="word-break"></a>word-break</h3><blockquote><p>word-break: normal(默认) | break-all | keep-all</p></blockquote><ul><li>normal: 依照亚洲语言和非亚洲语言的文本规则，允许在字内换行。</li><li>break-all: 该行为与亚洲语言的 normal 相同。也允许非亚洲语言文本行的任意字内断开。该值适合包含一些非亚洲文本的亚洲文本。</li><li>keep-all: 与所有非亚洲语言的 normal 相同。对于中文，韩文，日文，不允许字断开。适合包含少量亚洲文本的非亚洲文本。</li></ul><p><strong>说明</strong><br>word-break:break-all，是断开单词。在单词到边界时，下个字母自动到下一行。主要解决了长串英文的问题（恰恰弥补了上面 word-wrap:break-word 对于长串文字不起作用的缺陷）</p><p><strong>范例</strong><br>继续以上面 congratulation 这个单词属于长串英文，word-break:break-all 它会把单词截断，该行末端就会变成类似 conra(congratulation 的前端部分)，下一行为 tulation（conguatulation）的后端部分了。<br>word-break:keep-all，是指 Chinese, Japanese, and Korean 不断词。即只用此时，不用 word-wrap，中文就不会换行了。（英文语句正常。）</p><p><strong>结论</strong><br>作用范围仅为 div 这类标准块级元素，th,td 这类 table 元素虽然识别但是没有效果（经测试 Chrome 下 word-break:break-all 是有效果的，但根据完全兼容性方便记忆角度上来说还是以前面的结论为准）。Firefox,Opera 是无法识别 word-break 的，更不用提 Firefox 下的 th,td 中使用 word-break 的效果了。</p><h3 id="white-space"><a href="#white-space" class="headerlink" title="white-space"></a>white-space</h3><blockquote><p>white-space: normal(默认) | pre | nowrap</p></blockquote><ul><li>normal: 默认。空白会被浏览器忽略。</li><li>pre: 空白会被浏览器保留。其行为方式类似 HTML 中的 pre 标签</li><li>nowrap: 文本不会换行，文本会在在同一行上继续，直到遇到 br 标签为止。</li></ul><p><strong>说明</strong></p><ul><li>对于 pre 属性，其实就是 HTML 中连续的多个空白符会被合并，然后为了不让他合并（最常用的场合就是表示代码文字缩进）让其中的空白符继续保留而不需要我们增加额外的样式和标签来控制它的缩进和换行。pre 标签的原理也是一样的内部默认有了个 white-space:pre。</li><li>对于 nowrap 属性，这个是强制不换行核心，一般强制不换行就是利用这个属性。Firefox 的 div 和 td 中，以及 IE 的 div 中，均没有问题。唯一的瑕疵就是在 IE 的 td 中会有一个问题，如果 td 没有指定宽度，则 nowrap 仍然有效，如果 td 有宽度，并且文字中无标点、无空格（例如中文长串文字），nowrap 则不再有效。解决方式就是可以加 word-break:keep-all;可以解决此问题。</li></ul><h3 id="总结强制换行"><a href="#总结强制换行" class="headerlink" title="总结强制换行"></a>总结强制换行</h3><ul><li>div（块级元素）<ul><li>word-wrap:break-word; word-break:break-all;</li></ul></li><li>td,th 这类 table 元素<ul><li>先为 table 设定 table-layout:fixed，基本上设定完这个属性后基本的换行问题都能够解决而不会出现 table 中 td,th 因为里面各个内容的多寡发生抢夺其他 td,th 宽度的情形发生。这时如果你依旧有强制换行问题，那么在此 td 中内部加一层 div，那么情况就会像上面讨论的方式来解决。</li></ul></li></ul><h3 id="总结强制不换行"><a href="#总结强制不换行" class="headerlink" title="总结强制不换行"></a>总结强制不换行</h3><ul><li>white-space:nowrap<ul><li>在文字与 td 之间再套一层 div，然后使用 nowrap</li></ul></li><li>overflow:hidden<ul><li>防止文字溢出</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
