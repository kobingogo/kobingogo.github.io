<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>扬舲の博客</title>
  
  
  <link href="https://kobingogo.github.io/atom.xml" rel="self"/>
  
  <link href="https://kobingogo.github.io/"/>
  <updated>2024-08-08T10:31:05.013Z</updated>
  <id>https://kobingogo.github.io/</id>
  
  <author>
    <name>yangling</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Taro初识</title>
    <link href="https://kobingogo.github.io/framework-Taro%E5%88%9D%E8%AF%86/"/>
    <id>https://kobingogo.github.io/framework-Taro%E5%88%9D%E8%AF%86/</id>
    <published>2024-01-11T17:47:56.000Z</published>
    <updated>2024-08-08T10:31:05.013Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Taro：多端统一开发的跨平台小程序框架"><a href="#Taro：多端统一开发的跨平台小程序框架" class="headerlink" title="Taro：多端统一开发的跨平台小程序框架"></a>Taro：多端统一开发的跨平台小程序框架</h3><p>在现代应用开发中，多平台支持已成为常态。然而，各平台的技术栈和生态差异巨大，导致了开发、维护和迭代的复杂度显著增加。Taro 作为一款开源的跨平台开发框架，通过提供一致的开发体验，帮助开发者构建多端应用，包括微信小程序、支付宝小程序、H5、React Native 等。本文将深入探讨 Taro 的特点、架构以及如何高效利用它来开发跨平台应用。</p><h3 id="什么是-Taro？"><a href="#什么是-Taro？" class="headerlink" title="什么是 Taro？"></a>什么是 Taro？</h3><p>Taro 是由凹凸实验室（JD.com）开发的一个开源多端开发框架，主要面向小程序开发。它的核心思想是“<strong>一次编写，多端运行</strong>”，旨在解决不同平台之间的兼容性问题。通过 Taro，开发者可以用 React 语法编写代码，然后通过编译器将代码转换为不同平台所需的代码格式。</p><h3 id="Taro-的特点"><a href="#Taro-的特点" class="headerlink" title="Taro 的特点"></a>Taro 的特点</h3><p><strong>1. 跨平台支持</strong><br>Taro 支持多个平台，包括但不限于：微信小程序、支付宝小程序、百度小程序、字节跳动小程序、快应用、H5、React Native 等。开发者只需编写一套代码，即可部署到多个平台，显著提高开发效率。</p><p><strong>2. React 风格的开发体验</strong><br>Taro 基于 React，支持 JSX 语法和 React 生命周期方法。对于熟悉 React 的开发者来说，可以无缝切换到 Taro 开发。此外，Taro 还支持 React 的 Hooks 特性，使开发更加简洁和高效。</p><p><strong>3. 丰富的生态</strong><br>Taro 具有丰富的生态系统，支持诸如 Redux、MobX 等主流的状态管理库，此外还支持 Taro UI 等专为 Taro 设计的组件库。这些生态工具的存在，使得开发者能够快速构建复杂的应用。</p><p><strong>4. CLI 工具</strong><br>Taro 提供强大的 CLI 工具，支持项目初始化、开发、构建、测试等功能。通过 CLI 工具，开发者可以轻松管理项目的生命周期。</p><p><strong>5. 小程序插件支持</strong><br>Taro 允许开发者使用小程序的原生组件和 API，并通过插件机制扩展框架的功能。这种灵活性使得 Taro 能够充分利用小程序平台的特性，同时保持跨平台的一致性。</p><h3 id="Taro-的架构"><a href="#Taro-的架构" class="headerlink" title="Taro 的架构"></a>Taro 的架构</h3><p>Taro 的架构主要包括以下几个部分：</p><p><strong>1. 编译器</strong><br>Taro 的核心是其编译器，它将开发者编写的 React 代码编译成不同平台的代码格式。例如，对于微信小程序，Taro 会将代码编译成 WXML、WXSS、JS 等格式。</p><p><strong>2. 运行时</strong><br>Taro 提供了一个运行时库，用于在不同平台上执行编译后的代码。这个运行时库封装了平台相关的 API，确保开发者可以使用统一的 API 进行开发。</p><p><strong>3. 多端 UI 组件</strong><br>Taro 提供了一套多端 UI 组件，开发者可以使用这些组件构建具有跨平台一致性的用户界面。这些组件会根据平台自动调整样式和行为，确保用户体验的一致性。</p><p><strong>4. 状态管理</strong><br>Taro 支持多种状态管理方式，包括 Redux、MobX 等。开发者可以根据项目需求选择合适的状态管理工具，以便更好地组织和管理应用的状态。</p><h3 id="如何开始使用-Taro"><a href="#如何开始使用-Taro" class="headerlink" title="如何开始使用 Taro"></a>如何开始使用 Taro</h3><p>要开始使用 Taro，首先需要安装 Taro 的 CLI 工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @tarojs/cli</span><br></pre></td></tr></table></figure><p>然后，通过 CLI 工具创建一个新项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taro init myApp</span><br></pre></td></tr></table></figure><p>在项目初始化过程中，Taro 会提示选择项目类型和使用的状态管理工具。完成后，开发者可以进入项目目录，并启动开发服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> myApp</span><br><span class="line">npm run dev:weapp  <span class="comment"># 开发微信小程序</span></span><br></pre></td></tr></table></figure><p>Taro 提供了丰富的文档和示例，帮助开发者快速上手。在开发过程中，开发者可以使用 Taro 的组件和 API 进行跨平台开发，并通过热更新功能提高开发效率。</p><h3 id="Taro-的社区和生态"><a href="#Taro-的社区和生态" class="headerlink" title="Taro 的社区和生态"></a>Taro 的社区和生态</h3><p>Taro 的成功离不开其背后的强大社区和丰富的生态系统。社区的活跃度和贡献度使得 Taro 不断迭代和进化，为开发者提供更多的功能和优化。</p><p><strong>1. 官方文档和教程</strong><br>Taro 提供详尽的官方文档和教程，帮助开发者从基础到进阶地学习和使用 Taro。这些文档涵盖了从环境搭建、项目结构、组件使用到高级特性等各个方面，为开发者提供了全面的指导。</p><p><strong>2. 开源插件和工具</strong><br>Taro 的社区贡献了大量的开源插件和工具，使得开发者可以轻松扩展和定制 Taro 的功能。例如，Taro UI 是一个专为 Taro 设计的多端 UI 组件库，提供了丰富的组件，帮助开发者快速构建高质量的用户界面。</p><p><strong>3. 社区支持</strong><br>Taro 社区活跃在 GitHub、论坛、微信群等多个平台。开发者可以在这些平台上寻求帮助、分享经验、提出建议，甚至参与 Taro 的开发。这种开放和包容的社区氛围，使得 Taro 成为一个不断成长和进化的框架。</p><h3 id="Taro-的未来发展"><a href="#Taro-的未来发展" class="headerlink" title="Taro 的未来发展"></a>Taro 的未来发展</h3><p>随着小程序和跨平台开发需求的不断增长，Taro 作为一款领先的多端开发框架，未来有着广阔的发展前景。Taro 的团队和社区将继续致力于提升框架的性能和易用性，扩展支持的平台，优化开发者体验。</p><p>未来，Taro 可能会进一步增强对云开发的支持，集成更多的服务和功能，为开发者提供一站式的开发解决方案。同时，随着 React 和小程序平台的不断演进，Taro 也将不断更新和适应新的技术趋势。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Taro 是一个功能强大且灵活的跨平台开发框架，通过提供一致的开发体验和丰富的生态系统，帮助开发者高效地构建多端应用。无论是小程序开发者，还是希望支持多平台的应用开发者，Taro 都是一个值得考虑的选择。随着社区的不断壮大和技术的不断迭代，Taro 的未来将更加光明。</p>]]></content>
    
    
    <summary type="html">在现代应用开发中，多平台支持已成为常态。然而，各平台的技术栈和生态差异巨大，导致了开发、维护和迭代的复杂度显著增加。Taro 作为一款开源的跨平台开发框架，通过提供一致的开发体验，帮助开发者构建多端应用，包括微信小程序、支付宝小程序、H5、React Native 等。本文将深入探讨 Taro 的特点、架构以及如何高效利用它来开发跨平台应用。</summary>
    
    
    
    <category term="小程序" scheme="https://kobingogo.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="taro" scheme="https://kobingogo.github.io/tags/taro/"/>
    
  </entry>
  
  <entry>
    <title>知识图谱在金融领域的应用</title>
    <link href="https://kobingogo.github.io/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%9C%A8%E9%87%91%E8%9E%8D%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>https://kobingogo.github.io/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%9C%A8%E9%87%91%E8%9E%8D%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/</id>
    <published>2023-11-10T20:43:53.000Z</published>
    <updated>2024-08-08T10:31:05.017Z</updated>
    
    <content type="html"><![CDATA[<h2 id="知识图谱在金融领域的应用"><a href="#知识图谱在金融领域的应用" class="headerlink" title="知识图谱在金融领域的应用"></a><strong>知识图谱在金融领域的应用</strong></h2><div class="story post-story"><p>摘要</p><p>知识图谱旨在对现实世界中的实体或概念及其之间的关系进行建模，是一种新的海量数据组织、管理和利用方式。自 2012 年谷歌推出知识图谱以来，它在学术界和工业界掀起了一股热潮，已经在许多领域扮演着重要角色。本文重点关注知识图谱在金融领域的应用，首先从知识图谱是什么（What），为什么要构建知识图谱（Why），怎样构建知识图谱（How）的逻辑出发，介绍知识图谱的技术背景；然后对知识图谱的金融应用场景（Where）加以探讨和展望。</p><p><strong>关键词：</strong>  知识图谱 金融 应用</p></div><h2 id="1-知识图谱是什么（What）"><a href="#1-知识图谱是什么（What）" class="headerlink" title="1. 知识图谱是什么（What）"></a><strong>1. 知识图谱是什么（What）</strong></h2><div class="story post-story"><p>知识图谱（Knowledge Graph）的提出是为了描述现实世界中的实体、概念以及它们之间的关联。它本质上是一个语义网络，是基于图的数据结构，由节点和边组成。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730174622.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730174622.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730174622">如上图所示，知识图谱的基本形式为&lt;实体 1, 关系, 实体 2&gt;、&lt;实体, 属性, 属性值&gt;。其中，节点表示实体、概念或属性值；边表示关系或属性。下面分别对实体、概念、属性、属性值、关系的含义进行阐释说明：</p><ul><li><strong>实体</strong>：实体是知识图谱中最基本的元素，指的是具有可区别性且独立存在的某种事物。如某一个人：Barack Obama、姚明等；某一个国家：中国、英国等；某一座城市：北京、纽约等。即现实世界由实体组成。</li><li><strong>概念</strong>：指对具有相同特性的实体的概括和抽象，如国家、城市、民族等。</li><li><strong>属性</strong>：用于区分概念的特征，不同概念具有不同的属性。如城市对应的属性有：面积、人口等。</li><li><strong>属性值</strong>：实体指向的属性的值。例如：“中国的面积为 960 万平方公里”，其中“中国”为实体，“面积”为属性，“960 万平方公里”为属性值。</li><li><strong>关系</strong>：关系是实体或概念之间的关联，如：路遥与《平凡的世界》之间存在着创作关系。关系可以看作是一种特殊的属性，当属性值对应的是概念或实体时，属性就等价于关系。</li></ul><p>基于上述基本概念，我们对知识图谱有了初步的认知，下面本节将依次介绍知识图谱的组成结构、表示方法、分类以及发展历程。</p><h3 id="1-1-组成结构"><a href="#1-1-组成结构" class="headerlink" title="1.1 组成结构"></a><strong>1.1 组成结构</strong></h3><p>与传统的数据库相似，知识图谱同样可分为模式层和实例层；但与关系型数据库的 ER 模型不同的是，知识图谱的模式层一般称为本体层（Ontology）。如下图，“Barack Obama”与“New York City”等节点是实例层的实体，“Politician”与“City”等节点是它们对应的本体层的概念。位于箭头旁的“was_born_in”、“leader”等则表示关系。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730174646.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730174646.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730174646"></p><p>可以看出：不仅实例层的节点之间存在关系，本体层的节点之间也存在关系。另外，与普通的图不同的是，知识图谱中包含多种类型的节点和边，因此知识图谱又可看作是一种异质信息网络。</p><h3 id="1-2-表示方法"><a href="#1-2-表示方法" class="headerlink" title="1.2 表示方法"></a><strong>1.2 表示方法</strong></h3><p>知识图谱的表示方法一般可分为两类：基于符号的表示和基于向量的表示。</p><h3 id="1-2-1-基于符号的表示"><a href="#1-2-1-基于符号的表示" class="headerlink" title="1.2.1 基于符号的表示"></a><strong>1.2.1 基于符号的表示</strong></h3><p>基于符号的表示有 RDF、RDFS、OWL 等。</p><p>RDF（Resource Description Framework）本质是一个基于有向标记图（Directed Labeled Graph）的数据模型，它提供了一个统一的标准，用于描述实体（资源）。RDF 形式上表示为 SPO 三元组，即(Subject-主语, Predicate-谓语, Object-宾语)。一个 SPO 三元组对应一个逻辑表达式或关于现实世界的陈述，可以理解为：Subject 表示头实体，Predicate 表示关系，Object 表示尾实体。</p><p>RDF 的表达能力有限，无法区分类（Class）和对象（Object），也无法定义描述类的属性以及类间的关系，因此 W3C 又制定了 RDFS 和 OWL 标准。</p><p>RDFS（Resource Description Framework Schema）是一种基础的模式语言，它在 RDF 的基础上扩展了本体的表达。RDFS 主要包括如下元语：Class, subClassOf, type, Property, subPropertyOf, Domain, Range 等。基于这些简单的表达构件可以构建最基本的类层次体系和属性体系。</p><p>OWL（Web Ontology Language）在 RDFS 的基础上又增加了预定义的词汇，进一步扩展了表示类和属性约束的表示能力，可以构建更为复杂而完备的本体。这些扩展的本体表达能力包括：</p><ul><li>复杂类表达（Complex Classes），如：intersection, union, complement 等；</li><li>属性约束（Property Restrictions），如：existential quantification, universal quantification, hasValue 等；</li><li>基数约束（Cardinality Restrictions），如：maxQualifiedCardinality, minQualifiedCardinality, qualifiedCardinality 等；</li><li>属性特征（Property Characteristics），如：inverseOf, SymmetricProperty, AsymmetricProperty, propertyDisjointWith, ReflexiveProperty, FunctionalProperty 等。</li></ul><p>上述基于符号的表示易于刻画显性、离散的知识，因而具有内生的可解释性。但由于人类知识还包含大量不易于符号化的隐性知识，完全基于符号逻辑的知识表示通常由于知识的不完备而失去鲁棒性，特别是推理很难达到实用。由此催生了采用连续向量方式表示知识的研究。</p><h3 id="1-2-2-基于向量的表示"><a href="#1-2-2-基于向量的表示" class="headerlink" title="1.2.2 基于向量的表示"></a><strong>1.2.2 基于向量的表示</strong></h3><p>基于向量的表示有组合模型、神经网络模型、转换模型等。</p><p>组合（Composition）模型将知识图谱建模为三维邻接张量，又被称为“张量分解”（tensor factorization）模型。其典型特征是将实体建模为列向量、关系建模为矩阵，然后通过头实体向量与关系矩阵的线性组合，再与尾实体进行点积计算打分函数。例如采用普通矩阵的 RESCAL<a href="https://www.fanzhuoya.com/ai/knowledge-graph/#fn:3" target="_blank" rel="noopener external nofollow noreferrer">3</a>、采用低秩矩阵的 LFM<a href="https://www.fanzhuoya.com/ai/knowledge-graph/#fn:4" target="_blank" rel="noopener external nofollow noreferrer">4</a>等。</p><p>神经网络（Neural Network）模型通过非线性计算对实体-关系交互进行建模，如采用单层非线性网络的 SLM、NTN<a href="https://www.fanzhuoya.com/ai/knowledge-graph/#fn:5" target="_blank" rel="noopener external nofollow noreferrer">5</a>等。</p><p>转换（Translation）模型的灵感来自 word2vec 中词汇关系的平移不变性。它将关系建模为转换（translation）操作，即将关系看作是头实体到尾实体的转换，认为经过向量化的头实体、关系和尾实体满足：，如基于向量的三角形法则和范数原理的 TransE<a href="https://www.fanzhuoya.com/ai/knowledge-graph/#fn:6" target="_blank" rel="noopener external nofollow noreferrer">6</a>、通过超平面转化处理多元关系的 TransH<a href="https://www.fanzhuoya.com/ai/knowledge-graph/#fn:7" target="_blank" rel="noopener external nofollow noreferrer">7</a>等。</p><p>这种基于向量的知识表示可以通过数值运算发现新事实和新关系，并能更有效地发现更多的隐性知识和潜在假设，这些隐性知识通常是人的主观不易于观察和总结出来的。更为重要的是，知识图谱嵌入也通常作为一种辅助的先验知识输入到很多深度神经网络模型中，用来约束和监督神经网络的训练过程。</p><h3 id="1-3-分类"><a href="#1-3-分类" class="headerlink" title="1.3 分类"></a><strong>1.3 分类</strong></h3><p>知识图谱的分类方式很多，分类依据可以是知识种类、构建方法等。从所涉领域的角度出发，知识图谱通常可分为通用领域知识图谱（Open Domain）和特定领域知识图谱（Specific Domain）两类。</p><p>通用领域知识图谱可以看作是一个面向通用领域的结构化的百科知识库，其中包含了大量的现实世界中的常识性知识，覆盖面广，如 Freebase<a href="https://www.fanzhuoya.com/ai/knowledge-graph/#fn:8" target="_blank" rel="noopener external nofollow noreferrer">8</a>、YAGO<a href="https://www.fanzhuoya.com/ai/knowledge-graph/#fn:9" target="_blank" rel="noopener external nofollow noreferrer">9</a>、WikiData<a href="https://www.fanzhuoya.com/ai/knowledge-graph/#fn:10" target="_blank" rel="noopener external nofollow noreferrer">10</a>、DBPedia<a href="https://www.fanzhuoya.com/ai/knowledge-graph/#fn:11" target="_blank" rel="noopener external nofollow noreferrer">11</a>、Nell<a href="https://www.fanzhuoya.com/ai/knowledge-graph/#fn:12" target="_blank" rel="noopener external nofollow noreferrer">12</a>、Probase<a href="https://www.fanzhuoya.com/ai/knowledge-graph/#fn:13" target="_blank" rel="noopener external nofollow noreferrer">13</a>和谷歌的 Knowledge Vault<a href="https://www.fanzhuoya.com/ai/knowledge-graph/#fn:14" target="_blank" rel="noopener external nofollow noreferrer">14</a>等。</p><p>特定领域知识图谱可以看作是一个基于语义技术的行业知识库，因其基于行业数据构建，有着严格而丰富的数据模式，对领域知识的深度、知识准确性要求高，如生命科学领域的 Bio2RDF<a href="https://www.fanzhuoya.com/ai/knowledge-graph/#fn:15" target="_blank" rel="noopener external nofollow noreferrer">15</a>和 Gene Ontology<a href="https://www.fanzhuoya.com/ai/knowledge-graph/#fn:16" target="_blank" rel="noopener external nofollow noreferrer">16</a>，以及描述家谱关系的 Kinship<a href="https://www.fanzhuoya.com/ai/knowledge-graph/#fn:17" target="_blank" rel="noopener external nofollow noreferrer">17</a>等。</p><h3 id="1-4-发展历程"><a href="#1-4-发展历程" class="headerlink" title="1.4 发展历程"></a><strong>1.4 发展历程</strong></h3><p>知识图谱属于人工智能重要研究领域——知识工程的一个分支。为了更好地了解知识图谱的理论基础，下面我们回顾一下知识工程的发展历程。如下图，知识工程的发展历程可分成五个标志性的阶段：前知识工程时期、专家系统时期、万维网时期，群体智能时期以及知识图谱时期<a href="https://www.fanzhuoya.com/ai/knowledge-graph/#fn:1" target="_blank" rel="noopener external nofollow noreferrer">1</a><a href="https://www.fanzhuoya.com/ai/knowledge-graph/#fn:2" target="_blank" rel="noopener external nofollow noreferrer">2</a>。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730174736.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730174736.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730174736"></p><ul><li><strong>1950-1970 年代：前知识工程时期</strong></li></ul><p>前知识工程时期使用图灵测试作为评测智能的手段。这一时期人们对人工智能的理解主要可分为两个学派：符号主义和连结主义。符号主义认为物理符号系统是智能行为的充要条件；连结主义则认为大脑（大脑神经元及其连接机制）是一切智能活动的基础。这一时期具有代表性的工作是通用问题求解程序（GPS）：首先将问题进行形式化表达，然后通过搜索，从问题初始状态，结合规则或表示得到目标状态。其中比较成功的应用是博弈论和机器定理证明等。这一时期的知识表示方法主要有逻辑知识表示、产生式规则、语义网络等。人工智能和知识工程的先驱 Minsky，Mccarthy，Newell 和 Simon 四位学者因为在感知机、人工智能语言、通用问题求解和形式化语言方面的杰出工作分别获得了 1969 年、1971 年、1975 年的图灵奖。</p><ul><li><strong>1970-1990 年代：专家系统时期</strong></li></ul><p>通用问题求解强调利用人的求解问题的能力建立智能系统，而忽略了知识对智能的支持，使人工智能难以在实际应用中发挥作用。1970 年开始，人工智能开始转向建立基于知识的系统，通过“知识库+推理机”实现智能，这一时期涌现出很多成功的限定领域专家系统，如 MYCIN 医疗诊断专家系统、识别分子结构的 DENRAL 专家系统、以及计算机故障诊断 XCON 专家系统等。1994 年图灵奖获得者 Feigenbaum 在 70 年代提出知识工程的定义，从此确立了知识工程在人工智能中的核心地位。这一时期知识表示方法有新的演进，包括框架和脚本等。80 年代后期出现很多专家系统的开发平台，可以帮助将专家的领域知识转变成计算机可以处理的知识。</p><ul><li><strong>1990-2000 年代：万维网时期（Web 1.0）</strong></li></ul><p>在 1990-2000 年间，出现了很多人工构建的大规模知识库，包括英文的 WordNet、采用一阶谓词逻辑知识表示的 Cyc 常识知识库、以及中文的 Hownet。万维网的产生为人们提供了一个开放平台，它使用 HTML 定义文本的内容，通过超链接把文本连接起来，使得大众可以共享信息。W3C 提出的可扩展标记语言 XML，通过定义标签对互联网文档内容的结构进行标记，为互联网环境下大规模的知识表示和共享奠定了基础。这一时期还提出了本体的知识表示方法。</p><ul><li><strong>2000-2006 年代：群体智能时期（Web 2.0）</strong></li></ul><p>在 2001 年，万维网发明人、2016 年图灵奖获得者 Tim Berners-Lee 提出语义 Web 的概念，旨在对互联网内容进行结构化语义表示。W3C 进一步提出互联网语义标识语言 RDF（资源描述框架）和 OWL（万维网本体表述语言），利用本体描述互联网内容的语义结构，通过对网页进行语义标识得到网页语义信息，使人和机器能够更好地协同工作。</p><p>万维网的出现使得互联网上的知识由封闭走向开放，由集中变为分布。原来专家系统是系统内部定义的知识，现在可以实现知识源之间相互链接，可以通过关联来产生更多的知识，而非完全由固定人生产。这个过程中出现了群体智能，最典型的代表就是维基百科，实际上是用户去建立知识，体现了互联网大众用户对知识的贡献，成为今天大规模结构化知识图谱的重要基础。</p><ul><li><strong>2006 年至今：知识图谱时期</strong></li></ul><p>从 2006 年开始，大规模维基百科类富结构知识资源的出现和网络信息提取方法的进步，使得大规模知识获取方法取得了巨大进展。与 Cyc、WordNet 和 HowNet 等手工研制的知识库不同，这一时期知识获取是自动化的，并且在网络规模下运行。最具代表性的大规模网络知识获取的工作包括 Freebase、YAGO、WikiData、DBPedia、Nell、Probase 等。</p><p>除了这些通用领域的应用，知识图谱逐渐扩展到限定领域。典型的例子是谷歌收购 Freebase 后在 2012 年推出的语义搜索产品，IBM 的 Watson 深度问答系统，以及商业、金融、生命科学等特定领域的知识库。此外，知识图谱的应用还包括大数据语义分析、智能知识服务等。更多知识图谱的创新应用还有待开发。</p></div><h2 id="2-为什么构建知识图谱（Why）"><a href="#2-为什么构建知识图谱（Why）" class="headerlink" title="2. 为什么构建知识图谱（Why）"></a><strong>2. 为什么构建知识图谱（Why）</strong></h2><div class="story post-story"><p>上文介绍了什么是知识图谱，那么为什么要构建知识图谱呢？整体而言，知识图谱是大数据时代应运而生的一种技术手段。相较数据库时代，大数据时代的数据性质和数据模式都发生了巨大的变化。</p><p>在数据性质方面，数据库时代的数据规模较小，类型较单一，且通常是结构化数据；而大数据时代的数据量较大，类型较丰富，不仅包含结构化的数据，还包含半结构化，甚至非结构化的数据。</p><p>在数据模式方面，数据库时代的数据模式相对固定，一般可以预先确定，即先有数据模式后产生数据；而大数据时代的数据模式随着数据增长不断演变，难以预先确定。</p><p>由于这些差异，大数据时代面临着众多挑战，而知识图谱则提供了应对这些挑战的一种方式。</p><p>第一，针对多源异构数据难以融合的挑战，使用知识图谱进行抽象建模，基于可动态变化的“概念-实体-属性-关系”数据模型，可以实现各类数据的统一建模。</p><p>第二，针对数据模式动态变迁困难的挑战，知识图谱基于图模型的数据存储，便于数据模式的动态变化。</p><p>第三，针对分散的数据难以统一利用的挑战，知识图谱在知识融合的基础上，基于语义检索、智能问答、图计算、推理、可视化等技术，可以提供统一的数据检索、分析和利用平台。</p></div><h2 id="3-怎样构建知识图谱（How）"><a href="#3-怎样构建知识图谱（How）" class="headerlink" title="3. 怎样构建知识图谱（How）"></a><strong>3. 怎样构建知识图谱（How）</strong></h2><div class="story post-story"><p>本节首先介绍知识图谱的构建流程，然后对其中的技术要点做进一步展开说明。</p><h3 id="3-1-构建流程"><a href="#3-1-构建流程" class="headerlink" title="3.1 构建流程"></a><strong>3.1 构建流程</strong></h3><p>如下图所示，知识图谱的构建流程可分为知识建模、知识获取、知识融合、知识存储/计算、以及知识应用五阶段。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730174755.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730174755.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730174755">1. 在知识建模阶段，需要按照业务需求完成本体设计。 2. 在知识获取阶段，知识获取来源可以是结构化数据、半结构化数据或非结构化数据。其中，对半结构化和非结构化的数据需要经过实体抽取、关系抽取以及属性抽取等处理流程。 3. 在知识融合阶段，主要解决的问题是实体对齐。 4. 在知识存储/计算阶段，知识图谱通常存储在图数据库中，并通过知识表示学习完成进一步的知识推理。 5. 在知识应用阶段，上层应用依赖于知识图谱的底层支持。</p><h3 id="3-2-技术要点"><a href="#3-2-技术要点" class="headerlink" title="3.2 技术要点"></a><strong>3.2 技术要点</strong></h3><p>由上图可知：实体抽取、关系抽取、属性抽取和实体对齐是构建知识图谱的关键环节。由于关系可以看作是一种特殊的属性，关系抽取和属性抽取可归为一类，因此构建知识图谱的技术要点主要有三个：命名实体识别（Named Entity Recognition）、关系抽取（Relation Extraction）、以及实体对齐（Entity Matching）。下面分别介绍这三个技术要点的目标和实现方法。</p><h3 id="3-2-1-命名实体识别"><a href="#3-2-1-命名实体识别" class="headerlink" title="3.2.1 命名实体识别"></a><strong>3.2.1 命名实体识别</strong></h3><p>命名实体识别是自然语言处理中的一项基本任务，目标是从文本中识别出人们关注的实体类型。如下图<a href="https://www.fanzhuoya.com/ai/knowledge-graph/#fn:24" target="_blank" rel="noopener external nofollow noreferrer">24</a>，命名实体一般指的是文本中具有特定意义或者指代性强的实体，通常包括人名、地名、组织机构名、日期时间、专有名词等，在业务需要下也包括人们关注的特定领域内的实体。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730174816.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730174816.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730174816"></p><p>早期的命名实体识别方法多基于规则和字典，后来逐渐出现了基于传统机器学习的方法和基于深度学习的方法。</p><p>在基于传统机器学习的方法中，命名实体识别被看作是序列标注问题：首先利用大规模语料学习标注模型，然后对句子的各个位置进行标注，如生成式模型 HMM、判别式模型 CRF 等。但这些方法存在的问题是严重依赖手工特征，并且需要引入外部资源。</p><p>随着硬件计算能力的发展以及词分布式表示技术的提出，基于深度学习的方法逐渐兴起。目前比较主流的命名实体识别方法是 BiLSTM-CRF 模型<a href="https://www.fanzhuoya.com/ai/knowledge-graph/#fn:18" target="_blank" rel="noopener external nofollow noreferrer">18</a>，其模型架构如下图，主要包括：Embedding 层（主要有词向量、字向量和一些额外特征），BiLSTM 层，以及最后的 CRF 层。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730174835.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730174835.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730174835"></p><p>其中，BiLSTM 可以捕捉上下文的语义信息，只用 BiLSTM 也可以完成命名实体识别任务，处理流程为：首先将每个 token 映射到低维空间中成为稠密的嵌入表示，随后将句子的嵌入表示输入到 BiLSTM 中，用神经网络自动提取特征，随后用 softmax 来预测每个 token 的标签。</p><p>但这种方法的缺点是对每个 token 打标签的过程是独立的，不能直接利用上文已经预测的标签（只能靠隐含状态传递上文信息），从而导致预测出的标签序列可能是无效的，例如标签 I-PER（PER 实体的中间部分）后面不可能紧跟着 B-PER（PER 实体的开始部分），而 softmax 不会利用到这个信息。</p><p>为了避免预测出的标签序列无效，在上图中，BiLSTM 的输出会接入 CRF 层来做句子级别的标签预测。CRF 层使得标注过程不再是对各个 token 独立分类，能够给最终的预测标签添加一些约束以确保其合理有效。</p><p>实验结果表明：BiLSTM-CRF 模型的效果已经达到或者超过了基于丰富特征的 CRF 模型。在特征方面，该模型是一个端到端的模型，无需特征工程，使用词向量以及字符向量就可以达到很好的效果。如果有高质量的词典特征，模型效果能够获得进一步提高。</p><h3 id="3-2-2-关系抽取"><a href="#3-2-2-关系抽取" class="headerlink" title="3.2.2 关系抽取"></a><strong>3.2.2 关系抽取</strong></h3><p>关系抽取的目标是从给定的文本中抽取实体之间的语义关系。如下图<a href="https://www.fanzhuoya.com/ai/knowledge-graph/#fn:25" target="_blank" rel="noopener external nofollow noreferrer">25</a>，关系抽取技术可以从一段新闻文本中抽取出公司实体之间的子公司关系、人物实体之间的好友关系、以及人物与公司之间的任职关系等。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730174847.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730174847.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730174847"></p><p>现有的关系抽取方法主要有两种：流水线模型（Pipeline Model）和联合模型（Joint Model）。</p><p>流水线模型是将关系抽取任务分两步处理，即先进行命名实体识别，然后对识别出的实体两两组合，再进行关系分类。常用的关系分类模型例如 Att-BiLSTM<a href="https://www.fanzhuoya.com/ai/knowledge-graph/#fn:19" target="_blank" rel="noopener external nofollow noreferrer">19</a>，其模型架构如下图。该模型使用 BiLSTM 克服长距离依赖，并引入注意力机制关注重点信息，避免了传统方法复杂的特征设计工作。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730174902.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730174902.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730174902"></p><p>流水线模型可以灵活地选取命名实体识别模型与关系分类模型，但在处理过程中存在如下缺点：</p><p>1)存在误差传递问题，即命名实体识别模型的准确率会影响整体模型的效果；</p><p>2)割裂了实体抽取与关系抽取两个任务的内在联系，忽略了两个任务之间的有用信息，例如已知某两个实体之间存在 Country-President 关系，那么前一个实体必然属于 Location 类型，后一个实体必然属于 Person 类型，流水线模型无法利用这种信息；</p><p>3)信息冗余导致效率低，由于对识别出的实体进行两两组合，然后再进行关系分类，那些没有关系的实体对属于冗余信息，使得效率降低。</p><p>为克服流水线模型的上述问题，研究者提出联合模型，旨在将实体和关系的抽取同时进行，直接抽取得出实体关系三元组。但这种方法的模型结构相对复杂，在实际应用中不一定能取得更优的效果。</p><h3 id="3-2-3-实体对齐"><a href="#3-2-3-实体对齐" class="headerlink" title="3.2.3 实体对齐"></a><strong>3.2.3 实体对齐</strong></h3><p>实体对齐的目标是判断不同数据源指称的实体是否对应现实世界中的同一个实体，又称之为“实体消歧”、“实体消解”或“实体匹配”。例如：当两个数据源融合时，一个数据源中有实体“John Smith”，另一个数据源中有实体“J. Smith”，实体对齐要解决的问题就是从数据中寻找证据，从而判断“John Smith”与“J. Smith”是否对应现实世界中的同一个人。</p><p>实体对齐的方法大致可分为两类：成对实体对齐（Pair-wise Entity Matching）与集体实体对齐（Collective Entity Matching）。成对实体对齐根据两个实体成对属性之间的相似性判断实体是否匹配，但这种方法忽略了实体之间的关系对匹配决策的影响，因而准确率不高。集体实体对齐考虑了实体之间的关系，但是可以同时处理的实体数量有限，可扩展性差。</p><p>因此，有研究者提出了一种基于马尔科夫逻辑网的大规模集体实体对齐框架<a href="https://www.fanzhuoya.com/ai/knowledge-graph/#fn:20" target="_blank" rel="noopener external nofollow noreferrer">20</a>，如下图。该框架主要分为三个步骤：1) 将实体匹配器建模为黑盒；2) 将实体集合划分成不同的邻域（所有邻域的并集覆盖全部实体和关系），并在每个邻域上运行实体匹配器的实例；3) 在实体匹配器实例之间使用消息传递机制。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730175035.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730175035.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730175035"></p><p>上述三个步骤环环相扣，其中步骤 1)满足了框架的通用性，步骤 2)实现了集体实体对齐的可扩展性及可并行化，步骤 3)保证了实体对齐的准确性和完整性。实验结果显示：该框架在准确率、召回率及运行时间方面均取得了较好的性能。</p></div><h2 id="4-知识图谱可以用于哪些金融场景（Where）"><a href="#4-知识图谱可以用于哪些金融场景（Where）" class="headerlink" title="4. 知识图谱可以用于哪些金融场景（Where）"></a><strong>4. 知识图谱可以用于哪些金融场景（Where）</strong></h2><div class="story post-story"><p>在对知识图谱是什么、为什么构建知识图谱、怎样构建知识图谱有一定了解后，下面我们探讨知识图谱可以用于哪些金融场景。本节主要介绍知识图谱在风控、营销以及客服三类金融场景中的应用。</p><h3 id="4-1-风控类应用"><a href="#4-1-风控类应用" class="headerlink" title="4.1 风控类应用"></a><strong>4.1 风控类应用</strong></h3><p>知识图谱的风控类应用<a href="https://www.fanzhuoya.com/ai/knowledge-graph/#fn:23" target="_blank" rel="noopener external nofollow noreferrer">23</a>包括反欺诈、失联客户管理以及企业风险预测等。</p><h3 id="4-1-1-反欺诈"><a href="#4-1-1-反欺诈" class="headerlink" title="4.1.1 反欺诈"></a><strong>4.1.1 反欺诈</strong></h3><p>以网络借贷为例，网络借贷公司可以利用借款人基本信息、资产情况、信用记录以及消费记录等信息，构建借贷人知识图谱。在借贷人知识图谱上进行不一致检验，可以发现可能的个人欺诈或组团欺诈。如下图，张三就职于公司 1，李四就职于公司 2，公司 1 与公司 2 不是同一个，而两人却留了相同的公司电话，这就产生了不一致，说明可能存在欺诈风险。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730175047.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730175047.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730175047">另外，在借贷人知识图谱上进行社区检测，可以找出可能的风险团体。如下图，在借贷人知识图谱中，李四与张三是朋友关系，张三与王五是朋友关系，李四的父亲李明为王五提供了担保，因此这四个人构成了强连通图，属于一个社区。如果在这个社区中，张三存在着失信记录，那么这四个人构成的团体也可能存在着失信风险。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730175056.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730175056.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730175056"></p><h3 id="4-1-2-失联客户管理"><a href="#4-1-2-失联客户管理" class="headerlink" title="4.1.2 失联客户管理"></a><strong>4.1.2 失联客户管理</strong></h3><p>在网络借贷中，反欺诈属于贷前环节，失联客户管理则属于贷后环节。在贷后失联客户管理的问题上，利用知识图谱可以挖掘失联客户的潜在联系人，从而提高催收的成功率。如下图，已知公司 B 的法人张三贷后失联。从知识图谱中挖掘出李四曾经是公司 B 的法人，且李四与张三曾经存在夫妻关系，因此推断出李四为张三的潜在联系人，可以尝试通过李四联系张三。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730175105.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730175105.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730175105"></p><h3 id="4-1-3-企业风险预测"><a href="#4-1-3-企业风险预测" class="headerlink" title="4.1.3 企业风险预测"></a><strong>4.1.3 企业风险预测</strong></h3><p>利用丰富多维度的企业公开信息可以构建企业知识图谱<a href="https://www.fanzhuoya.com/ai/knowledge-graph/#fn:1" target="_blank" rel="noopener external nofollow noreferrer">1</a>。企业知识图谱主要由企业、人物、专利等实体构成，关注企业与人物之间任职及股权关系、专利与企业人物的所属权关系等。如下图，企查查<a href="https://www.fanzhuoya.com/ai/knowledge-graph/#fn:26" target="_blank" rel="noopener external nofollow noreferrer">26</a>立足于企业征信，通过深度学习、特征抽取以及知识图谱技术对相关信息进行整合，并向用户提供数据信息。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730175119.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730175119.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730175119"></p><p>上述企业知识图谱可以辅助完成企业风险预测，流程如下图所示：首先从企业资讯、社会舆情以及行业热点中监测到企业 A 发生某事件；然后在企业知识图谱中，通过企业关联分析找出企业 A 的上下游产业链、子母公司、合作公司以及对手公司等，分析该事件对这些相关企业的影响，进而进行风险预警。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730175131.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730175131.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730175131"></p><h3 id="4-2-营销类应用"><a href="#4-2-营销类应用" class="headerlink" title="4.2 营销类应用"></a><strong>4.2 营销类应用</strong></h3><p>知识图谱的营销类应用主要表现为个性化推荐，如文献<a href="https://www.fanzhuoya.com/ai/knowledge-graph/#fn:21" target="_blank" rel="noopener external nofollow noreferrer">21</a>针对证券公司向用户推荐金融新闻以吸引投资特定股票的场景，提出了一种如下图所示的基于知识图谱及图嵌入的金融新闻推荐框架，以期克服金融新闻推荐的难点：1)金融新闻涉及面广，新闻包含与公司、股票相关的外部知识；2)读者兴趣难刻画，金融新闻的读者通常同时对多个特定的公司、股票和行业感兴趣；3)金融新闻的时效性强，存在在线更新问题。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730175144.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730175144.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730175144"></p><p>该框架主要分为两部分：一是基于图嵌入的新闻推荐模型（Node2vec-based News Recommendation, NNR），二是增量更新模型（Incremental NNR, INNR）。</p><p>NNR 模型框架如下图所示：在图构建阶段，首先构建证券子图、用户子图及新闻子图，然后将三个子图连接起来构成知识图谱；在嵌入训练阶段，使用 Node2Vec 训练图嵌入表示（也可换用其他的图嵌入算法）；在新闻推荐阶段，计算用户嵌入与新闻嵌入的余弦相似度，推荐相似度最高的前 k 条新闻。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730175156.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730175156.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730175156"></p><p>INNR 模型框架如下图所示。由于金融新闻在线更新，训练全部千亿级别实体的图嵌入计算代价大，因此 INNR 选择实体较少发生改变的证券子图作为核心图，只训练核心图的嵌入表示。然后，基于核心图嵌入，INNR 使用多种策略来表示新用户或者新的新闻，从而解决用户冷启动及新闻冷启动的问题。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730175209.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730175209.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730175209"></p><p>以上应用知识图谱的金融新闻推荐框架，将基于 node2vec 的推荐方法与增量更新方法结合，可以较好地平衡推荐效率和推荐准确度。</p><h3 id="4-3-客服类应用"><a href="#4-3-客服类应用" class="headerlink" title="4.3 客服类应用"></a><strong>4.3 客服类应用</strong></h3><p>知识图谱的客服类应用主要表现为智能问答。基于文档的问答是智能问答的一个场景，系统面临的挑战则在于需要在包含多实体和关系的情况下直接应答。这个问题在需要解决基于多文档应答的情况下尤为显著。基于知识图谱的问答系统可能会给出较好的答案，但仍会受限于图谱固有的不完整性和延时性。</p><p>为此，支付宝 AI 工程师提出了 QUEST<a href="https://www.fanzhuoya.com/ai/knowledge-graph/#fn:22" target="_blank" rel="noopener external nofollow noreferrer">22</a>，一种能够基于即时文本来源，通过计算不同文档的部分结果相似性直接回答复杂问题的方法。QUEST 用节点和带权重的边构建了一个带噪声的类知识图谱，其由动态检索的实体名称和关系短语组成。这个类知识图谱又用实体类型和语义对齐进行了扩充，然后用 Group Steiner Tree 算法计算最佳答案。这种方法是无监督的，不存在训练数据瓶颈，从而能够应对在用户问题当中快速变化的特定主题和表达风格。实验结果表明：QUEST 在处理复杂问题时的效果远超目前的最优基线系统。</p></div><h2 id="5-总结与展望"><a href="#5-总结与展望" class="headerlink" title="5. 总结与展望"></a><strong>5. 总结与展望</strong></h2><div class="story post-story"><p>本文介绍了知识图谱的技术背景及其在金融场景中的应用。其风控类应用主要有反欺诈、失联客户管理以及企业风险预测，营销类应用主要表现为个性化推荐，客服类应用主要表现为智能问答。其他类的应用诸如智能投顾、智能投研等，在此不一一阐述。未来将会出现更多应用形态，如基于知识图谱的智能文本编制，通过知识图谱将行业中的业务知识与文档相结合，在文档编制过程中，进行实时的智能提示、知识校验、知识生产等，辅助文档编制。</p><p>总而言之，知识图谱在金融领域大有可为，但不可忽视的是，知识图谱的全面落地仍然面临诸多挑战，比如：领域知识复杂难以集成，数据的深层关系难抽取，生成的策略仅能辅助决策等。随着知识图谱构建技术的不断发展和对应用场景的持续探索，相信知识图谱能够在金融领域进一步解放生产力，助力业务转型。</p></div>]]></content>
    
    
    <summary type="html">知识图谱旨在对现实世界中的实体或概念及其之间的关系进行建模，是一种新的海量数据组织、管理和利用方式。自2012年谷歌推出知识图谱以来，它在学术界和工业界掀起了一股热潮，已经在许多领域扮演着重要角色。本文重点关注知识图谱在金融领域的应用，首先从知识图谱是什么（What），为什么要构建知识图谱（Why），怎样构建知识图谱（How）的逻辑出发，介绍知识图谱的技术背景；然后对知识图谱的金融应用场景（Where）加以探讨和展望。</summary>
    
    
    
    <category term="知识图谱" scheme="https://kobingogo.github.io/categories/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
    
    <category term="知识图谱" scheme="https://kobingogo.github.io/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
  </entry>
  
  <entry>
    <title>React Native学习笔记</title>
    <link href="https://kobingogo.github.io/framework-RN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://kobingogo.github.io/framework-RN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2023-08-01T16:48:35.000Z</published>
    <updated>2024-08-08T10:31:05.013Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-Native-介绍"><a href="#React-Native-介绍" class="headerlink" title="React Native 介绍"></a>React Native 介绍</h2><div class="story post-story"><h3 id="什么是-React-Native？"><a href="#什么是-React-Native？" class="headerlink" title="什么是 React Native？"></a>什么是 React Native？</h3><p>React Native 是 Facebook 于 2015 年推出的一款开源 JavaScript 框架，旨在让开发者使用 JavaScript 和 React 创建跨平台的移动应用。它结合了 React 的开发效率与 Native 应用的优良用户体验，通过 Virtual DOM 实现了真正意义上的“Learn Once, Write Anywhere”。</p><h3 id="React-Native-的特点"><a href="#React-Native-的特点" class="headerlink" title="React Native 的特点"></a>React Native 的特点</h3><h4 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a><strong>跨平台</strong></h4><p>使用 Virtual DOM 技术，只需编写一套代码，即可生成适用于不同平台的应用，极大地提高了开发效率，并降低了维护成本。</p><h4 id="学习门槛低"><a href="#学习门槛低" class="headerlink" title="学习门槛低"></a><strong>学习门槛低</strong></h4><p>JavaScript 的学习成本相对较低，语法灵活。Web 开发者可以利用现有经验快速上手 React Native，若熟悉 React，即可快速掌握 React Native。</p><h4 id="原生应用体验"><a href="#原生应用体验" class="headerlink" title="原生应用体验"></a><strong>原生应用体验</strong></h4><p>React Native 提供的组件是对原生 API 的封装，尽管使用 JavaScript 编写代码，最终调用的还是原生 API 和 UI 组件，因此在体验和性能上接近原生应用。</p><h4 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a><strong>热更新</strong></h4><p>React Native 应用支持热更新，开发者只需更新 bundle 文件，而无需用户重新下载整个应用即可实现功能迭代或 bug 修复。不过，App Store 对调用私有 API、修改原生代码和改变应用行为的热更新有一定限制。</p></div><h2 id="React-Native-原理"><a href="#React-Native-原理" class="headerlink" title="React Native 原理"></a>React Native 原理</h2><div class="story post-story"><h3 id="JavaScriptCore"><a href="#JavaScriptCore" class="headerlink" title="JavaScriptCore"></a><strong>JavaScriptCore</strong></h3><p>JavaScriptCore 是 React Native 使用的 JavaScript 引擎，负责解析和执行 JS 代码。React Native 利用 JavaScriptCore 的能力，通过 Bridge 与原生代码进行交互，实现 UI 渲染和功能调用。</p><p><strong>JS Engine</strong></p><p>React Native 需要一个 JS 的运行环境，因为 React Native 会把应用的 JS 代码编译成一个 JS 文件（x x.bundle），React Native 框架的目标就是解释运行这个 JS 脚本文件，如果是 Native 拓展的 API，则直接通过 bridge 调用 Native 方法，最基础的比如绘制 UI 界面，映射 Virtual DOM 到真实的 UI 组件中。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240731165137.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240731165137.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240731165137"></p><p>绿色的是我们应用开发的部分，我们写的代码基本上都是在这一层。</p><p>蓝色代表公用的跨平台的代码和工具引擎，一般我们不会动蓝色部分的代码。</p><p>黄色代表平台相关的 bridge 代码，做定制化的时候会添加修改代码。</p><p>红色代表系统平台的功能，另外红色上面有一个虚线，表示所有平台相关的东西都通过 bridge 隔离开来了，红色部分是独立于 React Native 的。</p><p><strong>脱离 React Native，纯原生端是如何与 JS 交互的？来看下 iOS 里面是如何实现的。</strong></p><p>在 Native 创建一个 JS 上下文：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个ctx的JS上下文</span><br><span class="line">JSContent *ctx = [[JSContent alloc] init];</span><br><span class="line">// 创建一个变量name</span><br><span class="line">[ctx evaluateScript:@&quot;var name = &#x27;Hellen&#x27;&quot;];</span><br><span class="line">// 创建一个方法</span><br><span class="line">[ctx evaluateScript:@&quot;var hello = function(name) &#123; return &#x27;hello &#x27; + name &#125;&quot;];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Native 调用 JavaScript 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 通过ctx上下文对象，获取到hello方法</span><br><span class="line">JSValue *helloFUnction = ctx[@&quot;hello&quot;];</span><br><span class="line">// 运行js方法</span><br><span class="line">JSValue *greetings = [helloFunction callWithArguments:@[@&quot;bytedancers&quot;]; // hello bytedancers</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所以，JavaScript 代码只要将变量暴露在 JS 上下文全局，Native 就能获取到，并运行 JS 的代码。</p><p>JavaScript 调用 Native，首先需要在 Native 端，将一个变量暴露在 JS 上下文全局，在 JavaScript 全局变量里面就能获取到并执行这个方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ctx[@&quot;createdByNative&quot;] = ^(NSString *name) &#123;</span><br><span class="line">    // do something</span><br><span class="line">    return someResult</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>React Native 同样借助 JS Engine 的能力，基于 JavaScriptCore 来执行 JS，但是是通过 Bridge 来进行交互的，JS 不会直接引用 Native 层的对象实例，Native 也不会直接引用 JS 层的对象实例(在 React Native 里所有 Native 和 JS 互调都是通过 Bridge 层的几个最基础的方法衔接的)。</p><p><strong>Hermes Engine</strong></p><p>Hermes 是 Facebook 在 2019 年发布的轻量级 JavaScript 引擎，专为 React Native 优化，特别是提升了 Android 平台上的启动速度、内存占用和应用大小。</p><p><strong>Hermes vs JavaScriptCore vs V8</strong></p><p>经过官方的数据验证，Faceback 团队提出的关键性指标相较于原先的 JavaScriptCore 方案都有了显著提高。首先，是产物文件的大小方面，RN 所依赖的必要 so 库，Hermes 比 JavaScriptCore 减少了约 16%，V8 则要远大于 Hermes 和 JavaScriptCore。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240731165309.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240731165309.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240731165309"></p><h3 id="Bridge"><a href="#Bridge" class="headerlink" title="Bridge"></a>Bridge</h3><p>React Native 中的 Bridge 用于连接 JavaScript 和原生代码。所有的本地存储、图片资源访问、图形绘制、网络访问等功能，都是通过 Bridge 封装成 JS 接口提供给 JavaScript 使用。Bridge 隔离了 JS 和原生代码，确保两者之间的通信是安全且高效的。</p><p><strong>React Native 中的 Native 模块如何暴露给 JS？</strong></p><p>我们知道，React Native 可以调用 Native 侧的方法，并且只要 Native 侧只要遵循一定的规则，是可以将方法暴露给 JS 调用的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// iOS端原生代码</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;React/RCTBridgeModule.h&gt;</span><br><span class="line"></span><br><span class="line">@interface NativeLogModule : NSObject&lt;RCTBridgeModule&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#import &quot;NativeLogBridge.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation NativeLogModule</span><br><span class="line">RCT_EXPORT_MODULE()</span><br><span class="line">RCT_EXPORT_METHOD(nativeLog:(id)obj) &#123;</span><br><span class="line">  NSLog(@&quot;%@&quot;,obj);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// JS端调用</span><br><span class="line">import &#123; NativeModules &#125; from &#x27;react-native&#x27;;</span><br><span class="line">NativeModules.NativeLogModule.nativeLog(&#x27;从JS侧来的消息&#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，上面的代码中使用了<strong>RCT_EXPORT_MODULE()</strong> 宏将 Native 类以 module 的形式暴露给了 JS，然后使用了<strong>RCT_EXPORT_METHOD</strong>将 Native 的方法暴露给 JS，最后在 JS 侧直接引用一个模块，便可以直接调用暴露的方法与 Native 通信。</p><p><strong>React Native 是如何实现 Native &lt;---&gt; JS 通信的呢？</strong></p><p>上面我们有提到 JS Engine，Native 可以把原生方法暴露到全局，同样的 JS 也可以把方法暴露给 Native，但是 React Native 并没有这样做，原因之一是这样会导致大量的全局变量污染，所以为了规范这个通信过程，React Native 自己实现了 Bridge。</p><p><strong>Native 调用 JS</strong></p><p>在 React Native 里面，JS 的方法可以通过 <code>global.batchedBridge.callFunctionReturnFlushedQueue</code> 这个方法进行调用，所以在 Native 侧，只需将 React Native 里面的 global.batchedBridge 对象中的方法和 Native 侧的 JSIExecutor 方法进行绑定（本质上 Native 指针指向 JS 函数）</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSIExecutor::<span class="attr">callFunctionReturnFlushedQueue_</span> = global.batchedBridge.callFunctionReturnFlushedQueue</span><br></pre></td></tr></table></figure><p>Native 侧的 callFunctionReturnFlushedQueue 主要做了这样的事情：</p><ul><li>通过 moduleid 和 methodid 完成方法的调用，通过这两个参数可以找到 JS 侧定义的方法模块。</li></ul><p><strong>JS 调用 Native</strong></p><p>当 JS 调用 Native 模块的时候，会调用一个 Native 暴露出来的全局方法：nativeFlushQueueImmediate，并通过传入要调用的 moduleName 、methodName、callback 参数给这个方法，然后这个方法再通知给 Native 侧找到相应的模块并执行。</p><h3 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h3><p>在认识 Virtual DOM 之前，我们先来看看浏览器的工作原理：</p><ul><li><p>浏览器有一套完整的 UI 控件，样式和功能都是按照 HTML 标准实现的。</p></li><li><p>浏览器能够解析 HTML 和 CSS，通过 HTML 告诉浏览器需要生成什么类型的 UI 控件，并通过 CSS 样式文件来描述该 UI 控件的外观（大小，背景，布局等等...）。</p></li><li><p>浏览器的主要作用就是解析 HTML 和 CSS 来形成渲染树，并通过 Render Engine 将页面渲染出来。</p></li></ul><p>了解浏览器的工作原理之后，Virtual DOM 是如何工作的？</p><ul><li><p>首先 Virtual DOM 和真实 DOM 都有一个共同点：都是用来描述页面 UI 控件。</p></li><li><p>Virtual DOM 具有平台无关性：它描述的 UI 控件只是数据结构层的，具体渲染工作是交给了原生渲染引擎（浏览器、iOS、Android）去处理。</p></li></ul><p><strong>React (Native)的 Virtual DOM</strong></p><p>在 React Native 里面，是如何把 Virtual DOM 渲染成真实的 UI 的呢？</p><p>首先，在 React 里面，用来表示 dom 属性的对象有以下关键属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var ele = &#123;</span><br><span class="line">    ...</span><br><span class="line">    type: type, // 元素的类型</span><br><span class="line">    key: key, // 元素key标示</span><br><span class="line">    ref: ref, // 元素的引用</span><br><span class="line">    props: props, // 元素的参数，包含children</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// example 1</span><br><span class="line">&lt;div&gt;hello&lt;/div&gt;</span><br><span class="line">// 会被描述为</span><br><span class="line"></span><br><span class="line">&#123;type: &#x27;div&#x27;,</span><br><span class="line">    props: &#123;</span><br><span class="line">        children: [&#x27;hello&#x27;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// example 2</span><br><span class="line">&lt;CustomerComponents /&gt;</span><br><span class="line">// 会被描述为</span><br><span class="line">&#123;</span><br><span class="line">    type: CustomerComponents</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>React 里面的 Virtual DOM 把真实 DOM 分为了以下几种类型：</p><ul><li><p>原子类型</p><ul><li>类型为字符串，结构上不可再分解，渲染由平台底层支持。</li><li>在浏览器端：原子类型表示为浏览器支持的原始标签，例如 div、ul、li、p、a、span 等等。</li><li>在 Native 端：原子类型表示为 Native 端的各种基础 UI 组件，例如 RCTText、RCTView 等等</li></ul></li><li><p>组合类型</p><ul><li>类型为函数构造器，它给我们提供了一种自定义元素 UI 和行为的能力，当渲染器遇到组合类型的元素时，会使用它的构造器创建一个实例并运行 render 方法得到一个新元素（原子类型，或者组合类型），然后再拿该元素继续进行渲染或者分解。</li><li>用户自定义的组件元素。</li></ul></li></ul><p><strong>渲染器</strong></p><p>在浏览器端和 Native 端，React (Native)中 Virtual DOM 用来渲染真实 DOM 的渲染器是不一样的：</p><p>在浏览器端：</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240731165723.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240731165723.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240731165723"></p><figure class="highlight plaintext"><figcaption><span>文本类型渲染器工作原理</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">mountComponent: function(</span><br><span class="line">    transaction,</span><br><span class="line">    hostParent,</span><br><span class="line">    hostContainerInfo,</span><br><span class="line">    context</span><br><span class="line">) &#123;</span><br><span class="line">    // 获取到DOM对象</span><br><span class="line">    var lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());</span><br><span class="line">    // 判断是不是文本类型</span><br><span class="line">    if (this._stringText) &#123;</span><br><span class="line">        DOMLazyTree.queueChild(</span><br><span class="line">            lazyTree,</span><br><span class="line">            DOMLazyTree(ownerDocument.createTextNode(this._stringText))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    return lazyTree</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 原子类型渲染器工作原理</span><br><span class="line">mountComponent: function(</span><br><span class="line">    transaction,</span><br><span class="line">    hostParent,</span><br><span class="line">    hostContainerInfo,</span><br><span class="line">    context</span><br><span class="line">) &#123;</span><br><span class="line">    var ownerDocument = hostContainerInfo._ownerDocument;</span><br><span class="line">    // 创建原子type类型dom</span><br><span class="line">    var el =</span><br><span class="line">ownerDocument.createElement(this._currentElement.type)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 创建子节点</span><br><span class="line">    this._createInitialChildren(transaction, props, context, lazyTree);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 组合类型渲染器工作原理</span><br><span class="line">mountComponent: function(</span><br><span class="line">    transaction,</span><br><span class="line">    hostParent,</span><br><span class="line">    hostContainerInfo,</span><br><span class="line">    context</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    // 运行构造器，获取到组件实例</span><br><span class="line"></span><br><span class="line">    var inst = this._constructComponent(&#123;</span><br><span class="line">        doConstruct,</span><br><span class="line">        publicProps,</span><br><span class="line">        publicContext,</span><br><span class="line">        updateQueue,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 获取到虚拟dom</span><br><span class="line">    if (renderedElement === undefined) &#123;</span><br><span class="line">      renderedElement = this._renderValidatedComponent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 获取到分解后的组件类型（ReactXXXComponent,可以看作是三种组件类型的集合）</span><br><span class="line">    this._renderedComponent = this._instantiateReactComponent(</span><br><span class="line">      renderedElement</span><br><span class="line">    );</span><br><span class="line">    // 最后通过ReactReconciler.mountComponent间接的调用不同类型的渲染器的mountComponent方法获取到生产的node节点，并返回。</span><br><span class="line">    var markup = ReactReconciler.mountComponent(</span><br><span class="line">      this._renderedComponent,</span><br><span class="line">      rootID,</span><br><span class="line">      transaction,</span><br><span class="line">      this._processChildContext(context)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    return markup</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看以下代码结构：</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240731165823.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240731165823.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240731165823"></p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240731165832.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240731165832.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240731165832"></p><p>在 Native 端：</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240731165846.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240731165846.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240731165846"></p><p>在浏览器里面，JavaScript 可以调用 DOM API 去完成创建 UI 的工作，而在 React Native 里面，是通过 UI Manager 来创建视图的，基于 Virtual DOM ，React Native 把不同平台创建视图的逻辑封装了一层，不同平台通过 Bridge 调用 UI Manager 来创建不同的 Native 视图。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240731165857.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240731165857.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240731165857"></p><p><strong>三个线程</strong></p><p>在 React Native 里面，真正有三个重要的线程在执行，他们分别是 Shadow thread、UI thread 和 JS thread。</p><p><strong>JS thread：</strong> 其实是 JavaScript 线程，负责 JS 和原生代码的交互线程，因为 JS 是单线程模型，所以需要一个单独的线程来驱动，并且 JS 和 Native 交互是异步的。</p><p><strong>Shadow thread</strong>: 这个线程是负责 Native 布局，提供给 yoga 引擎使用。</p><p><strong>UI thread</strong>：这个可以看作是主线程，可以看作是 UI Manager 线程，负责页面的交互和控件绘制逻辑。</p><h3 id="热更新-1"><a href="#热更新-1" class="headerlink" title="热更新"></a>热更新</h3><p>React Native 的 bundle 文件是 JS 逻辑代码与 React Native 运行时的集合，应用启动时会获取最新的 bundle 文件，从而实现热更新。开发者可以通过云端更新 bundle 文件，实现无感知的功能更新和 bug 修复。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240731165934.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240731165934.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240731165934"></p><p><strong>增量更新（拆包）</strong></p><p>对于 React Native 的代码打包之后只会生成一个 Bundle 文件，这里面包含了基础业务逻辑、React Native 的基础库类，所以我们可以把一个包拆分成：一个基础包+ n 个业务包，其中基础包是不变的，这就是 runtime，业务包就是具体的业务，后面如果有更新，也只需要再打出一个业务包就行。</p><p>目前行业的解决方案有 facebook 官方提供的 metro bundle：<a href="https://facebook.github.io/metro/" target="_blank" rel="noopener external nofollow noreferrer">facebook.github.io/metro/</a></p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240731170019.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240731170019.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240731170019"></p></div><h2 id="总结-amp-拓展"><a href="#总结-amp-拓展" class="headerlink" title="总结 &amp; 拓展"></a>总结 &amp; 拓展</h2><div class="story post-story"><h3 id="React-Native-的不足"><a href="#React-Native-的不足" class="headerlink" title="React Native 的不足"></a>React Native 的不足</h3><p>由于 React Native 和原生交互依赖的只有一个 Bridge，而且 JS 和 Native 交互是异步的，所以对需要和 Native 大量实时交互的功能可能会有性能上的不足，比如动画效率，<strong>性能是不如原生的</strong>。</p><p>React Native 始终是依赖原生的能力，所以摆脱不了对原生的依赖，相对 Flutter 的自己来画 UI 来说，React Native 显得有些尴尬。</p><h3 id="React-Native-的未来"><a href="#React-Native-的未来" class="headerlink" title="React Native 的未来"></a>React Native 的未来</h3><p><strong>JSI 是什么？</strong></p><p>在 RN 中， JSI 是 JavaScript Interface 的缩写，JSI 是 React Native 未来发展的一个关键技术，JSI 是一个轻量级的通用的 API 框架，可以在任何 JavaScript 虚拟机中使用，通过 JSI，JavaScript 和 Native 代码可以直接交互，无需通过 JSON 序列化传递消息，从而消除了 Bridge 的性能瓶颈</p><p>JSI 是用 C++写的，用于取代原先的 bridge，提高通信效率，已在 RN 的 <code>0.58</code> 中实现。</p><p><strong>JSI 能做什么？</strong></p><p>JSI 本身不是 React Native 的一部分——它是一个统一的、轻量的、通用适用于任何(理论上) JavaScript 虚拟机的接口层。</p><p>当把 JSI 加入到新架构中后，它使得一些真正重要的改进成为可能。</p><p>第一个改进很直观——javaScriptCore 现在可以更容易地被替换成其它引擎，其它选项包括微软的 ChakraCore 和谷歌的 V8。</p><p>第二个改进，可以说是整个新架构的基石，是通过使用 JSI，JavaScript 可以持有对 C++ 宿主对象的引用，并且对它进行调用。</p><p>这意味着：JavaScript 和 Native 之间真正地相互知晓，并且不再需要通过 JSON 序列化传递消息，这会消除 Bridge 的阻塞问题。</p><h3 id="和其他跨端技术比较"><a href="#和其他跨端技术比较" class="headerlink" title="和其他跨端技术比较"></a>和其他跨端技术比较</h3><p><strong>Flutter vs React Native</strong></p><p>首先来简单了解下 Flutter 和 React Native 的背景，Flutter 是由谷歌开发的软件开发工具包（SDK）。它可以帮助开发人员使用单一代码库构建 iOS 和 Android 应用程序。React Native 与 Flutter 具有相同的目的，但方式不同。它是由 Facebook 建立的，基于 React 用于创建移动应用程序，而不会影响应用程序的外观和感觉。</p><p><strong>开发体验</strong></p><p>React Native 延续了 React 的开发风格，支持 CSS-in-JS 和 React Hooks。Flutter 则将所有 UI 元素封装为 Widget，虽然提供了丰富的组件库，但代码嵌套可能显得复杂。</p><p><strong>状态管理</strong></p><p>两者的状态管理方式类似，都支持获取和设置组件状态来更新 UI。</p><p><strong>产物</strong></p><p>React Native 产生的是 bundle 文件，实际上就是 JS bundle 文件；而 Flutter 编译后 Android 产生的主要是一些应用程序指令段、数据段，虚拟机数据段、指令段，iOS 则是 App.framework，其实也是一些原生的数据集。</p><p><strong>原生能力 &amp; 性能</strong></p><p>React Native 由于需要通过 Bridge 与原生代码交互，因此性能稍逊于 Flutter，但在灵活性上略有优势。</p><p>总的来说，React Native 和 Flutter 各有所长，开发者可根据项目需求选择合适的框架。</p></div>]]></content>
    
    
    <summary type="html">React Native 是 Facebook 于 2015 年推出的一款开源 JavaScript 框架，旨在让开发者使用 JavaScript 和 React 创建跨平台的移动应用。它结合了 React 的开发效率与 Native 应用的优良用户体验，通过 Virtual DOM 实现了真正意义上的“Learn Once, Write Anywhere”。</summary>
    
    
    
    <category term="React" scheme="https://kobingogo.github.io/categories/react/"/>
    
    
    <category term="React Native" scheme="https://kobingogo.github.io/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title>深入分析当前主流的微前端方案及其实现原理</title>
    <link href="https://kobingogo.github.io/framework-%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E5%BD%93%E5%89%8D%E4%B8%BB%E6%B5%81%E7%9A%84%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%96%B9%E6%A1%88%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://kobingogo.github.io/framework-%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E5%BD%93%E5%89%8D%E4%B8%BB%E6%B5%81%E7%9A%84%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%96%B9%E6%A1%88%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2023-02-13T11:56:26.000Z</published>
    <updated>2024-08-08T10:31:05.013Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深入分析当前主流的微前端方案及其实现原理"><a href="#深入分析当前主流的微前端方案及其实现原理" class="headerlink" title="深入分析当前主流的微前端方案及其实现原理"></a>深入分析当前主流的微前端方案及其实现原理</h2><div class="story post-story"><p>随着前端应用的复杂性增加和团队协作需求的提升，微前端架构成为解决大规模前端项目开发和维护的有效方案。微前端架构允许将一个大型前端应用分解为多个独立开发、独立部署的小型应用，从而提高开发效率和可维护性。本文将深入分析当前主流的微前端方案，包括其实现原理和使用方法。</p><h3 id="1-Single-SPA"><a href="#1-Single-SPA" class="headerlink" title="1. Single-SPA"></a>1. <strong>Single-SPA</strong></h3><p><strong>实现原理：</strong></p><p>Single-SPA 是一个微前端框架，它的核心思想是允许多个前端框架（如 React、Vue、Angular 等）在同一个页面中共存，并且这些应用之间互不干扰。Single-SPA 通过子应用注册、应用激活和挂载等机制，实现对各子应用的加载和渲染管理。</p><ul><li><strong>应用注册</strong>：开发者在入口文件中通过 <code>registerApplication</code> 方法注册各个子应用，指定加载条件和加载函数。</li><li><strong>应用激活</strong>：当用户的导航行为满足某个子应用的激活条件时，Single-SPA 会加载和渲染该子应用。</li><li><strong>应用挂载与卸载</strong>：Single-SPA 会在子应用激活时挂载该应用，并在导航到其他子应用时卸载当前应用。</li></ul><p><strong>使用方法：</strong></p><p>首先，通过 npm 安装 single-spa：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install single-spa</span><br></pre></td></tr></table></figure><p>然后，在主应用中注册子应用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; registerApplication, start &#125; <span class="keyword">from</span> <span class="string">&#x27;single-spa&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">registerApplication</span>(</span><br><span class="line">    <span class="string">&#x27;app1&#x27;</span>,</span><br><span class="line">    <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;app1/App1&#x27;</span>), <span class="comment">// 子应用加载函数</span></span><br><span class="line">    <span class="function"><span class="params">location</span> =&gt;</span> location.<span class="property">pathname</span>.<span class="title function_">startsWith</span>(<span class="string">&#x27;/app1&#x27;</span>) <span class="comment">// 激活条件</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="title function_">registerApplication</span>(</span><br><span class="line">    <span class="string">&#x27;app2&#x27;</span>,</span><br><span class="line">    <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;app2/App2&#x27;</span>),</span><br><span class="line">    <span class="function"><span class="params">location</span> =&gt;</span> location.<span class="property">pathname</span>.<span class="title function_">startsWith</span>(<span class="string">&#x27;/app2&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="title function_">start</span>(); <span class="comment">// 启动 Single-SPA</span></span><br></pre></td></tr></table></figure><h3 id="2-Qiankun"><a href="#2-Qiankun" class="headerlink" title="2. Qiankun"></a>2. <strong>Qiankun</strong></h3><p><strong>实现原理：</strong></p><p>Qiankun 是基于 Single-SPA 的微前端框架，提供了更友好的 API 和更加完善的沙盒机制。Qiankun 主要通过加载器和沙盒机制来管理子应用的生命周期和隔离性。</p><h4 id="沙盒机制的实现原理："><a href="#沙盒机制的实现原理：" class="headerlink" title="沙盒机制的实现原理："></a>沙盒机制的实现原理：</h4><p>Qiankun 的沙盒机制确保了每个子应用的运行环境是隔离的，即使多个子应用共享同一个页面也不会互相干扰。沙盒机制包括以下几种类型：</p><ol><li><p><strong>Proxy 沙盒</strong>：这是 Qiankun 使用的默认沙盒机制。Proxy 沙盒利用 JavaScript 的 Proxy 对象拦截全局对象的操作，将对子应用的全局变量的访问和修改操作限制在沙盒范围内。这样，即使多个子应用使用相同的全局变量名称，它们之间也不会产生冲突。</p></li><li><p><strong>Snapshot 沙盒</strong>：这种沙盒机制在进入和退出子应用时记录和恢复全局对象的状态。虽然 Snapshot 沙盒可以提供隔离，但它更适合于低频切换的场景。</p></li><li><p><strong>沙盒的启动和卸载</strong>：每当一个子应用被加载和挂载时，Qiankun 会启动沙盒，捕获和管理全局变量的修改。子应用被卸载时，沙盒会还原之前保存的全局状态。</p></li></ol><h4 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h4><p>首先，安装 Qiankun：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install qiankun</span><br></pre></td></tr></table></figure><p>然后，在主应用中注册和启动子应用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; registerMicroApps, start &#125; <span class="keyword">from</span> <span class="string">&#x27;qiankun&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">registerMicroApps</span>([</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;app1&#x27;</span>,</span><br><span class="line">        <span class="attr">entry</span>: <span class="string">&#x27;//localhost:7100&#x27;</span>,</span><br><span class="line">        <span class="attr">container</span>: <span class="string">&#x27;#container&#x27;</span>,</span><br><span class="line">        <span class="attr">activeRule</span>: <span class="string">&#x27;/app1&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;app2&#x27;</span>,</span><br><span class="line">        <span class="attr">entry</span>: <span class="string">&#x27;//localhost:7200&#x27;</span>,</span><br><span class="line">        <span class="attr">container</span>: <span class="string">&#x27;#container&#x27;</span>,</span><br><span class="line">        <span class="attr">activeRule</span>: <span class="string">&#x27;/app2&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="title function_">start</span>();</span><br></pre></td></tr></table></figure><h3 id="3-Webpack-Module-Federation"><a href="#3-Webpack-Module-Federation" class="headerlink" title="3. Webpack Module Federation"></a>3. <strong>Webpack Module Federation</strong></h3><p><strong>实现原理：</strong></p><p>Webpack 5 引入了 Module Federation 特性，使得不同的前端应用可以共享代码模块。Module Federation 允许应用动态加载其他应用的模块，实现代码共享和按需加载。</p><ul><li><strong>远程模块</strong>：定义共享的模块以及从其他应用加载的模块。</li><li><strong>共享模块</strong>：指定多个应用共享的模块，如 React 或 Vue 之类的库，以避免重复加载。</li></ul><p><strong>使用方法：</strong></p><p>首先，在 Webpack 配置中设置 Module Federation：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ModuleFederationPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>).<span class="property">container</span>.<span class="property">ModuleFederationPlugin</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ModuleFederationPlugin</span>(&#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;app1&#x27;</span>,</span><br><span class="line">            <span class="attr">filename</span>: <span class="string">&#x27;remoteEntry.js&#x27;</span>,</span><br><span class="line">            <span class="attr">exposes</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;./Component&#x27;</span>: <span class="string">&#x27;./src/Component&#x27;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">shared</span>: [<span class="string">&#x27;react&#x27;</span>, <span class="string">&#x27;react-dom&#x27;</span>],</span><br><span class="line">        &#125;),</span><br><span class="line">    ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后，在需要使用共享模块的应用中，动态加载模块：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">RemoteComponent</span> = <span class="title class_">React</span>.<span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;app1/Component&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">React.Suspense</span> <span class="attr">fallback</span>=<span class="string">&quot;Loading...&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">RemoteComponent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">React.Suspense</span>&gt;</span></span>,</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>微前端架构为现代前端开发提供了灵活的解决方案，允许不同团队独立开发、测试和部署各自的子应用。Single-SPA 提供了基础的微前端实现，Qiankun 在此基础上增加了更强的隔离性和开发体验，而 Webpack Module Federation 则提供了强大的模块共享机制。在选择微前端方案时，应根据项目的具体需求、团队技术栈以及开发流程来决定。</p><p>这些微前端方案各有优缺点，选择适合的方案可以显著提高团队的开发效率和代码可维护性。</p></div>]]></content>
    
    
    <summary type="html">随着前端应用的复杂性增加和团队协作需求的提升，微前端架构成为解决大规模前端项目开发和维护的有效方案。微前端架构允许将一个大型前端应用分解为多个独立开发、独立部署的小型应用，从而提高开发效率和可维护性。本文将深入分析当前主流的微前端方案，包括其实现原理和使用方法。</summary>
    
    
    
    <category term="微前端" scheme="https://kobingogo.github.io/categories/%E5%BE%AE%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="微前端" scheme="https://kobingogo.github.io/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"/>
    
    <category term="qiankun" scheme="https://kobingogo.github.io/tags/qiankun/"/>
    
    <category term="Single-SPA" scheme="https://kobingogo.github.io/tags/single-spa/"/>
    
    <category term="Webpack Module Federation" scheme="https://kobingogo.github.io/tags/webpack-module-federation/"/>
    
  </entry>
  
  <entry>
    <title>深入React Fiber</title>
    <link href="https://kobingogo.github.io/framework-react-fiber/"/>
    <id>https://kobingogo.github.io/framework-react-fiber/</id>
    <published>2022-09-05T20:16:46.000Z</published>
    <updated>2024-08-08T10:31:05.013Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Fiber-设计思想"><a href="#Fiber-设计思想" class="headerlink" title="Fiber 设计思想"></a>Fiber 设计思想</h2><div class="story post-story"><p>Fiber 是对 React 核心算法的重构，facebook 团队使用两年多的时间去重构 React 的核心算法，在 React16 以上的版本中引入了 Fiber 架构，其中的设计思想是非常值得我们学习的。</p><h3 id="为什么需要-Fiber"><a href="#为什么需要-Fiber" class="headerlink" title="为什么需要 Fiber"></a>为什么需要 Fiber</h3><p>我们知道，在浏览器中，页面是一帧一帧绘制出来的，渲染的帧率与设备的刷新率保持一致。一般情况下，设备的屏幕刷新率为 1s 60 次，当每秒内绘制的帧数（FPS）超过 60 时，页面渲染是流畅的；而当 FPS 小于 60 时，会出现一定程度的卡顿现象。下面来看完整的一帧中，具体做了哪些事情：</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730171907.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730171907.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730171907"></p><ol><li>首先需要处理输入事件，能够让用户得到最早的反馈</li><li>接下来是处理定时器，需要检查定时器是否到时间，并执行对应的回调</li><li>接下来处理 Begin Frame（开始帧），即每一帧的事件，包括 window.resize、scroll、media query change 等</li><li>接下来执行请求动画帧 requestAnimationFrame（rAF），即在每次绘制之前，会执行 rAF 回调</li><li>紧接着进行 Layout 操作，包括计算布局和更新布局，即这个元素的样式是怎样的，它应该在页面如何展示</li><li>接着进行 Paint 操作，得到树中每个节点的尺寸与位置等信息，浏览器针对每个元素进行内容填充</li><li>到这时以上的六个阶段都已经完成了，接下来处于空闲阶段（Idle Peroid），可以在这时执行 requestIdleCallback 里注册的任务（后面会详细讲到这个 requestIdleCallback ，它是 React Fiber 实现的基础）</li></ol><p>js 引擎和页面渲染引擎是在同一个渲染线程之内，两者是互斥关系。如果在某个阶段执行任务特别长，例如在定时器阶段或<code>Begin Frame</code>阶段执行时间非常长，时间已经明显超过了 16ms，那么就会阻塞页面的渲染，从而出现卡顿现象。</p><p>在 react16 引入 Fiber 架构之前，react 会采用递归对比虚拟 DOM 树，找出需要变动的节点，然后同步更新它们，这个过程 react 称为<code>reconcilation</code>（协调）。在<code>reconcilation</code>期间，react 会一直占用浏览器资源，会导致用户触发的事件得不到响应。实现的原理如下所示：<br><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730172010.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730172010.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730172010"></p><p>这里有 7 个节点，B1、B2 是 A1 的子节点，C1、C2 是 B1 的子节点，C3、C4 是 B2 的子节点。传统的做法就是采用深度优先遍历去遍历节点，具体代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const root = &#123; key: &#x27;A1&#x27;, children: [&#123; key: &#x27;B1&#x27;, children: [&#123; key: &#x27;C1&#x27;, children: [] &#125;, &#123; key: &#x27;C2&#x27;, children: [] &#125;] &#125;, &#123; key: &#x27;B2&#x27;, children: [&#123; key: &#x27;C3&#x27;, children: [] &#125;, &#123; key: &#x27;C4&#x27;, children: [] &#125;] &#125;] &#125; const walk = dom =&gt; &#123; console.log(dom.key) dom.children.forEach(child =&gt; walk(child)) &#125; walk(root)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>打印：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;span data-line-num=&quot;1&quot;&gt;A1&lt;/span&gt;</span><br><span class="line">&lt;span data-line-num=&quot;2&quot;&gt;B1&lt;/span&gt;</span><br><span class="line">&lt;span data-line-num=&quot;3&quot;&gt;C1&lt;/span&gt;</span><br><span class="line">&lt;span data-line-num=&quot;4&quot;&gt;C2&lt;/span&gt;</span><br><span class="line">&lt;span data-line-num=&quot;5&quot;&gt;B2&lt;/span&gt;</span><br><span class="line">&lt;span data-line-num=&quot;6&quot;&gt;C3&lt;/span&gt;</span><br><span class="line">&lt;span data-line-num=&quot;7&quot;&gt;C4&lt;/span&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这种遍历是递归调用，执行栈会越来越深，而且不能中断，中断后就不能恢复了。递归如果非常深，就会十分卡顿。如果递归花了 100ms，则这 100ms 浏览器是无法响应的，代码执行时间越长卡顿越明显。传统的方法存在不能中断和执行栈太深的问题。</p><p>因此，为了解决以上的痛点问题，React 希望能够彻底解决主线程长时间占用问题，于是引入了 Fiber 来改变这种不可控的现状，把渲染/更新过程拆分为一个个小块的任务，通过合理的调度机制来调控时间，指定任务执行的时机，从而降低页面卡顿的概率，提升页面交互体验。通过 Fiber 架构，让<code>reconcilation</code>过程变得可被中断。适时地让出 CPU 执行权，可以让浏览器及时地响应用户的交互。</p><p>React16 中使用了 Fiber，但是 Vue 是没有 Fiber 的，为什么呢？原因是二者的优化思路不一样：</p><ol><li>Vue 是基于 template 和 watcher 的组件级更新，把每个更新任务分割得足够小，不需要使用到 Fiber 架构，将任务进行更细粒度的拆分</li><li>React 是不管在哪里调用 setState，都是从根节点开始更新的，更新任务还是很大，需要使用到 Fiber 将大任务分割为多个小任务，可以中断和恢复，不阻塞主进程执行高优先级的任务</li></ol><p>下面，让我们走进 Fiber 的世界，看看具体是怎么实现的。</p><h3 id="什么是-Fiber"><a href="#什么是-Fiber" class="headerlink" title="什么是 Fiber"></a>什么是 Fiber</h3><p>Fiber 可以理解为是一个执行单元，也可以理解为是一种数据结构。</p><h3 id="一个执行单元"><a href="#一个执行单元" class="headerlink" title="一个执行单元"></a>一个执行单元</h3><p>Fiber 可以理解为一个执行单元，每次执行完一个执行单元，react 就会检查现在还剩多少时间，如果没有时间则将控制权让出去。React Fiber 与浏览器的核心交互流程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730172031.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730172031.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730172031"></p><p>首先 React 向浏览器请求调度，浏览器在一帧中如果还有空闲时间，会去判断是否存在待执行任务，不存在就直接将控制权交给浏览器，如果存在就会执行对应的任务，执行完成后会判断是否还有时间，有时间且有待执行任务则会继续执行下一个任务，否则就会将控制权交给浏览器。这里会有点绕，可以结合上述的图进行理解。</p><p>Fiber 可以被理解为划分一个个更小的执行单元，它是把一个大任务拆分为了很多个小块任务，一个小块任务的执行必须是一次完成的，不能出现暂停，但是一个小块任务执行完后可以移交控制权给浏览器去响应用户，从而不用像之前一样要等那个大任务一直执行完成再去响应用户。</p><h3 id="一种数据结构"><a href="#一种数据结构" class="headerlink" title="一种数据结构"></a>一种数据结构</h3><p>Fiber 还可以理解为是一种数据结构，React Fiber 就是采用链表实现的。每个 Virtual DOM 都可以表示为一个 fiber，如下图所示，每个节点都是一个 fiber。一个 fiber 包括了 child（第一个子节点）、sibling（兄弟节点）、return（父节点）等属性，React Fiber 机制的实现，就是依赖于以下的数据结构。在下文中会讲到基于这个链表结构，Fiber 究竟是如何实现的。</p><p>PS：这里需要说明一下，Fiber 是 React 进行重构的核心算法，fiber 是指数据结构中的每一个节点，如下图所示的 A1、B1 都是一个 fiber。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730172050.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730172050.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730172050"></p><h3 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h3><p>在 Fiber 中使用到了<a href="https://kobingogo.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8-requestIdleCallback%E5%92%8CrequestAnimationFrame%E8%AF%A6%E8%A7%A3/">requestAnimationFrame</a>，它是浏览器提供的绘制动画的 api 。它要求浏览器在下次重绘之前（即下一帧）调用指定的回调函数更新动画。</p><p>例如我想让浏览器在每一帧中，将页面 div 元素的宽变长 1px，直到宽度达到 100px 停止，这时就可以采用<code>requestAnimationFrame</code>来实现这个功能。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div&quot;</span> <span class="attr">class</span>=<span class="string">&quot;progress-bar &quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;start&quot;</span>&gt;</span>开始动画<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;start&#x27;</span>) <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div&#x27;</span>) <span class="keyword">let</span> start = <span class="number">0</span> <span class="keyword">let</span> allInterval = [] <span class="keyword">const</span> <span class="title function_">progress</span> = (<span class="params"></span>) =&gt; &#123; div.<span class="property">style</span>.<span class="property">width</span> = div.<span class="property">offsetWidth</span> + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span> div.<span class="property">innerHTML</span> = (div.<span class="property">offsetWidth</span>) + <span class="string">&#x27;%&#x27;</span> <span class="keyword">if</span> (div.<span class="property">offsetWidth</span> &lt; <span class="number">100</span>) &#123; <span class="keyword">let</span> current = <span class="title class_">Date</span>.<span class="title function_">now</span>() allInterval.<span class="title function_">push</span>(current - start) start = current <span class="title function_">requestAnimationFrame</span>(progress) &#125; <span class="keyword">else</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(allInterval) <span class="comment">// 打印requestAnimationFrame的全部时间间隔 &#125; &#125; btn.addEventListener(&#x27;click&#x27;, () =&gt; &#123; div.style.width = 0 let currrent = Date.now() start = currrent requestAnimationFrame(progress) console.log(allInterval) &#125;)</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器会在每一帧中，将 div 的宽度变宽 1px，知道到达 100px 为止。打印出每一帧的时间间隔如下，大约是 16ms 左右。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730172119.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730172119.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730172119">### requestIdleCallback</p><p><a href="https://kobingogo.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8-requestIdleCallback%E5%92%8CrequestAnimationFrame%E8%AF%A6%E8%A7%A3/">requestIdleCallback</a> 也是 react Fiber 实现的基础 api 。我们希望能够快速响应用户，让用户觉得够快，不能阻塞用户的交互，<code>requestIdleCallback</code>能使开发者在主事件循环上执行后台和低优先级的工作，而不影响延迟关键事件，如动画和输入响应。正常帧任务完成后没超过 16ms，说明有多余的空闲时间，此时就会执行<code>requestIdleCallback</code>里注册的任务。</p><p>具体的执行流程如下，开发者采用<code>requestIdleCallback</code>方法注册对应的任务，告诉浏览器我的这个任务优先级不高，如果每一帧内存在空闲时间，就可以执行注册的这个任务。另外，开发者是可以传入<code>timeout</code>参数去定义超时时间的，如果到了超时时间了，浏览器必须立即执行，使用方法如下：<code>window.requestIdleCallback(callback, &#123; timeout: 1000 &#125;)</code>。浏览器执行完这个方法后，如果没有剩余时间了，或者已经没有下一个可执行的任务了，React 应该归还控制权，并同样使用<code>requestIdleCallback</code>去申请下一个时间片。具体的流程如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730172256.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730172256.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730172256"></p><p><code>window.requestIdleCallback(callback)</code>的<code>callback</code>中会接收到默认参数 deadline ，其中包含了以下两个属性：</p><ul><li>timeRamining 返回当前帧还剩多少时间供用户使用</li><li>didTimeout 返回 callback 任务是否超时</li></ul><p><code>requestIdleCallback</code> 方法非常重要，下面分别讲两个例子来理解这个方法，在每个例子中都需要执行多个任务，但是任务的执行时间是不一样的，下面来看浏览器是如何分配时间执行这些任务的：</p><h3 id="一帧执行"><a href="#一帧执行" class="headerlink" title="一帧执行"></a>一帧执行</h3><p>直接执行 task1、task2、task3，各任务的时间均小于 16ms：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>上面定义了一个任务队列<code>taskQueue</code>，并定义了<code>workloop</code>函数，其中采用 <code>window.requestIdleCallback(workloop, &#123; timeout: 1000 &#125;)</code>去执行<code>taskQueue</code>中的任务。每个任务中仅仅做了<code>console.log</code>的工作，�� 间是非常短的，浏览器计算此帧中还剩余 15.52ms，足以一次执行完这三个任务，因此在此帧的空闲时间中，<code>taskQueue</code>中定义的三个任务均执行完毕。打印结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730172234.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730172234.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730172234"></p><h3 id="多帧执行"><a href="#多帧执行" class="headerlink" title="多帧执行"></a>多帧执行</h3><p>在 task1、task2、task3 中加入睡眠时间，各自执行时间超过 16ms：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> taskQueue = [</span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;task1 start&#x27;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;task1 end&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;task2 start&#x27;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;task2 end&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;task3 start&#x27;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;task3 end&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">performUnitWork</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 取出第一个队列中的第一个任务并执行 taskQueue.shift()()</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">workloop</span> = deadline =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`此帧的剩余时间为: <span class="subst">$&#123;deadline.timeRemaining()&#125;</span>`</span>); <span class="comment">// 如果此帧剩余时间大于0或者已经到了定义的超时时间（上文定义了timeout时间为1000，到达时间时必须强制执行），且当时存在任务，则直接执行这个任务</span></span><br><span class="line">    <span class="comment">// 如果没有剩余时间，则应该放弃执行任务控制权，把执行权交还给浏览器</span></span><br><span class="line">    <span class="keyword">while</span> ((deadline.<span class="title function_">timeRemaining</span>() &gt; <span class="number">0</span> || deadline.<span class="property">didTimeout</span>) &amp;&amp; taskQueue.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="title function_">performUnitWork</span>();</span><br><span class="line">    &#125; <span class="comment">// 如果还有未完成的任务，继续调用requestIdleCallback申请下一个时间片</span></span><br><span class="line">    <span class="keyword">if</span> (taskQueue.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">requestIdleCallback</span>(workloop, &#123; <span class="attr">timeout</span>: <span class="number">1000</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">requestIdleCallback</span>(workloop, &#123; <span class="attr">timeout</span>: <span class="number">1000</span> &#125;);</span><br></pre></td></tr></table></figure><p>基于以上的例子做了部分改造，让<code>taskQueue</code>中的每个任务的执行时间都超过 16.6ms，看打印结果知道浏览器第一帧的空闲时间为 14ms，只能执行一个任务，同理，在第二帧、第三帧的时间也只够执行一个任务。所有这三个任务分别是在三帧中分别完成的。打印结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730172326.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730172326.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730172326"></p><p>浏览器一帧的时间并不严格是 16ms，是可以动态控制的（如第三帧剩余时间为 49.95ms）。如果子任务的时间超过了一帧的剩余时间，则会一直卡在这里执行，直到子任务执行完毕。如果代码存在死循环，则浏览器会卡死。如果此帧的剩余时间大于 0（有空闲时间）或者已经超时（上文定义了 timeout 时间为 1000，必须强制执行了），且当时存在任务，则直接执行该任务。如果没有剩余时间，则应该放弃执行任务控制权，把执行权交还给浏览器。如果多个任务执行总时间小于空闲时间的话，是可以在一帧内执行多个任务的。</p><h3 id="Fiber-链表结构设计"><a href="#Fiber-链表结构设计" class="headerlink" title="Fiber 链表结构设计"></a>Fiber 链表结构设计</h3><p>Fiber 结构是使用链表实现的，<code>Fiber tree</code>实际上是个单链表树结构，详见<a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiber.new.js">ReactFiber.js 源码</a>，在这里我们看看 Fiber 的链表结构是怎样的，了解了这个链表结构后，能更快地理解后续 Fiber 的遍历过程。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730172400.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730172400.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730172400"></p><p>以上每一个单元包含了<code>payload</code>（数据）和<code>nextUpdate</code>（指向下一个单元的指针），定义结构如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Update</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">payload, nextUpdate</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">payload</span> = payload; <span class="comment">// payload 数据</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">nextUpdate</span> = nextUpdate; <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来定义一个队列，把每个单元串联起来，其中定义了两个指针：头指针<code>firstUpdate</code>和尾指针<code>lastUpdate</code>，作用是指向第一个单元和最后一个单元，并加入了<code>baseState</code>属性存储 React 中的 state 状态。如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class UpdateQueue &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.baseState = null; // state</span><br><span class="line">        this.firstUpdate = null; // 第一个更新</span><br><span class="line">        this.lastUpdate = null; // 最后一个更新</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来定义两个方法：插入节点单元（enqueueUpdate）、更新队列（forceUpdate）。插入节点单元时需要考虑是否已经存在节点，如果不存在直接将<code>firstUpdate</code>、<code>lastUpdate</code>指向此节点即可。更新队列是遍历这个链表，根据<code>payload</code>中的内容去更新<code>state</code>的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UpdateQueue</span> &#123;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="title function_">enqueueUpdate</span>(<span class="params">update</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前链表是空链表</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">firstUpdate</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">firstUpdate</span> = <span class="variable language_">this</span>.<span class="property">lastUpdate</span> = update;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前链表不为空</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">lastUpdate</span>.<span class="property">nextUpdate</span> = update;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">lastUpdate</span> = update;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取state，然后遍历这个链表，进行更新</span></span><br><span class="line">    <span class="title function_">forceUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> currentState = <span class="variable language_">this</span>.<span class="property">baseState</span> || &#123;&#125;;</span><br><span class="line">        <span class="keyword">let</span> currentUpdate = <span class="variable language_">this</span>.<span class="property">firstUpdate</span>;</span><br><span class="line">        <span class="keyword">while</span> (currentUpdate) &#123;</span><br><span class="line">            <span class="comment">// 判断是函数还是对象，是函数则需要执行，是对象则直接返回</span></span><br><span class="line">            <span class="keyword">let</span> nextState =</span><br><span class="line">                <span class="keyword">typeof</span> currentUpdate.<span class="property">payload</span> === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">                    ? currentUpdate.<span class="title function_">payload</span>(currentState)</span><br><span class="line">                    : currentUpdate.<span class="property">payload</span>;</span><br><span class="line">            currentState = &#123; ...currentState, ...nextState &#125;;</span><br><span class="line">            currentUpdate = currentUpdate.<span class="property">nextUpdate</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新完成后清空链表</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">firstUpdate</span> = <span class="variable language_">this</span>.<span class="property">lastUpdate</span> = <span class="literal">null</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">baseState</span> = currentState;</span><br><span class="line">        <span class="keyword">return</span> currentState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后写一个 demo，实例化一个队列，向其中加入很多节点，再更新这个队列：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> queue = <span class="keyword">new</span> <span class="title class_">UpdateQueue</span>();</span><br><span class="line">queue.<span class="title function_">enqueueUpdate</span>(<span class="keyword">new</span> <span class="title class_">Update</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;www&#x27;</span> &#125;));</span><br><span class="line">queue.<span class="title function_">enqueueUpdate</span>(<span class="keyword">new</span> <span class="title class_">Update</span>(&#123; <span class="attr">age</span>: <span class="number">10</span> &#125;));</span><br><span class="line">queue.<span class="title function_">enqueueUpdate</span>(<span class="keyword">new</span> <span class="title class_">Update</span>(<span class="function"><span class="params">state</span> =&gt;</span> (&#123; <span class="attr">age</span>: state.<span class="property">age</span> + <span class="number">1</span> &#125;)));</span><br><span class="line">queue.<span class="title function_">enqueueUpdate</span>(<span class="keyword">new</span> <span class="title class_">Update</span>(<span class="function"><span class="params">state</span> =&gt;</span> (&#123; <span class="attr">age</span>: state.<span class="property">age</span> + <span class="number">1</span> &#125;)));</span><br><span class="line">queue.<span class="title function_">forceUpdate</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue.<span class="property">baseState</span>);</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; name:<span class="string">&#x27;www&#x27;</span>,age:<span class="number">12</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Fiber-节点设计"><a href="#Fiber-节点设计" class="headerlink" title="Fiber 节点设计"></a>Fiber 节点设计</h3><p>Fiber 的拆分单位是 fiber（<code>fiber tree</code>上的一个节点），实际上就是按虚拟 DOM 节点拆，我们需要根据虚拟 dom 去生成 Fiber 树。下文中我们把每一个节点叫做 fiber 。fiber 节点结构如下，源码详见<a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactInternalTypes.js">ReactInternalTypes.js</a>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">type</span>: any, <span class="comment">// 对于类组件，它指向构造函数；对于DOM元素，它指定HTML tag</span></span><br><span class="line">    <span class="attr">key</span>: <span class="literal">null</span> | string, <span class="comment">// 唯一标识符</span></span><br><span class="line">    <span class="attr">stateNode</span>: any, <span class="comment">// 保存对组件的类实例，DOM节点或与fiber节点关联的其他React元素类型的引用</span></span><br><span class="line">    <span class="attr">child</span>: <span class="title class_">Fiber</span> | <span class="literal">null</span>, <span class="comment">// 大儿子</span></span><br><span class="line">    <span class="attr">sibling</span>: <span class="title class_">Fiber</span> | <span class="literal">null</span>, <span class="comment">// 下一个兄弟</span></span><br><span class="line">    <span class="attr">return</span>: <span class="title class_">Fiber</span> | <span class="literal">null</span>, <span class="comment">// 父节点</span></span><br><span class="line">    <span class="attr">tag</span>: <span class="title class_">WorkTag</span>, <span class="comment">// 定义fiber操作的类型, 详见https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactWorkTags.js</span></span><br><span class="line">    <span class="attr">nextEffect</span>: <span class="title class_">Fiber</span> | <span class="literal">null</span>, <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">    <span class="attr">updateQueue</span>: mixed, <span class="comment">// 用于状态更新，回调函数，DOM更新的队列</span></span><br><span class="line">    <span class="attr">memoizedState</span>: any, <span class="comment">// 用于创建输出的fiber状态</span></span><br><span class="line">    <span class="attr">pendingProps</span>: any, <span class="comment">// 已从React元素中的新数据更新，并且需要应用于子组件或DOM元素的props</span></span><br><span class="line">    <span class="attr">memoizedProps</span>: any, <span class="comment">// 在前一次渲染期间用于创建输出的props</span></span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>fiber 节点包括了以下的属性：</p><p>（1）type &amp; key</p><ul><li>fiber 的 type 和 key 与 React 元素的作用相同。fiber 的 type 描述了它对应的组件，对于复合组件，type 是函数或类组件本身。对于原生标签（div，span 等），type 是一个字符串。随着 type 的不同，在 reconciliation 期间使用 key 来确定 fiber 是否可以重新使用。</li></ul><p>（2）stateNode</p><ul><li>stateNode 保存对组件的类实例，DOM 节点或与 fiber 节点关联的其他 React 元素类型的引用。一般来说，可以认为这个属性用于保存与 fiber 相关的本地状态。</li></ul><p>（3）child &amp; sibling &amp; return</p><ul><li>child 属性指向此节点的第一个子节点（大儿子）。</li><li>sibling 属性指向此节点的下一个兄弟节点（大儿子指向二儿子、二儿子指向三儿子）。</li><li>return 属性指向此节点的父节点，即当前节点处理完毕后，应该向谁提交自己的成果。如果 fiber 具有多个子 fiber，则每个子 fiber 的 return fiber 是 parent 。</li></ul><p>所有 fiber 节点都通过以下属性：child，sibling 和 return 来构成一个 fiber node 的 linked list(后面我们称之为链表)。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730172437.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730172437.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730172437"></p><p>其他的属性还有<code>memoizedState</code>（创建输出的 fiber 的状态）、<code>pendingProps</code>（将要改变的 props ）、<code>memoizedProps</code>（上次渲染创建输出的 props ）、<code>pendingWorkPriority</code>（定义 fiber 工作优先级）等等，在这里就不展开描述了。</p></div><h2 id="Fiber-执行原理"><a href="#Fiber-执行原理" class="headerlink" title="Fiber 执行原理"></a>Fiber 执行原理</h2><div class="story post-story"><p>从根节点开始渲染和调度的过程可以分为两个阶段：render 阶段、commit 阶段。</p><ul><li>render 阶段：这个阶段是可中断的，会找出所有节点的变更</li><li>commit 阶段：这个阶段是不可中断的，会执行所有的变更</li></ul><h3 id="render-阶段"><a href="#render-阶段" class="headerlink" title="render 阶段"></a>render 阶段</h3><p>此阶段会找出所有节点的变更，如节点新增、删除、属性变更等，这些变更 react 统称为副作用（effect），此阶段会构建一棵<code>Fiber tree</code>，以虚拟 dom 节点为维度对任务进行拆分，即一个虚拟 dom 节点对应一个任务，最后产出的结果是<code>effect list</code>，从中可以知道哪些节点更新、哪些节点增加、哪些节点删除了。</p><h3 id="遍历流程"><a href="#遍历流程" class="headerlink" title="遍历流程"></a>遍历流程</h3><p><code>React Fiber</code>首先是将虚拟 DOM 树转化为<code>Fiber tree</code>，因此每个节点都有<code>child</code>、<code>sibling</code>、<code>return</code>属性，遍历<code>Fiber tree</code>时采用的是后序遍历方法：</p><ol><li>从顶点开始遍历</li><li>如果有大儿子，先遍历大儿子；如果没有大儿子，则表示遍历完成</li><li>大儿子： a. 如果有弟弟，则返回弟弟，跳到 2 b. 如果没有弟弟，则返回父节点，并标志完成父节点遍历，跳到 2 d. 如果没有父节点则标志遍历结束</li></ol><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730172459.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730172459.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730172459"></p><p>定义树结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const A1 = &#123; type: &#x27;div&#x27;, key: &#x27;A1&#x27; &#125;</span><br><span class="line">const B1 = &#123; type: &#x27;div&#x27;, key: &#x27;B1&#x27;, return: A1 &#125;</span><br><span class="line">const B2 = &#123; type: &#x27;div&#x27;, key: &#x27;B2&#x27;, return: A1 &#125;</span><br><span class="line">const C1 = &#123; type: &#x27;div&#x27;, key: &#x27;C1&#x27;, return: B1 &#125;</span><br><span class="line">const C2 = &#123; type: &#x27;div&#x27;, key: &#x27;C2&#x27;, return: B1 &#125;</span><br><span class="line">const C3 = &#123; type: &#x27;div&#x27;, key: &#x27;C3&#x27;, return: B2 &#125;</span><br><span class="line">const C4 = &#123; type: &#x27;div&#x27;, key: &#x27;C4&#x27;, return: B2 &#125;</span><br><span class="line"></span><br><span class="line">A1.child = B1</span><br><span class="line">B1.sibling = B2</span><br><span class="line">B1.child = C1</span><br><span class="line">C1.sibling = C2</span><br><span class="line">B2.child = C3</span><br><span class="line">C3.sibling = C4</span><br><span class="line"></span><br><span class="line">module.exports = A1</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>写遍历方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">let rootFiber = require(&#x27;./element&#x27;)</span><br><span class="line"></span><br><span class="line">const beginWork = (Fiber) =&gt; &#123;</span><br><span class="line">  console.log(`$&#123;Fiber.key&#125; start`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const completeUnitWork = (Fiber) =&gt; &#123;</span><br><span class="line">  console.log(`$&#123;Fiber.key&#125; end`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 遍历函数</span><br><span class="line">const performUnitOfWork = (Fiber) =&gt; &#123;</span><br><span class="line">  beginWork(Fiber)</span><br><span class="line">  if (Fiber.child) &#123;</span><br><span class="line">    return Fiber.child</span><br><span class="line">  &#125;</span><br><span class="line">  while (Fiber) &#123;</span><br><span class="line">    completeUnitWork(Fiber)</span><br><span class="line">    if (Fiber.sibling) &#123;</span><br><span class="line">      return Fiber.sibling</span><br><span class="line">    &#125;</span><br><span class="line">    Fiber = Fiber.return</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const workloop = (nextUnitOfWork) =&gt; &#123;</span><br><span class="line">  // 如果有待执行的执行单元则执行，返回下一个执行单元</span><br><span class="line">  while (nextUnitOfWork) &#123;</span><br><span class="line">    nextUnitOfWork = performUnitOfWork(nextUnitOfWork)</span><br><span class="line">  &#125;</span><br><span class="line">  if (!nextUnitOfWork) &#123;</span><br><span class="line">    console.log(&#x27;reconciliation阶段结束&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">workloop(rootFiber)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">A1 start</span><br><span class="line">B1 start</span><br><span class="line">C1 start</span><br><span class="line">C1 end <span class="comment">// C1完成</span></span><br><span class="line">C2 start</span><br><span class="line">C2 end <span class="comment">// C2完成</span></span><br><span class="line">B1 end <span class="comment">// B1完成</span></span><br><span class="line">B2 start</span><br><span class="line">C3 start</span><br><span class="line">C3 end <span class="comment">// C3完成</span></span><br><span class="line">C4 start</span><br><span class="line">C4 end <span class="comment">// C4完成</span></span><br><span class="line">B2 end <span class="comment">// B2完成</span></span><br><span class="line">A1 end <span class="comment">// A1完成</span></span><br><span class="line">reconciliation阶段结束</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="收集-effect-list"><a href="#收集-effect-list" class="headerlink" title="收集 effect list"></a>收集 effect list</h3><p>知道了遍历方法之后，接下来需要做的工作就是在遍历过程中，收集所有节点的变更产出<code>effect list</code>，注意其中只包含了需要变更的节点。通过每个节点更新结束时向上归并<code>effect list</code>来收集任务结果，最后根节点的<code>effect list</code>里就记录了包括了所有需要变更的结果。</p><p>收集<code>effect list</code>的具体步骤为：</p><ol><li>如果当前节点需要更新，则打<code>tag</code>更新当前节点状态（props, state, context 等）</li><li>为每个子节点创建 fiber。如果没有产生<code>child fiber</code>，则结束该节点，把<code>effect list</code>归并到<code>return</code>，把此节点的<code>sibling</code>节点作为下一个遍历节点；否则把<code>child</code>节点作为下一个遍历节点</li><li>如果有剩余时间，则开始下一个节点，否则等下一次主线程空闲再开始下一个节点</li><li>如果没有下一个节点了，进入<code>pendingCommit</code>状态，此时<code>effect list</code>收集完毕，结束。</li></ol><p>收集<code>effect list</code>的遍历顺序如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730172513.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730172513.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730172513">遍历子虚拟 DOM 元素数组，为每个虚拟 DOM 元素创建子 fiber：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">reconcileChildren</span> = (<span class="params">currentFiber, newChildren</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> newChildIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> prevSibling; <span class="comment">// 上一个子fiber</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历子虚拟DOM元素数组，为每个虚拟DOM元素创建子fiber</span></span><br><span class="line">    <span class="keyword">while</span> (newChildIndex &lt; newChildren.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> newChild = newChildren[newChildIndex];</span><br><span class="line">        <span class="keyword">let</span> tag;</span><br><span class="line">        <span class="comment">// 打tag，定义 fiber类型</span></span><br><span class="line">        <span class="keyword">if</span> (newChild.<span class="property">type</span> === <span class="variable constant_">ELEMENT_TEXT</span>) &#123;</span><br><span class="line">            <span class="comment">// 这是文本节点</span></span><br><span class="line">            tag = <span class="variable constant_">TAG_TEXT</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild.<span class="property">type</span> === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果type是字符串，则是原生DOM节点</span></span><br><span class="line">            tag = <span class="variable constant_">TAG_HOST</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> newFiber = &#123;</span><br><span class="line">            tag,</span><br><span class="line">            <span class="attr">type</span>: newChild.<span class="property">type</span>,</span><br><span class="line">            <span class="attr">props</span>: newChild.<span class="property">props</span>,</span><br><span class="line">            <span class="attr">stateNode</span>: <span class="literal">null</span>, <span class="comment">// 还未创建DOM元素</span></span><br><span class="line">            <span class="attr">return</span>: currentFiber, <span class="comment">// 父亲fiber</span></span><br><span class="line">            <span class="attr">effectTag</span>: <span class="variable constant_">INSERT</span>, <span class="comment">// 副作用标识，包括新增、删除、更新</span></span><br><span class="line">            <span class="attr">nextEffect</span>: <span class="literal">null</span>, <span class="comment">// 指向下一个fiber，effect list通过nextEffect指针进行连接</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (newFiber) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newChildIndex === <span class="number">0</span>) &#123;</span><br><span class="line">                currentFiber.<span class="property">child</span> = newFiber; <span class="comment">// child为大儿子</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prevSibling.<span class="property">sibling</span> = newFiber; <span class="comment">// 让大儿子的sibling指向二儿子</span></span><br><span class="line">            &#125;</span><br><span class="line">            prevSibling = newFiber;</span><br><span class="line">        &#125;</span><br><span class="line">        newChildIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>定义一个方法收集此 fiber 节点下所有的副作用，并组成<code>effect list</code>。注意每个 fiber 有两个属性：</p><ul><li>firstEffect：指向第一个有副作用的子 fiber</li><li>lastEffect：指向最后一个有副作用的子 fiber</li></ul><p>中间的使用<code>nextEffect</code>做成一个单链表。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在完成的时候要收集有副作用的fiber，组成effect list</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">completeUnitOfWork</span> = currentFiber =&gt; &#123;</span><br><span class="line">    <span class="comment">// 后续遍历，儿子们完成之后，自己才能完成。最后会得到以上图中的链条结构。</span></span><br><span class="line">    <span class="keyword">let</span> returnFiber = currentFiber.<span class="property">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (returnFiber) &#123;</span><br><span class="line">        <span class="comment">// 如果父亲fiber的firstEffect没有值，则将其指向当前fiber的firstEffect</span></span><br><span class="line">        <span class="keyword">if</span> (!returnFiber.<span class="property">firstEffect</span>) &#123;</span><br><span class="line">            returnFiber.<span class="property">firstEffect</span> = currentFiber.<span class="property">firstEffect</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前fiber的lastEffect有值</span></span><br><span class="line">        <span class="keyword">if</span> (currentFiber.<span class="property">lastEffect</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (returnFiber.<span class="property">lastEffect</span>) &#123;</span><br><span class="line">                returnFiber.<span class="property">lastEffect</span>.<span class="property">nextEffect</span> = currentFiber.<span class="property">firstEffect</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            returnFiber.<span class="property">lastEffect</span> = currentFiber.<span class="property">lastEffect</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> effectTag = currentFiber.<span class="property">effectTag</span>;</span><br><span class="line">        <span class="keyword">if</span> (effectTag) &#123;</span><br><span class="line">            <span class="comment">// 说明有副作用</span></span><br><span class="line">            <span class="comment">// 每个fiber有两个属性：</span></span><br><span class="line">            <span class="comment">// 1）firstEffect：指向第一个有副作用的子fiber</span></span><br><span class="line">            <span class="comment">// 2）lastEffect：指向最后一个有副作用的子fiber</span></span><br><span class="line">            <span class="comment">// 中间的使用nextEffect做成一个单链表</span></span><br><span class="line">            <span class="keyword">if</span> (returnFiber.<span class="property">lastEffect</span>) &#123;</span><br><span class="line">                returnFiber.<span class="property">lastEffect</span>.<span class="property">nextEffect</span> = currentFiber;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                returnFiber.<span class="property">lastEffect</span> = currentFiber;</span><br><span class="line">            &#125;</span><br><span class="line">            returnFiber.<span class="property">lastEffect</span> = currentFiber;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来定义一个递归函数，从根节点出发，把全部的 fiber 节点遍历一遍，产出最终全部的<code>effect list</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把该节点和子节点任务都执行完</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">performUnitOfWork</span> = currentFiber =&gt; &#123;</span><br><span class="line">    <span class="title function_">beginWork</span>(currentFiber);</span><br><span class="line">    <span class="keyword">if</span> (currentFiber.<span class="property">child</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> currentFiber.<span class="property">child</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (currentFiber) &#123;</span><br><span class="line">        <span class="title function_">completeUnitOfWork</span>(currentFiber); <span class="comment">// 让自己完成</span></span><br><span class="line">        <span class="keyword">if</span> (currentFiber.<span class="property">sibling</span>) &#123;</span><br><span class="line">            <span class="comment">// 有弟弟则返回弟弟</span></span><br><span class="line">            <span class="keyword">return</span> currentFiber.<span class="property">sibling</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        currentFiber = currentFiber.<span class="property">return</span>; <span class="comment">// 没有弟弟，则找到父亲，让父亲完成，父亲会去找他的弟弟即叔叔</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="commit-阶段"><a href="#commit-阶段" class="headerlink" title="commit 阶段"></a>commit 阶段</h3><p>commit 阶段需要将上阶段计算出来的需要处理的副作用一次性执行，此阶段不能暂停，否则会出现 UI 更新不连续的现象。此阶段需要根据<code>effect list</code>，将所有更新都 commit 到 DOM 树上。</p><h3 id="根据一个-fiber-的-effect-list-更新视图"><a href="#根据一个-fiber-的-effect-list-更新视图" class="headerlink" title="根据一个 fiber 的 effect list 更新视图"></a>根据一个 fiber 的 effect list 更新视图</h3><p>根据一个 fiber 的<code>effect list</code>列表去更新视图（这里只列举了新增节点、删除节点、更新节点的三种操作）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">commitWork</span> = currentFiber =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!currentFiber) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> returnFiber = currentFiber.<span class="property">return</span>;</span><br><span class="line">    <span class="keyword">let</span> returnDOM = returnFiber.<span class="property">stateNode</span>; <span class="comment">// 父节点元素</span></span><br><span class="line">    <span class="keyword">if</span> (currentFiber.<span class="property">effectTag</span> === <span class="variable constant_">INSERT</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前fiber的effectTag标识位INSERT，则代表其是需要插入的节点</span></span><br><span class="line">        returnDOM.<span class="title function_">appendChild</span>(currentFiber.<span class="property">stateNode</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentFiber.<span class="property">effectTag</span> === <span class="variable constant_">DELETE</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前fiber的effectTag标识位DELETE，则代表其是需要删除的节点</span></span><br><span class="line">        returnDOM.<span class="title function_">removeChild</span>(currentFiber.<span class="property">stateNode</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentFiber.<span class="property">effectTag</span> === <span class="variable constant_">UPDATE</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前fiber的effectTag标识位UPDATE，则代表其是需要更新的节点</span></span><br><span class="line">        <span class="keyword">if</span> (currentFiber.<span class="property">type</span> === <span class="variable constant_">ELEMENT_TEXT</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (currentFiber.<span class="property">alternate</span>.<span class="property">props</span>.<span class="property">text</span> !== currentFiber.<span class="property">props</span>.<span class="property">text</span>) &#123;</span><br><span class="line">                currentFiber.<span class="property">stateNode</span>.<span class="property">textContent</span> = currentFiber.<span class="property">props</span>.<span class="property">text</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    currentFiber.<span class="property">effectTag</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="根据全部-fiber-的-effect-list-更新视图"><a href="#根据全部-fiber-的-effect-list-更新视图" class="headerlink" title="根据全部 fiber 的 effect list 更新视图"></a>根据全部 fiber 的 effect list 更新视图</h3><p>写一个递归函数，从根节点出发，根据<code>effect list</code>完成全部更新：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">commitRoot</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> currentFiber = workInProgressRoot.<span class="property">firstEffect</span>;</span><br><span class="line">    <span class="keyword">while</span> (currentFiber) &#123;</span><br><span class="line">        <span class="title function_">commitWork</span>(currentFiber);</span><br><span class="line">        currentFiber = currentFiber.<span class="property">nextEffect</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    currentRoot = workInProgressRoot; <span class="comment">// 把当前渲染成功的根fiber赋给currentRoot</span></span><br><span class="line">    workInProgressRoot = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="完成视图更新"><a href="#完成视图更新" class="headerlink" title="完成视图更新"></a>完成视图更新</h3><p>接下来定义循环执行工作，当计算完成每个 fiber 的<code>effect list</code>后，调用 commitRoot 完成视图更新：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">workloop</span> = deadline =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> shouldYield = <span class="literal">false</span>; <span class="comment">// 是否需要让出控制权</span></span><br><span class="line">    <span class="keyword">while</span> (nextUnitOfWork &amp;&amp; !shouldYield) &#123;</span><br><span class="line">        nextUnitOfWork = <span class="title function_">performUnitOfWork</span>(nextUnitOfWork);</span><br><span class="line">        shouldYield = deadline.<span class="title function_">timeRemaining</span>() &lt; <span class="number">1</span>; <span class="comment">// 如果执行完任务后，剩余时间小于1ms，则需要让出控制权给浏览器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!nextUnitOfWork &amp;&amp; workInProgressRoot) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;render阶段结束&#x27;</span>);</span><br><span class="line">        <span class="title function_">commitRoot</span>(); <span class="comment">// 没有下一个任务了，根据effect list结果批量更新视图</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 请求浏览器进行再次调度</span></span><br><span class="line">    <span class="title function_">requestIdleCallback</span>(workloop, &#123; <span class="attr">timeout</span>: <span class="number">1000</span> &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>到这时，已经根据收集到的变更信息，完成了视图的刷新操作。</p><p><a href="https://juejin.cn/post/6943896410987659277#heading-10" target="_blank" rel="noopener external nofollow noreferrer">原文</a></p></div>]]></content>
    
    
    <summary type="html">Fiber 是对 React 核心算法的重构，facebook 团队使用两年多的时间去重构 React 的核心算法，在React16 以上的版本中引入了 Fiber 架构，其中的设计思想是非常值得我们学习的。</summary>
    
    
    
    <category term="react" scheme="https://kobingogo.github.io/categories/react/"/>
    
    
    <category term="React Fiber" scheme="https://kobingogo.github.io/tags/react-fiber/"/>
    
  </entry>
  
  <entry>
    <title>对前端常见的框架（Angular/React/Vue）的理解</title>
    <link href="https://kobingogo.github.io/framework-%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/"/>
    <id>https://kobingogo.github.io/framework-%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/</id>
    <published>2022-08-06T12:03:47.000Z</published>
    <updated>2024-08-08T10:31:05.013Z</updated>
    
    <content type="html"><![CDATA[<p>前端开发中常见的三大框架 Angular、React 和 Vue 各有其独特的设计理念和适用场景。下面是对这三个框架的理解和比较。</p><h3 id="Angular"><a href="#Angular" class="headerlink" title="Angular"></a>Angular</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Angular 是由 Google 维护的一个完整的前端框架。它是一个“全家桶”框架，包含了开发现代单页应用所需的各种工具和功能。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li><strong>全能框架</strong>：包含路由、HTTP 客户端、表单处理、依赖注入等完整功能，适用于大型复杂应用。</li><li><strong>TypeScript</strong>：Angular 使用 TypeScript 进行开发，提供了静态类型检查和现代 JavaScript 特性。</li><li><strong>双向数据绑定</strong>：Angular 的双向数据绑定使视图和模型保持同步，简化了数据更新的流程。</li><li><strong>模块化架构</strong>：使用模块（NgModule）组织代码，增强了代码的可维护性和可重用性。</li><li><strong>依赖注入（DI）</strong>：内置的依赖注入机制，使得组件之间的依赖管理更加简单和灵活。</li></ol><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>适用于大型企业级应用</li><li>需要完整解决方案的项目</li><li>强类型系统和高代码规范要求的团队</li></ul><h4 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h4><p>Angular 使用基于 HTML 的模板，结合 Angular 表达式和指令来描述视图。Angular 编译模板并生成相应的组件视图。</p><ul><li><strong>实现方式</strong>：Angular 编译器将模板转换为渲染函数，并结合数据模型生成 DOM 结构。它使用 Zone.js 进行变更检测，以实现数据的自动更新。</li></ul><h4 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h4><p>Angular 的双向数据绑定允许视图和模型之间的同步更新。</p><ul><li><strong>实现方式</strong>：通过 <code>[(ngModel)]</code> 指令，Angular 可以在输入元素和数据模型之间创建双向绑定。变更检测机制确保模型和视图的同步更新。</li></ul><h4 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h4><p>Angular 提供了强大的依赖注入系统，使得组件之间的依赖关系可以通过配置管理。</p><ul><li><strong>实现方式</strong>：使用装饰器（如 <code>@Injectable</code> 和 <code>@Inject</code>）标注依赖，Angular 在运行时通过构造函数注入实例。</li></ul><h4 id="模块化架构"><a href="#模块化架构" class="headerlink" title="模块化架构"></a>模块化架构</h4><p>Angular 使用模块（NgModule）组织代码和功能。</p><ul><li><strong>实现方式</strong>：通过定义 <code>@NgModule</code> 装饰器，开发者可以将组件、指令、服务等组织到一个模块中，从而实现功能的模块化和代码的可重用性。</li></ul><h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>React 是由 Facebook 开发和维护的一个 JavaScript 库，用于构建用户界面。与 Angular 和 Vue 不同，React 专注于视图层。</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ol><li><strong>组件化</strong>：React 强调组件化开发，UI 被分解成独立的组件，提升了代码的重用性和可维护性。</li><li><strong>虚拟 DOM</strong>：React 通过虚拟 DOM 提高了性能，避免了直接操作真实 DOM 带来的性能问题。</li><li><strong>单向数据流</strong>：React 提倡单向数据流，数据从父组件流向子组件，简化了数据管理和调试。</li><li><strong>JSX</strong>：使用 JSX 语法，允许在 JavaScript 中直接编写 HTML，提高了开发效率。</li><li><strong>生态系统</strong>：React 的生态系统非常丰富，有许多第三方库和工具，如 Redux、React Router 等。</li></ol><h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>需要高度定制化的 UI 组件</li><li>关注性能和灵活性的项目</li><li>需要与其他技术栈集成的项目</li></ul><h4 id="虚拟-DOM"><a href="#虚拟-DOM" class="headerlink" title="虚拟 DOM"></a>虚拟 DOM</h4><p>React 使用虚拟 DOM 提高性能，通过在内存中维护一个虚拟 DOM 树来避免不必要的真实 DOM 操作。</p><ul><li><strong>实现方式</strong>：React 在组件状态变化时，首先在虚拟 DOM 中生成新的 DOM 树，然后与旧的虚拟 DOM 树进行比较（diffing），最后只更新实际需要变更的部分到真实 DOM 中。</li></ul><h4 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h4><p>React 强调组件化开发，每个 UI 组件都是一个独立的模块，可以组合和重用。</p><ul><li><strong>实现方式</strong>：React 组件是使用 JavaScript 类或函数定义的，组件之间通过 props 进行通信。React 还支持状态管理，通过 state 处理组件内部状态。</li></ul><h4 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h4><p>React 采用单向数据流模式，数据从父组件流向子组件，简化了数据管理和调试。</p><ul><li><strong>实现方式</strong>：通过 props 将数据从父组件传递到子组件，子组件通过回调函数向父组件传递事件或数据。</li></ul><h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>Vue 是一个由 Evan You 开发的渐进式 JavaScript 框架，旨在构建用户界面。Vue 的设计灵活，可以逐步集成到项目中。</p><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ol><li><strong>渐进式框架</strong>：Vue 可以作为一个简单的库使用，也可以扩展为一个完整的框架，适应不同规模的项目需求。</li><li><strong>响应式数据绑定</strong>：Vue 提供响应式数据绑定系统，简化了数据的管理和更新。</li><li><strong>组件化</strong>：与 React 类似，Vue 也采用组件化开发，提升了代码的可维护性和重用性。</li><li><strong>模板语法</strong>：使用基于 HTML 的模板语法，易于上手和理解。</li><li><strong>Vue CLI</strong>：提供了强大的脚手架工具，快速生成项目结构和配置，提升开发效率。</li></ol><h4 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>中小型项目或快速原型开发</li><li>希望在现有项目中逐步引入前端框架</li><li>团队成员对 HTML 和模板语法更熟悉</li></ul><h4 id="响应式数据绑定"><a href="#响应式数据绑定" class="headerlink" title="响应式数据绑定"></a>响应式数据绑定</h4><p>Vue 的响应式数据系统使得视图和数据模型能够自动同步。</p><ul><li><strong>实现方式</strong>：Vue 使用 <code>Object.defineProperty</code> 或 <code>Proxy</code> 对数据对象进行劫持，拦截对数据的访问和修改，从而在数据变化时自动更新视图。</li></ul><h4 id="组件化-1"><a href="#组件化-1" class="headerlink" title="组件化"></a>组件化</h4><p>Vue 组件化开发方式使得开发者可以将 UI 分解成独立的、可重用的组件。</p><ul><li><strong>实现方式</strong>：Vue 组件是使用 JavaScript 对象定义的，组件之间通过 props 和事件进行通信。Vue 还支持插槽（slot），使得组件的内容可以灵活配置。</li></ul><h4 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h4><p>Vue 使用基于 HTML 的模板语法，结合指令（如 <code>v-if</code>、<code>v-for</code>）来描述视图。</p><ul><li><strong>实现方式</strong>：Vue 的模板编译器将模板转换为渲染函数，结合数据模型生成 DOM 结构。Vue 的响应式系统确保数据变化时视图自动更新。</li></ul><h3 id="实现细节比较"><a href="#实现细节比较" class="headerlink" title="实现细节比较"></a>实现细节比较</h3><table><thead><tr><th>功能</th><th>Angular 实现方式</th><th>React 实现方式</th><th>Vue 实现方式</th></tr></thead><tbody><tr><td>模板引擎</td><td>基于 HTML 的模板，结合 Angular 表达式和指令</td><td>JSX 语法，将 HTML 嵌入 JavaScript</td><td>基于 HTML 的模板，结合 Vue 指令</td></tr><tr><td>数据绑定</td><td>双向数据绑定，变更检测机制</td><td>单向数据流，状态管理通过 props 和 state</td><td>响应式数据绑定，通过 <code>Object.defineProperty</code> 或 <code>Proxy</code> 实现</td></tr><tr><td>组件化</td><td>通过 <code>@Component</code> 装饰器定义组件</td><td>通过类或函数定义组件，组件之间通过 props 进行通信</td><td>通过 JavaScript 对象定义组件，组件之间通过 props 和事件通信</td></tr><tr><td>依赖注入（DI）</td><td>使用 <code>@Injectable</code> 和 <code>@Inject</code> 装饰器进行依赖注入</td><td>无内置 DI 系统，可以使用第三方库（如 InversifyJS）</td><td>无内置 DI 系统，可以使用第三方库（如 Vue Dependency Injection）</td></tr><tr><td>虚拟 DOM</td><td>不使用虚拟 DOM，直接操作真实 DOM</td><td>使用虚拟 DOM，diffing 算法比较新旧虚拟 DOM 树，并更新真实 DOM</td><td>使用虚拟 DOM，diffing 算法比较新旧虚拟 DOM 树，并更新真实 DOM</td></tr><tr><td>模块化架构</td><td>通过 <code>@NgModule</code> 装饰器定义模块</td><td>无内置模块系统，可以使用 ES6 模块或其他模块化方案</td><td>无内置模块系统，可以使用 ES6 模块或其他模块化方案</td></tr><tr><td>状态管理</td><td>内置服务（Service）和状态管理库（如 NgRx）</td><td>无内置状态管理系统，常用 Redux、MobX 或 Context API</td><td>无内置状态管理系统，常用 Vuex 或组合式 API</td></tr></tbody></table><h3 id="比较总结"><a href="#比较总结" class="headerlink" title="比较总结"></a>比较总结</h3><table><thead><tr><th>特点</th><th>Angular</th><th>React</th><th>Vue</th></tr></thead><tbody><tr><td>核心理念</td><td>完整框架，全家桶</td><td>视图层库，组件化</td><td>渐进式框架</td></tr><tr><td>数据绑定</td><td>双向数据绑定</td><td>单向数据流</td><td>双向数据绑定</td></tr><tr><td>语言</td><td>TypeScript</td><td>JavaScript (JSX)</td><td>JavaScript (模板语法)</td></tr><tr><td>学习曲线</td><td>陡峭</td><td>中等</td><td>平缓</td></tr><tr><td>适用场景</td><td>大型复杂应用</td><td>高度定制化和性能优化</td><td>中小型项目和快速开发</td></tr><tr><td>社区和生态系统</td><td>稳定但相对保守</td><td>活跃且生态丰富</td><td>活跃且逐步壮大</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>Angular</strong> 适合大型企业级应用，提供全面的解决方案，但学习曲线较陡。</li><li><strong>React</strong> 适合需要高度定制化和性能优化的项目，生态系统丰富，学习曲线适中。</li><li><strong>Vue</strong> 适合中小型项目和快速开发，易于上手且灵活，可以根据需求逐步扩展。</li></ul><p>根据项目需求、团队技能和技术栈选择合适的前端框架是成功开发的重要前提。</p>]]></content>
    
    
    <summary type="html">前端开发中常见的三大框架 Angular、React 和 Vue 各有其独特的设计理念和适用场景。下面是对这三个框架的理解和比较。</summary>
    
    
    
    <category term="framework" scheme="https://kobingogo.github.io/categories/framework/"/>
    
    
    <category term="Angular" scheme="https://kobingogo.github.io/tags/angular/"/>
    
    <category term="React" scheme="https://kobingogo.github.io/tags/react/"/>
    
    <category term="Vue" scheme="https://kobingogo.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>浏览器渲染机制</title>
    <link href="https://kobingogo.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/"/>
    <id>https://kobingogo.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/</id>
    <published>2022-08-05T17:03:48.000Z</published>
    <updated>2024-08-08T10:31:05.017Z</updated>
    
    <content type="html"><![CDATA[<h2 id="页面加载过程"><a href="#页面加载过程" class="headerlink" title="页面加载过程"></a>页面加载过程</h2><div class="story post-story"><p>在介绍浏览器渲染过程之前，我们简明扼要介绍下页面的加载过程，有助于更好理解后续渲染过程。</p><p>要点如下：</p><ul><li>浏览器根据 DNS 服务器得到域名的 IP 地址</li><li>向这个 IP 的机器发送 HTTP 请求</li><li>服务器收到、处理并返回 HTTP 请求</li><li>浏览器得到返回内容</li></ul><p>例如在浏览器输入<code>https://juejin.im/timeline</code>，然后经过 DNS 解析，<code>juejin.im</code>对应的 IP 是<code>36.248.217.149</code>（不同时间、地点对应的 IP 可能会不同）。然后浏览器向该 IP 发送 HTTP 请求。</p><p>服务端接收到 HTTP 请求，然后经过计算（向不同的用户推送不同的内容），返回 HTTP 请求，返回的内容如下：</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730170556.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730170556.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730170556"></p><p>其实就是一堆 HMTL 格式的字符串，因为只有 HTML 格式浏览器才能正确解析，这是 W3C 标准的要求。接下来就是浏览器的渲染过程。</p></div><h2 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h2><div class="story post-story"><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730170608.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730170608.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730170608"></p><p>浏览器渲染过程大体分为如下三部分：</p><h3 id="1）浏览器会解析三个东西："><a href="#1）浏览器会解析三个东西：" class="headerlink" title="1）浏览器会解析三个东西："></a>1）浏览器会解析三个东西：</h3><ul><li>一是 HTML/SVG/XHTML，HTML 字符串描述了一个页面的结构，浏览器会把 HTML 结构字符串解析转换 DOM 树形结构。</li></ul><p><a href="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/31/169d470437a6c15a~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" target="_blank" rel="noopener external nofollow noreferrer">https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/31/169d470437a6c15a~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp</a></p><ul><li>二是 CSS，解析 CSS 会产生 CSS 规则树，它和 DOM 结构比较像。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730170734.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730170734.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730170734"></p><ul><li>三是 Javascript 脚本，等到 Javascript 脚本文件加载后， 通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730170744.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730170744.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730170744">### 2）解析完成后，浏览器引擎会通过 DOM Tree 和 CSS Rule Tree 来构造 Rendering Tree。</p><ul><li>Rendering Tree 渲染树并不等同于 DOM 树，渲染树只会包括需要显示的节点和这些节点的样式信息。</li><li>CSS 的 Rule Tree 主要是为了完成匹配并把 CSS Rule 附加上 Rendering Tree 上的每个 Element（也就是每个 Frame）。</li><li>然后，计算每个 Frame 的位置，这又叫 layout 和 reflow 过程。</li></ul><h3 id="3）最后通过调用操作系统-Native-GUI-的-API-绘制。"><a href="#3）最后通过调用操作系统-Native-GUI-的-API-绘制。" class="headerlink" title="3）最后通过调用操作系统 Native GUI 的 API 绘制。"></a>3）最后通过调用操作系统 Native GUI 的 API 绘制。</h3><blockquote><p>接下来我们针对这其中所经历的重要步骤详细阐述</p></blockquote></div><h2 id="构建-DOM"><a href="#构建-DOM" class="headerlink" title="构建 DOM"></a>构建 DOM</h2><div class="story post-story"><p>浏览器会遵守一套步骤将 HTML 文件转换为 DOM 树。宏观上，可以分为几个步骤：</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730170811.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730170811.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730170811"></p><ul><li>浏览器从磁盘或网络读取 HTML 的原始字节，并根据文件的指定编码（例如 UTF-8）将它们转换成字符串。</li></ul><p>在网络中传输的内容其实都是 0 和 1 这些字节数据。当浏览器接收到这些字节数据以后，它会将这些字节数据转换为字符串，也就是我们写的代码。</p><ul><li>将字符串转换成 Token，例如：<code>&lt;html&gt;</code>、<code>&lt;body&gt;</code>等。<strong>Token 中会标识出当前 Token 是“开始标签”或是“结束标签”亦或是“文本”等信息</strong>。</li></ul><p>这时候你一定会有疑问，节点与节点之间的关系如何维护？</p><p>事实上，这就是 Token 要标识“起始标签”和“结束标签”等标识的作用。例如“title”Token 的起始标签和结束标签之间的节点肯定是属于“head”的子节点。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730170826.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730170826.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730170826"></p><p>上图给出了节点之间的关系，例如：“Hello”Token 位于“title”开始标签与“title”结束标签之间，表明“Hello”Token 是“title”Token 的子节点。同理“title”Token 是“head”Token 的子节点。</p><ul><li>生成节点对象并构建 DOM</li></ul><p>事实上，构建 DOM 的过程中，不是等所有 Token 都转换完成后再去生成节点对象，而是一边生成 Token 一边消耗 Token 来生成节点对象。换句话说，每个 Token 被生成后，会立刻消耗这个 Token 创建出节点对象。<strong>注意：带有结束标签标识的 Token 不会创建节点对象。</strong></p><p>接下来我们举个例子，假设有段 HTML 文本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;span data-line-num=&quot;1&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;</span><br><span class="line">&lt;span data-line-num=&quot;2&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;</span><br><span class="line">&lt;span data-line-num=&quot;3&quot;&gt;    &amp;lt;title&amp;gt;Web page parsing&amp;lt;/title&amp;gt;&lt;/span&gt;</span><br><span class="line">&lt;span data-line-num=&quot;4&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;</span><br><span class="line">&lt;span data-line-num=&quot;5&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;</span><br><span class="line">&lt;span data-line-num=&quot;6&quot;&gt;    &amp;lt;div&amp;gt;&lt;/span&gt;</span><br><span class="line">&lt;span data-line-num=&quot;7&quot;&gt;        &amp;lt;h1&amp;gt;Web page parsing&amp;lt;/h1&amp;gt;&lt;/span&gt;</span><br><span class="line">&lt;span data-line-num=&quot;8&quot;&gt;        &amp;lt;p&amp;gt;This is an example Web page.&amp;lt;/p&amp;gt;&lt;/span&gt;</span><br><span class="line">&lt;span data-line-num=&quot;9&quot;&gt;    &amp;lt;/div&amp;gt;&lt;/span&gt;</span><br><span class="line">&lt;span data-line-num=&quot;10&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;</span><br><span class="line">&lt;span data-line-num=&quot;11&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面这段 HTML 会解析成这样：</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730170842.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730170842.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730170842">## 构建 CSSOM</p><p>DOM 会捕获页面的内容，但浏览器还需要知道页面如何展示，所以需要构建 CSSOM。</p><p>构建 CSSOM 的过程与构建 DOM 的过程非常相似，当浏览器接收到一段 CSS，浏览器首先要做的是识别出 Token，然后构建节点并生成 CSSOM。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730170857.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730170857.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730170857"></p><p>在这一过程中，浏览器会确定下每一个节点的样式到底是什么，并且这一过程其实是很消耗资源的。因为样式你可以自行设置给某个节点，也可以通过继承获得。在这一过程中，浏览器得递归 CSSOM 树，然后确定具体的元素到底是什么样式。</p><p><strong>注意：CSS 匹配 HTML 元素是一个相当复杂和有性能问题的事情。所以，DOM 树要小，CSS 尽量用 id 和 class，千万不要过渡层叠下去</strong>。</p></div><h2 id="构建渲染树"><a href="#构建渲染树" class="headerlink" title="构建渲染树"></a>构建渲染树</h2><div class="story post-story"><p>当我们生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730170911.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730170911.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730170911"><br>在这一过程中，不是简单的将两者合并就行了。<strong>渲染树只会包括需要显示的节点和这些节点的样式信息</strong>，如果某个节点是 <code>display: none</code> 的，那么就不会在渲染树中显示。</p><p>我们或许有个疑惑：<strong>浏览器如果渲染过程中遇到 JS 文件怎么处理</strong>？</p><p>渲染过程中，如果遇到<code>&lt;script&gt;</code>就停止渲染，执行 JS 代码。因为浏览器有 GUI 渲染线程与 JS 引擎线程，为了防止渲染出现不可预期的结果，这两个线程是互斥的关系。 JavaScript 的加载、解析与执行会阻塞 DOM 的构建，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停构建 DOM，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复 DOM 构建。</p><p>也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性（下文会介绍这两者的区别）。</p><p><strong>JS 文件不只是阻塞 DOM 的构建，它会导致 CSSOM 也阻塞 DOM 的构建</strong>。</p><p>原本 DOM 和 CSSOM 的构建是互不影响，井水不犯河水，但是一旦引入了 JavaScript，CSSOM 也开始阻塞 DOM 的构建，只有 CSSOM 构建完毕后，DOM 再恢复 DOM 构建。</p><p>这是什么情况？</p><p>这是因为 JavaScript 不只是可以改 DOM，它还可以更改样式，也就是它可以更改 CSSOM。因为不完整的 CSSOM 是无法使用的，如果 JavaScript 想访问 CSSOM 并更改它，那么在执行 JavaScript 时，必须要能拿到完整的 CSSOM。所以就导致了一个现象，如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟脚本执行和 DOM 构建，直至其完成 CSSOM 的下载和构建。也就是说，<strong>在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后在继续构建 DOM</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730170926.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730170926.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730170926"></p></div><h2 id="布局与绘制"><a href="#布局与绘制" class="headerlink" title="布局与绘制"></a>布局与绘制</h2><div class="story post-story"><p>当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。</p><p>布局流程的输出是一个“盒模型”，它会精确地捕获每个元素在视口内的确切位置和尺寸，所有相对测量值都将转换为屏幕上的绝对像素。</p><p>布局完成后，浏览器会立即发出“Paint Setup”和“Paint”事件，将渲染树转换成屏幕上的像素。</p><blockquote><p>以上我们详细介绍了浏览器工作流程中的重要步骤，接下来我们讨论几个相关的问题：</p></blockquote></div><h2 id="几点补充说明"><a href="#几点补充说明" class="headerlink" title="几点补充说明"></a>几点补充说明</h2><div class="story post-story"><h3 id="1-async-和-defer-的作用是什么？有什么区别"><a href="#1-async-和-defer-的作用是什么？有什么区别" class="headerlink" title="1.async 和 defer 的作用是什么？有什么区别?"></a>1.async 和 defer 的作用是什么？有什么区别?</h3><p>接下来我们对比下 defer 和 async 属性的区别：</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730170936.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730170936.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730170936"><br>其中蓝色线代表 JavaScript 加载；红色线代表 JavaScript 执行；绿色线代表 HTML 解析。</p><h3 id="1）情况-1-lt-script-src-quot-script-js-quot-gt-lt-script-gt"><a href="#1）情况-1-lt-script-src-quot-script-js-quot-gt-lt-script-gt" class="headerlink" title="1）情况 1&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;"></a>1）情况 1<code>&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</code></h3><p>没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。</p><h3 id="2）情况-2-lt-script-async-src-quot-script-js-quot-gt-lt-script-gt-异步下载"><a href="#2）情况-2-lt-script-async-src-quot-script-js-quot-gt-lt-script-gt-异步下载" class="headerlink" title="2）情况 2&lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt; (异步下载)"></a>2）情况 2<code>&lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt;</code> (<strong>异步下载</strong>)</h3><p>async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。</p><h3 id="3）情况-3-lt-script-defer-src-quot-script-js-quot-gt-lt-script-gt-延迟执行"><a href="#3）情况-3-lt-script-defer-src-quot-script-js-quot-gt-lt-script-gt-延迟执行" class="headerlink" title="3）情况 3 &lt;script defer src=&quot;script.js&quot;&gt;&lt;/script&gt;(延迟执行)"></a>3）情况 3 <code>&lt;script defer src=&quot;script.js&quot;&gt;&lt;/script&gt;</code>(<strong>延迟执行</strong>)</h3><p>defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。</p><p>defer 与相比普通 script，有两点区别：<strong>载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。 在加载多个 JS 脚本的时候，async 是无顺序的加载，而 defer 是有顺序的加载。</strong></p><h3 id="2-为什么操作-DOM-慢"><a href="#2-为什么操作-DOM-慢" class="headerlink" title="2.为什么操作 DOM 慢"></a>2.为什么操作 DOM 慢</h3><p>把 DOM 和 JavaScript 各自想象成一个岛屿，它们之间用收费桥梁连接。——《高性能 JavaScript》</p><p>JS 是很快的，在 JS 中修改 DOM 对象也是很快的。在 JS 的世界里，一切是简单的、迅速的。但 DOM 操作并非 JS 一个人的独舞，而是两个模块之间的协作。</p><p>因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们用 JS 去操作 DOM 时，本质上是 JS 引擎和渲染引擎之间进行了“跨界交流”。这个“跨界交流”的实现并不简单，它依赖了桥接接口作为“桥梁”（如下图）。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730170955.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730170955.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730170955"></p><p>过“桥”要收费——这个开销本身就是不可忽略的。我们每操作一次 DOM（不管是为了修改还是仅仅为了访问其值），都要过一次“桥”。过“桥”的次数一多，就会产生比较明显的性能问题。因此“减少 DOM 操作”的建议，并非空穴来风。</p><h3 id="3-你真的了解回流和重绘吗"><a href="#3-你真的了解回流和重绘吗" class="headerlink" title="3.你真的了解回流和重绘吗"></a>3.你真的了解回流和重绘吗</h3><p>渲染的流程基本上是这样（如下图黄色的四个步骤）：1.计算 CSS 样式 2.构建 Render Tree 3.Layout – 定位坐标和大小 4.正式开画</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730171007.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730171007.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730171007"><br>注意：上图流程中有很多连接线，这表示了 Javascript 动态修改了 DOM 属性或是 CSS 属性会导致重新 Layout，但有些改变不会重新 Layout，就是上图中那些指到天上的箭头，比如修改后的 CSS rule 没有被匹配到元素。</p><p>这里重要要说两个概念，一个是 Reflow，另一个是 Repaint</p><ul><li>重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。</li><li>回流：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）</li></ul><p>我们知道，当网页生成的时候，至少会渲染一次。在用户访问的过程中，还会不断重新渲染。重新渲染会重复回流+重绘或者只有重绘。 <strong>回流必定会发生重绘，重绘不一定会引发回流</strong>。重绘和回流会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。</p><h3 id="1）常见引起回流属性和方法"><a href="#1）常见引起回流属性和方法" class="headerlink" title="1）常见引起回流属性和方法"></a>1）常见引起回流属性和方法</h3><p>任何会改变元素几何信息(元素的位置和尺寸大小)的操作，都会触发回流，</p><ul><li>添加或者删除可见的 DOM 元素；</li><li>元素尺寸改变——边距、填充、边框、宽度和高度</li><li>内容变化，比如用户在 input 框中输入文字</li><li>浏览器窗口尺寸改变——resize 事件发生时</li><li>计算 offsetWidth 和 offsetHeight 属性</li><li>设置 style 属性的值</li></ul><h3 id="2）常见引起重绘属性和方法"><a href="#2）常见引起重绘属性和方法" class="headerlink" title="2）常见引起重绘属性和方法"></a>2）常见引起重绘属性和方法</h3><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730171020.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730171020.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730171020"></p><h3 id="3）如何减少回流、重绘"><a href="#3）如何减少回流、重绘" class="headerlink" title="3）如何减少回流、重绘"></a>3）如何减少回流、重绘</h3><ul><li>使用 transform 替代 top</li><li>使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）</li><li>不要把节点的属性值放在一个循环里当成循环里的变量。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;span data-line-num=&quot;1&quot;&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = 0; i &amp;lt; 1000; i++) &#123;&lt;/span&gt;</span><br><span class="line">&lt;span data-line-num=&quot;2&quot;&gt;    // 获取 offsetTop 会导致回流，因为需要去获取正确的值&lt;/span&gt;</span><br><span class="line">&lt;span data-line-num=&quot;3&quot;&gt;    console.log(document.querySelector(&lt;span&gt;&#x27;.test&#x27;&lt;/span&gt;).style.offsetTop)&lt;/span&gt;</span><br><span class="line">&lt;span data-line-num=&quot;4&quot;&gt;&#125;&lt;/span&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局</li><li>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame</li><li>CSS 选择符从右往左匹配查找，避免节点层级过多</li><li>将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 video 标签来说，浏览器会自动将该节点变为图层。</li></ul></div><h2 id="性能优化策略"><a href="#性能优化策略" class="headerlink" title="性能优化策略"></a>性能优化策略</h2><div class="story post-story"><p>基于上面介绍的浏览器渲染原理，DOM 和 CSSOM 结构构建顺序，初始化可以对页面渲染做些优化，提升页面性能。</p><ul><li>JS 优化： <code>&lt;script&gt;</code> 标签加上 defer 属性 和 async 属性 用于在不阻塞页面文档解析的前提下，控制脚本的下载和执行。<ul><li>defer 属性： 用于开启新的线程下载脚本文件，并使脚本在文档解析完成后执行。</li><li>async 属性： HTML5 新增属性，用于异步下载脚本文件，下载完毕立即解释执行代码。</li></ul></li><li>CSS 优化： <code>&lt;link&gt;</code> 标签的 rel 属性 中的属性值设置为 preload 能够让你在你的 HTML 页面中可以指明哪些资源是在页面加载完成后即刻需要的,最优的配置加载顺序，提高渲染性能</li></ul></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="story post-story"><p>综上所述，我们得出这样的结论：</p><ul><li>浏览器工作流程：构建 DOM -&gt; 构建 CSSOM -&gt; 构建渲染树 -&gt; 布局 -&gt; 绘制。</li><li>CSSOM 会阻塞渲染，只有当 CSSOM 构建完毕后才会进入下一个阶段构建渲染树。</li><li>通常情况下 DOM 和 CSSOM 是并行构建的，但是当浏览器遇到一个不带 defer 或 async 属性的 script 标签时，DOM 构建将暂停，如果此时又恰巧浏览器尚未完成 CSSOM 的下载和构建，由于 JavaScript 可以修改 CSSOM，所以需要等 CSSOM 构建完毕后再执行 JS，最后才重新 DOM 构建。</li></ul></div><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><div class="story post-story"><ul><li><a href="https://link.juejin.cn/?target=https://segmentfault.com/q/1010000000640869" target="_blank" rel="noopener external nofollow noreferrer">async 和 defer 的区别 | SegmentFault</a></li><li><a href="https://link.juejin.cn/?target=https://coolshell.cn/articles/9666.html" target="_blank" rel="noopener external nofollow noreferrer">浏览器的渲染原理简介</a></li><li><a href="https://juejin.cn/book/6844733763675488269/section/6844733763742597127" target="_blank" rel="noopener external nofollow noreferrer">前端面试之道</a></li><li><a href="https://link.juejin.cn/?target=https://mp.weixin.qq.com/s?__biz=MzA5NzkwNDk3MQ==&mid=2650588806&idx=1&sn=408a54e7c8102fd6944c9a40b119015a&chksm=8891d6a2bfe65fb42f493fe9a4dab672dd7e440f31e753196cee0cfbc6696e4f8dd3a669e040&mpshare=1&scene=1&srcid=1228ZrXsmbZKcgCSu7zTVDwy%23" target="_blank" rel="noopener external nofollow noreferrer">关键渲染路径</a></li><li><a href="https://juejin.cn/book/6844733750048210957/section/6844733750111272973" target="_blank" rel="noopener external nofollow noreferrer">前端性能优化原理与实践</a></li><li><a href="https://juejin.cn/book/6844733781945876488/section/6844733781987819533" target="_blank" rel="noopener external nofollow noreferrer">由入门到专家：前端全链路开发实践手册</a></li><li><a href="https://juejin.cn/book/6844733713780047886/section/6844733713838931981" target="_blank" rel="noopener external nofollow noreferrer">Web 前端面试指南与高频考题解析</a></li></ul></div>]]></content>
    
    
    <summary type="html">浏览器的内核是指支持浏览器运行的最核心的程序，分为两个部分的，一是渲染引擎，另一个是JS引擎。渲染引擎在不同的浏览器中也不是都相同的。目前市面上常见的浏览器内核可以分为这四种：Trident（IE）、Gecko（火狐）、Blink（Chrome、Opera）、Webkit（Safari）。其中最耳熟能详的可能就是 Webkit 内核了，Webkit 内核是当下浏览器世界真正的霸主。 本文我们就以 Webkit 为例，对现代浏览器的渲染过程进行一个深度的剖析</summary>
    
    
    
    <category term="浏览器" scheme="https://kobingogo.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
    <category term="浏览器渲染机制" scheme="https://kobingogo.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>requestIdleCallback和requestAnimationFrame</title>
    <link href="https://kobingogo.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8-requestIdleCallback%E5%92%8CrequestAnimationFrame%E8%AF%A6%E8%A7%A3/"/>
    <id>https://kobingogo.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8-requestIdleCallback%E5%92%8CrequestAnimationFrame%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-07-30T16:52:05.000Z</published>
    <updated>2024-08-08T10:31:05.017Z</updated>
    
    <content type="html"><![CDATA[<h3 id="页面流畅与-FPS"><a href="#页面流畅与-FPS" class="headerlink" title="页面流畅与 FPS"></a>页面流畅与 FPS</h3><p>页面是一帧一帧绘制出来的，当每秒绘制的帧数（FPS）达到 60 时，页面是流畅的，小于这个值时，用户会感觉到卡顿。</p><p>1s 60 帧，所以每一帧分到的时间是 1000/60 ≈ 16 ms。所以我们书写代码时力求不让一帧的工作量超过 16ms。</p><h3 id="Frame"><a href="#Frame" class="headerlink" title="Frame"></a>Frame</h3><p>那么浏览器每一帧都需要完成哪些工作？</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730165444.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730165444.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730165444"></p><p>通过上图可看到，一帧内需要完成如下六个步骤的任务：</p><ul><li>处理用户的交互</li><li>JS 解析执行</li><li>帧开始。窗口尺寸变更，页面滚去等的处理</li><li>requestAnimationFrame(rAF)</li><li>布局</li><li>绘制</li></ul><h3 id="requestIdleCallback"><a href="#requestIdleCallback" class="headerlink" title="requestIdleCallback"></a>requestIdleCallback</h3><p>上面六个步骤完成后没超过 16 ms，说明时间有富余，此时就会执行 <code>requestIdleCallback</code> 里注册的任务。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730165501.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730165501.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730165501"></p><p>从上图也可看出，和 <strong><code>requestAnimationFrame</code> 每一帧必定会执行不同，<code>requestIdleCallback</code> 是捡浏览器空闲来执行任务。</strong></p><p>如此一来，假如浏览器一直处于非常忙碌的状态，<code>requestIdleCallback</code> 注册的任务有可能永远不会执行。此时可通过设置 <code>timeout</code> （见下面 API 介绍）来保证执行。</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handle = <span class="variable language_">window</span>.<span class="title function_">requestIdleCallback</span>(callback[, options])</span><br></pre></td></tr></table></figure><ul><li><strong>callback</strong>：回调，即空闲时需要执行的任务，该回调函数接收一个<code>IdleDeadline</code>对象作为入参。其中<code>IdleDeadline</code>对象包含：<ul><li><code>didTimeout</code>，布尔值，表示任务是否超时，结合 <code>timeRemaining</code> 使用。</li><li><code>timeRemaining()</code>，表示当前帧剩余的时间，也可理解为留给任务的时间还有多少。</li></ul></li><li><strong>options</strong>：目前 options 只有一个参数<ul><li><code>timeout</code>。表示超过这个时间后，如果任务还没执行，则强制执行，不必等待空闲。</li></ul></li></ul><blockquote><p>IdleDeadline 对象参考 MDN:developer.mozilla.org/zh-CN/docs/…</p></blockquote><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">requestIdleCallback</span>(myNonEssentialWork, &#123; <span class="attr">timeout</span>: <span class="number">2000</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务队列</span></span><br><span class="line"><span class="keyword">const</span> tasks = [</span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第一个任务&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第二个任务&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第三个任务&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myNonEssentialWork</span>(<span class="params">deadline</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果帧内有富余的时间，或者超时</span></span><br><span class="line">    <span class="keyword">while</span> ((deadline.<span class="title function_">timeRemaining</span>() &gt; <span class="number">0</span> || deadline.<span class="property">didTimeout</span>) &amp;&amp; tasks.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="title function_">work</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tasks.<span class="property">length</span> &gt; <span class="number">0</span>) <span class="title function_">requestIdleCallback</span>(myNonEssentialWork);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">work</span>(<span class="params"></span>) &#123;</span><br><span class="line">    tasks.<span class="title function_">shift</span>()();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行任务&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>超时的情况，其实就是浏览器很忙，没有空闲时间，此时会等待指定的 <code>timeout</code> 那么久再执行，通过入参 <code>dealine</code> 拿到的 <code>didTmieout</code> 会为 <code>true</code>，同时 <code>timeRemaining ()</code> 返回的也是 0。超时的情况下如果选择继续执行的话，肯定会出现卡顿的，因为必然会将一帧的时间拉长。</p><h3 id="cancelIdleCallback"><a href="#cancelIdleCallback" class="headerlink" title="cancelIdleCallback"></a>cancelIdleCallback</h3><p>与 <code>setTimeout</code> 类似，返回一个唯一 id，可通过 <code>cancelIdleCallback</code> 来取消任务。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一些低优先级的任务可使用 <code>requestIdleCallback</code> 等浏览器不忙的时候来执行，同时因为时间有限，它所执行的任务应该尽量是能够量化，细分的微任务（micro task）。</p><p>因为它发生在一帧的最后，此时页面布局已经完成，<strong>所以不建议在 <code>requestIdleCallback</code> 里再操作 DOM</strong>，这样会导致页面再次重绘。<strong>DOM 操作建议在 rAF 中进行</strong>。同时，操作 DOM 所需要的耗时是不确定的，因为会导致重新计算布局和视图的绘制，所以这类操作不具备可预测性。</p><p><strong>Promise 也不建议在这里面进行，因为 Promise 的回调属性 Event loop 中优先级较高的一种微任务，会在 <code>requestIdleCallback</code> 结束时立即执行，不管此时是否还有富余的时间，这样有很大可能会让一帧超过 16 ms。</strong></p><h3 id="额外补充一下window-requestAnimationFrame"><a href="#额外补充一下window-requestAnimationFrame" class="headerlink" title="额外补充一下window.requestAnimationFrame"></a>额外补充一下<code>window.requestAnimationFrame</code></h3><p>在没有 <code>requestAnimationFrame</code> 方法的时候，执行动画，我们可能使用 <code>setTimeout</code> 或 <code>setInterval</code> 来触发视觉变化；但是这种做法的问题是：回调函数执行的时间是不固定的，可能刚好就在末尾，或者直接就不执行了，经常会引起丢帧而导致页面卡顿。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730165525.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20240730165525.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20240730165525"></p><p>归根到底发生上面这个问题的原因在于时机，也就是浏览器要知道何时对回调函数进行响应。**<code>setTimeout</code> 或 <code>setInterval</code> 是使用定时器来触发回调函数的，而定时器并无法保证能够准确无误的执行，有许多因素会影响它的运行时机，比如说：当有同步代码执行时，会先等同步代码执行完毕，异步队列中没有其他任务，才会轮到自己执行**。并且，我们知道每一次重新渲染的最佳时间大约是 16.6 ms，如果定时器的时间间隔过短，就会造成 <a href="https://link.juejin.cn/?target=https://link.zhihu.com/?target=https%253A//www.zhangxinxu.com/wordpress/2013/09/css3-animation-requestanimationframe-tween-%25E5%258A%25A8%25E7%2594%25BB%25E7%25AE%2597%25E6%25B3%2595/" target="_blank" rel="noopener external nofollow noreferrer">过度渲染</a>，增加开销；过长又会延迟渲染，使动画不流畅。</p><p><code>requestAnimationFrame</code> 方法不同与 <code>setTimeout</code> 或 <code>setInterval</code>，它是由系统来决定回调函数的执行时机的，会请求浏览器在下一次重新渲染之前执行回调函数。无论设备的刷新率是多少，**<code>requestAnimationFrame</code> 的时间间隔都会紧跟屏幕刷新一次所需要的时间<strong>；例如某一设备的刷新率是 75 Hz，那这时的时间间隔就是 13.3 ms（1 秒 / 75 次）。需要注意的是这个方法虽然能够</strong>保证回调函数在每一帧内只渲染一次<strong>，但是</strong>如果这一帧有太多任务执行，还是会造成卡顿的；因此它只能保证重新渲染的时间间隔最短是屏幕的刷新时间。**</p><p><code>requestAnimationFrame</code> 方法的具体说明可以看 <a href="https://link.juejin.cn/?target=https://link.zhihu.com/?target=https%253A//developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" target="_blank" rel="noopener external nofollow noreferrer">MDN</a> 的相关文档，下面通过一个网页动画的示例来了解一下如何使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let offsetTop = 0;</span><br><span class="line">const div = document.querySelector(&quot;.div&quot;);</span><br><span class="line">const run = () =&gt; &#123;</span><br><span class="line"> div.style.transform = `translate3d(0, $&#123;offsetTop += 10&#125;px, 0)`;</span><br><span class="line"> window.requestAnimationFrame(run);</span><br><span class="line">&#125;;</span><br><span class="line">run();</span><br></pre></td></tr></table></figure><p>如果想要实现动画效果，每一次执行回调函数，必须要再次调用 <code>requestAnimationFrame</code> 方法；与 <code>setTimeout</code> 实现动画效果的方式是一样的，只不过不需要设置时间间隔。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/39878259" target="_blank" rel="noopener external nofollow noreferrer">网页渲染性能优化 —— 性能优化上</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;页面流畅与-FPS&quot;&gt;&lt;a href=&quot;#页面流畅与-FPS&quot; class=&quot;headerlink&quot; title=&quot;页面流畅与 FPS&quot;&gt;&lt;/a&gt;页面流畅与 FPS&lt;/h3&gt;&lt;p&gt;页面是一帧一帧绘制出来的，当每秒绘制的帧数（FPS）达到 60 时，页面是流畅的，小</summary>
      
    
    
    
    <category term="浏览器" scheme="https://kobingogo.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
    <category term="requestIdleCallback" scheme="https://kobingogo.github.io/tags/requestidlecallback/"/>
    
    <category term="requestAnimationFrame" scheme="https://kobingogo.github.io/tags/requestanimationframe/"/>
    
  </entry>
  
  <entry>
    <title>让代码更规范优雅 - husky的使用</title>
    <link href="https://kobingogo.github.io/tools-husky/"/>
    <id>https://kobingogo.github.io/tools-husky/</id>
    <published>2022-02-17T17:52:37.000Z</published>
    <updated>2024-08-08T10:31:05.017Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>日常工作中，几乎每个项目都是由多个人进行维护，每个人的代码书写习惯和风格又不尽相同，在这种情况下，规范和约束就显得尤为重要！</p></blockquote><h2 id="githooks"><a href="#githooks" class="headerlink" title="githooks"></a>githooks</h2><div class="story post-story"><p>类似于前端框架中的生命周期钩子，git在某些特定事件发生前或后也会有某些执行特定功能的钩子，githooks就是在git执行特定事件（如commit、push、receive等）时触发运行的脚本。</p><p>githooks 保存在 .git 文件夹中</p><p>具体钩子如下表所示：</p><table><thead><tr><th>git hook</th><th>执行时机</th><th>说明</th></tr></thead><tbody><tr><td>applypatch-msg</td><td>git am 执行前</td><td>默认情况下，如果commit-msg启用的话，applpatch-msg钩子在启用时会运行commit-msg钩子</td></tr><tr><td>pre-applypatc</td><td>git am 执行前</td><td>默认的pre-applypatch钩子在启用时运行pre-commit钩子（如果后者已启用）</td></tr><tr><td>post-applypatch</td><td>git am 执行后</td><td>这个钩子主要用于通知，不能影响git-am的结果</td></tr><tr><td>pre-commit</td><td>git commit 执行前</td><td>可以使用 git commit --no verify 命令绕过该钩子</td></tr><tr><td>pre-merge-commit</td><td>git merge 执行前</td><td>可以使用 git merge --no verify 命令绕过该钩子</td></tr><tr><td>prepare-commit-msg</td><td>git commit执行之后，编辑器打开之前</td><td></td></tr><tr><td>commit-msg</td><td>git commit 执行前</td><td>可以使用 git commit --no verify 命令绕过该钩子</td></tr><tr><td>post-commit</td><td>git commit 执行后</td><td>不影响git commit的结果</td></tr><tr><td>pre-rebase</td><td>git rebase执行前</td><td></td></tr><tr><td>post-checkout</td><td>git checkout 或 git switch执行后</td><td>如果不使用 --no-checkout 参数，则在 git clone 之后也会执行</td></tr><tr><td>post-merge</td><td>git merge 执行后</td><td>在执行git pull 时也会被调用</td></tr><tr><td>pre-push</td><td></td><td>git push 执行前</td></tr><tr><td>pre-receive</td><td>git receive pack 执行前</td><td></td></tr><tr><td>update</td><td></td><td></td></tr><tr><td>proc-receive</td><td></td><td></td></tr><tr><td>post-receive</td><td>git receive pack 执行前</td><td>不影响 git receive pack 的执行结果</td></tr><tr><td>post-update</td><td>当git receive pack对 git push 作出反应并更新仓库中的引用时</td><td></td></tr><tr><td>reference-transaction</td><td></td><td></td></tr><tr><td>push-to-checkout</td><td>当git receive pack对 git push 作出反应并更新仓库中的引用时，以及当推送试图更新当前被签出的分支且 receive.denyCurrentBranch配置被updateInstead时</td><td></td></tr><tr><td>pre-auto-gc</td><td>git gc --auto 执行前</td><td></td></tr><tr><td>post-rewrite</td><td>执行 git commit --amend 或 git rebase 时</td><td></td></tr><tr><td>sendemail-validate</td><td>git send-email 执行前</td><td></td></tr><tr><td>fsmonitor-watchman</td><td>配置core.fsmonitor被设置为.git/hooks/fsmonitor-watchman 或.git/hooks/fsmonitor-watchmanv2时</td><td></td></tr><tr><td>p4-changelist</td><td>git-p4 submit 执行并编辑完changelist message 之后</td><td>可以使用 git-p4 submit --no-verify绕过该钩子</td></tr><tr><td>p4-prepare-changelist</td><td>git-p4 submit 执行后，编辑器启动前</td><td>可以使用 git-p4 submit --no-verify绕过该钩子</td></tr><tr><td>p4-post-changelist</td><td>git-p4 submit 执行后</td><td></td></tr><tr><td>p4-pre-submit</td><td>git-p4 submit 执行前</td><td>可以使用 git-p4 submit --no-verify绕过该钩子</td></tr><tr><td>post-index-change</td><td>索引被写入 read-cache.c do_write_locked_index后</td><td></td></tr></tbody></table></div><h2 id="husky-v7-0-1"><a href="#husky-v7-0-1" class="headerlink" title="husky(v7.0.1)"></a>husky(v7.0.1)</h2><div class="story post-story"><p>husky 是一个让配置 git 钩子变得更简单的工具。支持所有的git钩子。</p><h3 id="使用husky"><a href="#使用husky" class="headerlink" title="使用husky"></a>使用husky</h3><ul><li><p>  首先执行安装命令 <code>npm install husky --save-dev</code></p></li><li><p>  要在安装后自动启用钩子，我们需要执行<code>npm set-script prepare &quot;husky install&quot;</code></p></li><li><p>执行完上一步的命令之后可以在package.json 文件的scripts配置项中看到如下代码：</p><p>  &quot;scripts&quot;: {</p><pre><code>  &quot;prepare&quot;: &quot;husky install&quot;</code></pre><p>  }<br>  复制代码</p></li><li><p>创建钩子，比如我们创建一个commit-msg钩子：<code>yarn husky add .husky/commit-msg &#39;yarn commitlint --edit &quot;$1&quot;&#39;</code></p></li><li><p>将上一步创建的 commit-msg 钩子添加到git中：<code>git add .husky/commit-msg</code></p></li><li><p>此外还有 <code>husky-init</code>命令， 执行之后可以在项目中快速的初始化一个husky。</p></li></ul></div><h2 id="lint-staged-v11-0-0"><a href="#lint-staged-v11-0-0" class="headerlink" title="lint-staged(v11.0.0)"></a>lint-staged(v11.0.0)</h2><div class="story post-story"><p><strong>lint-staged 是一个在git暂存区上运行linters的工具。</strong>（Run linters against staged git files and don&#39;t let 💩 slip into your code base!）</p><p>它将根据package.json依赖项中的代码质量工具来安装和配置 husky 和 lint-staged ，因此请确保在此之前安装（npm install --save-dev）并配置所有代码质量工具，比如Prettier和ESlint。</p><ul><li><p>安装：执行 <code>yarn add lint-staged -D</code> 命令</p><p>  执行 npx lint-staged --help 命令可以看到相关的所有参数如下：<br>  用法: lint-staged [options]</p><p>  Options:</p><pre><code>-V, --version                      输出版本号--allow-empty                      当任务撤消所有分阶段的更改时允许空提交（默认值：false）-c, --config [path]                配置文件的路径-d, --debug                        打印其他调试信息（默认值：false）-p, --concurrent &lt;parallel tasks&gt;  要同时运行的任务数，或者为false则要连续运行任务（默认值：true）-q, --quiet                        自己的控制台输出（默认值：false）-r, --relative                     将相对文件路径传递给任务（默认值：false）-x, --shell                        跳过任务解析以更好地支持shell（默认值：false）-h, --help                         输出用法信息</code></pre><p>  复制代码</p></li><li><p>  <strong>--allow-empty</strong>：使用此参数允许创建空的git提交。默认情况下，当LITER任务撤消所有阶段性的更改时，LITET阶段将抛出一个错误，并中止提交。</p></li></ul></div><h2 id="git-commit提交规范"><a href="#git-commit提交规范" class="headerlink" title="git commit提交规范"></a>git commit提交规范</h2><div class="story post-story"><p>通常使用 Google AnguarJS 规范的要求。 格式要求：</p><pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&lt;BLANK LINE&gt;&lt;body&gt;&lt;BLANK LINE&gt;&lt;footer&gt;复制代码</code></pre><ul><li>  <code>&lt;type&gt;</code>代表某次提交的类型，比如是修复一个 bug 或是增加一个 feature，具体类型如下：</li></ul><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>feat</td><td>新增feature</td></tr><tr><td>fix</td><td>修复bug</td></tr><tr><td>docs</td><td>仅仅修改了文档，比如README, CHANGELOG, CONTRIBUTE等等;</td></tr><tr><td>style</td><td>仅仅修改了空格、格式缩进、逗号等等，不改变代码逻辑;</td></tr><tr><td>refactor</td><td>代码重构，没有加新功能或者修复bug</td></tr><tr><td>perf</td><td>优化相关，比如提升性能、体验</td></tr><tr><td>test</td><td>测试用例，包括单元测试、集成测试等</td></tr><tr><td>chore</td><td>改变构建流程、或者增加依赖库、工具等</td></tr><tr><td>revert</td><td>回滚到上一个版本</td></tr></tbody></table><ul><li>  <code>scope</code>：说明commit影响的范围。scope依据项目而定，例如在业务项目中可以依据菜单或者功能模块划分，如果是组件库开发，则可以依据组件划分。</li><li>  <code>subject</code>:是commit的简短描述；</li><li>  <code>body</code>:提交代码的详细描述；</li><li>  <code>footer</code>:如果代码的提交是不兼容变更或关闭缺陷，则footer必需，否则可以省略。</li></ul></div><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><div class="story post-story"><ul><li>首先我们来安装需要用到的依赖，执行以下命令：</li><li>执行 <code>yarn add husky -D</code> 安装husky。</li><li>接着执行 <code>npm set-script prepare &quot;husky install&quot;</code> 之后，可以在package.json文件的scripts配置项中看到 <code>&quot;prepare&quot;: &quot;husky install&quot;</code></li></ul><p><strong>ps:</strong> <code>npm set-script prepare &quot;husky install&quot;</code> 在npm v7以上生效</p><ul><li>  继续执行 <code>yarn prepare</code>之后，可以在项目的根目录下看到多了如下图所示的目录：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20220217194344.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20220217194344.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20220217194344"></p><ul><li>  如果执行<code>yarn prepare</code>之后报如下图所示错误，则需要执行<code>git init</code>然后再执行<code>yarn prepare</code></li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd27bbdf20094e5db1210059e737b9db~tplv-k3u1fbpfcp-watermark.awebp" class="lazyload" data-srcset="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd27bbdf20094e5db1210059e737b9db~tplv-k3u1fbpfcp-watermark.awebp" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image.png"></p><ul><li><p>husky 准备好之后，我们接着来安装其他的用于规范，检查代码的依赖。</p></li><li><p>执行<code>yarn add lint-staged -D</code></p></li><li><p>执行<code>yarn add eslint prettier -D</code></p></li><li><p>在package.json文件下添加如下代码：</p><p>  &quot;lint-staged&quot;: {</p><pre><code>  &quot;src/**/*.&#123;js,jsx,ts,tsx,json&#125;&quot;: [    &quot;prettier --write&quot;,    &quot;eslint&quot;,    &quot;git add&quot;  ]</code></pre><p>  }<br>  复制代码</p></li><li><p>执行<code>yarn add @commitlint/cli @commitlint/config-conventional -D</code>安装commitlint相关依赖，用来帮助我们在多人开发时，遵守 git 提交约定。</p></li><li><p>执行<code>echo &quot;module.exports = &#123;extends: [&#39;@commitlint/config-conventional&#39;]&#125;&quot; &gt; commitlint.config.js</code>在根目录创建 commitlint.config.js 文件（当然也可以手动创建此文件），其内容如下所示：</p><p>  module.exports = {</p><pre><code>extends: [  &quot;@commitlint/config-conventional&quot;],rules: &#123;  &#39;type-enum&#39;: [    2,    &#39;always&#39;,    [      &#39;bug&#39;,       &#39;feat&#39;,       &#39;fix&#39;,       &#39;docs&#39;,       &#39;style&#39;,       &#39;refactor&#39;,       &#39;test&#39;,       &#39;chore&#39;,       &#39;revert&#39;,       &#39;merge&#39;     ]  ]&#125;</code></pre><p>  };</p><p>  复制代码</p></li><li><p>如果还需要别的代码优化依赖包，可以接着进行安装</p></li><li><p>至此，准备好我们需要的依赖包之后，我们开始添加钩子</p></li><li><p>执行<code>yarn husky add .husky/commit-msg &#39;yarn commitlint --edit &quot;$1&quot;&#39;</code>之后，会看到在根目录的<code>.husky</code>文件夹下多了一个 <code>commit-msg</code> 文件，其内容如下：</p><p>  #!/bin/sh<br>  . &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot;</p><p>  yarn commitlint --edit &quot;$1&quot;<br>  复制代码</p></li><li><p>紧接着，我们需要将上一步添加的钩子添加到git中去，执行<code>git add .husky/commit-msg</code></p></li><li><p>执行<code>yarn husky add .husky/pre-commit &#39;yarn lint-staged --allow-empty &quot;$1&quot;&#39;</code>之后，会看到在根目录的<code>.husky</code>文件夹下多了一个 <code>pre-commit</code> 文件，其内容如下：</p><p>  #!/bin/sh<br>  . &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot;</p><p>  yarn lint-staged --allow-empty &quot;$1&quot;<br>  复制代码</p></li><li><p>同样的，我们需要将上一步添加的钩子添加到git中去，执行<code>git add .husky/pre-commit</code></p></li><li><p>接下来，就是检验我么配置的时候了：当我们按照 commit规范正确提交时，可以在控制台看到如下输出</p></li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f95bad7174b422cab42b6ef64686bbd~tplv-k3u1fbpfcp-watermark.awebp" class="lazyload" data-srcset="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f95bad7174b422cab42b6ef64686bbd~tplv-k3u1fbpfcp-watermark.awebp" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image.png"></p><ul><li>  当我们不按照配置的规范来提交commit时，就会发现如下报错，并阻止你提交代码</li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea5260a7b47c4d32b9aa1d526d64b397~tplv-k3u1fbpfcp-watermark.awebp" class="lazyload" data-srcset="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea5260a7b47c4d32b9aa1d526d64b397~tplv-k3u1fbpfcp-watermark.awebp" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image.png"></p><ul><li>  至此，我们的钩子配置已经完美收官！</li></ul></div>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;日常工作中，几乎每个项目都是由多个人进行维护，每个人的代码书写习惯和风格又不尽相同，在这种情况下，规范和约束就显得尤为重要！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;githooks&quot;&gt;&lt;a href=&quot;#githooks&quot; class</summary>
      
    
    
    
    <category term="tool" scheme="https://kobingogo.github.io/categories/tool/"/>
    
    
    <category term="工程化" scheme="https://kobingogo.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>2021前端发展展望</title>
    <link href="https://kobingogo.github.io/2021%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E5%B1%95%E6%9C%9B/"/>
    <id>https://kobingogo.github.io/2021%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E5%B1%95%E6%9C%9B/</id>
    <published>2021-01-14T18:06:10.000Z</published>
    <updated>2024-08-08T10:31:05.013Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>又到了年底，想简单谈谈这一年前端的发展，以及21年可能会出现的一些趋势。毋庸置疑，2020年确实是不平凡的一年，对前端来说，私以为可以用“大前端持续深耕，泛前端兼容并包”这十四个字来形容。这里需要明确一下我对“大前端”以及“泛前端”这两个概念的理解：首先大前端可以分为广义的“大前端”和狭义的“大前端”，市面上常...</p></blockquote><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><div class="story post-story"><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20210114180804.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20210114180804.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20210114180804"></p><p>又到了年底，想简单谈谈这一年前端的发展，以及21年可能会出现的一些趋势。毋庸置疑，2020年确实是不平凡的一年，对前端来说，私以为可以用“大前端持续深耕，泛前端兼容并包”这十四个字来形容。这里需要明确一下我对“大前端”以及“泛前端”这两个概念的理解：首先大前端可以分为广义的“大前端”和狭义的“大前端”，市面上常说的大前端主要分为这两类，所谓广义的“大前端”是指以前端技术解决所有本属于其他领域问题的前端技术，这里其实是包含了后边所说的泛前端的概念，也就是说只要是使用前端技术去解决的都可以定义为“大前端”；而狭义的“大前端”是仅指垂直到后端领域的前端技术，其代表是以node.js为主的扩展的去解决后端领域的技术，如出现了诸如express、koa、egg、nest等等配套的后端技术框架，甚至出现了node的微服务框架，我这里不做说明仅指狭义的“大前端”概念。对于“泛前端”，这个概念没有歧义，通常指的都是跨端技术，比如客户端、桌面端，甚至HUB等等，上图中所示的仅仅指一部分框架，并未收录完全，毕竟js/ts的社区实在太太太太活跃了，下面简单分说一下“大前端”和“泛前端”个人的一些见解，是以前端三大框架Vue、React、Angular为核心进行横向和纵向的框架探讨</p><h3 id="泛前端技术框架探讨"><a href="#泛前端技术框架探讨" class="headerlink" title="泛前端技术框架探讨"></a>泛前端技术框架探讨</h3><table><thead><tr><th></th><th>Vue</th><th>React</th><th>Angular</th></tr></thead><tbody><tr><td>web端</td><td>Vue全家桶</td><td>React全家桶</td><td>Angular全家桶</td></tr><tr><td>桌面端</td><td>Electron/Nw</td><td>Electron/Nw</td><td>Electron/Nw/Cordova/Ionic</td></tr><tr><td>原生移动端</td><td>Weex</td><td>React Native</td><td>Cordova/Ionic</td></tr><tr><td>小程序端</td><td>uniapp/mpvue/mapx</td><td>taro/Rax</td><td>无</td></tr></tbody></table><h3 id="大前端技术框架探讨"><a href="#大前端技术框架探讨" class="headerlink" title="大前端技术框架探讨"></a>大前端技术框架探讨</h3><table><thead><tr><th></th><th>Vue</th><th>React</th><th>Angular</th></tr></thead><tbody><tr><td>web端</td><td>Vue全家桶</td><td>React全家桶</td><td>Angular全家桶</td></tr><tr><td>SSR</td><td>Nuxt</td><td>Next</td><td>Universal</td></tr><tr><td>服务端</td><td>无特定</td><td>无特定</td><td>可配合Nest</td></tr></tbody></table><p>今年<a href="https://mp.weixin.qq.com/s/Nm1G3jgS-fafEeNywTCtDA" target="_blank" rel="noopener external nofollow noreferrer">阿里前端练习生计划</a>将前端领域划分了七大方向，分别是工程化方向、前端中后台方向、Node.js方向、跨端技术方向、互动技术方向、可视化技术方向、前端智能化方向，个人认为Node.js是一个整体的前端基础，并不能单算做一个方向，因而我将其替换为音视频方向，私以为可将前端方向划分为以下几种，下面我将在这几个不同的方向维度进行个人的一些阐述和拙见：</p><ul><li>  中后台方向：微前端</li><li>  可视化方向：antv</li><li>  智能化方向：imgcook</li><li>  互动方向：Eva</li><li>  音视频方向：wasm</li><li>  工程化方向：severless、全链路工程</li><li>  跨端方向：kbone、rax</li></ul></div><h2 id="中后台方向"><a href="#中后台方向" class="headerlink" title="中后台方向"></a>中后台方向</h2><div class="story post-story"><ol><li> 对于中后台方向，这是传统web方向，对于前端来说，2020年对于微前端的落地应用已有很多实践。因此，私以为微前端会作为未来前端大型应用的一种趋势，对于不同团队的不同技术栈的汇总整合是一个比较好的方案，虽然不同于服务端的那种微服务可以微的很彻底，但是前端加持着ts等的特性也是可以实现微化的效果，从而优化工时，提升效率，避免重复劳作；</li><li> 既然第一点提到了ts，那这里我想说一说关于ts的问题，在19年我对ts的态度尚存观望，但在今年，我认为ts可以作为一种必备技能来考察和实践，并不是因为大家都在用，而是因为随着时间的发展，现在前端要承载的能力越来越重，项目也越来越大，ts可以很好的约定，对于后期的维护以及修改都可以很好的限制，对于大型团队、大型项目来说，ts是不二之选；另外，如果有团队真的要去开发服务端，那我真的建议你去用ts，如果你用过nest.js，你会发现和写java真的没什么区别，而且服务端的很多理念也可以通过ts的各种特性来使用，比如泛型、抽象类等。当然，如果是小团队，而且需要快速开发，对于小而美的应用，个人认为还是js适合，毕竟js是一门灵活的语言，哈哈哈</li></ol></div><h2 id="可视化方向"><a href="#可视化方向" class="headerlink" title="可视化方向"></a>可视化方向</h2><div class="story post-story"><ol><li> 可视化这里，今年其实没有做多少实践，但是个人认为，这七个大方向而言，最容易出成果，或者说最能出大佬的，可能还真是可视化领域，如果能在可视化领域做到了前5%，那么我相信各大厂肯定会花钱养着你，毕竟我拥有你不一定重要，但是对手不拥有你对我很重要，你的技术壁垒就呈现了出来，也就在这个内卷的江湖获得了一些领先和优势，最起码裁员的优先级也不会那么靠前，哈哈哈</li><li> 第一点说的有点儿远，说说实在的，个人觉得可以将阿里的antv作为可视化领域的一个标杆，针对各种特定领域进行展开，比如gis等，当然，其实可视化领域研究的深的话还是挺冷门的，这其实也会有一些机会，webGL/webAR/webVR等等都可以作为切入点，配合着下面的音视频领域，这两个的相互结合，确实还是能做出些东西的</li></ol></div><h2 id="智能化方向"><a href="#智能化方向" class="headerlink" title="智能化方向"></a>智能化方向</h2><div class="story post-story"><ol><li> 智能化领域，个人认为其实核心不在于前端，而在于人工智能，而人工智能领域就不仅仅前端那么些东西了，对于封装好的如TensorFlow.js，我们是直接拿来用的，但是对于领面的模型建立其实才是关键，如果有同学想在智能化领域有所发展，个人建议还是要深钻一下，最好可以深造一下，毕竟这个东西是真的需要学术研究+产业实践的</li><li> 在产业实践的前端领域，阿里还是比较领先的，比如imgcook，其核心目的是将图片转成前端代码，利用的机器视觉去识别图片中的不同的位置信息等，将其转成前端的代码，也就是所谓的D2C，即：Design to Code，今年的D2大会上又提出了P2C，即：Product to Code，但并不是真的将人类语言直接转换成code，而是对D2C的一个业务扩展，对于D2C某些业务代码利用一些特定的schema进行约定，让机器学习过程中多一些参数约束，从而提升代码实现度。虽然转化的代码还很冗余，但是对于一些初级的项目或页面，确实可以交给机器去实现，个人认为人工智能对低端重复的工作确实会进行替代，也算是对前端内卷做了一定的贡献，摊手...</li></ol></div><h2 id="互动方向"><a href="#互动方向" class="headerlink" title="互动方向"></a>互动方向</h2><div class="story post-story"><ol><li> 互动方向，目前大头还是在游戏方向，但是我还是认为页游或前端实现游戏主要还是做一些开胃菜的功能，并不能真正的将用户带进沉浸式的体验，对于小游戏引擎，今年阿里好像出了一个eva的引擎，感兴趣的同学可以看看</li><li> 对于新体验方面，AR/VR/MR等可能在明年5g深化的时候会有一些落地实践，但可能还是不温不火，互动方向配合设计的新理念可能会是一个新的突破点</li></ol></div><h2 id="音视频方向"><a href="#音视频方向" class="headerlink" title="音视频方向"></a>音视频方向</h2><div class="story post-story"><ol><li> 这里想说一说WebAssembly，虽然都说wasm是会替代掉js，但目前看应该还不太现实，wasm目前主要还是配合音视频领域多一些，另外就是一些额外的优化措施，配合rust进行优化等，如果有志于音视频领域有所建树的同学，wasm确实可以储备起来</li><li> webrtc是音视频领域一个绕不开的技术，另外就是播放器的实现，video.js、flv.js等，对于一些视频播放的协议也要了解，如rtmp/rtsp等，今年疫情的关系，带动着直播领域的火热，前端音视频方向说不定会是一个风口</li></ol></div><h2 id="工程化方向"><a href="#工程化方向" class="headerlink" title="工程化方向"></a>工程化方向</h2><div class="story post-story"><ol><li> 工程化方向就不得不提serverless，这是今年前端最火热的一个话题了，私以为serverless不仅仅是前端领域的变化，它可能改变目前的开发模式，以后没有前后端之分（ps：目前确实是有合的趋势），只有云工程师和端工程师之分，那么对于目前的前端来说，我们就不能仅仅只关注前端领域的一些内容了，docker、k8s等属于传统后端或运维的部分，我们也需要掌握，对于一些后端的思维及名词也需要熟悉，如限流、削峰、服务降级等。当然serverless的前提其实是云原生，如果没有云化，那实现serverless的效果应该不如目前这样，当然个人认为这是一个必然的趋势，从今年的云栖大会以及运营商5g云化来看，云网融合、云边协同应该会是主流</li><li> 前端工程化另外一个方向就是全链路的工程化，从脚手架、low code、插件市场等全链路的提供，简化前端开发门槛，这里可以参考淘系的飞冰，对low code以及ide的插件提供都有涉及，以及ui组件库的提供等等，形成一个全链路的前端生态。这里可以说说low code和no code，no code是一个无需任何编码的现成的工具，就是完全没有编程的入口；low code是一个需要部分编码的工具，为了是给一些非专业人士但又有编程需要的人员使用，强调开发出来给别人用，常见的比如给运营人员用的h5编辑器，如易企秀、maka、ih5等</li></ol></div><h2 id="跨端方向"><a href="#跨端方向" class="headerlink" title="跨端方向"></a>跨端方向</h2><div class="story post-story"><ol><li> 跨端方向是一个老生常谈的问题，主流还是要write once，run anywhere，常见的无非就是利用各种框架将各个DSL进行来回转换，但其实这是一个伪命题，本质是不可能达到大一统的局面的，抽象就很难具象，这两者需要有一个平衡，需要对具体常见具体分析</li><li> 私以为小程序领域是端方向下一个各家大佬追逐的市场，因为app领域的跑马圈地都已基本形成，现在再去开发出一个现象级的app几乎很难很难了，但是将app作为操作系统，以小程序去带动用户，形成用户闭环，还是有很大市场的，类小程序应用，如pwa、快应用等都是这种承载方式的不同展现，对跨端来说，这个不失为一种发展选择。对于小程序的框架也出现了kbone、rax等，可能也会有一个类似w3c这样的一个小程序标准，但是像微信这种巨无霸应用，是否真的会遵守就是另一回事了，总之，其实也不失为一个选择</li></ol></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="story post-story"><p>回望2020，展望2021，总结如下：</p><ol><li> 大前端持续深耕，泛前端兼容并包</li><li> 中后台微服务化，可视化行业细化</li><li> 智能侧算法深化，互娱侧形态变化</li><li> 音视频结构优化，工程侧全面转化</li><li> 跨端侧具体改化，前端更加内卷化</li></ol><p>好了，2021到了，愿大家在这个内卷的时代，都有自己的一技之长，形成自己的核心竞争力，升职加薪，再创辉煌，共勉！！！</p><p>转载自<a href="https://segmentfault.com/a/1190000038768154" target="_blank" rel="noopener external nofollow noreferrer">Source</a></p></div>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;又到了年底，想简单谈谈这一年前端的发展，以及21年可能会出现的一些趋势。毋庸置疑，2020年确实是不平凡的一年，对前端来说，私以为可以用“大前端持续深耕，泛前端兼容并包”这十四个字来形容。这里需要明确一下我对“大前端”以及“泛前端”这两个概念的理解：首先大前端可以分为广义的“大前端”和狭义的“大前端”，市面上常...&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>css实现两个圆重叠</title>
    <link href="https://kobingogo.github.io/css-css%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E5%9C%86%E9%87%8D%E5%8F%A0/"/>
    <id>https://kobingogo.github.io/css-css%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E5%9C%86%E9%87%8D%E5%8F%A0/</id>
    <published>2021-01-07T17:04:27.000Z</published>
    <updated>2024-08-08T10:31:05.013Z</updated>
    
    <content type="html"><![CDATA[<p>工作中有一个需求，实现两个椭圆相交，并且相交区域颜色不同，类似于一个简单的<code>韦恩图</code>，如何用css实现这个效果？ 经过一番探索，找到了答案。</p><span id="more"></span><p>要实现这个效果，需要用到的神技：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/mix-blend-mode#%E4%B8%8D%E5%90%8Cmix-blend-mode%E5%80%BC%E7%9A%84%E6%95%88%E6%9E%9C" target="_blank" rel="noopener external nofollow noreferrer"><code>css-blend-mode</code></a>, 它是一个css属性，描述了元素的内容应该与元素的直系父元素的内容和元素的背景如何混合。</p><p>有了这个，就可以愉快的直接上代码了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;isolate&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;circle circle-1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;circle circle-2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.circle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">110px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">70px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span> / <span class="number">35px</span>;</span><br><span class="line">  <span class="attribute">mix-blend-mode</span>: color-dodge;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.circle-1</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#39518A</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.circle-2</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#0091FF</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.isolate</span> &#123;</span><br><span class="line">  <span class="attribute">isolation</span>: isolate; <span class="comment">/* Without isolation, the background color will be taken into account */</span></span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体效果参见：<a href="https://codepen.io/jiangawait/pen/zYKaRZx" target="_blank" rel="noopener external nofollow noreferrer">例子</a></p><p>当然css-blend-mode不仅仅只有这点作用，它还能用作背景混合，纹理叠加，视频混合等场景，具体可参考：</p><p><a href="https://www.zhangxinxu.com/wordpress/2019/05/css-mix-blend-mode-screen/" target="_blank" rel="noopener external nofollow noreferrer">大神的文章</a></p><p>打完收工😊</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;工作中有一个需求，实现两个椭圆相交，并且相交区域颜色不同，类似于一个简单的&lt;code&gt;韦恩图&lt;/code&gt;，如何用css实现这个效果？ 经过一番探索，找到了答案。&lt;/p&gt;</summary>
    
    
    
    <category term="css" scheme="https://kobingogo.github.io/categories/css/"/>
    
    
    <category term="css" scheme="https://kobingogo.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>ES6全部特性汇总</title>
    <link href="https://kobingogo.github.io/javascript-ES6%E5%85%A8%E9%83%A8%E7%89%B9%E6%80%A7%E6%B1%87%E6%80%BB/"/>
    <id>https://kobingogo.github.io/javascript-ES6%E5%85%A8%E9%83%A8%E7%89%B9%E6%80%A7%E6%B1%87%E6%80%BB/</id>
    <published>2020-10-23T10:58:51.000Z</published>
    <updated>2024-08-08T10:31:05.017Z</updated>
    
    <content type="html"><![CDATA[<p>本文的知识点完全是参考或摘录<a href="https://es6.ruanyifeng.com/" target="_blank" rel="noopener external nofollow noreferrer">《ES6》</a>里的语句，有部分语句为了方便理解和记忆，进行了相同意思的转义，同时对知识点进行归类划分。为了让大家能集中精力来记住这些特性，全文一句废话和题外话都没有，全部模块以笔记的形式进行书写，如果看得不是很惯建议对照<a href="https://es6.ruanyifeng.com/" target="_blank" rel="noopener external nofollow noreferrer">《ES6》</a>的内容来学习。</p><p>本文整理出来的笔记都是书中的精华内容，囊括了整个<code>ES6体系</code>的所有特性，非常方便大家重新认识<code>全部ES6特性</code>。半小时的阅读就可对<code>ES6</code>有一个全面的了解，可认为是一本<code>ES6特性小字典</code>，收藏后可随时查阅。即使看不完也要拉到本文末尾喔，有个大彩蛋，嘻嘻！</p><span id="more"></span><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201023110159.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201023110159.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20201023110159"></p><h3 id="修正"><a href="#修正" class="headerlink" title="修正"></a>修正</h3><p><strong>ES6</strong>是<code>ECMA</code>为<code>JavaScript</code>制定的第6个标准版本，相关历史可查看此章节<a href="https://es6.ruanyifeng.com/#docs/intro" target="_blank" rel="noopener external nofollow noreferrer">《ES6-ECMAScript6简介》</a>。</p><p>标准委员会最终决定，标准在每年6月正式发布并作为当年的正式版本，接下来的时间里就在此版本的基础上进行改动，直到下一年6月草案就自然变成新一年的版本，这样一来就无需以前的版本号，只要用年份标记即可。<code>ECMAscript 2015</code>是在<code>2015年6月</code>发布ES6的第一个版本。以此类推，<code>ECMAscript 2016</code>是ES6的第二个版本、 <code>ECMAscript 2017</code>是ES6的第三个版本。<strong>ES6</strong>既是一个历史名词也是一个泛指，含义是<code>5.1版本</code>以后的<code>JavaScript下一代标准</code>，目前涵盖了<code>ES2015</code>、<code>ES2016</code>、<code>ES2017</code>、<code>ES2018</code>、<code>ES2019</code>、<code>ES2020</code>。</p><p>所以有些文章上提到的<code>ES7</code>(实质上是<code>ES2016</code>)、<code>ES8</code>(实质上是<code>ES2017</code>)、<code>ES9</code>(实质上是<code>ES2018</code>)、<code>ES10</code>(实质上是<code>ES2019</code>)、<code>ES11</code>(实质上是<code>ES2020</code>)，实质上都是一些不规范的概念。从ES1到ES6，每个标准都是花了好几年甚至十多年才制定下来，你一个ES6到ES7，ES7到ES8，才用了一年，按照这样的定义下去，那不是很快就ES20了。用正确的概念来说ES6目前涵盖了<strong>ES2015</strong>、<strong>ES2016</strong>、<strong>ES2017</strong>、<strong>ES2018</strong>、<strong>ES2019</strong>、<strong>ES2020</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201023110231.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201023110231.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20201023110231"></p><p>另外，ES6更新的内容主要分为以下几点</p><ul><li>  <strong>表达式</strong>：声明、解构赋值</li><li>  <strong>内置对象</strong>：字符串扩展、数值扩展、对象扩展、数组扩展、函数扩展、正则扩展、Symbol、Set、Map、Proxy、Reflect</li><li>  <strong>语句与运算</strong>：Class、Module、Iterator</li><li>  <strong>异步编程</strong>：Promise、Generator、Async</li></ul><h2 id="ES2015"><a href="#ES2015" class="headerlink" title="ES2015"></a>ES2015</h2><div class="story post-story"><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201023110314.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201023110314.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20201023110314"></p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><ul><li>  <strong>const命令</strong>：声明常量</li><li>  <strong>let命令</strong>：声明变量</li></ul><blockquote><p>作用</p></blockquote><ul><li>作用域<ul><li>  <strong>全局作用域</strong></li><li>  <strong>函数作用域</strong>：<code>function() &#123;&#125;</code></li><li>  <strong>块级作用域</strong>：<code>&#123;&#125;</code></li></ul></li><li>作用范围<ul><li>  <code>var命令</code>在全局代码中执行</li><li>  <code>const命令</code>和<code>let命令</code>只能在代码块中执行</li></ul></li><li>赋值使用<ul><li>  <code>const命令</code>声明常量后必须立马赋值</li><li>  <code>let命令</code>声明变量后可立马赋值或使用时赋值</li></ul></li><li>  声明方法：<code>var</code>、<code>const</code>、<code>let</code>、<code>function</code>、<code>class</code>、<code>import</code></li></ul><blockquote><p>重点难点</p></blockquote><ul><li>  不允许重复声明</li><li>  未定义就使用会报错：<code>const命令</code>和<code>let命令</code>不存在变量提升</li><li>  暂时性死区：在代码块内使用<code>const命令</code>和<code>let命令</code>声明变量之前，该变量都不可用</li></ul><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><ul><li>  <strong>字符串解构</strong>：<code>const [a, b, c, d, e] = &quot;hello&quot;</code></li><li>  <strong>数值解构</strong>：<code>const &#123; toString: s &#125; = 123</code></li><li>  <strong>布尔解构</strong>：<code>const &#123; toString: b &#125; = true</code></li><li><strong>对象解构</strong><ul><li>  形式：<code>const &#123; x, y &#125; = &#123; x: 1, y: 2 &#125;</code></li><li>  默认：<code>const &#123; x, y = 2 &#125; = &#123; x: 1 &#125;</code></li><li>  改名：<code>const &#123; x, y: z &#125; = &#123; x: 1, y: 2 &#125;</code></li></ul></li><li><strong>数组解构</strong><ul><li>  规则：数据结构具有<code>Iterator接口</code>可采用数组形式的解构赋值</li><li>  形式：<code>const [x, y] = [1, 2]</code></li><li>  默认：<code>const [x, y = 2] = [1]</code></li></ul></li><li><strong>函数参数解构</strong><ul><li>  数组解构：<code>function Func([x = 0, y = 1]) &#123;&#125;</code></li><li>  对象解构：<code>function Func(&#123; x = 0, y = 1 &#125; = &#123;&#125;) &#123;&#125;</code></li></ul></li></ul><blockquote><p>应用场景</p></blockquote><ul><li>  交换变量值：<code>[x, y] = [y, x]</code></li><li>  返回函数多个值：<code>const [x, y, z] = Func()</code></li><li>  定义函数参数：<code>Func([1, 2])</code></li><li>  提取JSON数据：<code>const &#123; name, version &#125; = packageJson</code></li><li>  定义函数参数默认值：<code>function Func(&#123; x = 1, y = 2 &#125; = &#123;&#125;) &#123;&#125;</code></li><li>  遍历Map结构：<code>for (let [k, v] of Map) &#123;&#125;</code></li><li>  输入模块指定属性和方法：<code>const &#123; readFile, writeFile &#125; = require(&quot;fs&quot;)</code></li></ul><blockquote><p>重点难点</p></blockquote><ul><li>  匹配模式：只要等号两边的模式相同，左边的变量就会被赋予对应的值</li><li>  解构赋值规则：只要等号右边的值不是对象或数组，就先将其转为对象</li><li>  解构默认值生效条件：属性值严格等于<code>undefined</code></li><li>  解构遵循匹配模式</li><li>  解构不成功时变量的值等于<code>undefined</code></li><li>  <code>undefined</code>和<code>null</code>无法转为对象，因此无法进行解构</li></ul><h3 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h3><ul><li>  <strong>Unicode表示法</strong>：<code>大括号包含</code>表示Unicode字符(<code>\u&#123;0xXX&#125;</code>或<code>\u&#123;0XXX&#125;</code>)</li><li>  <strong>字符串遍历</strong>：可通过<code>for-of</code>遍历字符串</li><li>  <strong>字符串模板</strong>：可单行可多行可插入变量的增强版字符串</li><li>  <strong>标签模板</strong>：函数参数的特殊调用</li><li>  **String.raw()**：返回把字符串所有变量替换且对斜杠进行转义的结果</li><li>  **String.fromCodePoint()**：返回码点对应字符</li><li>  **codePointAt()**：返回字符对应码点(<code>String.fromCodePoint()</code>的逆操作)</li><li>  **normalize()**：把字符的不同表示方法统一为同样形式，返回<code>新字符串</code>(Unicode正规化)</li><li>  **repeat()**：把字符串重复n次，返回<code>新字符串</code></li><li>  **matchAll()**：返回正则表达式在字符串的所有匹配</li><li>  **includes()**：是否存在指定字符串</li><li>  **startsWith()**：是否存在字符串头部指定字符串</li><li>  **endsWith()**：是否存在字符串尾部指定字符串</li></ul><blockquote><p>重点难点</p></blockquote><ul><li>  以上扩展方法均可作用于由<code>4个字节储存</code>的<code>Unicode字符</code>上</li></ul><h3 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h3><ul><li>  <strong>二进制表示法</strong>：<code>0b或0B开头</code>表示二进制(<code>0bXX</code>或<code>0BXX</code>)</li><li>  <strong>八进制表示法</strong>：<code>0o或0O开头</code>表示二进制(<code>0oXX</code>或<code>0OXX</code>)</li><li>  <strong>Number.EPSILON</strong>：数值最小精度</li><li>  <strong>Number.MIN_SAFE_INTEGER</strong>：最小安全数值(<code>-2^53</code>)</li><li>  <strong>Number.MAX_SAFE_INTEGER</strong>：最大安全数值(<code>2^53</code>)</li><li>  **Number.parseInt()**：返回转换值的整数部分</li><li>  **Number.parseFloat()**：返回转换值的浮点数部分</li><li>  **Number.isFinite()**：是否为有限数值</li><li>  **Number.isNaN()**：是否为NaN</li><li>  **Number.isInteger()**：是否为整数</li><li>  **Number.isSafeInteger()**：是否在数值安全范围内</li><li>  **Math.trunc()**：返回数值整数部分</li><li>  **Math.sign()**：返回数值类型(<code>正数1</code>、<code>负数-1</code>、<code>零0</code>)</li><li>  **Math.cbrt()**：返回数值立方根</li><li>  **Math.clz32()**：返回数值的32位无符号整数形式</li><li>  **Math.imul()**：返回两个数值相乘</li><li>  **Math.fround()**：返回数值的32位单精度浮点数形式</li><li>  **Math.hypot()**：返回所有数值平方和的平方根</li><li>  **Math.expm1()**：返回<code>e^n - 1</code></li><li>  **Math.log1p()**：返回<code>1 + n</code>的自然对数(<code>Math.log(1 + n)</code>)</li><li>  **Math.log10()**：返回以10为底的n的对数</li><li>  **Math.log2()**：返回以2为底的n的对数</li><li>  **Math.sinh()**：返回n的双曲正弦</li><li>  **Math.cosh()**：返回n的双曲余弦</li><li>  **Math.tanh()**：返回n的双曲正切</li><li>  **Math.asinh()**：返回n的反双曲正弦</li><li>  **Math.acosh()**：返回n的反双曲余弦</li><li>  **Math.atanh()**：返回n的反双曲正切</li></ul><h3 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h3><ul><li>  <strong>简洁表示法</strong>：直接写入变量和函数作为对象的属性和方法(<code>&#123; prop, method() &#123;&#125; &#125;</code>)</li><li>  <strong>属性名表达式</strong>：字面量定义对象时使用<code>[]</code>定义键(<code>[prop]</code>，不能与上同时使用)</li><li><strong>方法的name属性</strong>：返回方法函数名<ul><li>  取值函数(getter)和存值函数(setter)：<code>get/set 函数名</code>(属性的描述对象在<code>get</code>和<code>set</code>上)</li><li>  bind返回的函数：<code>bound 函数名</code></li><li>  Function构造函数返回的函数实例：<code>anonymous</code></li></ul></li><li>  <strong>属性的可枚举性和遍历</strong>：描述对象的<code>enumerable</code></li><li>  <strong>super关键字</strong>：指向当前对象的原型对象(只能用在对象的简写方法中<code>method() &#123;&#125;</code>)</li><li>  **Object.is()**：对比两值是否相等</li><li>  **Object.assign()**：合并对象(浅拷贝)，返回原对象</li><li>  **Object.getPrototypeOf()**：返回对象的原型对象</li><li>  **Object.setPrototypeOf()**：设置对象的原型对象</li><li>  **__proto__**：返回或设置对象的原型对象</li></ul><blockquote><p>属性遍历</p></blockquote><ul><li>  描述：<code>自身</code>、<code>可继承</code>、<code>可枚举</code>、<code>非枚举</code>、<code>Symbol</code></li><li>遍历<ul><li>  <code>for-in</code>：遍历对象<code>自身可继承可枚举</code>属性</li><li>  <code>Object.keys()</code>：返回对象<code>自身可枚举</code>属性键组成的数组</li><li>  <code>Object.getOwnPropertyNames()</code>：返回对象<code>自身非Symbol</code>属性键组成的数组</li><li>  <code>Object.getOwnPropertySymbols()</code>：返回对象<code>自身Symbol</code>属性键组成的数组</li><li>  <code>Reflect.ownKeys()</code>：返回对象<code>自身全部</code>属性键组成的数组</li></ul></li><li>规则<ul><li>  首先遍历所有数值键，按照数值升序排列</li><li>  其次遍历所有字符串键，按照加入时间升序排列</li><li>  最后遍历所有Symbol键，按照加入时间升序排列</li></ul></li></ul><h3 id="数组扩展"><a href="#数组扩展" class="headerlink" title="数组扩展"></a>数组扩展</h3><ul><li>  **扩展运算符(...)**：转换数组为用逗号分隔的参数序列(<code>[...arr]</code>，相当于<code>rest/spread参数</code>的逆运算)</li><li>**Array.from()**：转换具有<code>Iterator接口</code>的数据结构为真正数组，返回新数组<ul><li>  类数组对象：<code>包含length的对象</code>、<code>Arguments对象</code>、<code>NodeList对象</code></li><li>  可遍历对象：<code>String</code>、<code>Set结构</code>、<code>Map结构</code>、<code>Generator函数</code></li></ul></li><li>  **Array.of()**：转换一组值为真正数组，返回新数组</li><li>  **copyWithin()**：把指定位置的成员复制到其他位置，返回原数组</li><li>  **find()**：返回第一个符合条件的成员</li><li>  **findIndex()**：返回第一个符合条件的成员索引值</li><li>  **fill()**：根据指定值填充整个数组，返回原数组</li><li>  **keys()**：返回以索引值为遍历器的对象</li><li>  **values()**：返回以属性值为遍历器的对象</li><li>  **entries()**：返回以索引值和属性值为遍历器的对象</li><li>  <strong>数组空位</strong>：ES6明确将数组空位转为<code>undefined</code>(空位处理规不一，建议避免出现)</li></ul><blockquote><p>扩展应用</p></blockquote><ul><li>  克隆数组：<code>const arr = [...arr1]</code></li><li>  合并数组：<code>const arr = [...arr1, ...arr2]</code></li><li>  拼接数组：<code>arr.push(...arr1)</code></li><li>  代替apply：<code>Math.max.apply(null, [x, y])</code> =&gt; <code>Math.max(...[x, y])</code></li><li>  转换字符串为数组：<code>[...&quot;hello&quot;]</code></li><li>  转换类数组对象为数组：<code>[...Arguments, ...NodeList]</code></li><li>  转换可遍历对象为数组：<code>[...String, ...Set, ...Map, ...Generator]</code></li><li>  与数组解构赋值结合：<code>const [x, ...rest/spread] = [1, 2, 3]</code></li><li>  计算Unicode字符长度：<code>Array.from(&quot;hello&quot;).length</code> =&gt; <code>[...&quot;hello&quot;].length</code></li></ul><blockquote><p>重点难点</p></blockquote><ul><li>  使用<code>keys()</code>、<code>values()</code>、<code>entries()</code>返回的遍历器对象，可用<code>for-of</code>自动遍历或<code>next()</code>手动遍历</li></ul><h3 id="函数扩展"><a href="#函数扩展" class="headerlink" title="函数扩展"></a>函数扩展</h3><ul><li><strong>参数默认值</strong>：为函数参数指定默认值<ul><li>  形式：<code>function Func(x = 1, y = 2) &#123;&#125;</code></li><li>  参数赋值：惰性求值(函数调用后才求值)</li><li>  参数位置：尾参数</li><li>  参数作用域：函数作用域</li><li>  声明方式：默认声明，不能用<code>const</code>或<code>let</code>再次声明</li><li>  length：返回没有指定默认值的参数个数</li><li>  与解构赋值默认值结合：<code>function Func(&#123; x = 1, y = 2 &#125; = &#123;&#125;) &#123;&#125;</code></li><li>应用<ul><li>  指定某个参数不得省略，省略即抛出错误：<code>function Func(x = throwMissing()) &#123;&#125;</code></li><li>  将参数默认值设为<code>undefined</code>，表明此参数可省略：<code>Func(undefined, 1)</code></li></ul></li></ul></li><li>**rest/spread参数(...)**：返回函数多余参数<ul><li>  形式：以数组的形式存在，之后不能再有其他参数</li><li>  作用：代替<code>Arguments对象</code></li><li>  length：返回没有指定默认值的参数个数但不包括<code>rest/spread参数</code></li></ul></li><li><strong>严格模式</strong>：在严格条件下运行JS<ul><li>  应用：只要函数参数使用默认值、解构赋值、扩展运算符，那么函数内部就不能显式设定为严格模式</li></ul></li><li><strong>name属性</strong>：返回函数的函数名<ul><li>  将匿名函数赋值给变量：<code>空字符串</code>(<strong>ES5</strong>)、<code>变量名</code>(<strong>ES6</strong>)</li><li>  将具名函数赋值给变量：<code>函数名</code>(<strong>ES5和ES6</strong>)</li><li>  bind返回的函数：<code>bound 函数名</code>(<strong>ES5和ES6</strong>)</li><li>  Function构造函数返回的函数实例：<code>anonymous</code>(<strong>ES5和ES6</strong>)</li></ul></li><li>**箭头函数(=&gt;)**：函数简写<ul><li>  无参数：<code>() =&gt; &#123;&#125;</code></li><li>  单个参数：<code>x =&gt; &#123;&#125;</code></li><li>  多个参数：<code>(x, y) =&gt; &#123;&#125;</code></li><li>  解构参数：<code>(&#123;x, y&#125;) =&gt; &#123;&#125;</code></li><li>  嵌套使用：部署管道机制</li><li>this指向固定化<ul><li>  并非因为内部有绑定<code>this</code>的机制，而是根本没有自己的<code>this</code>，导致内部的<code>this</code>就是外层代码块的<code>this</code></li><li>  因为没有<code>this</code>，因此不能用作构造函数</li></ul></li></ul></li><li><strong>尾调用优化</strong>：只保留内层函数的调用帧<ul><li>尾调用<ul><li>  定义：某个函数的最后一步是调用另一个函数</li><li>  形式：<code>function f(x) &#123; return g(x); &#125;</code></li></ul></li><li>尾递归<ul><li>  定义：函数尾调用自身</li><li>  作用：只要使用尾递归就不会发生栈溢出，相对节省内存</li><li>  实现：把所有用到的内部变量改写成函数的参数并使用参数默认值</li></ul></li></ul></li></ul><blockquote><p>箭头函数误区</p></blockquote><ul><li>  函数体内的<code>this</code>是<code>定义时所在的对象</code>而不是<code>使用时所在的对象</code></li><li>  可让<code>this</code>指向固定化，这种特性很有利于封装回调函数</li><li>  不可当作<code>构造函数</code>，因此箭头函数不可使用<code>new命令</code></li><li>  不可使用<code>yield命令</code>，因此箭头函数不能用作<code>Generator函数</code></li><li>  不可使用<code>Arguments对象</code>，此对象在函数体内不存在(可用<code>rest/spread参数</code>代替)</li><li>  返回对象时必须在对象外面加上括号</li></ul><h3 id="正则扩展"><a href="#正则扩展" class="headerlink" title="正则扩展"></a>正则扩展</h3><ul><li>  <strong>变更RegExp构造函数入参</strong>：允许首参数为<code>正则对象</code>，尾参数为<code>正则修饰符</code>(返回的正则表达式会忽略原正则表达式的修饰符)</li><li>  <strong>正则方法调用变更</strong>：字符串对象的<code>match()</code>、<code>replace()</code>、<code>search()</code>、<code>split()</code>内部调用转为调用<code>RegExp</code>实例对应的<code>RegExp.prototype[Symbol.方法]</code></li><li><strong>u修饰符</strong>：Unicode模式修饰符，正确处理大于<code>\uFFFF</code>的<code>Unicode字符</code><ul><li>  <code>点字符</code>(.)</li><li>  <code>Unicode表示法</code></li><li>  <code>量词</code></li><li>  <code>预定义模式</code></li><li>  <code>i修饰符</code></li><li>  <code>转义</code></li></ul></li><li>  <strong>y修饰符</strong>：粘连修饰符，确保匹配必须从剩余的第一个位置开始全局匹配(与<code>g修饰符</code>作用类似)</li><li>  <strong>unicode</strong>：是否设置<code>u修饰符</code></li><li>  <strong>sticky</strong>：是否设置<code>y修饰符</code></li><li>  <strong>flags</strong>：返回正则表达式的修饰符</li></ul><blockquote><p>重点难点</p></blockquote><ul><li>  <code>y修饰符</code>隐含头部匹配标志<code>^</code></li><li>  单单一个<code>y修饰符</code>对<code>match()</code>只能返回第一个匹配，必须与<code>g修饰符</code>联用才能返回所有匹配</li></ul><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><ul><li>  定义：独一无二的值</li><li>  声明：<code>const set = Symbol(str)</code></li><li>  入参：字符串(可选)</li><li>方法<ul><li>  **Symbol()**：创建以参数作为描述的<code>Symbol值</code>(不登记在全局环境)</li><li>  **Symbol.for()**：创建以参数作为描述的<code>Symbol值</code>，如存在此参数则返回原有的<code>Symbol值</code>(先搜索后创建，登记在全局环境)</li><li>  **Symbol.keyFor()**：返回已登记的<code>Symbol值</code>的描述(只能返回<code>Symbol.for()</code>的<code>key</code>)</li><li>  **Object.getOwnPropertySymbols()**：返回对象中所有用作属性名的<code>Symbol值</code>的数组</li></ul></li><li>内置<ul><li>  <strong>Symbol.hasInstance</strong>：指向一个内部方法，当其他对象使用<code>instanceof运算符</code>判断是否为此对象的实例时会调用此方法</li><li>  <strong>Symbol.isConcatSpreadable</strong>：指向一个布尔，定义对象用于<code>Array.prototype.concat()</code>时是否可展开</li><li>  <strong>Symbol.species</strong>：指向一个构造函数，当实例对象使用自身构造函数时会调用指定的构造函数</li><li>  <strong>Symbol.match</strong>：指向一个函数，当实例对象被<code>String.prototype.match()</code>调用时会重新定义<code>match()</code>的行为</li><li>  <strong>Symbol.replace</strong>：指向一个函数，当实例对象被<code>String.prototype.replace()</code>调用时会重新定义<code>replace()</code>的行为</li><li>  <strong>Symbol.search</strong>：指向一个函数，当实例对象被<code>String.prototype.search()</code>调用时会重新定义<code>search()</code>的行为</li><li>  <strong>Symbol.split</strong>：指向一个函数，当实例对象被<code>String.prototype.split()</code>调用时会重新定义<code>split()</code>的行为</li><li>  <strong>Symbol.iterator</strong>：指向一个默认遍历器方法，当实例对象执行<code>for-of</code>时会调用指定的默认遍历器</li><li>  <strong>Symbol.toPrimitive</strong>：指向一个函数，当实例对象被转为原始类型的值时会返回此对象对应的原始类型值</li><li>  <strong>Symbol.toStringTag</strong>：指向一个函数，当实例对象被<code>Object.prototype.toString()</code>调用时其返回值会出现在<code>toString()</code>返回的字符串之中表示对象的类型</li><li>  <strong>Symbol.unscopables</strong>：指向一个对象，指定使用<code>with</code>时哪些属性会被<code>with环境</code>排除</li></ul></li></ul><blockquote><p>数据类型</p></blockquote><ul><li>  <strong>Undefined</strong></li><li>  <strong>Null</strong></li><li>  <strong>String</strong></li><li>  <strong>Number</strong></li><li>  <strong>Boolean</strong></li><li>  <strong>Object</strong>(包含<code>Array</code>、<code>Function</code>、<code>Date</code>、<code>RegExp</code>、<code>Error</code>)</li><li>  <strong>Symbol</strong></li></ul><blockquote><p>应用场景</p></blockquote><ul><li>  唯一化对象属性名：属性名属于Symbol类型，就都是独一无二的，可保证不会与其他属性名产生冲突</li><li>  消除魔术字符串：在代码中多次出现且与代码形成强耦合的某一个具体的字符串或数值</li><li>  遍历属性名：无法通过<code>for-in</code>、<code>for-of</code>、<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回，只能通过<code>Object.getOwnPropertySymbols</code>返回</li><li>  启用模块的Singleton模式：调用一个类在任何时候返回同一个实例(<code>window</code>和<code>global</code>)，使用<code>Symbol.for()</code>来模拟全局的<code>Singleton模式</code></li></ul><blockquote><p>重点难点</p></blockquote><ul><li>  <code>Symbol()</code>生成一个原始类型的值不是对象，因此<code>Symbol()</code>前不能使用<code>new命令</code></li><li>  <code>Symbol()</code>参数表示对当前<code>Symbol值</code>的描述，相同参数的<code>Symbol()</code>返回值不相等</li><li>  <code>Symbol值</code>不能与其他类型的值进行运算</li><li>  <code>Symbol值</code>可通过<code>String()</code>或<code>toString()</code>显式转为字符串</li><li>  <code>Symbol值</code>作为对象属性名时，此属性是公开属性，但不是私有属性</li><li>  <code>Symbol值</code>作为对象属性名时，只能用方括号运算符(<code>[]</code>)读取，不能用点运算符(<code>.</code>)读取</li><li>  <code>Symbol值</code>作为对象属性名时，不会被常规方法遍历得到，可利用此特性为对象定义<code>非私有但又只用于内部的方法</code></li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h5 id="Set-1"><a href="#Set-1" class="headerlink" title="Set"></a>Set</h5><ul><li>  定义：类似于数组的数据结构，成员值都是唯一且没有重复的值</li><li>  声明：<code>const set = new Set(arr)</code></li><li>  入参：具有<code>Iterator接口</code>的数据结构</li><li>属性<ul><li>  <strong>constructor</strong>：构造函数，返回Set</li><li>  <strong>size</strong>：返回实例成员总数</li></ul></li><li>方法<ul><li>  **add()**：添加值，返回实例</li><li>  **delete()**：删除值，返回布尔</li><li>  **has()**：检查值，返回布尔</li><li>  **clear()**：清除所有成员</li><li>  **keys()**：返回以属性值为遍历器的对象</li><li>  **values()**：返回以属性值为遍历器的对象</li><li>  **entries()**：返回以属性值和属性值为遍历器的对象</li><li>  **forEach()**：使用回调函数遍历每个成员</li></ul></li></ul><blockquote><p>应用场景</p></blockquote><ul><li>  去重字符串：<code>[...new Set(str)].join(&quot;&quot;)</code></li><li>  去重数组：<code>[...new Set(arr)]</code>或<code>Array.from(new Set(arr))</code></li><li>集合数组<ul><li>  声明：<code>const a = new Set(arr1)</code>、<code>const b = new Set(arr2)</code></li><li>  并集：<code>new Set([...a, ...b])</code></li><li>  交集：<code>new Set([...a].filter(v =&gt; b.has(v)))</code></li><li>  差集：<code>new Set([...a].filter(v =&gt; !b.has(v)))</code></li></ul></li><li>映射集合<ul><li>  声明：<code>let set = new Set(arr)</code></li><li>  映射：<code>set = new Set([...set].map(v =&gt; v * 2))</code>或<code>set = new Set(Array.from(set, v =&gt; v * 2))</code></li></ul></li></ul><blockquote><p>重点难点</p></blockquote><ul><li>  遍历顺序：插入顺序</li><li>  没有键只有值，可认为键和值两值相等</li><li>  添加多个<code>NaN</code>时，只会存在一个<code>NaN</code></li><li>  添加相同的对象时，会认为是不同的对象</li><li>  添加值时不会发生类型转换(<code>5 !== &quot;5&quot;</code>)</li><li>  <code>keys()</code>和<code>values()</code>的行为完全一致，<code>entries()</code>返回的遍历器同时包括键和值且两值相等</li></ul><h5 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h5><ul><li>  定义：和Set结构类似，成员值只能是对象</li><li>  声明：<code>const set = new WeakSet(arr)</code></li><li>  入参：具有<code>Iterator接口</code>的数据结构</li><li>属性<ul><li>  <strong>constructor</strong>：构造函数，返回WeakSet</li></ul></li><li>方法<ul><li>  **add()**：添加值，返回实例</li><li>  **delete()**：删除值，返回布尔</li><li>  **has()**：检查值，返回布尔</li></ul></li></ul><blockquote><p>应用场景</p></blockquote><ul><li>  储存DOM节点：DOM节点被移除时自动释放此成员，不用担心这些节点从文档移除时会引发内存泄漏</li><li>  临时存放一组对象或存放跟对象绑定的信息：只要这些对象在外部消失，它在<code>WeakSet结构</code>中的引用就会自动消</li></ul><blockquote><p>重点难点</p></blockquote><ul><li>  成员都是<code>弱引用</code>，垃圾回收机制不考虑<code>WeakSet结构</code>对此成员的引用</li><li>  成员不适合引用，它会随时消失，因此ES6规定<code>WeakSet结构不可遍历</code></li><li>  其他对象不再引用成员时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于<code>WeakSet结构</code>中</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h5 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h5><ul><li>  定义：类似于对象的数据结构，成员键是任何类型的值</li><li>  声明：<code>const set = new Map(arr)</code></li><li>  入参：具有<code>Iterator接口</code>且每个成员都是一个双元素数组的数据结构</li><li>属性<ul><li>  <strong>constructor</strong>：构造函数，返回Map</li><li>  <strong>size</strong>：返回实例成员总数</li></ul></li><li>方法<ul><li>  **get()**：返回键值对</li><li>  **set()**：添加键值对，返回实例</li><li>  **delete()**：删除键值对，返回布尔</li><li>  **has()**：检查键值对，返回布尔</li><li>  **clear()**：清除所有成员</li><li>  **keys()**：返回以键为遍历器的对象</li><li>  **values()**：返回以值为遍历器的对象</li><li>  **entries()**：返回以键和值为遍历器的对象</li><li>  **forEach()**：使用回调函数遍历每个成员</li></ul></li></ul><blockquote><p>重点难点</p></blockquote><ul><li>  遍历顺序：插入顺序</li><li>  对同一个键多次赋值，后面的值将覆盖前面的值</li><li>  对同一个对象的引用，被视为一个键</li><li>  对同样值的两个实例，被视为两个键</li><li>  键跟内存地址绑定，只要内存地址不一样就视为两个键</li><li>  添加多个以<code>NaN</code>作为键时，只会存在一个以<code>NaN</code>作为键的值</li><li>  <code>Object结构</code>提供<code>字符串—值</code>的对应，<code>Map结构</code>提供<code>值—值</code>的对应</li></ul><h5 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h5><ul><li>  定义：和Map结构类似，成员键只能是对象</li><li>  声明：<code>const set = new WeakMap(arr)</code></li><li>  入参：具有<code>Iterator接口</code>且每个成员都是一个双元素数组的数据结构</li><li>属性<ul><li>  <strong>constructor</strong>：构造函数，返回WeakMap</li></ul></li><li>方法<ul><li>  **get()**：返回键值对</li><li>  **set()**：添加键值对，返回实例</li><li>  **delete()**：删除键值对，返回布尔</li><li>  **has()**：检查键值对，返回布尔</li></ul></li></ul><blockquote><p>应用场景</p></blockquote><ul><li>  储存DOM节点：DOM节点被移除时自动释放此成员键，不用担心这些节点从文档移除时会引发内存泄漏</li><li>  部署私有属性：内部属性是实例的弱引用，删除实例时它们也随之消失，不会造成内存泄漏</li></ul><blockquote><p>重点难点</p></blockquote><ul><li>  成员键都是<code>弱引用</code>，垃圾回收机制不考虑<code>WeakMap结构</code>对此成员键的引用</li><li>  成员键不适合引用，它会随时消失，因此ES6规定<code>WeakMap结构不可遍历</code></li><li>  其他对象不再引用成员键时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于<code>WeakMap结构</code>中</li><li>  一旦不再需要，成员会自动消失，不用手动删除引用</li><li>  弱引用的<code>只是键而不是值</code>，值依然是正常引用</li><li>  即使在外部消除了成员键的引用，内部的成员值依然存在</li></ul><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><ul><li>  定义：修改某些操作的默认行为</li><li>  声明：<code>const proxy = new Proxy(target, handler)</code></li><li>入参<ul><li>  <strong>target</strong>：拦截的目标对象</li><li>  <strong>handler</strong>：定制拦截行为</li></ul></li><li>方法<ul><li>  **Proxy.revocable()**：返回可取消的Proxy实例(返回<code>&#123; proxy, revoke &#125;</code>，通过revoke()取消代理)</li></ul></li><li>拦截方式<ul><li>  **get()**：拦截对象属性读取</li><li>  **set()**：拦截对象属性设置，返回布尔</li><li>  **has()**：拦截对象属性检查<code>k in obj</code>，返回布尔</li><li>  **deleteProperty()**：拦截对象属性删除<code>delete obj[k]</code>，返回布尔</li><li>  **defineProperty()**：拦截对象属性定义<code>Object.defineProperty()</code>、<code>Object.defineProperties()</code>，返回布尔</li><li>  **ownKeys()**：拦截对象属性遍历<code>for-in</code>、<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>Object.getOwnPropertySymbols()</code>，返回数组</li><li>  **getOwnPropertyDescriptor()**：拦截对象属性描述读取<code>Object.getOwnPropertyDescriptor()</code>，返回对象</li><li>  **getPrototypeOf()**：拦截对象原型读取<code>instanceof</code>、<code>Object.getPrototypeOf()</code>、<code>Object.prototype.__proto__</code>、<code>Object.prototype.isPrototypeOf()</code>、<code>Reflect.getPrototypeOf()</code>，返回对象</li><li>  **setPrototypeOf()**：拦截对象原型设置<code>Object.setPrototypeOf()</code>，返回布尔</li><li>  **isExtensible()**：拦截对象是否可扩展读取<code>Object.isExtensible()</code>，返回布尔</li><li>  **preventExtensions()**：拦截对象不可扩展设置<code>Object.preventExtensions()</code>，返回布尔</li><li>  **apply()**：拦截Proxy实例作为函数调用<code>proxy()</code>、<code>proxy.apply()</code>、<code>proxy.call()</code></li><li>  **construct()**：拦截Proxy实例作为构造函数调用<code>new proxy()</code></li></ul></li></ul><blockquote><p>应用场景</p></blockquote><ul><li>  <code>Proxy.revocable()</code>：不允许直接访问对象，必须通过代理访问，一旦访问结束就收回代理权不允许再次访问</li><li>  <code>get()</code>：读取未知属性报错、读取数组负数索引的值、封装链式操作、生成DOM嵌套节点</li><li>  <code>set()</code>：数据绑定(Vue数据绑定实现原理)、确保属性值设置符合要求、防止内部属性被外部读写</li><li>  <code>has()</code>：隐藏内部属性不被发现、排除不符合属性条件的对象</li><li>  <code>deleteProperty()</code>：保护内部属性不被删除</li><li>  <code>defineProperty()</code>：阻止属性被外部定义</li><li>  <code>ownKeys()</code>：保护内部属性不被遍历</li></ul><blockquote><p>重点难点</p></blockquote><ul><li>  要使<code>Proxy</code>起作用，必须针对<code>实例</code>进行操作，而不是针对<code>目标对象</code>进行操作</li><li>  没有设置任何拦截时，等同于<code>直接通向原对象</code></li><li>  属性被定义为<code>不可读写/扩展/配置/枚举</code>时，使用拦截方法会报错</li><li>  代理下的目标对象，内部<code>this</code>指向<code>Proxy代理</code></li></ul><h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><ul><li>  定义：保持<code>Object方法</code>的默认行为</li><li>方法<ul><li>  **get()**：返回对象属性</li><li>  **set()**：设置对象属性，返回布尔</li><li>  **has()**：检查对象属性，返回布尔</li><li>  **deleteProperty()**：删除对象属性，返回布尔</li><li>  **defineProperty()**：定义对象属性，返回布尔</li><li>  **ownKeys()**：遍历对象属性，返回数组(<code>Object.getOwnPropertyNames()</code>+<code>Object.getOwnPropertySymbols()</code>)</li><li>  **getOwnPropertyDescriptor()**：返回对象属性描述，返回对象</li><li>  **getPrototypeOf()**：返回对象原型，返回对象</li><li>  **setPrototypeOf()**：设置对象原型，返回布尔</li><li>  **isExtensible()**：返回对象是否可扩展，返回布尔</li><li>  **preventExtensions()**：设置对象不可扩展，返回布尔</li><li>  **apply()**：绑定this后执行指定函数</li><li>  **construct()**：调用构造函数创建实例</li></ul></li></ul><blockquote><p>设计目的</p></blockquote><ul><li>  将<code>Object</code>属于<code>语言内部的方法</code>放到<code>Reflect</code>上</li><li>  将某些Object方法报错情况改成返回<code>false</code></li><li>  让<code>Object操作</code>变成<code>函数行为</code></li><li>  <code>Proxy</code>与<code>Reflect</code>相辅相成</li></ul><blockquote><p>废弃方法</p></blockquote><ul><li>  <code>Object.defineProperty()</code> =&gt; <code>Reflect.defineProperty()</code></li><li>  <code>Object.getOwnPropertyDescriptor()</code> =&gt; <code>Reflect.getOwnPropertyDescriptor()</code></li></ul><blockquote><p>重点难点</p></blockquote><ul><li>  <code>Proxy方法</code>和<code>Reflect方法</code>一一对应</li><li>  <code>Proxy</code>和<code>Reflect</code>联合使用，前者负责<code>拦截赋值操作</code>，后者负责<code>完成赋值操作</code></li></ul><blockquote><p>数据绑定：观察者模式</p></blockquote><pre><code>const observerQueue = new Set();const observe = fn =&gt; observerQueue.add(fn);const observable = obj =&gt; new Proxy(obj, &#123;    set(tgt, key, val, receiver) &#123;        const result = Reflect.set(tgt, key, val, receiver);        observerQueue.forEach(v =&gt; v());        return result;    &#125;&#125;);const person = observable(&#123; age: 25, name: &quot;Yajun&quot; &#125;);const print = () =&gt; console.log(`$&#123;person.name&#125; is $&#123;person.age&#125; years old`);observe(print);person.name = &quot;Joway&quot;;复制代码</code></pre><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><ul><li>  定义：对一类具有共同特征的事物的抽象(构造函数语法糖)</li><li>  原理：类本身指向构造函数，所有方法定义在<code>prototype</code>上，可看作构造函数的另一种写法(<code>Class === Class.prototype.constructor</code>)</li><li>方法和关键字<ul><li>  **constructor()**：构造函数，<code>new命令</code>生成实例时自动调用</li><li>  <strong>extends</strong>：继承父类</li><li>  <strong>super</strong>：新建父类的<code>this</code></li><li>  <strong>static</strong>：定义静态属性方法</li><li>  <strong>get</strong>：取值函数，拦截属性的取值行为</li><li>  <strong>set</strong>：存值函数，拦截属性的存值行为</li></ul></li><li>属性<ul><li>  **__proto__**：<code>构造函数的继承</code>(总是指向<code>父类</code>)</li><li>  **__proto__.__proto__**：子类的原型的原型，即父类的原型(总是指向父类的<code>__proto__</code>)</li><li>  **prototype.__proto__**：<code>属性方法的继承</code>(总是指向父类的<code>prototype</code>)</li></ul></li><li>  静态属性：定义类完成后赋值属性，该属性<code>不会被实例继承</code>，只能通过类来调用</li><li>  静态方法：使用<code>static</code>定义方法，该方法<code>不会被实例继承</code>，只能通过类来调用(方法中的<code>this</code>指向类，而不是实例)</li><li>继承<ul><li>实质<ul><li>  ES5实质：先创造子类实例的<code>this</code>，再将父类的属性方法添加到<code>this</code>上(<code>Parent.apply(this)</code>)</li><li>  ES6实质：先将父类实例的属性方法加到<code>this</code>上(调用<code>super()</code>)，再用子类构造函数修改<code>this</code></li></ul></li><li>super<ul><li>  作为函数调用：只能在构造函数中调用<code>super()</code>，内部<code>this</code>指向继承的<code>当前子类</code>(<code>super()</code>调用后才可在构造函数中使用<code>this</code>)</li><li>  作为对象调用：在<code>普通方法</code>中指向<code>父类的原型对象</code>，在<code>静态方法</code>中指向<code>父类</code></li></ul></li><li>  显示定义：使用<code>constructor() &#123; super(); &#125;</code>定义继承父类，没有书写则<code>显示定义</code></li><li>子类继承父类：子类使用父类的属性方法时，必须在构造函数中调用<code>super()</code>，否则得不到父类的<code>this</code><ul><li>  父类静态属性方法可被子类继承</li><li>  子类继承父类后，可从<code>super</code>上调用父类静态属性方法</li></ul></li></ul></li><li>实例：类相当于<code>实例的原型</code>，所有在类中定义的属性方法都会被实例继承<ul><li>  显式指定属性方法：使用<code>this</code>指定到自身上(使用<code>Class.hasOwnProperty()</code>可检测到)</li><li>  隐式指定属性方法：直接声明定义在对象原型上(使用<code>Class.__proto__.hasOwnProperty()</code>可检测到)</li></ul></li><li>表达式<ul><li>  类表达式：<code>const Class = class &#123;&#125;</code></li><li>  name属性：返回紧跟<code>class</code>后的类名</li><li>  属性表达式：<code>[prop]</code></li><li>  Generator方法：<code>* mothod() &#123;&#125;</code></li><li>  Async方法：<code>async mothod() &#123;&#125;</code></li></ul></li><li>this指向：解构实例属性或方法时会报错<ul><li>  绑定this：<code>this.mothod = this.mothod.bind(this)</code></li><li>  箭头函数：<code>this.mothod = () =&gt; this.mothod()</code></li></ul></li><li>属性定义位置<ul><li>  定义在构造函数中并使用<code>this</code>指向</li><li>  定义在<code>类最顶层</code></li></ul></li><li>  <strong>new.target</strong>：确定构造函数是如何调用</li></ul><blockquote><p>原生构造函数</p></blockquote><ul><li>  <strong>String()</strong></li><li>  <strong>Number()</strong></li><li>  <strong>Boolean()</strong></li><li>  <strong>Array()</strong></li><li>  <strong>Object()</strong></li><li>  <strong>Function()</strong></li><li>  <strong>Date()</strong></li><li>  <strong>RegExp()</strong></li><li>  <strong>Error()</strong></li></ul><blockquote><p>重点难点</p></blockquote><ul><li>  在实例上调用方法，实质是调用原型上的方法</li><li>  <code>Object.assign()</code>可方便地一次向类添加多个方法(<code>Object.assign(Class.prototype, &#123; ... &#125;)</code>)</li><li>  类内部所有定义的方法是不可枚举的(<code>non-enumerable</code>)</li><li>  构造函数默认返回实例对象(<code>this</code>)，可指定返回另一个对象</li><li>  取值函数和存值函数设置在属性的<code>Descriptor对象</code>上</li><li>  类不存在变量提升</li><li>  利用<code>new.target === Class</code>写出不能独立使用必须继承后才能使用的类</li><li>  子类继承父类后，<code>this</code>指向子类实例，通过<code>super</code>对某个属性赋值，赋值的属性会变成子类实例的属性</li><li>  使用<code>super</code>时，必须显式指定是作为函数还是作为对象使用</li><li>  <code>extends</code>不仅可继承类还可继承原生的构造函数</li></ul><blockquote><p>私有属性方法</p></blockquote><pre><code>const name = Symbol(&quot;name&quot;);const print = Symbol(&quot;print&quot;);class Person &#123;    constructor(age) &#123;        this[name] = &quot;Bruce&quot;;        this.age = age;    &#125;    [print]() &#123;        console.log(`$&#123;this[name]&#125; is $&#123;this.age&#125; years old`);    &#125;&#125;复制代码</code></pre><blockquote><p>继承混合类</p></blockquote><pre><code>function CopyProperties(target, source) &#123;    for (const key of Reflect.ownKeys(source)) &#123;        if (key !== &quot;constructor&quot; &amp;&amp; key !== &quot;prototype&quot; &amp;&amp; key !== &quot;name&quot;) &#123;            const desc = Object.getOwnPropertyDescriptor(source, key);            Object.defineProperty(target, key, desc);        &#125;    &#125;&#125;function MixClass(...mixins) &#123;    class Mix &#123;        constructor() &#123;            for (const mixin of mixins) &#123;                CopyProperties(this, new mixin());            &#125;        &#125;    &#125;    for (const mixin of mixins) &#123;        CopyProperties(Mix, mixin);        CopyProperties(Mix.prototype, mixin.prototype);    &#125;    return Mix;&#125;class Student extends MixClass(Person, Kid) &#123;&#125;复制代码</code></pre><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><ul><li>命令<ul><li><strong>export</strong>：规定模块对外接口<ul><li>  <strong>默认导出</strong>：<code>export default Person</code>(导入时可指定模块任意名称，无需知晓内部真实名称)</li><li>  <strong>单独导出</strong>：<code>export const name = &quot;Bruce&quot;</code></li><li>  <strong>按需导出</strong>：<code>export &#123; age, name, sex &#125;</code>(推荐)</li><li>  <strong>改名导出</strong>：<code>export &#123; name as newName &#125;</code></li></ul></li><li><strong>import</strong>：导入模块内部功能<ul><li>  <strong>默认导入</strong>：<code>import Person from &quot;person&quot;</code></li><li>  <strong>整体导入</strong>：<code>import * as Person from &quot;person&quot;</code></li><li>  <strong>按需导入</strong>：<code>import &#123; age, name, sex &#125; from &quot;person&quot;</code></li><li>  <strong>改名导入</strong>：<code>import &#123; name as newName &#125; from &quot;person&quot;</code></li><li>  <strong>自执导入</strong>：<code>import &quot;person&quot;</code></li><li>  <strong>复合导入</strong>：<code>import Person, &#123; name &#125; from &quot;person&quot;</code></li></ul></li><li><strong>复合模式</strong>：<code>export命令</code>和<code>import命令</code>结合在一起写成一行，变量实质没有被导入当前模块，相当于对外转发接口，导致当前模块无法直接使用其导入变量<ul><li>  <strong>默认导入导出</strong>：<code>export &#123; default &#125; from &quot;person&quot;</code></li><li>  <strong>整体导入导出</strong>：<code>export * from &quot;person&quot;</code></li><li>  <strong>按需导入导出</strong>：<code>export &#123; age, name, sex &#125; from &quot;person&quot;</code></li><li>  <strong>改名导入导出</strong>：<code>export &#123; name as newName &#125; from &quot;person&quot;</code></li><li>  <strong>具名改默认导入导出</strong>：<code>export &#123; name as default &#125; from &quot;person&quot;</code></li><li>  <strong>默认改具名导入导出</strong>：<code>export &#123; default as name &#125; from &quot;person&quot;</code></li></ul></li></ul></li><li>  继承：<code>默认导出</code>和<code>改名导出</code>结合使用可使模块具备继承性</li><li>  设计思想：尽量地静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量</li><li>  严格模式：ES6模块自动采用严格模式(不管模块头部是否添加<code>use strict</code>)</li></ul><blockquote><p>模块方案</p></blockquote><ul><li>  <strong>CommonJS</strong>：用于服务器(动态化依赖)</li><li>  <strong>AMD</strong>：用于浏览器(动态化依赖)</li><li>  <strong>CMD</strong>：用于浏览器(动态化依赖)</li><li>  <strong>UMD</strong>：用于浏览器和服务器(动态化依赖)</li><li>  <strong>ESM</strong>：用于浏览器和服务器(静态化依赖)</li></ul><blockquote><p>加载方式</p></blockquote><ul><li><strong>运行时加载</strong><ul><li>  定义：整体加载模块生成一个对象，再从对象上获取需要的属性和方法进行加载(全部加载)</li><li>  影响：只有运行时才能得到这个对象，导致无法在编译时做静态优化</li></ul></li><li><strong>编译时加载</strong><ul><li>  定义：直接从模块中获取需要的属性和方法进行加载(按需加载)</li><li>  影响：在编译时就完成模块加载，效率比其他方案高，但无法引用模块本身(<strong>本身不是对象</strong>)，可拓展JS高级语法(<strong>宏和类型校验</strong>)</li></ul></li></ul><blockquote><p>加载实现</p></blockquote><ul><li><strong>传统加载</strong>：通过<code>&lt;script&gt;</code>进行同步或异步加载脚本<ul><li>  同步加载：<code>&lt;script src=&quot;&quot;&gt;&lt;/script&gt;</code></li><li>  Defer异步加载：<code>&lt;script src=&quot;&quot; defer&gt;&lt;/script&gt;</code>(顺序加载，渲染完再执行)</li><li>  Async异步加载：<code>&lt;script src=&quot;&quot; async&gt;&lt;/script&gt;</code>(乱序加载，下载完就执行)</li></ul></li><li>  <strong>模块加载</strong>：<code>&lt;script type=&quot;module&quot; src=&quot;&quot;&gt;&lt;/script&gt;</code>(默认是Defer异步加载)</li></ul><blockquote><p>CommonJS和ESM的区别</p></blockquote><ul><li><code>CommonJS</code>输出<code>值的拷贝</code>，<code>ESM</code>输出<code>值的引用</code><ul><li>  <code>CommonJS</code>一旦输出一个值，模块内部的变化就影响不到这个值</li><li>  <code>ESM</code>是动态引用且不会缓存值，模块里的变量绑定其所在的模块，等到脚本真正执行时，再根据这个只读引用到被加载的那个模块里去取值</li></ul></li><li><code>CommonJS</code>是运行时加载，<code>ESM</code>是编译时加载<ul><li>  <code>CommonJS</code>加载模块是对象(即<code>module.exports</code>)，该对象只有在脚本运行完才会生成</li><li>  <code>ESM</code>加载模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成</li></ul></li></ul><blockquote><p>Node加载</p></blockquote><ul><li>  背景：<code>CommonJS</code>和<code>ESM</code>互不兼容，目前解决方案是将两者分开，采用各自的加载方案</li><li>区分：要求<code>ESM</code>采用<code>.mjs</code>后缀文件名<ul><li>  <code>require()</code>不能加载<code>.mjs文件</code>，只有<code>import命令</code>才可加载<code>.mjs文件</code></li><li>  <code>.mjs文件</code>里不能使用<code>require()</code>，必须使用<code>import命令</code>加载文件</li></ul></li><li>  驱动：<code>node --experimental-modules file.mjs</code></li><li>  限制：Node的<code>import命令</code>目前只支持加载本地模块(<code>file:协议</code>)，不支持加载远程模块</li><li>加载优先级<ul><li>  脚本文件省略后缀名：依次尝试加载四个后缀名文件(<code>.mjs</code>、<code>.js</code>、<code>.json</code>、<code>node</code>)</li><li>  以上不存在：尝试加载<code>package.json</code>的<code>main字段</code>指定的脚本</li><li>  以上不存在：依次尝试加载名称为<code>index</code>四个后缀名文件(<code>.mjs</code>、<code>.js</code>、<code>.json</code>、<code>node</code>)</li><li>  以上不存在：报错</li></ul></li><li>  不存在的内部变量：<code>arguments</code>、<code>exports</code>、<code>module</code>、<code>require</code>、<code>this</code>、<code>__dirname</code>、<code>__filename</code></li><li>CommonJS加载ESM<ul><li>  不能使用<code>require()</code>，只能使用<code>import()</code></li></ul></li><li>ESM加载CommonJS<ul><li>  自动将<code>module.exports</code>转化成<code>export default</code></li><li>  <code>CommonJS</code>输出缓存机制在<code>ESM</code>加载方式下依然有效</li><li>  采用<code>import命令</code>加载<code>CommonJS模块</code>时，不允许采用<code>按需导入</code>，应使用<code>默认导入</code>或<code>整体导入</code></li></ul></li></ul><blockquote><p>循环加载</p></blockquote><ul><li>  定义：<code>脚本A</code>的执行依赖<code>脚本B</code>，而<code>脚本A</code>的执行又依赖<code>脚本B</code></li><li>加载原理<ul><li>  CommonJS：<code>require()</code>首次加载脚本就会执行整个脚本，在内存里生成一个对象缓存下来，二次加载脚本时直接从缓存中获取</li><li>  ESM：<code>import命令</code>加载变量不会被缓存，而是成为一个指向被加载模块的引用</li></ul></li><li>循环加载<ul><li>  CommonJS：只输出已经执行的部分，还未执行的部分不会输出</li><li>  ESM：需开发者自己保证真正取值时能够取到值(可把变量写成函数形式，函数具有提升作用)</li></ul></li></ul><blockquote><p>重点难点</p></blockquote><ul><li>  ES6模块中，顶层<code>this</code>指向<code>undefined</code>，不应该在顶层代码使用<code>this</code></li><li>  一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取</li><li>  <code>export命令</code>输出的接口与其对应的值是<code>动态绑定关系</code>，即通过该接口可获取模块内部实时的值</li><li>  <code>import命令</code>大括号里的变量名必须与被导入模块对外接口的名称相同</li><li>  <code>import命令</code>输入的变量只读(本质是输入接口)，不允许在加载模块的脚本里改写接口</li><li>  <code>import命令</code>命令具有提升效果，会提升到整个模块的头部，首先执行</li><li>  重复执行同一句<code>import语句</code>，只会执行一次</li><li>  <code>export default</code>命令只能使用一次</li><li>  <code>export default命令</code>导出的整体模块，在执行<code>import命令</code>时其后不能跟<code>大括号</code></li><li>  <code>export default命令</code>本质是输出一个名为<code>default</code>的变量，后面不能跟<code>变量声明语句</code></li><li>  <code>export default命令</code>本质是将后面的值赋给名为<code>default</code>的变量，可直接将值写在其后</li><li>  <code>export default命令</code>和<code>export &#123;&#125;命令</code>可同时存在，对应<code>复合导入</code></li><li>  <code>export命令</code>和<code>import命令</code>可出现在模块任何位置，只要处于模块顶层即可，不能处于块级作用域</li><li>  <code>import()</code>加载模块成功后，此模块会作为一个对象，当作<code>then()</code>的参数，可使用<code>对象解构赋值</code>来获取输出接口</li><li>  同时动态加载多个模块时，可使用<code>Promise.all()</code>和<code>import()</code>相结合来实现</li><li>  <code>import()</code>和结合<code>async/await</code>来书写同步操作的代码</li></ul><blockquote><p>单例模式：跨模块常量</p></blockquote><pre><code>const NAME = &quot;Bruce&quot;;const AGE = 25;const SEX = &quot;male&quot;;export &#123; AGE, NAME, SEX &#125;;复制代码import &#123; AGE &#125; from &quot;person&quot;;console.log(AGE);复制代码import &#123; AGE, NAME, SEX &#125; from &quot;person&quot;;console.log(AGE, NAME, SEX);复制代码</code></pre><blockquote><p>默认导入互换整体导入</p></blockquote><pre><code>import Person from &quot;person&quot;;console.log(Person.AGE);复制代码import * as Person from &quot;person&quot;;console.log(Person.default.AGE);复制代码</code></pre><h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><ul><li>  定义：为各种不同的数据结构提供统一的访问机制</li><li>  原理：创建一个指针指向首个成员，按照次序使用<code>next()</code>指向下一个成员，直接到结束位置(数据结构只要部署<code>Iterator接口</code>就可完成遍历操作)</li><li>作用<ul><li>  为各种数据结构提供一个统一的简便的访问接口</li><li>  使得数据结构成员能够按某种次序排列</li><li>  ES6创造了新的遍历命令<code>for-of</code>，<code>Iterator接口</code>主要供<code>for-of</code>消费</li></ul></li><li>  形式：<code>for-of</code>(自动去寻找Iterator接口)</li><li>数据结构<ul><li>  集合：<code>Array</code>、<code>Object</code>、<code>Set</code>、<code>Map</code></li><li>  原生具备接口的数据结构：<code>String</code>、<code>Array</code>、<code>Set</code>、<code>Map</code>、<code>TypedArray</code>、<code>Arguments</code>、<code>NodeList</code></li></ul></li><li>  部署：默认部署在<code>Symbol.iterator</code>(具备此属性被认为<code>可遍历的iterable</code>)</li><li>遍历器对象<ul><li>  **next()**：下一步操作，返回<code>&#123; done, value &#125;</code>(必须部署)</li><li>  **return()**：<code>for-of</code>提前退出调用，返回<code>&#123; done: true &#125;</code></li><li>  **throw()**：不使用，配合<code>Generator函数</code>使用</li></ul></li></ul><blockquote><p>ForOf循环</p></blockquote><ul><li>  定义：调用<code>Iterator接口</code>产生遍历器对象(<code>for-of</code>内部调用数据结构的<code>Symbol.iterator()</code>)</li><li>  遍历字符串：<code>for-in</code>获取<code>索引</code>，<code>for-of</code>获取<code>值</code>(可识别32位UTF-16字符)</li><li>  遍历数组：<code>for-in</code>获取<code>索引</code>，<code>for-of</code>获取<code>值</code></li><li>  遍历对象：<code>for-in</code>获取<code>键</code>，<code>for-of</code>需自行部署</li><li>  遍历Set：<code>for-of</code>获取<code>值</code> =&gt; <code>for (const v of set)</code></li><li>  遍历Map：<code>for-of</code>获取<code>键值对</code> =&gt; <code>for (const [k, v] of map)</code></li><li>  遍历类数组：<code>包含length的对象</code>、<code>Arguments对象</code>、<code>NodeList对象</code>(无<code>Iterator接口的类数组</code>可用<code>Array.from()</code>转换)</li><li>计算生成数据结构：<code>Array</code>、<code>Set</code>、<code>Map</code><ul><li>  **keys()**：返回遍历器对象，遍历所有的键</li><li>  **values()**：返回遍历器对象，遍历所有的值</li><li>  **entries()**：返回遍历器对象，遍历所有的键值对</li></ul></li><li>与<code>for-in</code>区别<ul><li>  有着同<code>for-in</code>一样的简洁语法，但没有<code>for-in</code>那些缺点、</li><li>  不同于<code>forEach()</code>，它可与<code>break</code>、<code>continue</code>和<code>return</code>配合使用</li><li>  提供遍历所有数据结构的统一操作接口</li></ul></li></ul><blockquote><p>应用场景</p></blockquote><ul><li>  改写具有<code>Iterator接口</code>的数据结构的<code>Symbol.iterator</code></li><li>  解构赋值：对Set进行结构</li><li>  扩展运算符：将部署<code>Iterator接口</code>的数据结构转为数组</li><li>  yield*：<code>yield*</code>后跟一个可遍历的数据结构，会调用其遍历器接口</li><li>  接受数组作为参数的函数：<code>for-of</code>、<code>Array.from()</code>、<code>new Set()</code>、<code>new WeakSet()</code>、<code>new Map()</code>、<code>new WeakMap()</code>、<code>Promise.all()</code>、<code>Promise.race()</code></li></ul><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><ul><li>  定义：包含异步操作结果的对象</li><li>状态<ul><li>  <strong>进行中</strong>：<code>pending</code></li><li>  <strong>已成功</strong>：<code>resolved</code></li><li>  <strong>已失败</strong>：<code>rejected</code></li></ul></li><li>特点<ul><li>  对象的状态不受外界影响</li><li>  一旦状态改变就不会再变，任何时候都可得到这个结果</li></ul></li><li>  声明：<code>new Promise((resolve, reject) =&gt; &#123;&#125;)</code></li><li>出参<ul><li>  <strong>resolve</strong>：将状态从<code>未完成</code>变为<code>成功</code>，在异步操作成功时调用，并将异步操作的结果作为参数传递出去</li><li>  <strong>reject</strong>：将状态从<code>未完成</code>变为<code>失败</code>，在异步操作失败时调用，并将异步操作的错误作为参数传递出去</li></ul></li><li>方法<ul><li>**then()**：分别指定<code>resolved状态</code>和<code>rejected状态</code>的回调函数<ul><li>  <strong>第一参数</strong>：状态变为<code>resolved</code>时调用</li><li>  <strong>第二参数</strong>：状态变为<code>rejected</code>时调用(可选)</li></ul></li><li>  **catch()**：指定发生错误时的回调函数</li><li>**Promise.all()**：将多个实例包装成一个新实例，返回全部实例状态变更后的结果数组(齐变更再返回)<ul><li>  入参：具有<code>Iterator接口</code>的数据结构</li><li>  成功：只有全部实例状态变成<code>fulfilled</code>，最终状态才会变成<code>fulfilled</code></li><li>  失败：其中一个实例状态变成<code>rejected</code>，最终状态就会变成<code>rejected</code></li></ul></li><li>**Promise.race()**：将多个实例包装成一个新实例，返回全部实例状态优先变更后的结果(先变更先返回)<ul><li>  入参：具有<code>Iterator接口</code>的数据结构</li><li>  成功失败：哪个实例率先改变状态就返回哪个实例的状态</li></ul></li><li>**Promise.resolve()**：将对象转为Promise对象(等价于<code>new Promise(resolve =&gt; resolve())</code>)<ul><li>  <strong>Promise实例</strong>：原封不动地返回入参</li><li>  <strong>Thenable对象</strong>：将此对象转为Promise对象并返回(Thenable为包含<code>then()</code>的对象，执行<code>then()</code>相当于执行此对象的<code>then()</code>)</li><li>  <strong>不具有then()的对象</strong>：将此对象转为Promise对象并返回，状态为<code>resolved</code></li><li>  <strong>不带参数</strong>：返回Promise对象，状态为<code>resolved</code></li></ul></li><li>  **Promise.reject()**：将对象转为状态为<code>rejected</code>的Promise对象(等价于<code>new Promise((resolve, reject) =&gt; reject())</code>)</li></ul></li></ul><blockquote><p>应用场景</p></blockquote><ul><li>  加载图片</li><li>  AJAX转Promise对象</li></ul><blockquote><p>重点难点</p></blockquote><ul><li>  只有异步操作的结果可决定当前状态是哪一种，其他操作都无法改变这个状态</li><li>  状态改变只有两种可能：从<code>pending</code>变为<code>resolved</code>、从<code>pending</code>变为<code>rejected</code></li><li>  一旦新建<code>Promise对象</code>就会立即执行，无法中途取消</li><li>  不设置回调函数，内部抛错不会反应到外部</li><li>  当处于<code>pending</code>时，无法得知目前进展到哪一个阶段</li><li>  实例状态变为<code>resolved</code>或<code>rejected</code>时，会触发<code>then()</code>绑定的回调函数</li><li>  <code>resolve()</code>和<code>reject()</code>的执行总是晚于本轮循环的同步任务</li><li>  <code>then()</code>返回新实例，其后可再调用另一个<code>then()</code></li><li>  <code>then()</code>运行中抛出错误会被<code>catch()</code>捕获</li><li>  <code>reject()</code>的作用等同于抛出错误</li><li>  实例状态已变成<code>resolved</code>时，再抛出错误是无效的，不会被捕获，等于没有抛出</li><li>  实例状态的错误具有<code>冒泡</code>性质，会一直向后传递直到被捕获为止，错误总是会被下一个<code>catch()</code>捕获</li><li>  不要在<code>then()</code>里定义<code>rejected</code>状态的回调函数(不使用其第二参数)</li><li>  建议使用<code>catch()</code>捕获错误，不要使用<code>then()</code>第二个参数捕获</li><li>  没有使用<code>catch()</code>捕获错误，实例抛错不会传递到外层代码，即<code>不会有任何反应</code></li><li>  作为参数的实例定义了<code>catch()</code>，一旦被<code>rejected</code>并不会触发<code>Promise.all()</code>的<code>catch()</code></li><li>  <code>Promise.reject()</code>的参数会原封不动地作为<code>rejected</code>的理由，变成后续方法的参数</li></ul><h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><ul><li>  定义：封装多个内部状态的异步编程解决方案</li><li>  形式：调用<code>Generator函数</code>(该函数不执行)返回指向内部状态的指针对象(不是运行结果)</li><li>  声明：<code>function* Func() &#123;&#125;</code></li><li>方法<ul><li>  **next()**：使指针移向下一个状态，返回<code>&#123; done, value &#125;</code>(入参会被当作上一个<code>yield命令表达式</code>的返回值)</li><li>  **return()**：返回指定值且终结遍历<code>Generator函数</code>，返回<code>&#123; done: true, value: 入参 &#125;</code></li><li>  **throw()**：在<code>Generator函数</code>体外抛出错误，在<code>Generator函数</code>体内捕获错误，返回自定义的<code>new Errow()</code></li></ul></li><li>yield命令：声明内部状态的值(<code>return</code>声明结束返回的值)<ul><li>  遇到<code>yield命令</code>就暂停执行后面的操作，并将其后表达式的值作为返回对象的<code>value</code></li><li>  下次调用<code>next()</code>时，再继续往下执行直到遇到下一个<code>yield命令</code></li><li>  没有再遇到<code>yield命令</code>就一直运行到<code>Generator函数</code>结束，直到遇到<code>return语句</code>为止并将其后表达式的值作为返回对象的<code>value</code></li><li>  <code>Generator函数</code>没有<code>return语句</code>则返回对象的<code>value</code>为<code>undefined</code></li></ul></li><li>  yield*命令：在一个<code>Generator函数</code>里执行另一个<code>Generator函数</code>(后随具有<code>Iterator接口</code>的数据结构)</li><li>  遍历：通过<code>for-of</code>自动调用<code>next()</code></li><li>作为对象属性<ul><li>  全写：<code>const obj = &#123; method: function*() &#123;&#125; &#125;</code></li><li>  简写：<code>const obj = &#123; * method() &#123;&#125; &#125;</code></li></ul></li><li>  上下文：执行产生的<code>上下文环境</code>一旦遇到<code>yield命令</code>就会暂时退出堆栈(但并不消失)，所有变量和对象会冻结在<code>当前状态</code>，等到对它执行<code>next()</code>时，这个<code>上下文环境</code>又会重新加入调用栈，冻结的变量和对象恢复执行</li></ul><blockquote><p>方法异同</p></blockquote><ul><li>  相同点：<code>next()</code>、<code>throw()</code>、<code>return()</code>本质上是同一件事，作用都是让函数恢复执行且使用不同的语句替换<code>yield命令</code></li><li>不同点<ul><li>  **next()**：将<code>yield命令</code>替换成一个<code>值</code></li><li>  **return()**：将<code>yield命令</code>替换成一个<code>return语句</code></li><li>  **throw()**：将<code>yield命令</code>替换成一个<code>throw语句</code></li></ul></li></ul><blockquote><p>应用场景</p></blockquote><ul><li>  异步操作同步化表达</li><li>  控制流管理</li><li>  为对象部署Iterator接口：把<code>Generator函数</code>赋值给对象的<code>Symbol.iterator</code>，从而使该对象具有<code>Iterator接口</code></li><li>  作为具有Iterator接口的数据结构</li></ul><blockquote><p>重点难点</p></blockquote><ul><li>  每次调用<code>next()</code>，指针就从<code>函数头部</code>或<code>上次停下的位置</code>开始执行，直到遇到下一个<code>yield命令</code>或<code>return语句</code>为止</li><li>  函数内部可不用<code>yield命令</code>，但会变成单纯的<code>暂缓执行函数</code>(还是需要<code>next()</code>触发)</li><li>  <code>yield命令</code>是暂停执行的标记，<code>next()</code>是恢复执行的操作</li><li>  <code>yield命令</code>用在另一个表达式中必须放在<code>圆括号</code>里</li><li>  <code>yield命令</code>用作函数参数或放在赋值表达式的右边，可不加<code>圆括号</code></li><li>  <code>yield命令</code>本身没有返回值，可认为是返回<code>undefined</code></li><li>  <code>yield命令表达式</code>为惰性求值，等<code>next()</code>执行到此才求值</li><li>  函数调用后生成遍历器对象，此对象的<code>Symbol.iterator</code>是此对象本身</li><li>  在函数运行的不同阶段，通过<code>next()</code>从外部向内部注入不同的值，从而调整函数行为</li><li>  首个<code>next()</code>用来启动遍历器对象，后续才可传递参数</li><li>  想首次调用<code>next()</code>时就能输入值，可在函数外面再包一层</li><li>  一旦<code>next()</code>返回对象的<code>done</code>为<code>true</code>，<code>for-of</code>遍历会中止且不包含该返回对象</li><li>  函数内部部署<code>try-finally</code>且正在执行<code>try</code>，那么<code>return()</code>会导致立刻进入<code>finally</code>，执行完<code>finally</code>以后整个函数才会结束</li><li>  函数内部没有部署<code>try-catch</code>，<code>throw()</code>抛错将被外部<code>try-catch</code>捕获</li><li>  <code>throw()</code>抛错要被内部捕获，前提是必须<code>至少执行过一次next()</code></li><li>  <code>throw()</code>被捕获以后，会附带执行下一条<code>yield命令</code></li><li>  函数还未开始执行，这时<code>throw()</code>抛错只可能抛出在函数外部</li></ul><blockquote><p>首次next()可传值</p></blockquote><pre><code>function Wrapper(func) &#123;    return function(...args) &#123;        const generator = func(...args);        generator.next();        return generator;    &#125;&#125;const print = Wrapper(function*() &#123;    console.log(`First Input: $&#123;yield&#125;`);    return &quot;done&quot;;&#125;);print().next(&quot;hello&quot;);复制代码</code></pre></div><h2 id="ES2016"><a href="#ES2016" class="headerlink" title="ES2016"></a>ES2016</h2><div class="story post-story"><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201023110400.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201023110400.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20201023110400"></p><h3 id="数值扩展-1"><a href="#数值扩展-1" class="headerlink" title="数值扩展"></a>数值扩展</h3><ul><li>  **指数运算符(**)**：数值求幂(相当于<code>Math.pow()</code>)</li></ul><h3 id="数组扩展-1"><a href="#数组扩展-1" class="headerlink" title="数组扩展"></a>数组扩展</h3><ul><li>  **includes()**：是否存在指定成员</li></ul></div><h2 id="ES2017"><a href="#ES2017" class="headerlink" title="ES2017"></a>ES2017</h2><div class="story post-story"><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201023110427.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201023110427.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20201023110427"></p><h3 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h3><ul><li>  <strong>共享内存和原子操作</strong>：由全局对象<code>SharedArrayBuffer</code>和<code>Atomics</code>实现，将数据存储在一块共享内存空间中，这些数据可在<code>JS主线程</code>和<code>web-worker线程</code>之间共享</li></ul><h3 id="字符串扩展-1"><a href="#字符串扩展-1" class="headerlink" title="字符串扩展"></a>字符串扩展</h3><ul><li>  **padStart()**：把指定字符串填充到字符串头部，返回新字符串</li><li>  **padEnd()**：把指定字符串填充到字符串尾部，返回新字符串</li></ul><h3 id="对象扩展-1"><a href="#对象扩展-1" class="headerlink" title="对象扩展"></a>对象扩展</h3><ul><li>  **Object.getOwnPropertyDescriptors()**：返回对象所有自身属性(非继承属性)的描述对象</li><li>  **Object.values()**：返回以值组成的数组</li><li>  **Object.entries()**：返回以键和值组成的数组</li></ul><h3 id="函数扩展-1"><a href="#函数扩展-1" class="headerlink" title="函数扩展"></a>函数扩展</h3><ul><li>  <strong>函数参数尾逗号</strong>：允许函数最后一个参数有尾逗号</li></ul><h3 id="Async"><a href="#Async" class="headerlink" title="Async"></a>Async</h3><ul><li>  定义：使异步函数以同步函数的形式书写(Generator函数语法糖)</li><li>  原理：将<code>Generator函数</code>和自动执行器<code>spawn</code>包装在一个函数里</li><li>  形式：将<code>Generator函数</code>的<code>*</code>替换成<code>async</code>，将<code>yield</code>替换成<code>await</code></li><li>声明<ul><li>  具名函数：<code>async function Func() &#123;&#125;</code></li><li>  函数表达式：<code>const func = async function() &#123;&#125;</code></li><li>  箭头函数：<code>const func = async() =&gt; &#123;&#125;</code></li><li>  对象方法：<code>const obj = &#123; async func() &#123;&#125; &#125;</code></li><li>  类方法：<code>class Cla &#123; async Func() &#123;&#125; &#125;</code></li></ul></li><li>await命令：等待当前Promise对象状态变更完毕<ul><li>  正常情况：后面是Promise对象则返回其结果，否则返回对应的值</li><li>  后随<code>Thenable对象</code>：将其等同于Promise对象返回其结果</li></ul></li><li>  错误处理：将<code>await命令Promise对象</code>放到<code>try-catch</code>中(可放多个)</li></ul><blockquote><p>Async对Generator改进</p></blockquote><ul><li>  内置执行器</li><li>  更好的语义</li><li>  更广的适用性</li><li>  返回值是Promise对象</li></ul><blockquote><p>应用场景</p></blockquote><ul><li>  按顺序完成异步操作</li></ul><blockquote><p>重点难点</p></blockquote><ul><li>  <code>Async函数</code>返回<code>Promise对象</code>，可使用<code>then()</code>添加回调函数</li><li>  内部<code>return返回值</code>会成为后续<code>then()</code>的出参</li><li>  内部抛出错误会导致返回的Promise对象变为<code>rejected状态</code>，被<code>catch()</code>接收到</li><li>  返回的Promise对象必须等到内部所有<code>await命令Promise对象</code>执行完才会发生状态改变，除非遇到<code>return语句</code>或<code>抛出错误</code></li><li>  任何一个<code>await命令Promise对象</code>变为<code>rejected状态</code>，整个<code>Async函数</code>都会中断执行</li><li>希望即使前一个异步操作失败也不要中断后面的异步操作<ul><li>  将<code>await命令Promise对象</code>放到<code>try-catch</code>中</li><li>  <code>await命令Promise对象</code>跟一个<code>catch()</code></li></ul></li><li>  <code>await命令Promise对象</code>可能变为<code>rejected状态</code>，最好把其放到<code>try-catch</code>中</li><li>  多个<code>await命令Promise对象</code>若不存在继发关系，最好让它们同时触发</li><li>  <code>await命令</code>只能用在<code>Async函数</code>之中，否则会报错</li><li>  数组使用<code>forEach()</code>执行<code>async/await</code>会失效，可使用<code>for-of</code>和<code>Promise.all()</code>代替</li><li>  可保留运行堆栈，函数上下文随着<code>Async函数</code>的执行而存在，执行完成就消失</li></ul></div><h2 id="ES2018"><a href="#ES2018" class="headerlink" title="ES2018"></a>ES2018</h2><div class="story post-story"><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201023110442.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201023110442.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20201023110442"></p><h3 id="字符串扩展-2"><a href="#字符串扩展-2" class="headerlink" title="字符串扩展"></a>字符串扩展</h3><ul><li>  <strong>放松对标签模板里字符串转义的限制</strong>：遇到不合法的字符串转义返回<code>undefined</code>，并且从<code>raw</code>上可获取原字符串</li></ul><h3 id="对象扩展-2"><a href="#对象扩展-2" class="headerlink" title="对象扩展"></a>对象扩展</h3><ul><li>  **扩展运算符(...)**：转换对象为用逗号分隔的参数序列(<code>&#123; ...obj &#125;</code>，相当于<code>rest/spread参数</code>的逆运算)</li></ul><blockquote><p>扩展应用</p></blockquote><ul><li>  克隆对象：<code>const obj = &#123; __proto__: Object.getPrototypeOf(obj1), ...obj1 &#125;</code></li><li>  合并对象：<code>const obj = &#123; ...obj1, ...obj2 &#125;</code></li><li>  转换字符串为对象：<code>&#123; ...&quot;hello&quot; &#125;</code></li><li>  转换数组为对象：<code>&#123; ...[1, 2] &#125;</code></li><li>  与对象解构赋值结合：<code>const &#123; x, ...rest/spread &#125; = &#123; x: 1, y: 2, z: 3 &#125;</code>(不能复制继承自原型对象的属性)</li><li>  修改现有对象部分属性：<code>const obj = &#123; x: 1, ...&#123; x: 2 &#125; &#125;</code></li></ul><h3 id="正则扩展-1"><a href="#正则扩展-1" class="headerlink" title="正则扩展"></a>正则扩展</h3><ul><li>  <strong>s修饰符</strong>：dotAll模式修饰符，使<code>.</code>匹配任意单个字符(<code>dotAll模式</code>)</li><li>  <strong>dotAll</strong>：是否设置<code>s修饰符</code></li><li>  <strong>后行断言</strong>：<code>x</code>只有在<code>y</code>后才匹配</li><li>  <strong>后行否定断言</strong>：<code>x</code>只有不在<code>y</code>后才匹配</li><li><strong>Unicode属性转义</strong>：匹配符合<code>Unicode某种属性</code>的所有字符<ul><li>  正向匹配：<code>\p&#123;PropRule&#125;</code></li><li>  反向匹配：<code>\P&#123;PropRule&#125;</code></li><li>  限制：<code>\p&#123;...&#125;</code>和<code>\P&#123;...&#125;</code>只对<code>Unicode字符</code>有效，使用时需加上<code>u修饰符</code></li></ul></li><li><strong>具名组匹配</strong>：为每组匹配指定名字(<code>?&lt;GroupName&gt;</code>)<ul><li>  形式：<code>str.exec().groups.GroupName</code></li><li>解构赋值替换<ul><li>  声明：<code>const time = &quot;2017-09-11&quot;</code>、<code>const regexp = /(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/u</code></li><li>  匹配：<code>time.replace(regexp, &quot;$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;&quot;)</code></li></ul></li></ul></li></ul><h3 id="Promise-1"><a href="#Promise-1" class="headerlink" title="Promise"></a>Promise</h3><ul><li>  **finally()**：指定不管最后状态如何都会执行的回调函数</li></ul><h3 id="Async-1"><a href="#Async-1" class="headerlink" title="Async"></a>Async</h3><ul><li>  **异步迭代器(for-await-of)**：循环等待每个<code>Promise对象</code>变为<code>resolved状态</code>才进入下一步</li></ul></div><h2 id="ES2019"><a href="#ES2019" class="headerlink" title="ES2019"></a>ES2019</h2><div class="story post-story"><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201023110456.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201023110456.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20201023110456"></p><h3 id="字符串扩展-3"><a href="#字符串扩展-3" class="headerlink" title="字符串扩展"></a>字符串扩展</h3><ul><li>  <strong>直接输入U+2028和U+2029</strong>：字符串可直接输入<code>行分隔符</code>和<code>段分隔符</code></li><li>  <strong>JSON.stringify()改造</strong>：可返回不符合UTF-8标准的字符串</li><li>  **trimStart()**：消除字符串头部空格，返回新字符串</li><li>  **trimEnd()**：消除字符串尾部空格，返回新字符串</li></ul><h3 id="对象扩展-3"><a href="#对象扩展-3" class="headerlink" title="对象扩展"></a>对象扩展</h3><ul><li>  **Object.fromEntries()**：返回以键和值组成的对象(<code>Object.entries()</code>的逆操作)</li></ul><h3 id="数组扩展-2"><a href="#数组扩展-2" class="headerlink" title="数组扩展"></a>数组扩展</h3><ul><li>  <strong>sort()稳定性</strong>：排序关键字相同的项目其排序前后的顺序不变，默认为<code>稳定</code></li><li>  **flat()**：扁平化数组，返回新数组</li><li>  **flatMap()**：映射且扁平化数组，返回新数组(只能展开一层数组)</li></ul><h3 id="函数扩展-2"><a href="#函数扩展-2" class="headerlink" title="函数扩展"></a>函数扩展</h3><ul><li>  <strong>toString()改造</strong>：返回函数原始代码(与编码一致)</li><li>  <strong>catch()参数可省略</strong>：<code>catch()</code>中的参数可省略</li></ul><h3 id="Symbol-1"><a href="#Symbol-1" class="headerlink" title="Symbol"></a>Symbol</h3><ul><li>  <strong>description</strong>：返回<code>Symbol值</code>的描述</li></ul></div><h2 id="ES2020"><a href="#ES2020" class="headerlink" title="ES2020"></a>ES2020</h2><div class="story post-story"><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201023110521.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201023110521.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20201023110521"></p><h3 id="声明-2"><a href="#声明-2" class="headerlink" title="声明"></a>声明</h3><ul><li><strong>globalThis</strong>：作为顶层对象，指向全局环境下的<code>this</code><ul><li>  Browser：顶层对象是<code>window</code></li><li>  Node：顶层对象是<code>global</code></li><li>  WebWorker：顶层对象是<code>self</code></li><li>  以上三者：通用顶层对象是<code>globalThis</code></li></ul></li></ul><h3 id="数值扩展-2"><a href="#数值扩展-2" class="headerlink" title="数值扩展"></a>数值扩展</h3><ul><li><strong>BigInt</strong>：任何位数的整数(新增的数据类型，使用<code>n</code>结尾)<ul><li>  **BigInt()**：转换普通数值为BigInt类型</li><li>  **BigInt.asUintN()**：转换BigInt为0到2n-1之间对应的值</li><li>  **BigInt.asIntN()**：转换BigInt为-2n-1 到2n-1-1</li><li>  **BigInt.parseInt()**：近似于<code>Number.parseInt()</code>，将一个字符串转换成指定进制的BigInt类型</li></ul></li></ul><blockquote><p>重点难点</p></blockquote><ul><li>  BigInt同样可使用各种进制表示，都要加上后缀</li><li>  BigInt与普通整数是两种值，它们之间并不相等</li><li>  typeof运算符对于BigInt类型的数据返回<code>bigint</code></li></ul><h3 id="对象扩展-4"><a href="#对象扩展-4" class="headerlink" title="对象扩展"></a>对象扩展</h3><ul><li>**链判断操作符(?.)**：是否存在对象属性(不存在返回<code>undefined</code>且不再往下执行)<ul><li>  对象属性：<code>obj?.prop</code>、<code>obj?.[expr]</code></li><li>  函数调用：<code>func?.(...args)</code></li></ul></li><li>  **空判断操作符(??)**：是否值为<code>undefined</code>或<code>null</code>，是则使用默认值</li></ul><h3 id="正则扩展-2"><a href="#正则扩展-2" class="headerlink" title="正则扩展"></a>正则扩展</h3><ul><li>  **matchAll()**：返回所有匹配的遍历器</li></ul><h3 id="Module-1"><a href="#Module-1" class="headerlink" title="Module"></a>Module</h3><ul><li>**import()**：动态导入(返回<code>Promise</code>)<ul><li>  背景：<code>import命令</code>被JS引擎静态分析，先于模块内的其他语句执行，无法取代<code>require()</code>的动态加载功能，提案建议引入<code>import()</code>来代替<code>require()</code></li><li>  位置：可在任何地方使用</li><li>  区别：<code>require()</code>是<strong>同步加载</strong>，<code>import()</code>是<strong>异步加载</strong></li><li>  场景：按需加载、条件加载、模块路径动态化</li></ul></li></ul><h3 id="Iterator-1"><a href="#Iterator-1" class="headerlink" title="Iterator"></a>Iterator</h3><ul><li>  <strong>for-in遍历顺序</strong>：不同的引擎已就如何迭代属性达成一致，从而使行为标准化</li></ul><h3 id="Promise-2"><a href="#Promise-2" class="headerlink" title="Promise"></a>Promise</h3><ul><li>**Promise.allSettled()**：将多个实例包装成一个新实例，返回全部实例状态变更后的状态数组(齐变更再返回)<ul><li>  入参：具有<code>Iterator接口</code>的数据结构</li><li>  成功：成员包含<code>status</code>和<code>value</code>，<code>status</code>为<code>fulfilled</code>，<code>value</code>为返回值</li><li>  失败：成员包含<code>status</code>和<code>reason</code>，<code>status</code>为<code>rejected</code>，<code>value</code>为错误原因</li></ul></li></ul></div><h2 id="ES提案"><a href="#ES提案" class="headerlink" title="ES提案"></a>ES提案</h2><div class="story post-story"><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201023110554.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201023110554.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20201023110554"></p><h3 id="声明-3"><a href="#声明-3" class="headerlink" title="声明"></a>声明</h3><ul><li>  <strong>do表达式</strong>：封装块级作用域的操作，返回内部最后执行表达式的值(<code>do&#123;&#125;</code>)</li><li>  <strong>throw表达式</strong>：直接使用<code>throw new Error()</code>，无需<code>()</code>或<code>&#123;&#125;</code>包括</li><li>  <strong>!#命令</strong>：指定脚本执行器(写在文件首行)</li></ul><h3 id="数值扩展-3"><a href="#数值扩展-3" class="headerlink" title="数值扩展"></a>数值扩展</h3><ul><li>  **数值分隔符(_)**：使用<code>_</code>作为千分位分隔符(增加数值的可读性)</li><li>  **Math.signbit()**：返回数值符号是否设置</li></ul><h3 id="函数扩展-3"><a href="#函数扩展-3" class="headerlink" title="函数扩展"></a>函数扩展</h3><ul><li>  <strong>函数部分执行</strong>：复用函数功能(<code>?</code>表示单个参数占位符，<code>...</code>表示多个参数占位符)</li><li>  **管道操作符(|&gt;)**：把左边表达式的值传入右边的函数进行求值(<code>f(x)</code> =&gt; <code>x |&gt; f</code>)</li><li>**绑定运算符(::)**：函数绑定(左边是对象右边是函数，取代<code>bind</code>、<code>apply</code>、<code>call</code>调用)<ul><li>  bind：<code>bar.bind(foo)</code> =&gt; <code>foo::bar</code></li><li>  apply：<code>bar.apply(foo, arguments)</code> =&gt; <code>foo::bar(...arguments)</code></li></ul></li></ul><h3 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h3><ul><li>  定义：提供<code>沙箱功能</code>，允许隔离代码，防止被隔离的代码拿到全局对象</li><li>  声明：<code>new Realm().global</code></li></ul><h3 id="Class-1"><a href="#Class-1" class="headerlink" title="Class"></a>Class</h3><ul><li>  <strong>静态属性</strong>：使用<code>static</code>定义属性，该属性<code>不会被实例继承</code>，只能通过类来调用</li><li>  <strong>私有属性</strong>：使用<code>#</code>定义属性，该属性只能在类内部访问</li><li>  <strong>私有方法</strong>：使用<code>#</code>定义方法，该方法只能在类内部访问</li><li>  <strong>装饰器</strong>：使用<code>@</code>注释或修改类和类方法</li></ul><h3 id="Module-2"><a href="#Module-2" class="headerlink" title="Module"></a>Module</h3><ul><li>  <strong>import.meta</strong>：返回脚本元信息</li></ul><h3 id="Promise-3"><a href="#Promise-3" class="headerlink" title="Promise"></a>Promise</h3><ul><li>**Promise.any()**：将多个实例包装成一个新实例，返回全部实例状态变更后的结果数组(齐变更再返回)<ul><li>  入参：具有<code>Iterator接口</code>的数据结构</li><li>  成功：其中一个实例状态变成<code>fulfilled</code>，最终状态就会变成<code>fulfilled</code></li><li>  失败：只有全部实例状态变成<code>rejected</code>，最终状态才会变成<code>rejected</code></li></ul></li><li>  **Promise.try()**：不想区分是否同步异步函数，包装函数为实例，使用<code>then()</code>指定下一步流程，使用<code>catch()</code>捕获错误</li></ul><h3 id="Async-2"><a href="#Async-2" class="headerlink" title="Async"></a>Async</h3><ul><li>  <strong>顶层Await</strong>：允许在模块的顶层独立使用<code>await命令</code>(借用<code>await</code>解决模块异步加载的问题)</li></ul><p><a href="https://juejin.im/post/6844903959283367950" target="_blank" rel="noopener external nofollow noreferrer">原文链接</a></p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文的知识点完全是参考或摘录&lt;a href=&quot;https://es6.ruanyifeng.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener external nofollow noreferrer&quot;&gt;《ES6》&lt;/a&gt;里的语句，有部分语句为了方便理解和记忆，进行了相同意思的转义，同时对知识点进行归类划分。为了让大家能集中精力来记住这些特性，全文一句废话和题外话都没有，全部模块以笔记的形式进行书写，如果看得不是很惯建议对照&lt;a href=&quot;https://es6.ruanyifeng.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener external nofollow noreferrer&quot;&gt;《ES6》&lt;/a&gt;的内容来学习。&lt;/p&gt;
&lt;p&gt;本文整理出来的笔记都是书中的精华内容，囊括了整个&lt;code&gt;ES6体系&lt;/code&gt;的所有特性，非常方便大家重新认识&lt;code&gt;全部ES6特性&lt;/code&gt;。半小时的阅读就可对&lt;code&gt;ES6&lt;/code&gt;有一个全面的了解，可认为是一本&lt;code&gt;ES6特性小字典&lt;/code&gt;，收藏后可随时查阅。即使看不完也要拉到本文末尾喔，有个大彩蛋，嘻嘻！&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://kobingogo.github.io/categories/javascript/"/>
    
    
    <category term="ES6" scheme="https://kobingogo.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>IntersectionObserver原理分析</title>
    <link href="https://kobingogo.github.io/Chrome%E6%BA%90%E7%A0%81-IntersectionObserver/"/>
    <id>https://kobingogo.github.io/Chrome%E6%BA%90%E7%A0%81-IntersectionObserver/</id>
    <published>2020-10-14T16:35:29.000Z</published>
    <updated>2024-08-08T10:31:05.013Z</updated>
    
    <content type="html"><![CDATA[<p>在介绍<code>IntersectionObserver</code>的时候曾提到过这个接口目前使用的最大问题就是浏览器的兼容性问题。所以，我们平时在使用的时候切记不要忘记判断这个API在我们的宿主环境中是否存在。如果不存在，我们可以通过引入其<code>polyfill</code>来作部分功能的兼容。</p><p><code>IntersectionObserver-polyfill</code>是<code>w3c</code>官方创建的<a href="https://github.com/w3c/IntersectionObserver" target="_blank" rel="noopener external nofollow noreferrer">https://github.com/w3c/IntersectionObserver</a>。我们可以在浏览器不支持<code>IntersectionObserver</code>的情况下引入它。当然，你也可以直接引入它，其内部也只会在浏览器不支持其的情况下进行<code>polyfill</code>。</p><span id="more"></span><p><code>IntersectionObserver</code>的使用前面做了简单的叙述</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;target&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(<span class="function">(<span class="params">entries</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [entry] = entries</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (entry.<span class="property">isIntersecting</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;元素曝光了&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">observe</span>(target)</span><br></pre></td></tr></table></figure><p>下面我们就从其<code>polyfill</code>的源码中来了解其基本原理</p><h2 id="IntersectionObserver"><a href="#IntersectionObserver" class="headerlink" title="IntersectionObserver"></a>IntersectionObserver</h2><div class="story post-story"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">IntersectionObserver</span>(<span class="params">callback, opt_options</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> options = opt_options || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> callback != <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;callback must be a function&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (options.<span class="property">root</span> &amp;&amp; options.<span class="property">root</span>.<span class="property">nodeType</span> != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;root must be an Element&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Binds and throttles `this._checkForIntersections`.</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_checkForIntersections</span> = <span class="title function_">throttle</span>(</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">_checkForIntersections</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="variable language_">this</span>.<span class="property">THROTTLE_TIMEOUT</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Private properties.</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_callback</span> = callback;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_observationTargets</span> = [];</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_queuedEntries</span> = [];</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_rootMarginValues</span> = <span class="variable language_">this</span>.<span class="title function_">_parseRootMargin</span>(options.<span class="property">rootMargin</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Public properties.</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">thresholds</span> = <span class="variable language_">this</span>.<span class="title function_">_initThresholds</span>(options.<span class="property">threshold</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = options.<span class="property">root</span> || <span class="literal">null</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">rootMargin</span> = <span class="variable language_">this</span>.<span class="property">_rootMarginValues</span>.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">margin</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> margin.<span class="property">value</span> + margin.<span class="property">unit</span>;</span><br><span class="line">      &#125;).<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>IntersectionObserver</code>是一个构造函数。当我们创建其实例的时候，可以传递两个参数。第一个参数必须是一个函数，否则会抛出一个错误。第二个参数是一个可选的对象，唯一的要求就是我们指定的<code>root</code>属性的值必须是一个<code>Element</code>。构造函数会在创建实例的时候添加很多私有属性。有些属性后面用到的时候会讲解，这里我们先看几个用来保存我们传递的选项的属性。</p><p>在创建<code>IntersectionObserver</code>实例的时候，我们可以在第二个参数对象中传入以下几个属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">root</span>: <span class="title class_">Element</span>,</span><br><span class="line">  <span class="attr">rootMargin</span>: string,</span><br><span class="line">  <span class="attr">threshold</span>: number | number[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造函数中首先会调用私有方法解析我们传入的<code>rootMargin</code>属性，下面是这个方法的基本实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">IntersectionObserver</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_parseRootMargin</span> = <span class="keyword">function</span>(<span class="params">opt_rootMargin</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> marginString = opt_rootMargin || <span class="string">&#x27;0px&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> margins = marginString.<span class="title function_">split</span>(<span class="regexp">/\s+/</span>).<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">margin</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> parts = <span class="regexp">/^(-?\d*\.?\d+)(px|%)$/</span>.<span class="title function_">exec</span>(margin);</span><br><span class="line">    <span class="keyword">if</span> (!parts) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;rootMargin must be specified in pixels or percent&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">value</span>: <span class="built_in">parseFloat</span>(parts[<span class="number">1</span>]), <span class="attr">unit</span>: parts[<span class="number">2</span>]&#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Handles shorthand.</span></span><br><span class="line">  margins[<span class="number">1</span>] = margins[<span class="number">1</span>] || margins[<span class="number">0</span>];</span><br><span class="line">  margins[<span class="number">2</span>] = margins[<span class="number">2</span>] || margins[<span class="number">0</span>];</span><br><span class="line">  margins[<span class="number">3</span>] = margins[<span class="number">3</span>] || margins[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> margins;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法就是将我们传入的<code>rootMargin</code>解析成数组，这个数组包含四个元素代表的分别是<code>上，右，下，左</code>边距的值和单位。<code>rootMargin</code>设置的时候和<code>css margin</code>设置的方式一样，可以传入<code>1,2,3,4</code>个值。比如</p><pre><code>rootMargin: &#39;10px&#39; --&gt; _parseRootMargin(rootMargin) --&gt; [&#123;value: 10, unit: &#39;px&#39;&#125;,&#123;value: 10, unit: &#39;px&#39;&#125;,&#123;value: 10, unit: &#39;px&#39;&#125;,&#123;value: 10, unit: &#39;px&#39;&#125;]// 传入2，3，4个值的解析规则和css margin的解析规则其实是一样的</code></pre><p>解析完<code>rootMargin</code>后，私有属性<code>this._rootMarginValues</code>就是如下形式</p><pre><code>[  &#123;value: 10, unit: &#39;px&#39;&#125;,  &#123;value: 10, unit: &#39;px&#39;&#125;,  &#123;value: 10, unit: &#39;px&#39;&#125;,  &#123;value: 10, unit: &#39;px&#39;&#125;]</code></pre><p>后面又将其转化为<code>this.rootMargin</code>的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">rootMargin</span> = <span class="variable language_">this</span>.<span class="property">_rootMarginValues</span>.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">margin</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> margin.<span class="property">value</span> + margin.<span class="property">unit</span>;</span><br><span class="line">  &#125;).<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>);</span><br></pre></td></tr></table></figure><p>所以，无论我们传入的<code>rootMargin</code>是什么样的形式，构造函数执行结束后都会变成<code>10px 10px 10px 10px</code>的形式。</p><p>在构造函数中还有一个步骤是初始化我们传入的<code>threshold</code>。我们知道，<code>threshold</code>可以是一个数字，也可以是由数字组成的数组。构造函数执行的时候，会统一将其转换成数组的形式并保存在<code>this.thresholds</code>属性中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">thresholds</span> = <span class="variable language_">this</span>.<span class="title function_">_initThresholds</span>(options.<span class="property">threshold</span>);</span><br></pre></td></tr></table></figure><p>下面是解析<code>threshold</code>的<code>_initThreshold</code>方法的实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">IntersectionObserver</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_initThresholds</span> = <span class="keyword">function</span>(<span class="params">opt_threshold</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> threshold = opt_threshold || [<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(threshold)) threshold = [threshold];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> threshold.<span class="title function_">sort</span>().<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">t, i, a</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> t != <span class="string">&#x27;number&#x27;</span> || <span class="built_in">isNaN</span>(t) || t &lt; <span class="number">0</span> || t &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;threshold must be a number between 0 and 1 inclusively&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t !== a[i - <span class="number">1</span>];</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法接收我们传入的<code>options.threshold</code>选项的值作为参数，如果我们没有传入这个值，则默认为0。如果我们传入的不是一个数组，就将其转化为数组。下面的<code>filter</code>是对一个数组进行去重的方法，即如果我们对<code>threshold</code>传入了重复的值，只会取一个。而且<code>threshold</code>中的每一个值都必须是数字，并且在<code>[0, 1]</code>之间。所以，<code>this.threshold</code>最终保存的值是如下形式</p><pre><code>this.threshold = [0]this.threshold = [0.25, 0.5, 1]</code></pre><p>上面就是<code>IntersectionObserver</code>构造函数大致的执行过程，实例创建好后，我们会调用<code>observe</code>方法监测元素。下面我们看一下<code>observe</code>方法的具体实现</p><h3 id="observe"><a href="#observe" class="headerlink" title="observe"></a>observe</h3><p><code>observe</code>方法定义在<code>IntersectionObserver.prototype</code>上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">IntersectionObserver</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">observe</span> = <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> isTargetAlreadyObserved = <span class="variable language_">this</span>.<span class="property">_observationTargets</span>.<span class="title function_">some</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> item.<span class="property">element</span> == target;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isTargetAlreadyObserved) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(target &amp;&amp; target.<span class="property">nodeType</span> == <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;target must be an Element&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">_registerInstance</span>();</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_observationTargets</span>.<span class="title function_">push</span>(&#123;<span class="attr">element</span>: target, <span class="attr">entry</span>: <span class="literal">null</span>&#125;);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">_monitorIntersections</span>();</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">_checkForIntersections</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收的参数就是我们需要监测的dom元素。首先会遍历<code>this._observationTargets</code>，这个属性是一个数组，它也是在初始化<code>IntersectionObserver</code>的时候创建的</p><pre><code>this._observationTargets = [];</code></pre><p>对这个属性的遍历，其实就是为了判断当前的<code>observer</code>是否已经通过<code>observe</code>方法监测过<code>target</code>元素。如果已经监测过，就直接<code>return</code>，防止同一个<code>observer</code>实例对同一个<code>target</code>元素进行多次监测。</p><p>如果没有监测过<code>target</code>元素，这里同样会对<code>target</code>的类型进行判断。如果不是一个dom结点，同样会抛出一个错误。</p><p>接着，会调用<code>this._registerInstance</code>方法。这个方法的主要作用就是将当前的<code>observer</code>实例添加到全局数组<code>registry</code>中，主要是为了防止我们的<code>observer</code>实例被垃圾回收进行清除</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">IntersectionObserver</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_registerInstance</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (registry.<span class="title function_">indexOf</span>(<span class="variable language_">this</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    registry.<span class="title function_">push</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，将我们<code>target</code>元素保存在<code>this._observationTargets</code>中。从上面代码中可以看到，<code>this._observationTargets</code>并不只是保存<code>target</code>元素。它会将<code>target</code>元素作为一个对象的<code>element</code>属性的值进行保存，同时这个对象还有一个<code>entry</code>属性。这个属性初始的时候是一个<code>null</code>，后续是<code>IntersectionObserverEntry</code>的一个实例对象。</p><p>之后调用<code>this._monitorIntersections</code>方法，这个方法后面我们会说。它的作用主要就是采用什么样的方式来检测<code>target</code>的状态。</p><p>最后调用<code>this._checkForIntersections</code>方法，这个方法同样会在后面讲解。这里它主要就是对<code>target</code>元素的状态进行一次初始的判断。如果<code>target</code>元素在初始的时候已经满足了和<code>root</code>元素的交集的状态，在调用这个方法的时候就会触发我们的回调函数。</p><h3 id="monitorIntersections"><a href="#monitorIntersections" class="headerlink" title="_monitorIntersections"></a>_monitorIntersections</h3><p>调用<code>observe</code>方法之后，我们就能够监测<code>target</code>元素的状态了。对<code>target</code>元素状态的监测，就是通过调用上面我们所提到的<code>this._monitorIntersections</code>方法。这里我们来看一下这个方法是怎么实现对元素的监测的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">IntersectionObserver</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_monitorIntersections</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_monitoringIntersections</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_monitoringIntersections</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If a poll interval is set, use polling instead of listening to</span></span><br><span class="line">    <span class="comment">// resize and scroll events or DOM mutations.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">POLL_INTERVAL</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_monitoringInterval</span> = <span class="built_in">setInterval</span>(</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">_checkForIntersections</span>, <span class="variable language_">this</span>.<span class="property">POLL_INTERVAL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">addEvent</span>(<span class="variable language_">window</span>, <span class="string">&#x27;resize&#x27;</span>, <span class="variable language_">this</span>.<span class="property">_checkForIntersections</span>, <span class="literal">true</span>);</span><br><span class="line">      <span class="title function_">addEvent</span>(<span class="variable language_">document</span>, <span class="string">&#x27;scroll&#x27;</span>, <span class="variable language_">this</span>.<span class="property">_checkForIntersections</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">USE_MUTATION_OBSERVER</span> &amp;&amp; <span class="string">&#x27;MutationObserver&#x27;</span> <span class="keyword">in</span> <span class="variable language_">window</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_domObserver</span> = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="variable language_">this</span>.<span class="property">_checkForIntersections</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_domObserver</span>.<span class="title function_">observe</span>(<span class="variable language_">document</span>, &#123;</span><br><span class="line">          <span class="attr">attributes</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">childList</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">characterData</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">subtree</span>: <span class="literal">true</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法提供了两种方式用来监测元素状态的变化。第一种很简单，也很粗暴 -- <code>polling</code>。这种方式默认是关闭的</p><pre><code>IntersectionObserver.prototype.POLL_INTERVAL = null;</code></pre><p>如果你想使用<code>polling</code>的方式监测元素的状态，则需要在创建<code>IntersectionObserver</code>实例之后，调用<code>observe</code>方法之前设置<code>observer.POLL_INTERVAL</code>属性，比如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line">observer.<span class="property">POLL_INTERVAL</span> = <span class="number">300</span></span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">observe</span>(target)</span><br></pre></td></tr></table></figure><p>如果按照上面代码的设置，浏览器就会开启一个定时器，每300毫秒判断一下元素的状态</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">_monitoringInterval</span> = <span class="built_in">setInterval</span>(</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">_checkForIntersections</span>, <span class="variable language_">this</span>.<span class="property">POLL_INTERVAL</span>);</span><br></pre></td></tr></table></figure><p>但是，这种方式不推荐；所以在<code>polyfill</code>的源码中默认将这种方式关闭，采用更高效的事件监听的方式来监测元素状态的变化。首先需要监听<code>window</code>的<code>resize</code>和<code>document</code>的<code>scroll</code>事件。监听这两种事件能够满足大多数对元素状态判断的情况。如果一个元素自身的属性没有变化，当窗口滚动或者大小改变的时候都会影响元素和&quot;视窗&quot;的交集。但是，在某些业务场景下这两种事件是无法监测到元素状态的变化的。比如选项卡切换，元素自身的显示和隐藏等。对于这种情况，<code>polyfill</code>中同样采用一种粗暴的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">USE_MUTATION_OBSERVER</span> &amp;&amp; <span class="string">&#x27;MutationObserver&#x27;</span> <span class="keyword">in</span> <span class="variable language_">window</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_domObserver</span> = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="variable language_">this</span>.<span class="property">_checkForIntersections</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_domObserver</span>.<span class="title function_">observe</span>(<span class="variable language_">document</span>, &#123;</span><br><span class="line">    <span class="attr">attributes</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">childList</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">characterData</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">subtree</span>: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>MutationObserver</code>接口监测<code>document</code>元素下所有节点的<code>attributes</code>，<code>childList</code>和<code>characterData</code>的变化。每当有子节点状态变化的时候都会去检测<code>target</code>元素和<code>root</code>元素的交集状态。这种方式很粗暴，但是某些业务场景下我们也不得不这样做。</p><p>上面监测元素所有的方式中，其回调函数都是<code>this._checkForIntersections</code>方法。这个方法在上面也提到过，在调用<code>observe</code>方法的时候同样也会调用这个方法。这个方法到底做了什么，下面就详细的看一下。</p><h3 id="checkForIntersections"><a href="#checkForIntersections" class="headerlink" title="_checkForIntersections"></a>_checkForIntersections</h3><p>在详细讲解这个方法之前，先来简单的总结一下这个方法会在什么样的条件下被调用</p><ul><li>  调用<code>observer.observe(target)</code>方法的时候</li><li>  采用轮询的方式监测元素，作为<code>setInterval</code>回调函数</li><li>  采用事件的方式监测元素，作为<code>document</code>的<code>scroll</code>事件的回调函数</li><li>  采用事件的方式监测元素，作为<code>window</code>的<code>resize</code>事件的回调函数</li><li>  采用事件的方式监测元素，作为<code>MutationObserver</code>的回调函数</li></ul><p>总之，在<code>this._checkForIntersections</code>方法被调用的时候，主要就是为了判断<code>target</code>元素和<code>root</code>元素的交集状态有没有发生变化，如果交集状态发生了变化，就会触发我们的回调函数。下面就详细的看一下这个方法到底做了哪些事情</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">IntersectionObserver</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_checkForIntersections</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> rootIsInDom = <span class="variable language_">this</span>.<span class="title function_">_rootIsInDom</span>();</span><br><span class="line">  <span class="keyword">var</span> rootRect = rootIsInDom ? <span class="variable language_">this</span>.<span class="title function_">_getRootRect</span>() : <span class="title function_">getEmptyRect</span>();</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_observationTargets</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> target = item.<span class="property">element</span>;</span><br><span class="line">    <span class="keyword">var</span> targetRect = <span class="title function_">getBoundingClientRect</span>(target);</span><br><span class="line">    <span class="keyword">var</span> rootContainsTarget = <span class="variable language_">this</span>.<span class="title function_">_rootContainsTarget</span>(target);</span><br><span class="line">    <span class="keyword">var</span> oldEntry = item.<span class="property">entry</span>;</span><br><span class="line">    <span class="keyword">var</span> intersectionRect = rootIsInDom &amp;&amp; rootContainsTarget &amp;&amp;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">_computeTargetAndRootIntersection</span>(target, rootRect);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> newEntry = item.<span class="property">entry</span> = <span class="keyword">new</span> <span class="title class_">IntersectionObserverEntry</span>(&#123;</span><br><span class="line">      <span class="attr">time</span>: <span class="title function_">now</span>(),</span><br><span class="line">      <span class="attr">target</span>: target,</span><br><span class="line">      <span class="attr">boundingClientRect</span>: targetRect,</span><br><span class="line">      <span class="attr">rootBounds</span>: rootRect,</span><br><span class="line">      <span class="attr">intersectionRect</span>: intersectionRect</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!oldEntry) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_queuedEntries</span>.<span class="title function_">push</span>(newEntry);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rootIsInDom &amp;&amp; rootContainsTarget) &#123;</span><br><span class="line">      <span class="comment">// If the new entry intersection ratio has crossed any of the</span></span><br><span class="line">      <span class="comment">// thresholds, add a new entry.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">_hasCrossedThreshold</span>(oldEntry, newEntry)) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_queuedEntries</span>.<span class="title function_">push</span>(newEntry);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// If the root is not in the DOM or target is not contained within</span></span><br><span class="line">      <span class="comment">// root but the previous entry for this target had an intersection,</span></span><br><span class="line">      <span class="comment">// add a new record indicating removal.</span></span><br><span class="line">      <span class="keyword">if</span> (oldEntry &amp;&amp; oldEntry.<span class="property">isIntersecting</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_queuedEntries</span>.<span class="title function_">push</span>(newEntry);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_queuedEntries</span>.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">_callback</span>(<span class="variable language_">this</span>.<span class="title function_">takeRecords</span>(), <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会判断<code>root</code>元素是不是在<code>dom</code>结构中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">IntersectionObserver</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_rootIsInDom</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> !<span class="variable language_">this</span>.<span class="property">root</span> || <span class="title function_">containsDeep</span>(<span class="variable language_">document</span>, <span class="variable language_">this</span>.<span class="property">root</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">containsDeep</span>(<span class="params">parent, child</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> node = child;</span><br><span class="line">  <span class="keyword">while</span> (node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == parent) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    node = <span class="title function_">getParentNode</span>(node);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getParentNode</span>(<span class="params">node</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> parent = node.<span class="property">parentNode</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (parent &amp;&amp; parent.<span class="property">nodeType</span> == <span class="number">11</span> &amp;&amp; parent.<span class="property">host</span>) &#123;</span><br><span class="line">    <span class="comment">// If the parent is a shadow root, return the host element.</span></span><br><span class="line">    <span class="keyword">return</span> parent.<span class="property">host</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (parent &amp;&amp; parent.<span class="property">assignedSlot</span>) &#123;</span><br><span class="line">    <span class="comment">// If the parent is distributed in a &lt;slot&gt;, return the parent of a slot.</span></span><br><span class="line">    <span class="keyword">return</span> parent.<span class="property">assignedSlot</span>.<span class="property">parentNode</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码主要就是用来判断<code>root</code>元素是不是在<code>dom</code>结构中。所以这就要求我们传入的<code>options.root</code>选项一定要是<code>target</code>的祖先元素。</p><p>接着会获取<code>root</code>元素的区域数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">IntersectionObserver</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_getRootRect</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> rootRect;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">    rootRect = <span class="title function_">getBoundingClientRect</span>(<span class="variable language_">this</span>.<span class="property">root</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Use &lt;html&gt;/&lt;body&gt; instead of window since scroll bars affect size.</span></span><br><span class="line">    <span class="keyword">var</span> html = <span class="variable language_">document</span>.<span class="property">documentElement</span>;</span><br><span class="line">    <span class="keyword">var</span> body = <span class="variable language_">document</span>.<span class="property">body</span>;</span><br><span class="line">    rootRect = &#123;</span><br><span class="line">      <span class="attr">top</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">left</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">right</span>: html.<span class="property">clientWidth</span> || body.<span class="property">clientWidth</span>,</span><br><span class="line">      <span class="attr">width</span>: html.<span class="property">clientWidth</span> || body.<span class="property">clientWidth</span>,</span><br><span class="line">      <span class="attr">bottom</span>: html.<span class="property">clientHeight</span> || body.<span class="property">clientHeight</span>,</span><br><span class="line">      <span class="attr">height</span>: html.<span class="property">clientHeight</span> || body.<span class="property">clientHeight</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">_expandRectByRootMargin</span>(rootRect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们自己传递了<code>root</code>元素，就会通过<code>root.getBoundingClientRect</code>方法获取到<code>root</code>的区域数据。如果采用默认的<code>document</code>元素，则会使用视窗的区域数据。后面又调用了<code>_expandRectByRootMargin</code>方法，这个方法主要是用来将我们传入的<code>rootMargin</code>和<code>rootRect</code>数据结合得出新的<code>newRootRect</code>数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">IntersectionObserver</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_expandRectByRootMargin</span> = <span class="keyword">function</span>(<span class="params">rect</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> margins = <span class="variable language_">this</span>.<span class="property">_rootMarginValues</span>.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">margin, i</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> margin.<span class="property">unit</span> == <span class="string">&#x27;px&#x27;</span> ? margin.<span class="property">value</span> :</span><br><span class="line">        margin.<span class="property">value</span> * (i % <span class="number">2</span> ? rect.<span class="property">width</span> : rect.<span class="property">height</span>) / <span class="number">100</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> newRect = &#123;</span><br><span class="line">    <span class="attr">top</span>: rect.<span class="property">top</span> - margins[<span class="number">0</span>],</span><br><span class="line">    <span class="attr">right</span>: rect.<span class="property">right</span> + margins[<span class="number">1</span>],</span><br><span class="line">    <span class="attr">bottom</span>: rect.<span class="property">bottom</span> + margins[<span class="number">2</span>],</span><br><span class="line">    <span class="attr">left</span>: rect.<span class="property">left</span> - margins[<span class="number">3</span>]</span><br><span class="line">  &#125;;</span><br><span class="line">  newRect.<span class="property">width</span> = newRect.<span class="property">right</span> - newRect.<span class="property">left</span>;</span><br><span class="line">  newRect.<span class="property">height</span> = newRect.<span class="property">bottom</span> - newRect.<span class="property">top</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newRect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_expandRectByRootMargin</code>方法很好理解，就是将<code>rootRect</code>和<code>rootMargin</code>结合计算出新的<code>rootRect</code>区域的大小。</p><p>在<code>root</code>的区域确定后，会遍历<code>this._observationTargets</code>属性。这个属性上面我们也提过，它用来保存被<code>observer</code>所监测的所有的<code>target</code>元素。遍历的过程先不看，后面还有一小段代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_queuedEntries</span>.<span class="property">length</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">_callback</span>(<span class="variable language_">this</span>.<span class="title function_">takeRecords</span>(), <span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>this._queuedEntries</code>这个属性一个数组，其中每一个元素都是<code>IntersectionObserverEntry</code>实例对象。只有当这个属性的长度大于0的时候，才会触发回调函数。在讲解<code>IntersectionObserver</code>方法的基本使用的时候我们曾经说过，<code>callback</code>的第一个参数是由<code>IntersectionObserverEntry</code>实例组成的数组，那这里是通过<code>this.takeRecords()</code>方法获取的，这个方法做了什么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">IntersectionObserver</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">takeRecords</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> records = <span class="variable language_">this</span>.<span class="property">_queuedEntries</span>.<span class="title function_">slice</span>();</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_queuedEntries</span> = [];</span><br><span class="line">  <span class="keyword">return</span> records;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法很简单，就是通过<code>slice</code>方法对<code>this._queuedEntries</code>数据做个备份，然后清空<code>this._queuedEntries</code>。这表示在这个时间段内和<code>root</code>发生交集变化的<code>target</code>会在调用<code>this._checkForIntersections</code>后交给我们的<code>callback</code>统一处理。也就是说，每个时间段都是重新收集发生变化的<code>target</code>的。</p><p>下面我们来看一下对<code>this._observationTargets</code>的遍历会做哪些事情？估计大家也能想到，它主要就是用来收集在这个阶段中和<code>root</code>元素发生交集变化的<code>target</code>元素，并将新的交集状态(<code>IntersectionObserverEntry</code>实例对象) 保存在<code>this._queuedEntries</code>队列中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">_observationTargets</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> target = item.<span class="property">element</span>;</span><br><span class="line">  <span class="keyword">var</span> targetRect = <span class="title function_">getBoundingClientRect</span>(target);</span><br><span class="line">  <span class="keyword">var</span> rootContainsTarget = <span class="variable language_">this</span>.<span class="title function_">_rootContainsTarget</span>(target);</span><br><span class="line">  <span class="keyword">var</span> oldEntry = item.<span class="property">entry</span>;</span><br><span class="line">  <span class="keyword">var</span> intersectionRect = rootIsInDom &amp;&amp; rootContainsTarget &amp;&amp;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">_computeTargetAndRootIntersection</span>(target, rootRect);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> newEntry = item.<span class="property">entry</span> = <span class="keyword">new</span> <span class="title class_">IntersectionObserverEntry</span>(&#123;</span><br><span class="line">    <span class="attr">time</span>: <span class="title function_">now</span>(),</span><br><span class="line">    <span class="attr">target</span>: target,</span><br><span class="line">    <span class="attr">boundingClientRect</span>: targetRect,</span><br><span class="line">    <span class="attr">rootBounds</span>: rootRect,</span><br><span class="line">    <span class="attr">intersectionRect</span>: intersectionRect</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!oldEntry) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_queuedEntries</span>.<span class="title function_">push</span>(newEntry);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rootIsInDom &amp;&amp; rootContainsTarget) &#123;</span><br><span class="line">    <span class="comment">// If the new entry intersection ratio has crossed any of the</span></span><br><span class="line">    <span class="comment">// thresholds, add a new entry.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">_hasCrossedThreshold</span>(oldEntry, newEntry)) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_queuedEntries</span>.<span class="title function_">push</span>(newEntry);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// If the root is not in the DOM or target is not contained within</span></span><br><span class="line">    <span class="comment">// root but the previous entry for this target had an intersection,</span></span><br><span class="line">    <span class="comment">// add a new record indicating removal.</span></span><br><span class="line">    <span class="keyword">if</span> (oldEntry &amp;&amp; oldEntry.<span class="property">isIntersecting</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_queuedEntries</span>.<span class="title function_">push</span>(newEntry);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="variable language_">this</span>);</span><br></pre></td></tr></table></figure><p>在遍历的过程中，首先获取每个<code>target</code>元素的区域数据，然后调用<code>this._rootContainsTarget</code>方法，这个方法就是用来判断<code>root</code>元素是不是<code>target</code>元素的祖先元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">IntersectionObserver</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_rootContainsTarget</span> = <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">containsDeep</span>(<span class="variable language_">this</span>.<span class="property">root</span> || <span class="variable language_">document</span>, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，我们先看一下这段代码做了啥，后面再看看<code>item.entry</code>是什么</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intersectionRect = rootIsInDom &amp;&amp; rootContainsTarget &amp;&amp;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">_computeTargetAndRootIntersection</span>(target, rootRect);</span><br></pre></td></tr></table></figure><p>如果<code>rootIsInDom</code>为真（表示root元素在dom结构中）且<code>rootContainsTarget</code>为真（表示<code>root</code>是<code>target</code>元素的祖先元素），就调用<code>this._computeTargetAndRootIntersection</code>方法。这个方法从名称上应该都能理解它的作用：计算<code>target</code>元素和<code>root</code>元素的相交区域。其实就是用来计算相交面积<code>intersectionRect</code>的大小。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">IntersectionObserver</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_computeTargetAndRootIntersection</span> =</span><br><span class="line">    <span class="keyword">function</span>(<span class="params">target, rootRect</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the element isn&#x27;t displayed, an intersection can&#x27;t happen.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(target).<span class="property">display</span> == <span class="string">&#x27;none&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> targetRect = <span class="title function_">getBoundingClientRect</span>(target);</span><br><span class="line">  <span class="keyword">var</span> intersectionRect = targetRect;</span><br><span class="line">  <span class="keyword">var</span> parent = <span class="title function_">getParentNode</span>(target);</span><br><span class="line">  <span class="keyword">var</span> atRoot = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!atRoot) &#123;</span><br><span class="line">    <span class="keyword">var</span> parentRect = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">var</span> parentComputedStyle = parent.<span class="property">nodeType</span> == <span class="number">1</span> ?</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(parent) : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the parent isn&#x27;t displayed, an intersection can&#x27;t happen.</span></span><br><span class="line">    <span class="keyword">if</span> (parentComputedStyle.<span class="property">display</span> == <span class="string">&#x27;none&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="variable language_">this</span>.<span class="property">root</span> || parent == <span class="variable language_">document</span>) &#123;</span><br><span class="line">      atRoot = <span class="literal">true</span>;</span><br><span class="line">      parentRect = rootRect;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// If the element has a non-visible overflow, and it&#x27;s not the &lt;body&gt;</span></span><br><span class="line">      <span class="comment">// or &lt;html&gt; element, update the intersection rect.</span></span><br><span class="line">      <span class="comment">// Note: &lt;body&gt; and &lt;html&gt; cannot be clipped to a rect that&#x27;s not also</span></span><br><span class="line">      <span class="comment">// the document rect, so no need to compute a new intersection.</span></span><br><span class="line">      <span class="keyword">if</span> (parent != <span class="variable language_">document</span>.<span class="property">body</span> &amp;&amp;</span><br><span class="line">          parent != <span class="variable language_">document</span>.<span class="property">documentElement</span> &amp;&amp;</span><br><span class="line">          parentComputedStyle.<span class="property">overflow</span> != <span class="string">&#x27;visible&#x27;</span>) &#123;</span><br><span class="line">        parentRect = <span class="title function_">getBoundingClientRect</span>(parent);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If either of the above conditionals set a new parentRect,</span></span><br><span class="line">    <span class="comment">// calculate new intersection data.</span></span><br><span class="line">    <span class="keyword">if</span> (parentRect) &#123;</span><br><span class="line">      intersectionRect = <span class="title function_">computeRectIntersection</span>(parentRect, intersectionRect);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!intersectionRect) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    parent = <span class="title function_">getParentNode</span>(parent);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> intersectionRect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法接收的两个参数分别是<code>target</code>元素和<code>root</code>元素区域的大小。如果元素是隐藏的，是不可能存在相交的，所以直接返回就行了。接着会获取<code>target</code>区域数据和其parentNode元素，并设置一个标志位用来表示下面的while循环是否循环到了<code>this.root</code>或者是<code>document</code>。在while循环中先会判断<code>target.parentNode</code>是否显示，如果其隐藏的话，<code>target</code>和<code>root</code>元素同样是不可能存在交集的。这里我们先假设我们采用默认的<code>root</code>即<code>document</code>，而且<code>parentNode</code>就是<code>document</code>，那么循环将会进入<code>if</code>分支，并将<code>parentRect</code>设置<code>rootRect</code>的大小，atRoot设置为<code>true</code>。接着会执行如下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (parentRect) &#123;</span><br><span class="line">  intersectionRect = <span class="title function_">computeRectIntersection</span>(parentRect, intersectionRect);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!intersectionRect) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">parent = <span class="title function_">getParentNode</span>(parent);</span><br></pre></td></tr></table></figure><p>在这个分支中会执行<code>computeRectIntersection</code>函数，这个函数才是真正的计算<code>target</code>和<code>root</code>相交区域的大小</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">computeRectIntersection</span>(<span class="params">rect1, rect2</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> top = <span class="title class_">Math</span>.<span class="title function_">max</span>(rect1.<span class="property">top</span>, rect2.<span class="property">top</span>);</span><br><span class="line">  <span class="keyword">var</span> bottom = <span class="title class_">Math</span>.<span class="title function_">min</span>(rect1.<span class="property">bottom</span>, rect2.<span class="property">bottom</span>);</span><br><span class="line">  <span class="keyword">var</span> left = <span class="title class_">Math</span>.<span class="title function_">max</span>(rect1.<span class="property">left</span>, rect2.<span class="property">left</span>);</span><br><span class="line">  <span class="keyword">var</span> right = <span class="title class_">Math</span>.<span class="title function_">min</span>(rect1.<span class="property">right</span>, rect2.<span class="property">right</span>);</span><br><span class="line">  <span class="keyword">var</span> width = right - left;</span><br><span class="line">  <span class="keyword">var</span> height = bottom - top;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (width &gt;= <span class="number">0</span> &amp;&amp; height &gt;= <span class="number">0</span>) &amp;&amp; &#123;</span><br><span class="line">    <span class="attr">top</span>: top,</span><br><span class="line">    <span class="attr">bottom</span>: bottom,</span><br><span class="line">    <span class="attr">left</span>: left,</span><br><span class="line">    <span class="attr">right</span>: right,</span><br><span class="line">    <span class="attr">width</span>: width,</span><br><span class="line">    <span class="attr">height</span>: height</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将这段代码用下面的图片来表示，就能看出它到底在做啥</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201014163228.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20201014163228.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>上图中红色的线段就是相交区域的<code>上，下，左，右</code>的长度。所以，相交区域的大小就是图中橙色实心部分的大小。如果<code>target</code>位于<code>root</code>的区域外，则表示<code>width</code>或者<code>height</code>至少有一个<code>&lt;=0</code>。那么计算出来的相交区域的大小也就为<code>0</code>。</p><p>假设<code>target.parentNode</code>不是<code>document</code>，那么while循环会执行<code>else</code>分支。其中执行<code>else</code>分支有一个条件<code>parentComputedStyle.overflow != &#39;visible&#39;</code>。如果<code>parentComputedStyle.overflow</code>的值为<code>visible</code>，那么<code>target</code>和<code>root</code>最大的交叉面积就是<code>target</code>的大小，如果<code>parentComputedStyle.overflow</code>的值不为<code>visible</code>，那么<code>target</code>和<code>root</code>最大的交叉面积是多少呢？最大的交叉面积就是<code>target</code>最大能显示出来的面积的大小。</p><p>交叉面积计算出来后，我们接着分析下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oldEntry = item.<span class="property">entry</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newEntry = item.<span class="property">entry</span> = <span class="keyword">new</span> <span class="title class_">IntersectionObserverEntry</span>(&#123;</span><br><span class="line">  <span class="attr">time</span>: <span class="title function_">now</span>(),</span><br><span class="line">  <span class="attr">target</span>: target,</span><br><span class="line">  <span class="attr">boundingClientRect</span>: targetRect,</span><br><span class="line">  <span class="attr">rootBounds</span>: rootRect,</span><br><span class="line">  <span class="attr">intersectionRect</span>: intersectionRect</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>先看对<code>newEntry</code>的赋值。我们上面说过<code>this._observationTargets</code>保存的数据的结构为<code>&#123;element: target, entry: null&#125;</code>这种类型。从这里就能看到<code>entry</code>就是通过<code>new IntersectionObserverEntry</code>就是创建的实例对象。那<code>oldEntry</code>是什么呢？<code>oldEntry</code>就是上一次调用<code>this._checkForIntersections</code>方法的时候所创建的<code>entry</code>对象。这里为什么取新老两次<code>entry</code>对象，后面我们会分析。这里我们先看一下<code>IntersectionObserverEntry</code>构造函数的执行流程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">IntersectionObserverEntry</span>(<span class="params">entry</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">time</span> = entry.<span class="property">time</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">target</span> = entry.<span class="property">target</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">rootBounds</span> = entry.<span class="property">rootBounds</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">boundingClientRect</span> = entry.<span class="property">boundingClientRect</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">intersectionRect</span> = entry.<span class="property">intersectionRect</span> || <span class="title function_">getEmptyRect</span>();</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">isIntersecting</span> = !!entry.<span class="property">intersectionRect</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Calculates the intersection ratio.</span></span><br><span class="line">  <span class="keyword">var</span> targetRect = <span class="variable language_">this</span>.<span class="property">boundingClientRect</span>;</span><br><span class="line">  <span class="keyword">var</span> targetArea = targetRect.<span class="property">width</span> * targetRect.<span class="property">height</span>;</span><br><span class="line">  <span class="keyword">var</span> intersectionRect = <span class="variable language_">this</span>.<span class="property">intersectionRect</span>;</span><br><span class="line">  <span class="keyword">var</span> intersectionArea = intersectionRect.<span class="property">width</span> * intersectionRect.<span class="property">height</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sets intersection ratio.</span></span><br><span class="line">  <span class="keyword">if</span> (targetArea) &#123;</span><br><span class="line">    <span class="comment">// Round the intersection ratio to avoid floating point math issues:</span></span><br><span class="line">    <span class="comment">// https://github.com/w3c/IntersectionObserver/issues/324</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">intersectionRatio</span> = <span class="title class_">Number</span>((intersectionArea / targetArea).<span class="title function_">toFixed</span>(<span class="number">4</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// If area is zero and is intersecting, sets to 1, otherwise to 0</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">intersectionRatio</span> = <span class="variable language_">this</span>.<span class="property">isIntersecting</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>IntersectionObserverEntry</code>函数的执行流程十分简单，就是计算出其各个属性的值。其它的属性我们就不多说了，这里我们主要看以下三个属性值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">intersectionRect</span> = entry.<span class="property">intersectionRect</span> || <span class="title function_">getEmptyRect</span>();</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">isIntersecting</span> = !!entry.<span class="property">intersectionRect</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (targetArea) &#123;</span><br><span class="line">    <span class="comment">// Round the intersection ratio to avoid floating point math issues:</span></span><br><span class="line">    <span class="comment">// https://github.com/w3c/IntersectionObserver/issues/324</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">intersectionRatio</span> = <span class="title class_">Number</span>((intersectionArea / targetArea).<span class="title function_">toFixed</span>(<span class="number">4</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// If area is zero and is intersecting, sets to 1, otherwise to 0</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">intersectionRatio</span> = <span class="variable language_">this</span>.<span class="property">isIntersecting</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>其中<code>this.intersectionRect</code>就是上面通过<code>this._computeTargetAndRootIntersection</code>方法计算出来的。<code>this.isIntersecting</code>的判定也十分简单，如果存在相交面积，就表示相交。不存在相交面积，就表示不想交。最后是相交比<code>this.intersectionRatio</code>的计算，正常情况下(target的width和height都不为0)就是<code>intersectionArea</code>和<code>target</code>区域面积的比值。</p><p>然后就会判断<code>oldEntry</code>是否存在，<code>oldEntry</code>在什么状态下不会存在？在初始调用，也就是调用<code>observer.observe</code>方法监测<code>target</code>元素的时候<code>item.entry</code>是不存在的。然后就会将<code>newEntry</code>添加到<code>this._queuedEntries</code>队列中，当执行到</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_queuedEntries</span>.<span class="property">length</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">_callback</span>(<span class="variable language_">this</span>.<span class="title function_">takeRecords</span>(), <span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>的时候，就会调用我们传入的回调函数。</p><p>如果不是在初始状态下，在<code>rootIsInDom &amp;&amp; rootContainsTarget</code>为真的时候，会调用<code>this._hasCrossedThreshold</code>方法，那这个方法是干啥的？我们在介绍<code>IntersectionObserver</code>的时候曾经提到在创建<code>IntersectionObserver</code>实例的时候，我们传入一个选项，可以通过这个选项的<code>threshold</code>属性指定相交比达到什么样的条件才需要触发我们的回调函数。<code>this._hasCrossedThreshold</code>就是用来判断这种情况的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">IntersectionObserver</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_hasCrossedThreshold</span> =</span><br><span class="line">    <span class="keyword">function</span>(<span class="params">oldEntry, newEntry</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// To make comparing easier, an entry that has a ratio of 0</span></span><br><span class="line">  <span class="comment">// but does not actually intersect is given a value of -1</span></span><br><span class="line">  <span class="keyword">var</span> oldRatio = oldEntry &amp;&amp; oldEntry.<span class="property">isIntersecting</span> ?</span><br><span class="line">      oldEntry.<span class="property">intersectionRatio</span> || <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> newRatio = newEntry.<span class="property">isIntersecting</span> ?</span><br><span class="line">      newEntry.<span class="property">intersectionRatio</span> || <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ignore unchanged ratios</span></span><br><span class="line">  <span class="keyword">if</span> (oldRatio === newRatio) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">thresholds</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> threshold = <span class="variable language_">this</span>.<span class="property">thresholds</span>[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return true if an entry matches a threshold or if the new ratio</span></span><br><span class="line">    <span class="comment">// and the old ratio are on the opposite sides of a threshold.</span></span><br><span class="line">    <span class="keyword">if</span> (threshold == oldRatio || threshold == newRatio ||</span><br><span class="line">        threshold &lt; oldRatio !== threshold &lt; newRatio) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>_hasCrossedThreshold</code>代码中我们可以看到。如果<code>target</code>完全没有显示<code>oldRatio === newRatio === -1</code>，直接<code>return</code>。这种情况下是不会执行我们的回调函数的。如果<code>target</code>完全显示<code>oldRatio === newRatio === newEntry.intersectionRatio</code>，这种情况下也不会执行我们的回调函数。那什么时候才会执行我们的回调函数呢，从这段代码的<code>for</code>循环中我们可以总结出<strong>只有当threshold设置的值在oldRatio和newRatio之间的时候才会执行我们的回调</strong>。这里大家可以画图分析一下。</p><p>上面就是关于怎么监测<code>target</code>和执行回调函数时机的分析，下面我们看一下<code>unobserve</code>的过程</p><h3 id="unobserve"><a href="#unobserve" class="headerlink" title="unobserve"></a>unobserve</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">IntersectionObserver</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">unobserve</span> = <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_observationTargets</span> =</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_observationTargets</span>.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> item.<span class="property">element</span> != target;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_observationTargets</span>.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">_unmonitorIntersections</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">_unregisterInstance</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>unobserve</code>的执行流程十分简单，首先是从<code>this._observationTargets</code>将<code>target</code>删除。如果<code>this._observationTargets</code>队列长度为0，表示当前的<code>observer</code>没有监听任何<code>target</code>，那么就可以将当前<code>observer</code>从全局的<code>registry</code>数组中删除。如果<code>registry</code>也为空，那么就可以卸载相关事件。这个过程主要是通过<code>this._unmonitorIntersections</code>和<code>this._unregisterInstance</code>方法来实现的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">IntersectionObserver</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_unmonitorIntersections</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_monitoringIntersections</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_monitoringIntersections</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">_monitoringInterval</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_monitoringInterval</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">removeEvent</span>(<span class="variable language_">window</span>, <span class="string">&#x27;resize&#x27;</span>, <span class="variable language_">this</span>.<span class="property">_checkForIntersections</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="title function_">removeEvent</span>(<span class="variable language_">document</span>, <span class="string">&#x27;scroll&#x27;</span>, <span class="variable language_">this</span>.<span class="property">_checkForIntersections</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_domObserver</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_domObserver</span>.<span class="title function_">disconnect</span>();</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_domObserver</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">IntersectionObserver</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_unregisterInstance</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> index = registry.<span class="title function_">indexOf</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="keyword">if</span> (index != -<span class="number">1</span>) registry.<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="disconnect"><a href="#disconnect" class="headerlink" title="disconnect"></a>disconnect</h3><p><code>disconnect</code>可以一次性取消<code>observer</code>对所有<code>target</code>的监测，这个方法的实现同样很简单</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">IntersectionObserver</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">disconnect</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_observationTargets</span> = [];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">_unmonitorIntersections</span>();</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">_unregisterInstance</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是对<code>IntersectionObserver polyfill</code>源码的大致分析。如有错误，欢迎指正。</p><h3 id="使用IntersectionObserver实现一个简单的无限滚动"><a href="#使用IntersectionObserver实现一个简单的无限滚动" class="headerlink" title="使用IntersectionObserver实现一个简单的无限滚动"></a>使用IntersectionObserver实现一个简单的无限滚动</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.img-area</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">320px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.my-photo</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">opacity</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">      -webkit-<span class="attribute">transition</span>: opacity <span class="number">0.25s</span> ease-in-out;</span></span><br><span class="line"><span class="language-css">      -moz-<span class="attribute">transition</span>: opacity <span class="number">0.25s</span> ease-in-out;</span></span><br><span class="line"><span class="language-css">      -o-<span class="attribute">transition</span>: opacity <span class="number">0.25s</span> ease-in-out;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">transition</span>: opacity <span class="number">0.25s</span> ease-in-out;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">class</span>=<span class="string">&quot;body&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img-area&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;my-photo&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;loading&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./img/1.png&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img-area&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;my-photo&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;loading&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./img/1.png&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img-area&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;my-photo&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;loading&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./img/1.png&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img-area&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;my-photo&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;loading&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./img/1.png&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img-area&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;my-photo&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;loading&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./img/1.png&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img-area&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;my-photo&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;loading&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./img/1.png&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img-area&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;my-photo&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;loading&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./img/1.png&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img-area&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;my-photo&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;loading&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./img/1.png&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img-area&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;my-photo&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;loading&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./img/1.png&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img-area&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;my-photo&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;loading&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./img/1.png&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="comment">&lt;!-- 页尾标志，判断是否需要新添加节点到文档流中 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">loadItems</span>(<span class="params">io, count = <span class="number">10</span></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> container = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.container&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> fragment = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>();</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> li = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        li.<span class="property">className</span> = <span class="string">&#x27;img-area&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        img.<span class="property">className</span> = <span class="string">&#x27;my-photo&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        img.<span class="property">alt</span> = <span class="string">&#x27;loading&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        img.<span class="property">dataset</span>.<span class="property">src</span> = <span class="string">&#x27;./img/1.png&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        li.<span class="title function_">appendChild</span>(img);</span></span><br><span class="line"><span class="language-javascript">        fragment.<span class="title function_">appendChild</span>(li);</span></span><br><span class="line"><span class="language-javascript">        io.<span class="title function_">observe</span>(img)</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">      container.<span class="title function_">appendChild</span>(fragment)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">lazyLoad</span>(<span class="params">imgClassName</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> imgList = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(imgClassName));</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> opts = &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">root</span>: <span class="variable language_">document</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">rootMargin</span>: <span class="string">&quot;500px 0px&quot;</span></span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> io = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(<span class="keyword">function</span> (<span class="params">ioes</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        ioes.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">ioe</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">const</span> el = ioe.<span class="property">target</span>;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">const</span> cn = el.<span class="property">className</span>;</span></span><br><span class="line"><span class="language-javascript">          <span class="comment">// const intersectionRatio = ioe.intersectionRatio;</span></span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">if</span> (cn === <span class="string">&#x27;footer&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (!ioe.<span class="property">isIntersecting</span>) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">loadItems</span>(io);</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;loaded new items&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ioe.<span class="property">isIntersecting</span>) &#123; <span class="comment">//对于图片节点，当其进入范围内，则load其src</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (!el.<span class="property">src</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">              el.<span class="property">src</span> = el.<span class="property">dataset</span>.<span class="property">src</span>;</span></span><br><span class="line"><span class="language-javascript">              el.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                el.<span class="property">style</span>.<span class="property">opacity</span> = <span class="number">1</span></span></span><br><span class="line"><span class="language-javascript">              &#125;</span></span><br><span class="line"><span class="language-javascript">              io.<span class="title function_">unobserve</span>(el); <span class="comment">//加载图片后停止观察该节点</span></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">      &#125;, opts);</span></span><br><span class="line"><span class="language-javascript">      imgList.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        io.<span class="title function_">observe</span>(item)</span></span><br><span class="line"><span class="language-javascript">      &#125;);</span></span><br><span class="line"><span class="language-javascript">      io.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.footer&quot;</span>)) <span class="comment">//观察footer节点，判断添加新节点的时机</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">lazyLoad</span>(<span class="string">&#x27;.my-photo&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>效果图：<br><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/Jietu20201014-172126.gif" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/Jietu20201014-172126.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Jietu20201014-172126"></p><!-- 转发自[赵赛赛个人博客](https://zhaosaisai.com/blog/2019/IntersectionObserver-polyfill%E8%A7%A3%E6%9E%90.html) --></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;在介绍&lt;code&gt;IntersectionObserver&lt;/code&gt;的时候曾提到过这个接口目前使用的最大问题就是浏览器的兼容性问题。所以，我们平时在使用的时候切记不要忘记判断这个API在我们的宿主环境中是否存在。如果不存在，我们可以通过引入其&lt;code&gt;polyfill&lt;/code&gt;来作部分功能的兼容。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IntersectionObserver-polyfill&lt;/code&gt;是&lt;code&gt;w3c&lt;/code&gt;官方创建的&lt;a href=&quot;https://github.com/w3c/IntersectionObserver&quot; target=&quot;_blank&quot; rel=&quot;noopener external nofollow noreferrer&quot;&gt;https://github.com/w3c/IntersectionObserver&lt;/a&gt;。我们可以在浏览器不支持&lt;code&gt;IntersectionObserver&lt;/code&gt;的情况下引入它。当然，你也可以直接引入它，其内部也只会在浏览器不支持其的情况下进行&lt;code&gt;polyfill&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="浏览器" scheme="https://kobingogo.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
    <category term="IntersectionObserver" scheme="https://kobingogo.github.io/tags/intersectionobserver/"/>
    
  </entry>
  
  <entry>
    <title>npm依赖管理中容易被忽略细节</title>
    <link href="https://kobingogo.github.io/node-2020-09-15-npm%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E4%B8%AD%E5%AE%B9%E6%98%93%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%BB%86%E8%8A%82/"/>
    <id>https://kobingogo.github.io/node-2020-09-15-npm%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E4%B8%AD%E5%AE%B9%E6%98%93%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%BB%86%E8%8A%82/</id>
    <published>2020-09-15T23:38:27.000Z</published>
    <updated>2024-08-08T10:31:05.017Z</updated>
    
    <content type="html"><![CDATA[<p>提起 npm，大家第一个想到的应该就是 npm install 了，但是 npm install 之后生成的 node_modules 大家有观察过吗？package-lock.json 文件的作用大家知道吗？除了 dependencies 和 devDependencies，其他的依赖有什么作用呢？接下来，本文将针对 npm 中的你可能忽略的细节和大家分享一些经验 。</p><span id="more"></span><h3 id="npm-安装机制"><a href="#npm-安装机制" class="headerlink" title="npm 安装机制"></a>npm 安装机制</h3><p>A 和 B 同时依赖 C，C 这个包会被安装在哪里呢？C 的版本相同和版本不同时安装会有什么差异呢？package.json 中包的前后顺序对于安装时有什么影响吗？这些问题平时大家可能没有注意过，今天我们就来一起研究一下吧。</p><h3 id="A-和-B-同时依赖-C，这个包会被安装在哪里呢？"><a href="#A-和-B-同时依赖-C，这个包会被安装在哪里呢？" class="headerlink" title="A 和 B 同时依赖 C，这个包会被安装在哪里呢？"></a>A 和 B 同时依赖 C，这个包会被安装在哪里呢？</h3><p>假如有 A 和 B 两个包，两个包都依赖 C 这个包，npm 2 会依次递归安装 A 和 B 两个包及其子依赖包到 node_modules 中。执行完毕后，我们会看到 <code>./node_modules </code>这层目录只含有这两个子目录：</p><p>node_modules/<br>├─┬ A<br>│ ├── C<br>├─┬ B<br>│ └── C</p><p>如果使用 npm 3 来进行安装的话，<code>./node_modules</code> 下的目录将会包含三个子目录：</p><p>node_modules/<br>├─┬ A<br>├─┬ B<br>├─┬ C</p><p>为什么会出现这样的区别呢？这就要从 npm 的工作方式说起了：</p><h3 id="npm-2-和-npm-3-模块安装机制的差异"><a href="#npm-2-和-npm-3-模块安装机制的差异" class="headerlink" title="npm 2 和 npm 3 模块安装机制的差异"></a>npm 2 和 npm 3 模块安装机制的差异</h3><p>虽然目前最新的 npm 版本是 npm 6，但 npm 2 到 npm 3 的版本变更中实现了目录打平，与其他版本相比差别较大。因此，让我们具体看下这两个版本的差异​。</p><p>npm 2 在安装依赖包时，采用简单的递归安装方法。执行 npm install 后，npm 根据 dependencies 和 devDependencies 属性中指定的包来确定第一层依赖，npm 2 会根据第一层依赖的子依赖，递归安装各个包到子依赖的 node_modules 中，直到子依赖不再依赖其他模块。执行完毕后，我们会看到 ./node_modules 这层目录中包含有我们 package.json 文件中所有的依赖包，而这些依赖包的子依赖包都安装在了自己的 node_modules 中 ，形成类似于下面的依赖树：<br><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200915234216.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200915234216.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20200915234216"></p><p>这样的目录有较为明显的好处：</p><ol><li>层级结构非常明显，可以清楚的在第一层的 node_modules 中看到我们安装的所有包的子目录；</li><li>在已知自己所需包的名字以及版本号时，可以复制粘贴相应的文件到 node_modules 中，然后手动更改 package.json 中的配置；</li><li>如果想要删除某个包，只需要简单的删除 package.json 文件中相应的某一行，然后删除 node_modules 中该包的目录；</li></ol><p>但是这样的层级结构也有较为明显的缺陷，当我的 A，B，C 三个包中有相同的依赖 D 时，执行 <code>npm install</code> 后，D 会被重复下载三次，而随着我们的项目越来越复杂，node_modules 中的依赖树也会越来越复杂，像 D 这样的包也会越来越多，造成了大量的冗余；在 windows 系统中，甚至会因为目录的层级太深导致文件的路径过长，触发文件路径不能超过 280 个字符的错误；</p><p>​ 为了解决以上问题，npm 3 的 node_modules 目录改成了更为扁平状的层级结构，尽量把依赖以及依赖的依赖平铺在 node_modules 文件夹下共享使用。</p><h3 id="npm-3-对于同一依赖的不同版本会怎么处理呢？"><a href="#npm-3-对于同一依赖的不同版本会怎么处理呢？" class="headerlink" title="npm 3 对于同一依赖的不同版本会怎么处理呢？"></a>npm 3 对于同一依赖的不同版本会怎么处理呢？</h3><p>npm 3 会遍历所有的节点，逐个将模块放在 node_modules 的第一层，当发现有重复模块时，则丢弃， 如果遇到某些依赖版本不兼容的问题，则继续采用 npm 2 的处理方式，前面的放在 node_modules 目录中，后面的放在依赖树中。举个例子： A，B，依赖 D(v 0.0.1)，C 依赖 D(v 0.0.2):</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200915234325.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200915234325.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20200915234325"></p><p>但是 npm 3 会带来一个新的问题：由于在执行 <code>npm install</code> 的时候，按照 <code>package.json </code>里依赖的顺序依次解析，上图如果 C 的顺序在 A，B 的前边，node_modules 树则会改变，会出现下边的情况：</p><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200915234354.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200915234354.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20200915234354"></p><p>由此可见，npm 3 并未完全解决冗余的问题，甚至还会带来新的问题。</p><h3 id="为什么会出现-package-lock-json-呢？"><a href="#为什么会出现-package-lock-json-呢？" class="headerlink" title="为什么会出现 package-lock.json 呢？"></a>为什么会出现 package-lock.json 呢？</h3><p>为什么会有 package-lock.json 文件呢？这个我们就要先从 package.json 文件说起了。</p><h3 id="package-json-的不足之处"><a href="#package-json-的不足之处" class="headerlink" title="package.json 的不足之处"></a>package.json 的不足之处</h3><p>npm install 执行后，会生成一个 node_modules 树，在理想情况下， 希望对于同一个 package.json 总是生成完全相同 node_modules 树。在某些情况下，确实如此。但在多数情况下，npm 无法做到这一点。有以下两个原因：</p><p>1）某些依赖项自上次安装以来，可能已发布了新版本 。比如：A 包在团队中第一个人安装的时候是 1.0.5 版本，package.json 中的配置项为 A: &#39;^1.0.5&#39; ；团队中第二个人把代码拉下来的时候，A 包的版本已经升级成了 1.0.8，根据 package.json 中的 semver-range version 规范，此时第二个人 npm install 后 A 的版本为 1.0.8； 可能会造成因为依赖版本不同而导致的 bug；</p><p>2）针对 1）中的问题，可能有的小伙伴会想，把 A 的版本号固定为 A: &#39;1.0.5&#39; 不就可以了吗？但是这样的做法其实并没有解决问题， 比如 A 的某个依赖在第一个人下载的时候是 2.1.3 版本，但是第二个人下载的时候已经升级到了 2.2.5 版本，此时生成的 node_modules 树依旧不完全相同 ，固定版本只是固定来自身的版本，依赖的版本无法固定。</p><h3 id="针对-package-json-不足的解决方法"><a href="#针对-package-json-不足的解决方法" class="headerlink" title="针对 package.json 不足的解决方法"></a>针对 package.json 不足的解决方法</h3><p>为了解决上述问题以及 npm 3 的问题，在 npm 5.0 版本后，npm install 后都会自动生成一个 package-lock.json 文件 ，当包中有 package-lock.json 文件时，npm install 执行时，如果 package.json 和 package-lock.json 中的版本兼容，会根据 package-lock.json 中的版本下载；如果不兼容，将会根据 package.json 的版本，更新 package-lock.json 中的版本，已保证 package-lock.json 中的版本兼容 package.json。</p><h3 id="package-lock-json-文件的结构"><a href="#package-lock-json-文件的结构" class="headerlink" title="package-lock.json 文件的结构"></a>package-lock.json 文件的结构</h3><p>package-lock.json 文件中的 name、version 与 package.json 中的 name、version 一样，描述了当前包的名字和版本，dependencies 是一个对象，该对象和 node_modules 中的包结构一一对应，对象的 key 为包的名称，值为包的一些描述信息， 根据 <a href="https://docs.npmjs.com/configuring-npm/package-lock-json.html#requires" target="_blank" rel="noopener external nofollow noreferrer">package-lock-json</a>官方文档，主要的结构如下：</p><ul><li>version ：包版本，即这个包当前安装在 node_modules 中的版本</li><li>resolved ：包具体的安装来源</li><li>integrity ：包 hash 值，验证已安装的软件包是否被改动过、是否已失效</li><li>requires ：对应子依赖的依赖，与子依赖的 package.json 中 dependencies 的依赖项相同</li><li>dependencies ：结构和外层的 dependencies 结构相同，存储安装在子依赖 node_modules 中的依赖包</li></ul><p>需要注意的是，并不是所有的子依赖都有 <code>dependencies</code> 属性，只有子依赖的依赖和当前已安装在根目录的 <code>node_modules</code> 中的依赖冲突之后，才会有这个属性。</p><h3 id="package-lock-json-文件的作用"><a href="#package-lock-json-文件的作用" class="headerlink" title="package-lock.json 文件的作用"></a>package-lock.json 文件的作用</h3><ul><li>在团队开发中，确保每个团队成员安装的依赖版本是一致的，确定一棵唯一的 node_modules 树；</li><li>node_modules 目录本身是不会被提交到代码库的，但是 package-lock.json 可以提交到代码库，如果开发人员想要回溯到某一天的目录状态，只需要把 package.json 和 package-lock.json 这两个文件回退到那一天即可 。</li><li>由于 package-lock.json 和 node_modules 中的依赖嵌套完全一致，可以更加清楚的了解树的结构及其变化。</li><li>在安装时，npm 会比较 node_modules 已有的包，和 package-lock.json 进行比较，如果重复的话，就跳过安装 ，从而优化了安装的过程。</li></ul><h3 id="依赖的区别与使用场景"><a href="#依赖的区别与使用场景" class="headerlink" title="依赖的区别与使用场景"></a>依赖的区别与使用场景</h3><p>npm 目前支持以下几类依赖包管理包括</p><ul><li>dependencies</li><li>devDependencies</li><li>optionalDependencies 可选择的依赖包</li><li>peerDependencies 同等依赖</li><li>bundledDependencies 捆绑依赖包</li></ul><p>下面我们来看一下这几种依赖的区别以及各自的应用场景：</p><h4 id="dependencies"><a href="#dependencies" class="headerlink" title="dependencies"></a>dependencies</h4><p>dependencies 是无论在开发环境还是在生产环境都必须使用的依赖，是我们最常用的依赖包管理对象，例如 React，Loadsh，Axios 等，通过 npm install XXX 下载的包都会默认安装在 dependencies 对象中，也可以使用 npm install XXX --save 下载 dependencies 中的包；</p><h4 id="devDependencies"><a href="#devDependencies" class="headerlink" title="devDependencies"></a>devDependencies</h4><p>devDependencies 是指可以在开发环境使用的依赖，例如 eslint，debug 等，通过 npm install packageName --save-dev 下载的包都会在 devDependencies 对象中；</p><p>dependencies 和 devDependencies 最大的区别是在打包运行时，执行 npm install 时默认会把所有依赖全部安装，但是如果使用 <code>npm install --production</code> 时就只会安装 dependencies 中的依赖，如果是 node 服务项目，就可以采用这样的方式用于服务运行时安装和打包，减少包大小。</p><h4 id="optionalDependencies"><a href="#optionalDependencies" class="headerlink" title="optionalDependencies"></a>optionalDependencies</h4><p>optionalDependencies 指的是可以选择的依赖，当你希望某些依赖即使下载失败或者没有找到时，项目依然可以正常运行或者 npm 继续运行的时，就可以把这些依赖放在 optionalDependencies 对象中，但是 optionalDependencies 会覆盖 dependencies 中的同名依赖包，所以不要把一个包同时写进两个对象中。</p><p>optionalDependencies 就像是我们的代码的一种保护机制一样，如果包存在的话就走存在的逻辑，不存在的就走不存在的逻辑。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> axios = <span class="built_in">require</span>(<span class="string">&#x27;axios&#x27;</span>)</span><br><span class="line">  <span class="keyword">var</span> fooVersion = <span class="built_in">require</span>(<span class="string">&#x27;axios/package.json&#x27;</span>).<span class="property">version</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (er) &#123;</span><br><span class="line">  foo = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// .. then later in your program ..</span></span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">  foo.<span class="title function_">doFooThings</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="peerDependencies"><a href="#peerDependencies" class="headerlink" title="peerDependencies"></a>peerDependencies</h4><p>peerDependencies 用于指定你当前的插件兼容的宿主必须要安装的包的版本，这个是什么意思呢？举个例子🌰：我们常用的 react 组件库 <a href="mailto:&#97;&#110;&#116;&#x2d;&#x64;&#101;&#115;&#105;&#103;&#110;&#64;&#51;&#46;&#120;">&#97;&#110;&#116;&#x2d;&#x64;&#101;&#115;&#105;&#103;&#110;&#64;&#51;&#46;&#120;</a> 的 package.json 中的配置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;peerDependencies&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;react&quot;</span>: <span class="string">&quot;&gt;=16.9.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;react-dom&quot;</span>: <span class="string">&quot;&gt;=16.9.0&quot;</span></span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p> 假设我们创建了一个名为 project 的项目，在此项目中我们要使用 <a href="mailto:&#97;&#x6e;&#116;&#x2d;&#x64;&#x65;&#115;&#105;&#103;&#110;&#x40;&#51;&#46;&#120;">&#97;&#x6e;&#116;&#x2d;&#x64;&#x65;&#115;&#105;&#103;&#110;&#x40;&#51;&#46;&#120;</a> 这个插件，此时我们的项目就必须先安装 React &gt;= 16.9.0 和 React-dom &gt;= 16.9.0 的版本。​</p><p>在 npm 2 中，当我们下载 <a href="mailto:&#97;&#110;&#x74;&#x2d;&#100;&#101;&#x73;&#x69;&#x67;&#110;&#x40;&#51;&#46;&#x78;">&#97;&#110;&#x74;&#x2d;&#100;&#101;&#x73;&#x69;&#x67;&#110;&#x40;&#51;&#46;&#x78;</a> 时，peerDependencies 中指定的依赖会随着 <a href="mailto:&#x61;&#110;&#x74;&#x2d;&#100;&#101;&#x73;&#x69;&#x67;&#x6e;&#x40;&#51;&#x2e;&#x78;">&#x61;&#110;&#x74;&#x2d;&#100;&#101;&#x73;&#x69;&#x67;&#x6e;&#x40;&#51;&#x2e;&#x78;</a> 一起被强制安装，所以我们不需要在宿主项目的 package.json 文件中指定 peerDependencies 中的依赖，但是在 npm 3 中，不会再强制安装 peerDependencies 中所指定的包，而是通过警告的方式来提示我们，此时就需要手动在 package.json 文件中手动添加依赖；</p><h4 id="bundledDependencies"><a href="#bundledDependencies" class="headerlink" title="bundledDependencies"></a>bundledDependencies</h4><p>这个依赖项也可以记为 bundleDependencies，与其他几种依赖项不同，他不是一个键值对的对象，而是一个数组，数组里是包名的字符串，例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;project&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;bundleDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;axios&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;lodash&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>当使用 npm pack 的方式来打包时，上述的例子会生成一个 project-1.0.0.tgz 的文件，在使用了 bundledDependencies 后，打包时会把 Axios 和 Lodash 这两个依赖一起放入包中，之后有人使用 npm install project-1.0.0.tgz 下载包时，Axios 和 Lodash 这两个依赖也会被安装。需要注意的是安装之后 Axios 和 Lodash 这两个包的信息在 dependencies 中，并且不包括版本信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;bundleDependencies&quot;</span>: [</span><br><span class="line">  <span class="string">&quot;axios&quot;</span>,</span><br><span class="line">  <span class="string">&quot;lodash&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;axios&quot;</span>: <span class="string">&quot;*&quot;</span>,</span><br><span class="line">  <span class="string">&quot;lodash&quot;</span>: <span class="string">&quot;*&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们使用常规的 npm publish 来发布的话，这个属性是不会生效的，所以日常情况中使用的较少。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文介绍的是 npm 2，npm 3，package-lock.json 以及几种依赖的区别和使用场景，希望能够让大家对 npm 的了解更加多一点，有什么不清楚的地方或者不足之处欢迎大家在评论区留言。</p><p>原文转载自：<a href="https://www.zoo.team/article/npm-details" target="_blank" rel="noopener external nofollow noreferrer">https://www.zoo.team/article/npm-details</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;提起 npm，大家第一个想到的应该就是 npm install 了，但是 npm install 之后生成的 node_modules 大家有观察过吗？package-lock.json 文件的作用大家知道吗？除了 dependencies 和 devDependencies，其他的依赖有什么作用呢？接下来，本文将针对 npm 中的你可能忽略的细节和大家分享一些经验 。&lt;/p&gt;</summary>
    
    
    
    <category term="npm" scheme="https://kobingogo.github.io/categories/npm/"/>
    
    
    <category term="npm" scheme="https://kobingogo.github.io/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>在 React 中实现 keep alive</title>
    <link href="https://kobingogo.github.io/framework-react-keep-alive/"/>
    <id>https://kobingogo.github.io/framework-react-keep-alive/</id>
    <published>2020-09-15T23:25:43.000Z</published>
    <updated>2024-08-08T10:31:05.013Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍一种在react中实现Vue的keep alive功能的方案。</p><span id="more"></span><h3 id="什么是-keep-alive"><a href="#什么是-keep-alive" class="headerlink" title="什么是 keep alive"></a>什么是 keep alive</h3><p>在 Vue 中，我们可以使用 keep-alive 包裹一个动态组件，从而缓存不活跃的实例，而不是直接销毁他们：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这对于某些路由切换等场景非常好用，例如，如果我们需要实现一个列表页和详情页，但在用户从详情页返回列表的时候，我们不希望重新请求接口获取，也不希望重置列表的过滤、排序等条件，那这时就可以对列表页的组件用 keep-alive 包裹一下，这样，当路由切换时，Vue 会将这个组件“失活”并缓存起来，而不是直接卸载掉。</p><h3 id="最简单的方案"><a href="#最简单的方案" class="headerlink" title="最简单的方案"></a>最简单的方案</h3><p>而在 React 中，其实一直以来都没有官方的 keep alive 解决方案，大部分开发者可能都会直接使用 display: none 来将 DOM 隐藏：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&#123;shouldHide ? &#123;<span class="attr">display</span>: <span class="string">&#x27;none&#x27;</span>&#125; : &#123;&#125;&#125;&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Foo</span>/&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>但这种方案其实只是在“视觉上”将元素隐藏起来了，并没有真正的移除，那有没有可能把 DOM 树真的移除掉，同时又让组件不被销毁呢？</p><h3 id="Portal实现"><a href="#Portal实现" class="headerlink" title="Portal实现"></a>Portal实现</h3><blockquote><p>Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。</p></blockquote><p>这是 React <a href="https://zh-hans.reactjs.org/docs/portals.html" target="_blank" rel="noopener external nofollow noreferrer">官方文档</a>上对 Portal 特性的介绍，值得注意的是，这里只是说“父组件以外的 DOM 节点”，但没有要求这个 DOM 节点是真的在页面上，还是只是存在于内存中。 因此，我们可以先通过 document.createElement 在内存中创建一个元素，然后再通过 React.createPoral 把 React 子节点渲染到这个元素上，这样就实现了“空渲染”。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetElement = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">createPortal</span>(child, targetElement)</span><br></pre></td></tr></table></figure><p>基于这种方案，我们可以进一步封装出一个 Conditional 组件，从而实现通用性的条件渲染逻辑：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">Conditional</span> = props =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [targetElement] = <span class="title function_">useState</span>(<span class="function">() =&gt;</span> <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>))</span><br><span class="line">  <span class="keyword">const</span> containerRef = <span class="title function_">useRef</span>()</span><br><span class="line">  <span class="title function_">useLayoutEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (props.<span class="property">active</span>) &#123;</span><br><span class="line">      containerRef.<span class="property">current</span>.<span class="title function_">appendChild</span>(targetElement)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        containerRef.<span class="property">current</span>.<span class="title function_">removeChild</span>(targetElement)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [props.<span class="property">active</span>])</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;containerRef&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;ReactDOM.createPortal(props.children, targetElement)&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们创建了一个 targetElement ，并且通过 createPortal 将 children 渲染到 targetElement 。 然后，我们会创建一个容器 div 元素，并且通过 containerRef 拿到它的引用。 最后，当 active 为 true 时，我们会把 targetElement 手动添加到 containerRef.current 的内部，反之，则会从其内部移除掉 targetElement 。 实际使用的方式如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Conditional</span> active=&#123;!shouldHide&#125;&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Foo</span>/&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Conditional</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>细心的读者可能会发现，目前我们的 Conditional 组件还有一点小小的瑕疵：当组件初次渲染时，不论当前的 active 是 true 还是 false ， Conditional 组件都会将 props.children 渲染。这对大型应用可能会带来非常明显的性能问题，所以，我们可以为其增加“懒加载”的特性：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">Conditional</span> = props =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [targetElement] = <span class="title function_">useState</span>(<span class="function">() =&gt;</span> <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>))</span><br><span class="line">  <span class="keyword">const</span> containerRef = <span class="title function_">useRef</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 增加一个 ref 记录组件是否“被激活过”</span></span><br><span class="line">  <span class="keyword">const</span> activatedRef = <span class="title function_">useRef</span>(<span class="literal">false</span>)</span><br><span class="line">  activatedRef.<span class="property">current</span> = activatedRef.<span class="property">current</span> || props.<span class="property">active</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">useLayoutEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (props.<span class="property">active</span>) &#123;</span><br><span class="line">      containerRef.<span class="property">current</span>.<span class="title function_">appendChild</span>(targetElement)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        containerRef.<span class="property">current</span>.<span class="title function_">removeChild</span>(targetElement)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [props.<span class="property">active</span>])</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;containerRef&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;activatedRef.current &amp;&amp; ( // 如果“被激活过”，才渲染 children</span></span><br><span class="line"><span class="language-xml">        ReactDOM.createPortal(props.children, targetElement)</span></span><br><span class="line"><span class="language-xml">      )&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一些遗憾"><a href="#一些遗憾" class="headerlink" title="一些遗憾"></a>一些遗憾</h3><p>不得不承认的是，基于 Portal 方案的 Conditional 组件并不能包治百病，和 Vue 的 keep-alive 相比，也存在不少缺憾：</p><ol><li>需要手动控制 active ，不能直接基于子组件销毁/创建的生命周期事件</li><li>缺少失活/激活的生命周期时间，子组件无法感知自己是不是被缓存起来了</li><li>依赖了 ReactDOM ，对 SSR 不够友好</li></ol><p>原文转载自知乎：<a href="https://zhuanlan.zhihu.com/p/214166951" target="_blank" rel="noopener external nofollow noreferrer">在 React 中实现 keep alive</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍一种在react中实现Vue的keep alive功能的方案。&lt;/p&gt;</summary>
    
    
    
    <category term="react" scheme="https://kobingogo.github.io/categories/react/"/>
    
    
    <category term="react" scheme="https://kobingogo.github.io/tags/react/"/>
    
    <category term="keep alice" scheme="https://kobingogo.github.io/tags/keep-alice/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法知识点汇总</title>
    <link href="https://kobingogo.github.io/algorithms-%E5%BC%80%E7%AF%87/"/>
    <id>https://kobingogo.github.io/algorithms-%E5%BC%80%E7%AF%87/</id>
    <published>2020-06-22T18:09:54.000Z</published>
    <updated>2024-08-08T10:31:05.013Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200622182516.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200622182516.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>]]></content>
    
    
    <summary type="html">数据结构与算法知识点汇总</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://kobingogo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://kobingogo.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解记录</title>
    <link href="https://kobingogo.github.io/algorithms-leetcode/"/>
    <id>https://kobingogo.github.io/algorithms-leetcode/</id>
    <published>2020-06-21T21:56:01.000Z</published>
    <updated>2024-08-08T10:31:05.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetCode题解记录"><a href="#leetCode题解记录" class="headerlink" title="leetCode题解记录"></a>leetCode题解记录</h1><ul><li><a href="#leetcode%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95">leetCode题解记录</a><ul><li><a href="#%E6%95%B0%E7%BB%84%E7%B1%BB">数组类</a><ul><li><a href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93">常用方法总结：</a></li><li><a href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C">两数之和</a></li><li><a href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C">15. 三数之和</a></li><li><a href="#16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C">16. 最接近的三数之和</a></li><li><a href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C">最大子序和</a></li><li><a href="#239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC">239. 滑动窗口最大值</a></li><li><a href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84">合并两个有序数组</a></li><li><a href="#14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80">14. 最长公共前缀</a></li></ul></li><li><a href="#%E9%93%BE%E8%A1%A8%E7%B1%BB">链表类</a><ul><li><a href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93-1">常用方法总结：</a></li><li><a href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8">合并两个有序链表</a></li><li><a href="#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8">141. 环形链表</a></li><li><a href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-ii">142. 环形链表 II</a></li><li><a href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">反转链表</a></li><li><a href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9">19. 删除链表的倒数第N个节点</a></li><li><a href="#876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9">876. 链表的中间结点</a></li></ul></li><li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B1%BB">动态规划类</a><ul><li><a href="#309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F">309. 最佳买卖股票时机含冷冻期</a></li><li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%98-1713-%E6%81%A2%E5%A4%8D%E7%A9%BA%E6%A0%BC">面试题 17.13. 恢复空格</a></li><li><a href="#96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">96. 不同的二叉搜索树</a></li></ul></li></ul></li></ul><h2 id="数组类"><a href="#数组类" class="headerlink" title="数组类"></a>数组类</h2><div class="story post-story"><h3 id="常用方法总结："><a href="#常用方法总结：" class="headerlink" title="常用方法总结："></a>常用方法总结：</h3><ul><li>结合Object(Map/set)等数据结构来解题；</li><li>滑动窗口方法（最小（大）子集等问题适用）</li><li>Trie 树</li></ul><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener external nofollow noreferrer">两数之和</a></h3><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p>示例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span></span><br><span class="line">所以返回 [<span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>方法一：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> twoSum = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, length = nums.<span class="property">length</span>; i &lt; length; i++)&#123;</span><br><span class="line">        <span class="keyword">const</span> left = target - nums[i];</span><br><span class="line">        <span class="keyword">const</span> leftIndex = nums.<span class="title function_">lastIndexOf</span>(left);</span><br><span class="line">        <span class="keyword">if</span>(leftIndex &gt; i)&#123;</span><br><span class="line">            result = [i ,leftIndex];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n<sup>2</sup>)</li><li>空间复杂度：o(1)</li></ul><p>方法二：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> k = target-nums[i]</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="title function_">has</span>(k)) &#123;</span><br><span class="line">            <span class="keyword">return</span> [map.<span class="title function_">get</span>(k), i]</span><br><span class="line">        &#125;</span><br><span class="line">        map.<span class="title function_">set</span>(nums[i], i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：o(n)</li></ul><h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum" target="_blank" rel="noopener external nofollow noreferrer">15. 三数之和</a></h3><p><strong>解题思路：</strong></p><ol><li>首先对数组从大到小进行排序；</li><li>遍历数组，设置左右俩指针初始位置在数组左右边界（first = i + 1,last = length -1）;</li><li>如果i, first, last 三个数值大于0，则last左移，如果小于0，则first右移；</li><li>使得最终三数之和等于0，则成功找出一组。重复步骤2。</li></ol><p><strong>实现代码:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> threeSum = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> length = nums.<span class="property">length</span>;</span><br><span class="line">  nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); <span class="comment">// 先排个队，最左边是最弱（小）的，最右边是最强(大)的</span></span><br><span class="line">  <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt; <span class="number">0</span> || nums[length - <span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length - <span class="number">2</span>; i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">let</span> first = i + <span class="number">1</span>, last = length - <span class="number">1</span>, sum;</span><br><span class="line">    <span class="keyword">while</span> (first &lt; last) &#123;</span><br><span class="line">      sum = nums[i] + nums[first] + nums[last];</span><br><span class="line">      <span class="keyword">if</span> (sum === <span class="number">0</span>) &#123;</span><br><span class="line">        res.<span class="title function_">push</span>([nums[i], nums[first], nums[last]]);</span><br><span class="line">        <span class="keyword">while</span> (first &lt; last &amp;&amp; nums[first] === nums[++first]) &#123; &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (first &lt; last &amp;&amp; nums[first] === nums[++first]) &#123; &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (first &lt; last &amp;&amp; nums[last] === nums[--last]) &#123; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (nums[i] === nums[++i]) &#123; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度： O(n<sup>2</sup>)</li></ul><h3 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a><a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener external nofollow noreferrer">16. 最接近的三数之和</a></h3><p><strong>解题思路</strong></p><p>思路同上一题类似，不同点在于此题是求最接近给定值的解。</p><p><strong>实现代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> threeSumClosest = <span class="keyword">function</span> (<span class="params">nums, target</span>) &#123;</span><br><span class="line">  nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">let</span> length = nums.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">let</span> result = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[length - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> first = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> last = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> sum;</span><br><span class="line">    <span class="keyword">while</span> (first &lt; last) &#123;</span><br><span class="line">      sum = nums[i] + nums[first] + nums[last];</span><br><span class="line">      sum &gt; target ? last-- : first++;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">abs</span>(target - result) &gt; <span class="title class_">Math</span>.<span class="title function_">abs</span>(target - sum)) &#123;</span><br><span class="line">        result = sum;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度： O(n<sup>2</sup>)</li></ul><h3 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h3><p>算法：</p><p>在整个数组或在固定大小的滑动窗口中找到总和或最大值或最小值的问题可以通过动态规划（DP）在线性时间内解决。<br>有两种标准 DP 方法适用于数组：</p><ol><li>常数空间，沿数组移动并在原数组修改。</li><li>线性空间，首先沿 left-&gt;right 方向移动，然后再沿 right-&gt;left 方向移动。 合并结果。</li></ol><p>我们在这里使用第一种方法，因为可以修改数组跟踪当前位置的最大和。<br>下一步是在知道当前位置的最大和后更新全局最大和。</p><p><img src="https://s1.ax1x.com/2020/04/16/Jk1psf.png" class="lazyload" data-srcset="https://s1.ax1x.com/2020/04/16/Jk1psf.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Jk1psf.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">var</span> maxSubArray = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>, length = nums.<span class="property">length</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i - <span class="number">1</span>] &gt; <span class="number">0</span>) nums[i] += nums[i - <span class="number">1</span>]; <span class="comment">// index位上的值变为到这位为止的最大值</span></span><br><span class="line">    maxSum = <span class="title class_">Math</span>.<span class="title function_">max</span>(nums[i], maxSum); <span class="comment">// 取当前位与历史位的最大值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析:</strong></p><ul><li><p>时间复杂度：O(N)。只遍历了一次数组。</p></li><li><p>空间复杂度：O(1)，使用了常数的空间。</p></li></ul><h3 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener external nofollow noreferrer">239. 滑动窗口最大值</a></h3><p><strong>解题思路</strong></p><ul><li>使用 队列 方式维护一个滑动窗口内的数值索引，并确保队列队首值是当前滑动窗口的最大值索引</li><li>对应索引i来说，在i前面并且比i的值小的数值是没有价值的，可以剔除掉</li></ul><p><strong>实现代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSlidingWindow = <span class="keyword">function</span> (<span class="params">nums, k</span>) &#123;</span><br><span class="line">  <span class="comment">//queue保存 SlidingWindow 数据，其中首位是最大值的索引</span></span><br><span class="line">  <span class="keyword">const</span> queue = [], result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">//剔除SlidingWindow外的数据</span></span><br><span class="line">    <span class="keyword">if</span> (i - queue[<span class="number">0</span>] &gt;= k) &#123;</span><br><span class="line">      queue.<span class="title function_">shift</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 剔除queue元素，确保queue首位保存的是最大值的索引</span></span><br><span class="line">    <span class="keyword">while</span> (nums[i] &gt; nums[queue[queue.<span class="property">length</span> - <span class="number">1</span>]]) &#123;</span><br><span class="line">      queue.<span class="title function_">pop</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    queue.<span class="title function_">push</span>(i)</span><br><span class="line">    <span class="comment">//从k-1开始输出结果</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(nums[queue[<span class="number">0</span>]])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener external nofollow noreferrer">合并两个有序数组</a></h3><p>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</p><p>说明:</p><p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。<br>示例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], m = <span class="number">3</span></span><br><span class="line">nums2 = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>],       n = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure><p><strong>思路分析</strong>：<br>nums1 、 nums2 有序，若把 nums2 全部合并到 nums1 ，则合并后的 nums1 长度为 m+n<br>我们可以从下标 m+n-1 的位置填充 nums1，循环比较 nums1[len1] 与 nums2[len2] 的大小，将最大值写入 nums1[len]。<br>边界条件：</p><ul><li>若 len1 &lt; 0， len2 &gt;= 0 ，此时 nums1 已重写入， nums2 还未合并完，只需将 nums2 的剩余元素写入 nums1 即可，写入后，合并完成；</li><li>若 len2 &lt; 0，此时 nums2 已全部合并到 nums1 ，合并完成。</li></ul><p><strong>实现代码：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">m</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125; Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> merge = <span class="keyword">function</span> (<span class="params">nums1, m, nums2, n</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> len1 = m - <span class="number">1</span>,</span><br><span class="line">    len2 = n - <span class="number">1</span>,</span><br><span class="line">    len = m + n - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//若len2 &lt; 0,说明 nums2 已全部合并到 nums1 ，合并完成</span></span><br><span class="line">  <span class="keyword">while</span> (len2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (len1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 此时 nums1 已重写入， nums2 还未合并完，仅仅需要将 nums2 的剩余元素写入 nums1 即可</span></span><br><span class="line">      nums1[len--] = nums2[len2--];</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nums1[len--] = nums1[len1] &gt;= nums2[len2] ? nums1[len1--] : nums2[len2--]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度为 O(m+n)</li><li>空间复杂度为 O(1）</li></ul><h3 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a><a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener external nofollow noreferrer">14. 最长公共前缀</a></h3><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 &quot;&quot;。<br>示例 1:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="string">&quot;flower&quot;</span>,<span class="string">&quot;flow&quot;</span>,<span class="string">&quot;flight&quot;</span>]</span><br><span class="line">输出: <span class="string">&quot;fl&quot;</span></span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="string">&quot;dog&quot;</span>,<span class="string">&quot;racecar&quot;</span>,<span class="string">&quot;car&quot;</span>]</span><br><span class="line">输出: <span class="string">&quot;&quot;</span></span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong>：</p><p>本题的解题方法很多，比如：</p><ol><li>直接逐个比较;</li><li>寻找最大字符串与最小字符串，将问题化解为比较这两个字符串的大小（ace &gt; acd &gt; abc =&gt; 这三个字符串的最长公共前缀一定是ace与abc两者的最长公共前缀）</li><li>分治/归并策略： 将问题分解为每两个字符串的最长公共前缀，再归并为一，求得最后值。如下图：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200622161032.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200622161032.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><ol start="4"><li>利用Trie 树（字典树）<br>Trie 树，也称为字典树或前缀树，顾名思义，它是用来处理字符串匹配问题的数据结构，以及用来解决集合中查找固定前缀字符串的数据结构。</li></ol><p>下面以Trie树方式为例来实现，思路如下：<br>构建一个 Trie 树，字符串数组的最长公共序列就为从根节点开始遍历树，直到：</p><ul><li><p>遍历节点存在超过一个子节点的节点</p></li><li><p>或遍历节点为一个字符串的结束字符</p></li></ul><p>为止，走过的字符为字符串数组的最长公共前缀。</p><p>如图，以[&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]为例，最终结果为<code>&quot;fl&quot;</code><br><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200622162347.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200622162347.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20200622162347"></p><p><strong>实现代码</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longestCommonPrefix = <span class="keyword">function</span> (<span class="params">strs</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (strs === <span class="literal">null</span> || strs.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="comment">// 初始化 Trie 树</span></span><br><span class="line">  <span class="keyword">let</span> trie = <span class="keyword">new</span> <span class="title class_">Trie</span>()</span><br><span class="line">  <span class="comment">// 构建 Trie 树</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; strs.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!trie.<span class="title function_">insert</span>(strs[i])) <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回最长公共前缀</span></span><br><span class="line">  <span class="keyword">return</span> trie.<span class="title function_">searchLongestPrefix</span>()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">TrieNode</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// next 放入当前节点的子节点</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">next</span> = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 当前是否是结束节点</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">isEnd</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trie 树</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Trie</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">root</span> = <span class="keyword">new</span> <span class="title class_">TrieNode</span>()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Trie</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">insert</span> = <span class="keyword">function</span> (<span class="params">word</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!word) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="property">root</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; word.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node.<span class="property">next</span>[word[i]]) &#123;</span><br><span class="line">      node.<span class="property">next</span>[word[i]] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    node = node.<span class="property">next</span>[word[i]]</span><br><span class="line">  &#125;</span><br><span class="line">  node.<span class="property">isEnd</span> = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Trie</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">searchLongestPrefix</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="property">root</span></span><br><span class="line">  <span class="keyword">let</span> prevs = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">while</span> (node.<span class="property">next</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(node.<span class="property">next</span>)</span><br><span class="line">    <span class="keyword">if</span> (keys.<span class="property">length</span> !== <span class="number">1</span>) <span class="keyword">break</span>; <span class="comment">//超过一个子节点的节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">next</span>[keys[<span class="number">0</span>]].<span class="property">isEnd</span>) &#123; <span class="comment">//节点为一个字符串的结束字符</span></span><br><span class="line">      prevs += keys[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    prevs += keys[<span class="number">0</span>]</span><br><span class="line">    node = node.<span class="property">next</span>[keys[<span class="number">0</span>]]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> prevs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res = <span class="title function_">longestCommonPrefix</span>([<span class="string">&quot;flower&quot;</span>, <span class="string">&quot;flow&quot;</span>, <span class="string">&quot;flight&quot;</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h2 id="链表类"><a href="#链表类" class="headerlink" title="链表类"></a>链表类</h2><div class="story post-story"><h3 id="常用方法总结：-1"><a href="#常用方法总结：-1" class="headerlink" title="常用方法总结："></a>常用方法总结：</h3><ul><li>快慢指针</li><li>标记位法</li></ul><h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener external nofollow noreferrer">合并两个有序链表</a></h3><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line">输出：<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong><br>从链表头开始比较，l1 与 l2 是有序递增的，所以比较 l1.val 与 l2.val 的较小值就是合并后链表的最小值，次小值就是小节点的 next.val 与大节点的 val 比较的较小值，依次递归，直到递归到 l1 l2 均为 null</p><p>确定边界条件： 当递归到任意链表为 null ，直接将 next 指向另外的链表即可，不需要继续递归了</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mergeTwoLists</span>(<span class="params">l1, l2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(l1 === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l2 === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l1.<span class="property">val</span> &lt;= l2.<span class="property">val</span>) &#123;</span><br><span class="line">        l1.<span class="property">next</span> = <span class="title function_">mergeTwoLists</span>(l1.<span class="property">next</span>, l2)</span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.<span class="property">next</span> = <span class="title function_">mergeTwoLists</span>(l2.<span class="property">next</span>, l1)</span><br><span class="line">        <span class="keyword">return</span> l2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener external nofollow noreferrer">141. 环形链表</a></h3><p>给定一个链表，判断链表中是否有环。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p>示例 1：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,-<span class="number">4</span>], pos = <span class="number">1</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200622140709.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200622140709.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20200622140709"></p><p>示例 2：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>], pos = <span class="number">0</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200622140800.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200622140800.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>示例 3：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>], pos = -<span class="number">1</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200622140841.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200622140841.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>方法一：标志法<br>给每个已遍历过的节点加标志位，遍历链表，当出现下一个节点已被标志时，则证明单链表有环</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hasCycle = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.<span class="property">flag</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head.<span class="property">flag</span> = <span class="number">1</span>;</span><br><span class="line">        head = head.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法二： 快慢指针法<br>设置快慢两个指针，遍历单链表，快指针一次走两步，慢指针一次走一步，如果单链表中存在环，则快慢指针终会指向同一个节点，否则直到快指针指向 null 时，快慢指针都不可能相遇。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasCycle = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head.<span class="property">next</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> fast = head.<span class="property">next</span>.<span class="property">next</span>, slow = head.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast.<span class="property">next</span>)&#123; <span class="comment">// fast.next为null说明fast是链表终点，无环</span></span><br><span class="line">        <span class="keyword">if</span>(fast === slow )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">        slow = slow.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法三： 利用 JSON.stringify() 不能序列化含有循环引用的结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasCycle = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(head);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener external nofollow noreferrer">142. 环形链表 II</a></h3><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p>说明：不允许修改给定的链表。</p><p><strong>解题思路：</strong></p><p>本题与上一题类似，增加的难度在于需要返回入环点。所以无法基于<code>JSON.stringify()</code>来实现了。<br>方法一： 标志法<br>此方法实现代码与上一题基本一样，只是返回值有所区别。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> detectCycle = <span class="keyword">function</span> (<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.<span class="property">flag</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        head.<span class="property">flag</span> = <span class="number">1</span>;</span><br><span class="line">        head = head.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法二： 快慢指针法</p><p>上一题中快慢指针相遇点（即<code>fast === slow</code>）肯定是环内某一点（注意不一定是入环点，所以本题不能直接返回这个节点）。</p><p>所以接下去主要工作是如何判断入环点？</p><p>基于上一题，我们设置fast指针速度是2，slow指针速度是1, fast速度是slow速度的2倍，所以最终相遇（<code>fast === slow</code>）时，fast走的距离也是slow走的距离的2倍。<br>具体分析如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A - 起点</span><br><span class="line">B - 第一次相遇点</span><br><span class="line">X - 入环点</span><br><span class="line">d1 - A-X距离</span><br><span class="line">d2 - X-B距离</span><br><span class="line">d3 - B-X距离</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200622145207.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/jiangawait/CDN/images/20200622145207.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="20200622145207"></p><p>最后得出<code>d1 = d3</code>。那么就可以在上题基础上进行寻找入环点：</p><p>当fast和slow在B点相遇后，将fast重回A点。将两个指针均以速度1向前走，最终会在X点相遇（距离一样，速度一样，所以到X点的时间也一样），相遇时返回节点即可。</p><p>实现代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> detectCycle = <span class="keyword">function</span> (<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head.<span class="property">next</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> fast = head.<span class="property">next</span>.<span class="property">next</span>, slow = head.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast.<span class="property">next</span>)&#123;<span class="comment">//fast.next为null说明fast是链表终点，无环</span></span><br><span class="line">        <span class="keyword">if</span>(fast === slow )&#123;</span><br><span class="line">            fast = head;</span><br><span class="line">            <span class="keyword">while</span>(fast !== slow)&#123;</span><br><span class="line">                fast = fast.<span class="property">next</span>;</span><br><span class="line">                slow = slow.<span class="property">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">        slow = slow.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/" target="_blank" rel="noopener external nofollow noreferrer">反转链表</a></h3><p><strong>解题思路</strong>：</p><p>定义一个反转链表prev, 循环head指针，将当前head指向prev，实现反转效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        <span class="comment">//临时存放下一个指针</span></span><br><span class="line">        <span class="keyword">let</span> next = head.<span class="property">next</span>;</span><br><span class="line">        <span class="comment">//将当前节点指向prev，实现反转效果</span></span><br><span class="line">        head.<span class="property">next</span> = prev;</span><br><span class="line">        <span class="comment">// 变更prev、head</span></span><br><span class="line">        prev = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener external nofollow noreferrer">19. 删除链表的倒数第N个节点</a></h3><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。<br>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>, 和 n = <span class="number">2.</span></span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5.</span></span><br></pre></td></tr></table></figure><p><strong>解题思路</strong>：<br>需要删除链表中的倒数第 n 个节点，我们需要知道的就是倒数第 n+1 个节点，然后删除删除倒数第 n+1 节点的后继节点即可.</p><p>使用快慢指针思想来解决此问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeNthFromEnd = <span class="keyword">function</span>(<span class="params">head, n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> fast = head, slow = head</span><br><span class="line">    <span class="comment">// 快先走 n - 1 步</span></span><br><span class="line">    <span class="keyword">while</span>(--n) &#123;</span><br><span class="line">        fast = fast.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!fast.<span class="property">next</span>) <span class="keyword">return</span> head.<span class="property">next</span>;<span class="comment">//说明列表长度为n,删除头结点</span></span><br><span class="line">    fast = fast.<span class="property">next</span></span><br><span class="line">    <span class="comment">// fast、slow 一起前进</span></span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast.<span class="property">next</span>) &#123;</span><br><span class="line">        fast = fast.<span class="property">next</span></span><br><span class="line">        slow = slow.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    slow.<span class="property">next</span> = slow.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener external nofollow noreferrer">876. 链表的中间结点</a></h3><p><strong>解题思路</strong>：<br>使用快慢指针方法： 快指针速度2，慢指针速度1，当快指针到达终点时，慢指针刚好在中间节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> middleNode = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> fast = head, slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast.<span class="property">next</span>)&#123;</span><br><span class="line">        fast = fast.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">        slow = slow.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul></div><h2 id="动态规划类"><a href="#动态规划类" class="headerlink" title="动态规划类"></a>动态规划类</h2><div class="story post-story"><h3 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener external nofollow noreferrer">309. 最佳买卖股票时机含冷冻期</a></h3><p>分析：</p><p>  第i天主要有三种情况，当天收益取三者最大值：</p><ol><li><p>当天持有此股票，那么股票可能是：<br>a. 前一天就持有的, 取值(dp[i - 1][0])，<br>b. 或者当天刚买的,取值(dp[i - 1][2] - prices[i]))，<br>这种情况的最大收益为： Math.max(dp[i - 1][0], dp[i - 1][2] - prices[i]);</p></li><li><p>当天卖出股票，则收益为前一天的持有收益 + 当天的股票价格收益， 即： dp[i - 1][0] + prices[i];</p></li><li><p>当天未持有，并且当天未卖出过，则有两种情况：<br>a. 前一天卖出过，dp[i-1][1]<br>b. 前一天未卖出， dp[i-1][2]。<br>这种情况的最大收益为： Math.max(dp[i - 1][1], dp[i - 1][2]);</p></li></ol><p>  第一天的初始值：dp[0] = [-prices[0], 0, 0];</p><p>  代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 最终的收益是当天的三种情况取最大</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; prices</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span> (<span class="params">prices</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> len = prices.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> dp = [];</span><br><span class="line">  dp.<span class="title function_">push</span>([-prices[<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">let</span> t0, t1, t2;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    t0 = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]); <span class="comment">// 当天持有此股票</span></span><br><span class="line">    t1 = dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]; <span class="comment">// 当天未持有，并且当天卖出</span></span><br><span class="line">    t2 = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]); <span class="comment">//当天未持有，并且不是当天卖出</span></span><br><span class="line">    dp.<span class="title function_">push</span>([t0, t1, t2]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(...dp.<span class="title function_">pop</span>())</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="面试题-17-13-恢复空格"><a href="#面试题-17-13-恢复空格" class="headerlink" title="面试题 17.13. 恢复空格"></a><a href="https://leetcode-cn.com/problems/re-space-lcci/" target="_blank" rel="noopener external nofollow noreferrer">面试题 17.13. 恢复空格</a></h3><p>分析：<br>  遍历 sentence，如果i-1结尾的子字符串 等于 dictionary的某个word, 说明dp[i] 可以等于 dp[i - word.length]；</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">dictionary</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">String</span>&#125; <span class="variable">sentence</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">respace</span> = (<span class="params">dictionary, sentence</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> len = sentence.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">if</span> (len === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(len + <span class="number">1</span>);</span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123; <span class="comment">//i代表 Length(sentence)</span></span><br><span class="line">    dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> word <span class="keyword">of</span> dictionary) &#123;</span><br><span class="line">      <span class="keyword">if</span> (word === sentence.<span class="title function_">substring</span>(i - word.<span class="property">length</span>, i)) &#123;</span><br><span class="line">        dp[i] = <span class="title class_">Math</span>.<span class="title function_">min</span>(dp[i], dp[i - word.<span class="property">length</span>])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dp[len]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener external nofollow noreferrer">96. 不同的二叉搜索树</a></h3><ul><li>思路:<br>标签：动态规划<br>假设n个节点存在二叉排序树的个数是dp(n)，令f(i)为以i为根的二叉搜索树的个数，则<br>dp(n) = f(1) + f(2) + f(3) + f(4) + ... + f(n)</li></ul><p>当i为根节点时，其左子树节点个数为i-1个，右子树节点为n-i，则<br>f(i) = dp(i-1)*dp(n-i)</p><p>综合两个公式可以得到 <a href="https://segmentfault.com/a/1190000021666634" target="_blank" rel="noopener external nofollow noreferrer">卡特兰数</a> 公式<br>dp(n) = dp(0)<em>dp(n-1)+dp(1)</em>(n-2)+...+dp(n-1)*dp(0)</p><ul><li>代码实现：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numTrees = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123; <span class="comment">//以j为顶点的个数计算</span></span><br><span class="line">      dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">汇集LeetCode题解思路，方便日后回忆</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://kobingogo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode" scheme="https://kobingogo.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>从Chrome源码看JS Array的底层实现</title>
    <link href="https://kobingogo.github.io/Chrome%E6%BA%90%E7%A0%81-array-knowledge/"/>
    <id>https://kobingogo.github.io/Chrome%E6%BA%90%E7%A0%81-array-knowledge/</id>
    <published>2020-06-17T22:41:59.000Z</published>
    <updated>2024-08-08T10:31:05.013Z</updated>
    
    <content type="html"><![CDATA[<p>作为前端er，我们都知道，JS 的数组可以存放不同类型的元素、并且数组长度是可变的。不像其他的语言，比如C，创建的时候要决定数组的大小，如果数组满了，就要重新申请内存空间。</p><p>知道归知道，但是要想弄清楚其中原因，就得从Chrome源码去探究了。</p><span id="more"></span><h3 id="JS-Array为什么可以保存不同类型"><a href="#JS-Array为什么可以保存不同类型" class="headerlink" title="JS Array为什么可以保存不同类型"></a>JS Array为什么可以保存不同类型</h3><p>先看下Chrome V8对JSArray的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The JSArray describes JavaScript Arrays</span></span><br><span class="line"><span class="comment">//  Such an array can be in one of two modes:</span></span><br><span class="line"><span class="comment">//    - fast, backing storage is a FixedArray and length &lt;= elements.length();</span></span><br><span class="line"><span class="comment">//       Please note: push and pop can be used to grow and shrink the array.</span></span><br><span class="line"><span class="comment">//    - slow, backing storage is a HashTable with numbers as keys.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JSArray</span>: <span class="keyword">public</span> JSObject &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// [length]: The length property.</span></span><br><span class="line">  <span class="built_in">DECL_ACCESSORS</span>(length, Object)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Number of element slots to pre-allocate for an empty array.</span></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kPreallocatedArrayElements = <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以看到 JSArray 是继承自 JSObject 的，所以在 JavaScript 中，数组可以是一个特殊的对象，内部是以 key-value 形式存储数据，所以 JavaScript 中的数组可以存放不同类型的值。</p><h3 id="JS-Array如何存储"><a href="#JS-Array如何存储" class="headerlink" title="JS Array如何存储"></a>JS Array如何存储</h3><p>从上述 V8 源码注释中可以看出，JSArray有两种存储方式：</p><ul><li>fast：存储结构是 FixedArray ，并且数组长度 &lt;= elements.length() ，push 或 pop 时可能会伴随着动态扩容或减容，源码里叫 <code>FastElements</code>;</li><li>slow：存储结构是 HashTable，并且数组下标作为 key,源码里叫 <code>SlowElements</code>;</li></ul><ol><li><p>快数组（FastElements）<br>FixedArray 是 V8 实现的一个类似于数组的类，它表示一段连续的内存，可以使用索引直接定位。新创建的空数组默认就是快数组。当数组满（数组的长度达到数组在内存中申请的内存容量最大值）的时候，继续 push 时， JSArray 会进行动态的扩容，以存储更多的元素。</p></li><li><p>慢数组（SlowElements）<br>慢数组以哈希表的形式存储在内存空间里，它不需要开辟连续的存储空间,节省了内存，但需要额外维护一个哈希表，性能相对较差。</p></li><li><p>什么时候会从 fast 转变为 slow</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/objects/js-objects.h</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> kMaxGap = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/objects/dictionary.h</span></span><br><span class="line"><span class="comment">// JSObjects prefer dictionary elements if the dictionary saves this much</span></span><br><span class="line"><span class="comment">// memory compared to a fast elements backing store.</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> kPreferFastElementsSizeFactor = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/objects/js-objects-inl.h</span></span><br><span class="line"><span class="comment">// If the fast-case backing storage takes up much more memory than a dictionary</span></span><br><span class="line"><span class="comment">// backing storage would, the object should have slow elements.</span></span><br><span class="line"><span class="comment">// static</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title">ShouldConvertToSlowElements</span><span class="params">(<span class="type">uint32_t</span> used_elements,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="type">uint32_t</span> new_capacity)</span> </span>&#123;</span><br><span class="line">  <span class="type">uint32_t</span> size_threshold = NumberDictionary::kPreferFastElementsSizeFactor *</span><br><span class="line">                            NumberDictionary::<span class="built_in">ComputeCapacity</span>(used_elements) *</span><br><span class="line">                            NumberDictionary::kEntrySize;</span><br><span class="line">  <span class="comment">// 快数组新容量是扩容后的容量3倍之多时，也会被转成慢数组</span></span><br><span class="line">  <span class="keyword">return</span> size_threshold &lt;= new_capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title">ShouldConvertToSlowElements</span><span class="params">(JSObject object,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="type">uint32_t</span> capacity,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="type">uint32_t</span> index,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="type">uint32_t</span>* new_capacity)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">STATIC_ASSERT</span>(JSObject::kMaxUncheckedOldFastElementsLength &lt;=</span><br><span class="line">                JSObject::kMaxUncheckedFastElementsLength);</span><br><span class="line">  <span class="keyword">if</span> (index &lt; capacity) &#123;</span><br><span class="line">    *new_capacity = capacity;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当加入的索引值（例如例3中的2000）比当前容量capacity 大于等于 1024时，</span></span><br><span class="line">  <span class="comment">// 返回true，转为慢数组</span></span><br><span class="line">  <span class="keyword">if</span> (index - capacity &gt;= JSObject::kMaxGap) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  *new_capacity = JSObject::<span class="built_in">NewElementsCapacity</span>(index + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">DCHECK_LT</span>(index, *new_capacity);</span><br><span class="line">  <span class="comment">// TODO(ulan): Check if it works with young large objects.</span></span><br><span class="line">  <span class="keyword">if</span> (*new_capacity &lt;= JSObject::kMaxUncheckedOldFastElementsLength ||</span><br><span class="line">      (*new_capacity &lt;= JSObject::kMaxUncheckedFastElementsLength &amp;&amp;</span><br><span class="line">       <span class="built_in">ObjectInYoungGeneration</span>(object))) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ShouldConvertToSlowElements</span>(object.<span class="built_in">GetFastElementsUsage</span>(),</span><br><span class="line">                                     *new_capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述源码看出，当处于以下情况时，快数组会被转变为慢数组：</p><ul><li>当加入的索引值 index 比当前容量 capacity 差值大于等于 1024 时（index - capacity &gt;= 1024）</li><li>快数组新容量是扩容后的容量 3 倍之多时</li></ul><p>增加一个2000的索引时，array就会被转成慢数组:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">array[<span class="number">2000</span>] = <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><ol start="4"><li>什么时候会从 slow 转变为 fast</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">ShouldConvertToFastElements</span><span class="params">(JSObject object,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        NumberDictionary dictionary,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">uint32_t</span> index,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">uint32_t</span>* new_capacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// If properties with non-standard attributes or accessors were added, we</span></span><br><span class="line">  <span class="comment">// cannot go back to fast elements.</span></span><br><span class="line">  <span class="keyword">if</span> (dictionary.<span class="built_in">requires_slow_elements</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// Adding a property with this index will require slow elements.</span></span><br><span class="line">  <span class="keyword">if</span> (index &gt;= <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(Smi::kMaxValue)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (object.<span class="built_in">IsJSArray</span>()) &#123;</span><br><span class="line">    Object length = JSArray::<span class="built_in">cast</span>(object).<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">if</span> (!length.<span class="built_in">IsSmi</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    *new_capacity = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(Smi::<span class="built_in">ToInt</span>(length));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object.<span class="built_in">IsJSArgumentsObject</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    *new_capacity = dictionary.<span class="built_in">max_number_key</span>() + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *new_capacity = <span class="built_in">Max</span>(index + <span class="number">1</span>, *new_capacity);</span><br><span class="line">  <span class="type">uint32_t</span> dictionary_size = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(dictionary.<span class="built_in">Capacity</span>()) *</span><br><span class="line">                             NumberDictionary::kEntrySize;</span><br><span class="line">  <span class="comment">// Turn fast if the dictionary only saves 50% space.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * dictionary_size &gt;= *new_capacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当慢数组的元素可存放在快数组中且长度在 <code>smi</code> 之间且仅节省了50%的空间(用慢数组节省的空间不大于50%),则会转变为快数组</p><blockquote><p>smi在64位平台为-2<sup>31</sup> 到 2<sup>31</sup> -1，在32位平台为-2<sup>30</sup> 到 2<sup>30</sup> -1</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line">a[<span class="number">1030</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">200</span>; i &lt; <span class="number">1030</span>; i++) &#123;</span><br><span class="line">    a[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 1030 的位置上面添加一个值，会造成多于 1024 个空洞，数组变成慢数组；<br>然后往这个数组中 200-1029 这些位置上赋值，使慢数组不再比快数组节省 50% 的空间，则数组变成快数组。</p><ol start="5"><li>总结</li></ol><p>快数组就是以空间换时间的方式，申请了大块连续内存，提高效率。 慢数组以时间换空间，不必申请连续的空间，节省了内存，但需要付出效率变差的代价。</p><h3 id="数组的动态扩容与减容"><a href="#数组的动态扩容与减容" class="headerlink" title="数组的动态扩容与减容"></a>数组的动态扩容与减容</h3><p>默认空数组初始化大小为 4 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Number of element slots to pre-allocate for an empty array.</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kPreallocatedArrayElements = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>在 Chrome 源码中， push 的操作是用汇编实现的，在 c++ 里嵌入的汇编，以提高执行效率，并且在汇编的基础上用 c++ 封装了一层，在编译执行的时候，会将这些 c++ 代码转成汇编代码。</p><p>计算新容量的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// js-objects.h</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> kMinAddedElementsCapacity = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// code-stub-assembler.cc</span></span><br><span class="line"><span class="function">Node* <span class="title">CodeStubAssembler::CalculateNewElementsCapacity</span><span class="params">(Node* old_capacity,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      ParameterMode mode)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">CSA_SLOW_ASSERT</span>(<span class="keyword">this</span>, <span class="built_in">MatchesParameterMode</span>(old_capacity, mode));</span><br><span class="line">  Node* half_old_capacity = <span class="built_in">WordOrSmiShr</span>(old_capacity, <span class="number">1</span>, mode);</span><br><span class="line">  Node* new_capacity = <span class="built_in">IntPtrOrSmiAdd</span>(half_old_capacity, old_capacity, mode);</span><br><span class="line">  Node* padding =</span><br><span class="line">      <span class="built_in">IntPtrOrSmiConstant</span>(JSObject::kMinAddedElementsCapacity, mode);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">IntPtrOrSmiAdd</span>(new_capacity, padding, mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以扩容后新容量计公式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_capacity = old_capacity /<span class="number">2</span> + old_capacity + <span class="number">16</span></span><br></pre></td></tr></table></figure><p>即老的容量的 1.5 倍加上 16 。初始化为 4 个，当 push 第 5 个的时候，容量将会变成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_capacity = <span class="number">4</span> / <span class="number">2</span> + <span class="number">4</span> + <span class="number">16</span> = <span class="number">22</span></span><br></pre></td></tr></table></figure><p>接着申请一块这么大的内存，把老的数据拷过去，把新元素放在当前 length 位置，然后将数组的 length + 1，并返回 length。</p><p>整个过程，用户是无感知的，不像 C，需用用户手动申请内存空间。</p><p>当数组执行 pop 操作时，会判断 pop 后数组的容量，是否需要进行减容。</p><p>不同于数组的 push 使用汇编实现的， pop 使用 c++ 实现的。</p><p>判断是否进行减容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">2</span> * length &lt;= capacity) &#123;</span><br><span class="line">  <span class="comment">// If more than half the elements won&#x27;t be used, trim the array.</span></span><br><span class="line">  isolate-&gt;<span class="built_in">heap</span>()-&gt;<span class="built_in">RightTrimFixedArray</span>(*backing_store, capacity - length);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Otherwise, fill the unused tail with holes.</span></span><br><span class="line">  BackingStore::<span class="built_in">cast</span>(*backing_store)-&gt;<span class="built_in">FillWithHoles</span>(length, old_length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，当数组 pop 后，如果数组容量大于等于 length 的 2 倍，则进行容量调整，使用 RightTrimFixedArray 函数，计算出需要释放的空间大小，做好标记，等待 GC 回收；如果数组容量小于 length 的 2 倍，则用 holes 对象填充。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>JavaScript 中， JSArray 继承自 JSObject ，是一个特殊的对象，内部是以 key-value 形式存储数据，所以 JavaScript 中的数组可以存放不同类型的值。</p><p>JSArray有两种存储方式，快数组与慢数组，初始化空数组时，使用快数组，快数组使用连续的内存空间，当快数组长度达到最大时，JSArray 会进行动态的扩容，以存储更多的元素，相对慢数组，性能要好得多。</p><p>当数组中 hole 太多时，会转变成慢数组，即以哈希表的方式（ key-value 的形式）存储数据，以节省内存空间。</p><h3 id="一道面试题-数组扁平化"><a href="#一道面试题-数组扁平化" class="headerlink" title="一道面试题 - 数组扁平化"></a>一道面试题 - 数组扁平化</h3><p>假如有个数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">5</span>]], <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>如何将其扁平化为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>核心思想： 遍历数组arr，若arr[i]为数组则递归遍历，直至arr[i]不为数组然后与之前的结果concat。</p><ol><li>ES6 flat</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">flat</span>(<span class="title class_">Infinity</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li>reduce</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">result, item</span>)=&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> result.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(item) ? <span class="title function_">flatten</span>(item) : item);</span><br><span class="line">    &#125;, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>toString / join</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>).<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Number</span>(item);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>递归</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> res = [];</span><br><span class="line">    arr.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(item)) &#123;</span><br><span class="line">            res = res.<span class="title function_">concat</span>(<span class="title function_">flatten</span>(item));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>扩展运算符</li></ol><p>es6的扩展运算符能将二维数组变为一维</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span>(arr.<span class="title function_">some</span>(<span class="function"><span class="params">item</span>=&gt;</span><span class="title class_">Array</span>.<span class="title function_">isArray</span>(item))) &#123;</span><br><span class="line">        arr = [].<span class="title function_">concat</span>(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考链接：<br><a href="https://github.com/sisterAn/JavaScript-Algorithms/issues/2" target="_blank" rel="noopener external nofollow noreferrer">前端进阶算法2：从Chrome V8源码看JavaScript数组</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;作为前端er，我们都知道，JS 的数组可以存放不同类型的元素、并且数组长度是可变的。不像其他的语言，比如C，创建的时候要决定数组的大小，如果数组满了，就要重新申请内存空间。&lt;/p&gt;
&lt;p&gt;知道归知道，但是要想弄清楚其中原因，就得从Chrome源码去探究了。&lt;/p&gt;</summary>
    
    
    
    <category term="Chrome源码" scheme="https://kobingogo.github.io/categories/chrome%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="array" scheme="https://kobingogo.github.io/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>常用系统命令汇总</title>
    <link href="https://kobingogo.github.io/others-%E5%B8%B8%E7%94%A8%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/"/>
    <id>https://kobingogo.github.io/others-%E5%B8%B8%E7%94%A8%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/</id>
    <published>2020-06-12T18:50:05.000Z</published>
    <updated>2024-08-08T10:31:05.017Z</updated>
    
    <content type="html"><![CDATA[<h3 id="端口检查"><a href="#端口检查" class="headerlink" title="端口检查"></a>端口检查</h3><ul><li>linux</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 192.168.1.102 3306</span><br></pre></td></tr></table></figure><ul><li>mac</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -vz -w 2 192.168.1.104 3306</span><br></pre></td></tr></table></figure><h3 id="查看端口占用"><a href="#查看端口占用" class="headerlink" title="查看端口占用"></a>查看端口占用</h3><ul><li>Centos7+</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lsof -i tcp:80  <span class="comment"># 查看80端口占用情况</span></span><br><span class="line"></span><br><span class="line">netstat -ntlp  <span class="comment"># 列出所有端口</span></span><br><span class="line"></span><br><span class="line">firewall-cmd --query-port=3306/tcp <span class="comment"># 查询是否开启3306端口</span></span><br><span class="line"></span><br><span class="line">firewall-cmd --zone=public --add-port=3306/tcp --permanent <span class="comment"># 开启端口</span></span><br><span class="line"></span><br><span class="line">firewall-cmd --zone=public --remove-port=3306/tcp --permanent <span class="comment"># 关闭端口</span></span><br><span class="line"></span><br><span class="line">firewall-cmd --reload <span class="comment">#重启防火墙</span></span><br></pre></td></tr></table></figure><h3 id="杀掉进程"><a href="#杀掉进程" class="headerlink" title="杀掉进程"></a>杀掉进程</h3><ul><li>Centos</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -tpnul <span class="comment"># 查看当前所有正在运行的进程</span></span><br><span class="line">ps aux |grep httpd <span class="comment"># 查看 httpd 进程</span></span><br><span class="line"><span class="built_in">kill</span> -9 6732 <span class="comment"># 6732为httpd进程对应的进程ID</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">各个系统常用终端命令汇总之地</summary>
    
    
    
    <category term="others" scheme="https://kobingogo.github.io/categories/others/"/>
    
    
    <category term="命令" scheme="https://kobingogo.github.io/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Vulter + v2ray / Trojan 使用教程</title>
    <link href="https://kobingogo.github.io/others-v2ray-manual/"/>
    <id>https://kobingogo.github.io/others-v2ray-manual/</id>
    <published>2020-06-11T18:25:33.000Z</published>
    <updated>2024-08-08T10:31:05.017Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直在使用的梯子服务临近到期，想要续费发现价格又涨了一波，再加上平时使用中并不是很稳定。就萌生了自建一个梯子的想法。</p><span id="more"></span><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>要想自建梯子有两个前提：</p><ul><li>境外VPS服务器(虚拟专用服务器)</li><li>科学上网工具</li></ul><h4 id="VPS服务器"><a href="#VPS服务器" class="headerlink" title="VPS服务器"></a>VPS服务器</h4><p>对比了阿里云国际版、谷歌云、AWS等巨头产品，以及VULTR、搬瓦工等服务商，最终选择了<code>VULTR</code>，主要原因在于：</p><ol><li>价格便宜： 最便宜的有$2.5/月的服务，价格是王道；</li><li>机房众多：拥有日本、美国、欧洲等 17 个机房；</li><li>架构优秀：全部采用 KVM 架构、SSD 固态硬盘、500G/月流量起步；</li><li>后台强大 ：拥有系统快照、一键装机部署脚本、备份、防火墙等强大功能，从 VPS 这点丝毫不输给阿里云。</li><li>计费灵活 : 采用小时计费模式，可以任意的添加和删除机器 , 并且是单向流量收费 , 也就是只计算下载的的流量;</li><li>支持支付宝/微信支付，国内用户购买方便；</li></ol><p>注册购买请进入官网自行操作：<a href="https://www.vultr.com/" target="_blank" rel="noopener external nofollow noreferrer">vultr官网</a></p><h4 id="科学上网工具"><a href="#科学上网工具" class="headerlink" title="科学上网工具"></a>科学上网工具</h4><p>本文主要实现v2ray 和 Trojan 两个工具的搭建</p><h3 id="SSH免密登录vultr服务器"><a href="#SSH免密登录vultr服务器" class="headerlink" title="SSH免密登录vultr服务器"></a>SSH免密登录vultr服务器</h3><ol><li>在本机生成密钥（如果已经有了不用重复生成）：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><ol start="2"><li>将本地公钥拷贝到服务器的<code>~/.ssh/authorized_keys</code>目录中：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一</span></span><br><span class="line">ssh-copy-id user@ip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 法二</span></span><br><span class="line"><span class="comment"># 将 本机 ~/.ssh目录中的 id_rsa.pub 这个文件拷贝到服务器 的~/.ssh目录中</span></span><br><span class="line">scp ~/.ssh/id_rsa.pub user@ip:~/.ssh/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在服务器运行以下命令来将公钥导入到~/.ssh/authorized_keys这个文件中</span></span><br><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># authorized_keys的权限要是600。</span></span><br><span class="line"><span class="built_in">chmod</span> 600 .ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>user: 服务器用户名，默认为root<br>ip: 服务器公网IP</p><p>至此，就可以用下面命令免密登录了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user@ip</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfopr1r33xj30pk0gpaar.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfopr1r33xj30pk0gpaar.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="v2ray安装与配置"><a href="#v2ray安装与配置" class="headerlink" title="v2ray安装与配置"></a>v2ray安装与配置</h3><p>登录了云服务后，就可以开始下载安装v2ray了，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://install.direct/go.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> +x go.sh</span><br><span class="line"></span><br><span class="line">./go.sh</span><br></pre></td></tr></table></figure><p>执行成功后，会输出 V2Ray v4.24.2 is installed. 等字样。</p><p>安装V2Ray后， 会在<code>/etc/v2ray/config.json</code>默认生成配置文件，我们需要编辑这个文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/v2ray/config.json</span><br></pre></td></tr></table></figure><p>然后连续按 d 键，将原本的文件内容清空，然后按 i 键开启编辑模式，复制以下配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;log&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;access&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/log/v2ray/access.log&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/log/v2ray/error.log&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;loglevel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;warning&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;inbound&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">9751</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;protocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vmess&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;clients&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;392029fa-a9e0-42e3-93cb-97a9288795ed&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;level&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;alterId&quot;</span><span class="punctuation">:</span> <span class="number">100</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;streamSettings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;network&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tcp&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;detour&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;to&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vmess-detour-118345&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;outbound&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;protocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;freedom&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;inboundDetour&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;protocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vmess&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10000-10010&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;tag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vmess-detour-118345&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;allocate&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;strategy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;random&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;concurrency&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;refresh&quot;</span><span class="punctuation">:</span> <span class="number">5</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;streamSettings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;network&quot;</span><span class="punctuation">:</span> <span class="string">&quot;kcp&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;outboundDetour&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;protocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;blackhole&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;tag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;blocked&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;routing&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;strategy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;rules&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;rules&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;field&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;0.0.0.0/8&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;10.0.0.0/8&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;100.64.0.0/10&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;127.0.0.0/8&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;169.254.0.0/16&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;172.16.0.0/12&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;192.0.0.0/24&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;192.0.2.0/24&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;192.168.0.0/16&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;198.18.0.0/15&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;198.51.100.0/24&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;203.0.113.0/24&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;::1/128&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;fc00::/7&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;fe80::/10&quot;</span></span><br><span class="line">          <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;outboundTag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;blocked&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>上述配置中可根据自己的喜好进行相应修改，也可直接使用不做修改。</p><p>保存并退出编辑模式，再启动v2ray服务，服务端的配置就完成了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start v2ray</span><br></pre></td></tr></table></figure><p>v2ray进程管理命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 v2ray 进程状态</span></span><br><span class="line">systemctl status v2ray</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start v2ray</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart v2ray</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">systemctl stop v2ray</span><br></pre></td></tr></table></figure><h3 id="配置防火墙"><a href="#配置防火墙" class="headerlink" title="配置防火墙"></a>配置防火墙</h3><p>CentOS 7 系统默认会开启防火墙，需要开放上面配置的端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --add-service=https</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">firewall-cmd --zone=public --add-port=9751/tcp --permanent</span><br></pre></td></tr></table></figure><p>– zone #作用域</p><p>– add-port=80/tcp #添加端口，格式为：端口/通讯协议</p><p>– permanent #永久生效，没有此参数重启后失效</p><p>防火墙其他相关命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld <span class="comment"># 查看防火墙状态</span></span><br><span class="line">firewall-cmd --reload <span class="comment">#重启firewall</span></span><br><span class="line">systemctl restart firewalld <span class="comment"># 重启2</span></span><br><span class="line">systemctl stop firewalld.service <span class="comment">#停止firewall</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service <span class="comment">#禁止firewall开机启动</span></span><br><span class="line">firewall-cmd --state <span class="comment">#查看默认防火墙状态（关闭后显示notrunning，开启后显示running）</span></span><br><span class="line"></span><br><span class="line">firewall-cmd --list-ports  <span class="comment"># 查看已经开放的端口</span></span><br></pre></td></tr></table></figure><p>至此，服务端部分就算完成了。下面开始客户端配置。</p><h3 id="V2Ray-客户端"><a href="#V2Ray-客户端" class="headerlink" title="V2Ray 客户端"></a>V2Ray 客户端</h3><ul><li>Mac端</li></ul><p>Mac端使用的是<a href="https://github.com/yichengchen/clashX/releases" target="_blank" rel="noopener external nofollow noreferrer">ClashX</a>客户端。安装下载后打开配置文件夹：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfoqnszotfj30ad0c0mya.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfoqnszotfj30ad0c0mya.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>新建一个<code>.yaml</code>配置文件，具体配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">port:</span> <span class="number">7890</span></span><br><span class="line"><span class="attr">socks-port:</span> <span class="number">7891</span></span><br><span class="line"><span class="attr">redir-port:</span> <span class="number">7892</span></span><br><span class="line"><span class="attr">allow-lan:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">mode:</span> <span class="string">Rule</span></span><br><span class="line"><span class="attr">log-level:</span> <span class="string">info</span></span><br><span class="line"><span class="attr">external-controller:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9090</span></span><br><span class="line"><span class="attr">secret:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="attr">cfw-bypass:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">localhost</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">127</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.16</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.17</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.18</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.19</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.20</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.21</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.22</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.23</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.24</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.25</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.26</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.27</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.28</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.29</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.30</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.31</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">192.168</span><span class="string">.*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&lt;local&gt;</span></span><br><span class="line"><span class="attr">cfw-latency-timeout:</span> <span class="number">3000</span></span><br><span class="line"><span class="attr">Proxy:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">V2-NewJersey</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">vmess</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">208.167</span><span class="number">.222</span><span class="number">.200</span> <span class="comment"># 服务器公网IP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">&quot;9751&quot;</span> <span class="comment"># v2ray配置的端口</span></span><br><span class="line">    <span class="attr">uuid:</span> <span class="string">392029fa-a9e0-42e3-93cb-97a9288795ed</span> <span class="comment"># v2ray的uuid</span></span><br><span class="line">    <span class="attr">alterId:</span> <span class="string">&quot;100&quot;</span> <span class="comment"># v2ray的额外ID</span></span><br><span class="line">    <span class="attr">cipher:</span> <span class="string">auto</span></span><br><span class="line">    <span class="attr">network:</span> <span class="string">tcp</span> <span class="comment"># 传输协议</span></span><br><span class="line"><span class="attr">Proxy Group:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CroLAX</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">select</span></span><br><span class="line">    <span class="attr">proxies:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">V2-NewJersey</span></span><br><span class="line"><span class="attr">Rule:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN,hls.itunes.apple.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN,itunes.apple.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN,itunes.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,icloud.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,icloud-content.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,me.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,mzstatic.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,akadns.net,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,aaplimg.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,cdn-apple.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,apple.com,DIRECT</span></span><br><span class="line">  <span class="comment">## 国内网站</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,cn,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,-cn,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,126.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,126.net,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,127.net,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,163.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,360buyimg.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,36kr.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,acfun.tv,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,air-matters.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,aixifan.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,akamaized.net,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,alicdn,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,alipay,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,taobao,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,amap.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,autonavi.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,baidu,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,bdimg.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,bdstatic.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,bilibili.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,caiyunapp.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,clouddn.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,cnbeta.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,cnbetacdn.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,cootekservice.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,csdn.net,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ctrip.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,dgtle.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,dianping.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,douban.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,doubanio.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,duokan.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,easou.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ele.me,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,feng.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,fir.im,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,frdic.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,g-cores.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,godic.net,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,gtimg.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,hongxiu.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,hxcdn.net,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,iciba.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ifeng.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ifengimg.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ipip.net,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,iqiyi.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,jd.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,jianshu.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,knewone.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,le.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,lecloud.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,lemicp.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,licdn.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,linkedin.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,luoo.net,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,meituan.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,meituan.net,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,mi.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,miaopai.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,microsoft.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,microsoftonline.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,miui.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,miwifi.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,mob.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,netease.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,office.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,officecdn,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,office365.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,oschina.net,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ppsimg.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,pstatp.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,qcloud.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,qdaily.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,qdmm.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,qhimg.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,qhres.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,qidian.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,qihucdn.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,qiniu.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,qiniucdn.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,qiyipic.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,qq.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,qqurl.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,rarbg.to,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ruguoapp.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,segmentfault.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,sinaapp.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,smzdm.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,sogou.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,sogoucdn.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,sohu.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,soku.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,speedtest.net,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,sspai.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,suning.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,taobao.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,tencent.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,tenpay.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,tianyancha.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,tmall.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,tudou.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,umetrip.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,upaiyun.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,upyun.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,v2ex.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,veryzhun.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,weather.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,weibo.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,xiami.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,xiami.net,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,xiaomicp.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ximalaya.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,xmcdn.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,xunlei.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,yhd.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,yihaodianimg.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,yinxiang.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ykimg.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,youdao.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,youku.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,zealer.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,zhihu.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,zhimg.com,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,zimuzu.tv,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,netflix,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,nflx,CroLAX</span></span><br><span class="line">  <span class="comment">## 抗 DNS 污染</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,amazon,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,google,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,gmail,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,youtube,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,facebook,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,fb.me,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,fbcdn.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,twitter,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,instagram,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,dropbox,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,twimg.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,blogspot,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,youtu.be,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,whatsapp,CroLAX</span></span><br><span class="line">  <span class="comment">## 国外网站</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,9to5mac.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,abpchina.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,adblockplus.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,adobe.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,alfredapp.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,amplitude.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ampproject.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,android.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,angularjs.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,aolcdn.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,apkpure.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,appledaily.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,appshopper.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,appspot.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,arcgis.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,archive.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,armorgames.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,aspnetcdn.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,att.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,awsstatic.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,azureedge.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,azurewebsites.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,bing.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,bintray.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,bit.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,bit.ly,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,bitbucket.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,bjango.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,bkrtx.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,blog.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,blogcdn.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,blogger.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,blogsmithmedia.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,blogspot.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,blogspot.hk,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,bloomberg.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,box.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,box.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,cachefly.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,chromium.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,cl.ly,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,cloudflare.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,cloudfront.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,cloudmagic.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,cmail19.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,cnet.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,cocoapods.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,comodoca.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,crashlytics.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,culturedcode.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,d.pr,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,danilo.to,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,dayone.me,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,db.tt,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,deskconnect.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,disq.us,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,disqus.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,disquscdn.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,dnsimple.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,docker.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,dribbble.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,droplr.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,duckduckgo.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,dueapp.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,dytt8.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,edgecastcdn.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,edgekey.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,edgesuite.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,engadget.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,entrust.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,eurekavpt.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,evernote.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,fabric.io,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,fast.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,fastly.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,fc2.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,feedburner.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,feedly.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,feedsportal.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,fiftythree.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,firebaseio.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,flexibits.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,flickr.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,flipboard.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,g.co,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,gabia.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,geni.us,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,gfx.ms,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ggpht.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ghostnoteapp.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,git.io,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,github,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,globalsign.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,gmodules.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,godaddy.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,golang.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,gongm.in,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,goo.gl,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,goodreaders.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,goodreads.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,gravatar.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,gstatic.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,gvt0.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,hockeyapp.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,hotmail.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,icons8.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ift.tt,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ifttt.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,iherb.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,imageshack.us,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,img.ly,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,imgur.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,imore.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,instapaper.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ipn.li,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,is.gd,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,issuu.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,itgonglun.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,itun.es,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ixquick.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,j.mp,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,js.revsci.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,jshint.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,jtvnw.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,justgetflux.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,kat.cr,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,klip.me,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,libsyn.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,linode.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,lithium.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,littlehj.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,live.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,live.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,livefilestore.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,llnwd.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,macid.co,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,macromedia.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,macrumors.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,mashable.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,mathjax.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,medium.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,mega.co.nz,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,mega.nz,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,megaupload.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,microsofttranslator.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,mindnode.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,mobile01.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,modmyi.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,msedge.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,myfontastic.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,name.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,nextmedia.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,nsstatic.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,nssurge.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,nyt.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,nytimes.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,omnigroup.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,onedrive.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,onenote.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ooyala.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,openvpn.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,openwrt.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,orkut.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,osxdaily.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,outlook.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ow.ly,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,paddleapi.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,parallels.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,parse.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,pdfexpert.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,periscope.tv,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,pinboard.in,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,pinterest.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,pixelmator.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,pixiv.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,playpcesor.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,playstation.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,playstation.com.hk,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,playstation.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,playstationnetwork.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,pushwoosh.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,rime.im,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,servebom.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,sfx.ms,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,shadowsocks.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,sharethis.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,shazam.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,skype.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,smartdnsProxy.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,smartmailcloud.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,sndcdn.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,sony.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,soundcloud.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,sourceforge.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,spotify.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,squarespace.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,sstatic.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,st.luluku.pw,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,stackoverflow.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,startpage.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,staticflickr.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,steamcommunity.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,symauth.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,symcb.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,symcd.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,tapbots.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,tapbots.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,tdesktop.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,techcrunch.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,techsmith.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,thepiratebay.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,theverge.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,time.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,timeinc.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,tiny.cc,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,tinypic.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,tmblr.co,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,todoist.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,trello.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,trustasiassl.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,tumblr.co,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,tumblr.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,tweetdeck.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,tweetmarker.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,twitch.tv,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,txmblr.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,typekit.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ubertags.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ublock.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ubnt.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ulyssesapp.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,urchin.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,usertrust.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,v.gd,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,vimeo.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,vimeocdn.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,vine.co,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,vivaldi.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,vox-cdn.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,vsco.co,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,vultr.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,w.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,w3schools.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,webtype.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,wikiwand.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,wikileaks.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,wikimedia.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,wikipedia.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,wikipedia.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,windows.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,windows.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,wire.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,wordpress.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,workflowy.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,wp.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,wsj.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,wsj.net,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,xda-developers.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,xeeno.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,xiti.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,yahoo.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,yimg.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ying.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,yoyo.org,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ytimg.com,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,telegram.me,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IP-CIDR,91.108.4.0/22,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IP-CIDR,91.108.8.0/22,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IP-CIDR,91.108.56.0/22,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IP-CIDR,109.239.140.0/24,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IP-CIDR,149.154.160.0/20,CroLAX</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IP-CIDR,127.0.0.0/8,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IP-CIDR,172.16.0.0/12,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IP-CIDR,192.168.0.0/16,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IP-CIDR,10.0.0.0/8,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IP-CIDR,17.0.0.0/8,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IP-CIDR,100.64.0.0/10,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">GEOIP,CN,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">MATCH,,CroLAX</span></span><br></pre></td></tr></table></figure><p>主要关注注释代码部分，更加详细的ClashX配置说明请参加 <a href="https://www.v2rayssr.com/clashxx.html" target="_blank" rel="noopener external nofollow noreferrer">此文</a>。</p><ul><li>windows端</li></ul><p>windows端使用<a href="https://github.com/2dust/v2rayN/releases" target="_blank" rel="noopener external nofollow noreferrer">v2rayN</a>软件，安装后点击服务器 -&gt; 添加[VMess]服务器, 具体配置如下：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gformgphhaj30kh0gqq3b.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gformgphhaj30kh0gqq3b.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="配置-BBR-加速"><a href="#配置-BBR-加速" class="headerlink" title="配置 BBR 加速"></a>配置 BBR 加速</h3><p>TCP BBR 是谷歌在 2016 年 9 月开源的一个优化 TCP 拥塞的算法，并且 Linux 内核从 4.9 版本开始集成该算法，据多方网友反馈，网速甚至可以提升好几个数量级，</p><p>一般新版的Linux操作系统以及自带了BBR，不需要手动安装，如果是老系统，可以执行下面命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载脚本</span></span><br><span class="line">wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可执行权限</span></span><br><span class="line"><span class="built_in">chmod</span> +x bbr.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行bbr脚本</span></span><br><span class="line">./bbr.sh</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://raw.githubusercontent.com/cx9208/Linux-NetSpeed/master/tcp.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> +x tcp.sh</span><br><span class="line"></span><br><span class="line">./tcp.sh</span><br></pre></td></tr></table></figure><p>我这边系统以及自带，运行bbr脚本后提示已经安装了，结果如下：<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfortv177sj30k109vq3t.jpg" class="lazyload" data-srcset="https://tva1.sinaimg.cn/large/007S8ZIlly1gfortv177sj30k109vq3t.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>可以验证一下是否成功安装最新内核并开启 TCP BBR，输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> -r  <span class="comment"># &gt;&gt; 4.18.0-147.8.1.el8_1.x86_64</span></span><br><span class="line"></span><br><span class="line">sysctl net.ipv4.tcp_available_congestion_control  <span class="comment"># &gt;&gt; net.ipv4.tcp_available_congestion_control = reno cubic bbr</span></span><br><span class="line"></span><br><span class="line">sysctl net.ipv4.tcp_congestion_control <span class="comment"># &gt;&gt; net.ipv4.tcp_congestion_control = bbr</span></span><br><span class="line"></span><br><span class="line">sysctl net.core.default_qdisc <span class="comment"># &gt;&gt; net.core.default_qdisc = fq</span></span><br><span class="line"></span><br><span class="line">lsmod | grep bbr <span class="comment"># &gt;&gt; tcp_bbr                20480  9</span></span><br></pre></td></tr></table></figure><p>返回值有 tcp_bbr 模块即说明bbr已启动。</p><h3 id="Trojan安装教程"><a href="#Trojan安装教程" class="headerlink" title="Trojan安装教程"></a>Trojan安装教程</h3><p>Trojan是一个近两年兴起的网络工具，项目官网（<a href="https://github.com/trojan-gfw" target="_blank" rel="noopener external nofollow noreferrer">https://github.com/trojan-gfw</a>）。与强调加密和混淆的SS/SSR等工具不同，trojan将通信流量伪装成互联网上最常见的https流量，从而有效防止流量被检测和干扰。</p><p>使用Trojan需要一个指向服务器IP的<a href="https://www.hijk.pw/namesilo-buy-domain-tutorial/" target="_blank" rel="noopener external nofollow noreferrer">域名</a>以及域名证书。</p><h4 id="使用Let’s-Encrypt获取免费证书"><a href="#使用Let’s-Encrypt获取免费证书" class="headerlink" title="使用Let’s Encrypt获取免费证书"></a>使用Let’s Encrypt获取免费证书</h4><ul><li>开发端口</li></ul><p>certbot 默认使用http方式对域名所有权进行验证，该操作需要绑定vps的80端口。需要开发防火墙端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=443/tcp --permanent</span><br></pre></td></tr></table></figure><p>如果80端口已被占用，请先停止占用的进程，例如停止Nginx：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall nginx</span><br></pre></td></tr></table></figure><ul><li>安装certbot</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y python3 &amp;&amp; pip3 install certbot</span><br></pre></td></tr></table></figure><p>查看certbot使用方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p>为指定域名生成证书：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot certonly --standalone -d 域名1 -d 域名2</span><br></pre></td></tr></table></figure><p>查看域名证书的路径和国旗时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot certificates</span><br></pre></td></tr></table></figure><h4 id="安装trojan服务端"><a href="#安装trojan服务端" class="headerlink" title="安装trojan服务端"></a>安装trojan服务端</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> bash -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/trojan-gfw/trojan-quickstart/master/trojan-quickstart.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>该命令会下载最新版的trojan并安装。安装完毕后，trojan配置文件路径是 /usr/local/etc/trojan/config.json，其初始内容为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;run_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;server&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;local_addr&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;local_port&quot;</span><span class="punctuation">:</span> <span class="number">443</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;remote_addr&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;remote_port&quot;</span><span class="punctuation">:</span> <span class="number">80</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;password1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;password2&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;log_level&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ssl&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;cert&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/certificate.crt&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/private.key&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;key_password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cipher&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cipher_tls13&quot;</span><span class="punctuation">:</span> <span class="string">&quot;TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;prefer_server_cipher&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;alpn&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;http/1.1&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;reuse_session&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;session_ticket&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;session_timeout&quot;</span><span class="punctuation">:</span> <span class="number">600</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;plain_http_response&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;curves&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;dhparam&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tcp&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;prefer_ipv4&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;no_delay&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;keep_alive&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;reuse_port&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fast_open&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fast_open_qlen&quot;</span><span class="punctuation">:</span> <span class="number">20</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;mysql&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;enabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;server_addr&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;server_port&quot;</span><span class="punctuation">:</span> <span class="number">3306</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;database&quot;</span><span class="punctuation">:</span> <span class="string">&quot;trojan&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;trojan&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>local_port：监听的端口，默认是443，除非端口被墙，不建议改成其他端口；</li><li>remote_addr和remote_port：非trojan协议时，将请求转发处理的地址和端口。可以是任意有效的ip/域名和端口号，默认是本机和80端口；</li><li>password：密码。需要几个密码就填几行，最后一行结尾不能有逗号；</li><li>cert和key：域名的证书和密钥，Let’s Encrypt申请的证书可用 certbot certificates 查看证书路径；</li><li>key_password：默认没有密码（如果证书文件有密码就要填上）；</li><li>alpn：建议填两行：http/1.1和h2，保持默认也没有问题。</li></ul><p>根据自己的情况修改配置，保存，然后设置开机启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> trojan</span><br></pre></td></tr></table></figure><p>启动Trojan：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start trojan</span><br></pre></td></tr></table></figure><p>检查是否运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -lp | grep trojan</span><br></pre></td></tr></table></figure><h4 id="证书自动更新"><a href="#证书自动更新" class="headerlink" title="证书自动更新"></a>证书自动更新</h4><p>Let’s Encrypt证书的有效期是三个月，超过期限则需要续签。证书续期可以手动完成，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop trojan</span><br><span class="line">certbot renew</span><br><span class="line">systemctl restart trojan</span><br></pre></td></tr></table></figure><p>也可以配置crontab任务自动续签，在/etc/crontab文件末添加一行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 1 */2 0 root systemctl stop trojan; /usr/local/bin/certbot renew; systemctl restart trojan</span><br></pre></td></tr></table></figure><h3 id="Trojan客户端"><a href="#Trojan客户端" class="headerlink" title="Trojan客户端"></a>Trojan客户端</h3><p>以Mac端使用ClashX客户端为例，配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Proxy:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">trojan_NJ5</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">trojan</span></span><br><span class="line">    <span class="attr">server:</span> <span class="string">nj5.kobingo.xyz</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">OF54OAJN3WZ66882</span></span><br><span class="line">    <span class="comment"># udp: true</span></span><br><span class="line">    <span class="comment"># sni: example.com # aka server name</span></span><br><span class="line">    <span class="attr">alpn:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">h2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">http/1.1</span></span><br><span class="line">    <span class="comment"># skip-cert-verify: true</span></span><br></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://trojan-gfw.github.io/trojan/" target="_blank" rel="noopener external nofollow noreferrer">Trojan官网</a></li><li><a href="https://tlanyan.me/trojan-tutorial/" target="_blank" rel="noopener external nofollow noreferrer">trojan教程</a></li><li><a href="https://github.com/hijkpw/scripts" target="_blank" rel="noopener external nofollow noreferrer">https://github.com/hijkpw/scripts</a></li><li><a href="https://www.hijk.pw/trojan-one-click-scrip/" target="_blank" rel="noopener external nofollow noreferrer">trojan一键脚本</a></li><li><a href="https://www.hijk.pw/namesilo-buy-domain-tutorial/" target="_blank" rel="noopener external nofollow noreferrer">Namesilo购买域名详细教程</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近一直在使用的梯子服务临近到期，想要续费发现价格又涨了一波，再加上平时使用中并不是很稳定。就萌生了自建一个梯子的想法。&lt;/p&gt;</summary>
    
    
    
    <category term="others" scheme="https://kobingogo.github.io/categories/others/"/>
    
    
    <category term="梯子" scheme="https://kobingogo.github.io/tags/%E6%A2%AF%E5%AD%90/"/>
    
  </entry>
  
</feed>
